
filex_standalone.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000238  08000000  08000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000113b4  08000238  08000238  00001238  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000190  080115ec  080115ec  000125ec  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM          00000008  0801177c  0801177c  0001277c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .init_array   00000004  08011784  08011784  00012784  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .fini_array   00000004  08011788  08011788  00012788  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .data         000000cc  20000000  0801178c  00013000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          00002d2c  200000d0  08011858  000130d0  2**3
                  ALLOC
  8 ._user_heap_stack 00000604  20002dfc  08011858  00013dfc  2**0
                  ALLOC
  9 .ARM.attributes 00000036  00000000  00000000  000130cc  2**0
                  CONTENTS, READONLY
 10 .debug_info   00031582  00000000  00000000  00013102  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_abbrev 00005a0a  00000000  00000000  00044684  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_aranges 000015e8  00000000  00000000  0004a090  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_rnglists 00000ff7  00000000  00000000  0004b678  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_macro  0003475e  00000000  00000000  0004c66f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_line   0002a56e  00000000  00000000  00080dcd  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_str    00126d20  00000000  00000000  000ab33b  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .comment      00000043  00000000  00000000  001d205b  2**0
                  CONTENTS, READONLY
 18 .debug_frame  000054f4  00000000  00000000  001d20a0  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_line_str 00000079  00000000  00000000  001d7594  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08000238 <__do_global_dtors_aux>:
 8000238:	b510      	push	{r4, lr}
 800023a:	4c05      	ldr	r4, [pc, #20]	@ (8000250 <__do_global_dtors_aux+0x18>)
 800023c:	7823      	ldrb	r3, [r4, #0]
 800023e:	b933      	cbnz	r3, 800024e <__do_global_dtors_aux+0x16>
 8000240:	4b04      	ldr	r3, [pc, #16]	@ (8000254 <__do_global_dtors_aux+0x1c>)
 8000242:	b113      	cbz	r3, 800024a <__do_global_dtors_aux+0x12>
 8000244:	4804      	ldr	r0, [pc, #16]	@ (8000258 <__do_global_dtors_aux+0x20>)
 8000246:	f3af 8000 	nop.w
 800024a:	2301      	movs	r3, #1
 800024c:	7023      	strb	r3, [r4, #0]
 800024e:	bd10      	pop	{r4, pc}
 8000250:	200000d0 	.word	0x200000d0
 8000254:	00000000 	.word	0x00000000
 8000258:	080115d4 	.word	0x080115d4

0800025c <frame_dummy>:
 800025c:	b508      	push	{r3, lr}
 800025e:	4b03      	ldr	r3, [pc, #12]	@ (800026c <frame_dummy+0x10>)
 8000260:	b11b      	cbz	r3, 800026a <frame_dummy+0xe>
 8000262:	4903      	ldr	r1, [pc, #12]	@ (8000270 <frame_dummy+0x14>)
 8000264:	4803      	ldr	r0, [pc, #12]	@ (8000274 <frame_dummy+0x18>)
 8000266:	f3af 8000 	nop.w
 800026a:	bd08      	pop	{r3, pc}
 800026c:	00000000 	.word	0x00000000
 8000270:	200000d4 	.word	0x200000d4
 8000274:	080115d4 	.word	0x080115d4

08000278 <__aeabi_uldivmod>:
 8000278:	b953      	cbnz	r3, 8000290 <__aeabi_uldivmod+0x18>
 800027a:	b94a      	cbnz	r2, 8000290 <__aeabi_uldivmod+0x18>
 800027c:	2900      	cmp	r1, #0
 800027e:	bf08      	it	eq
 8000280:	2800      	cmpeq	r0, #0
 8000282:	bf1c      	itt	ne
 8000284:	f04f 31ff 	movne.w	r1, #4294967295
 8000288:	f04f 30ff 	movne.w	r0, #4294967295
 800028c:	f000 b97e 	b.w	800058c <__aeabi_idiv0>
 8000290:	f1ad 0c08 	sub.w	ip, sp, #8
 8000294:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000298:	f000 f806 	bl	80002a8 <__udivmoddi4>
 800029c:	f8dd e004 	ldr.w	lr, [sp, #4]
 80002a0:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80002a4:	b004      	add	sp, #16
 80002a6:	4770      	bx	lr

080002a8 <__udivmoddi4>:
 80002a8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80002ac:	9d09      	ldr	r5, [sp, #36]	@ 0x24
 80002ae:	460c      	mov	r4, r1
 80002b0:	2b00      	cmp	r3, #0
 80002b2:	d14d      	bne.n	8000350 <__udivmoddi4+0xa8>
 80002b4:	428a      	cmp	r2, r1
 80002b6:	460f      	mov	r7, r1
 80002b8:	4684      	mov	ip, r0
 80002ba:	4696      	mov	lr, r2
 80002bc:	fab2 f382 	clz	r3, r2
 80002c0:	d960      	bls.n	8000384 <__udivmoddi4+0xdc>
 80002c2:	b14b      	cbz	r3, 80002d8 <__udivmoddi4+0x30>
 80002c4:	fa02 fe03 	lsl.w	lr, r2, r3
 80002c8:	f1c3 0220 	rsb	r2, r3, #32
 80002cc:	409f      	lsls	r7, r3
 80002ce:	fa00 fc03 	lsl.w	ip, r0, r3
 80002d2:	fa20 f202 	lsr.w	r2, r0, r2
 80002d6:	4317      	orrs	r7, r2
 80002d8:	ea4f 461e 	mov.w	r6, lr, lsr #16
 80002dc:	fa1f f48e 	uxth.w	r4, lr
 80002e0:	ea4f 421c 	mov.w	r2, ip, lsr #16
 80002e4:	fbb7 f1f6 	udiv	r1, r7, r6
 80002e8:	fb06 7711 	mls	r7, r6, r1, r7
 80002ec:	fb01 f004 	mul.w	r0, r1, r4
 80002f0:	ea42 4207 	orr.w	r2, r2, r7, lsl #16
 80002f4:	4290      	cmp	r0, r2
 80002f6:	d908      	bls.n	800030a <__udivmoddi4+0x62>
 80002f8:	eb1e 0202 	adds.w	r2, lr, r2
 80002fc:	f101 37ff 	add.w	r7, r1, #4294967295
 8000300:	d202      	bcs.n	8000308 <__udivmoddi4+0x60>
 8000302:	4290      	cmp	r0, r2
 8000304:	f200 812d 	bhi.w	8000562 <__udivmoddi4+0x2ba>
 8000308:	4639      	mov	r1, r7
 800030a:	1a12      	subs	r2, r2, r0
 800030c:	fa1f fc8c 	uxth.w	ip, ip
 8000310:	fbb2 f0f6 	udiv	r0, r2, r6
 8000314:	fb06 2210 	mls	r2, r6, r0, r2
 8000318:	fb00 f404 	mul.w	r4, r0, r4
 800031c:	ea4c 4c02 	orr.w	ip, ip, r2, lsl #16
 8000320:	4564      	cmp	r4, ip
 8000322:	d908      	bls.n	8000336 <__udivmoddi4+0x8e>
 8000324:	eb1e 0c0c 	adds.w	ip, lr, ip
 8000328:	f100 32ff 	add.w	r2, r0, #4294967295
 800032c:	d202      	bcs.n	8000334 <__udivmoddi4+0x8c>
 800032e:	4564      	cmp	r4, ip
 8000330:	f200 811a 	bhi.w	8000568 <__udivmoddi4+0x2c0>
 8000334:	4610      	mov	r0, r2
 8000336:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
 800033a:	ebac 0c04 	sub.w	ip, ip, r4
 800033e:	2100      	movs	r1, #0
 8000340:	b125      	cbz	r5, 800034c <__udivmoddi4+0xa4>
 8000342:	fa2c f303 	lsr.w	r3, ip, r3
 8000346:	2200      	movs	r2, #0
 8000348:	e9c5 3200 	strd	r3, r2, [r5]
 800034c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000350:	428b      	cmp	r3, r1
 8000352:	d905      	bls.n	8000360 <__udivmoddi4+0xb8>
 8000354:	b10d      	cbz	r5, 800035a <__udivmoddi4+0xb2>
 8000356:	e9c5 0100 	strd	r0, r1, [r5]
 800035a:	2100      	movs	r1, #0
 800035c:	4608      	mov	r0, r1
 800035e:	e7f5      	b.n	800034c <__udivmoddi4+0xa4>
 8000360:	fab3 f183 	clz	r1, r3
 8000364:	2900      	cmp	r1, #0
 8000366:	d14d      	bne.n	8000404 <__udivmoddi4+0x15c>
 8000368:	42a3      	cmp	r3, r4
 800036a:	f0c0 80f2 	bcc.w	8000552 <__udivmoddi4+0x2aa>
 800036e:	4290      	cmp	r0, r2
 8000370:	f080 80ef 	bcs.w	8000552 <__udivmoddi4+0x2aa>
 8000374:	4606      	mov	r6, r0
 8000376:	4623      	mov	r3, r4
 8000378:	4608      	mov	r0, r1
 800037a:	2d00      	cmp	r5, #0
 800037c:	d0e6      	beq.n	800034c <__udivmoddi4+0xa4>
 800037e:	e9c5 6300 	strd	r6, r3, [r5]
 8000382:	e7e3      	b.n	800034c <__udivmoddi4+0xa4>
 8000384:	2b00      	cmp	r3, #0
 8000386:	f040 80a2 	bne.w	80004ce <__udivmoddi4+0x226>
 800038a:	1a8a      	subs	r2, r1, r2
 800038c:	ea4f 471e 	mov.w	r7, lr, lsr #16
 8000390:	fa1f f68e 	uxth.w	r6, lr
 8000394:	2101      	movs	r1, #1
 8000396:	fbb2 f4f7 	udiv	r4, r2, r7
 800039a:	fb07 2014 	mls	r0, r7, r4, r2
 800039e:	ea4f 421c 	mov.w	r2, ip, lsr #16
 80003a2:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 80003a6:	fb06 f004 	mul.w	r0, r6, r4
 80003aa:	4290      	cmp	r0, r2
 80003ac:	d90f      	bls.n	80003ce <__udivmoddi4+0x126>
 80003ae:	eb1e 0202 	adds.w	r2, lr, r2
 80003b2:	f104 38ff 	add.w	r8, r4, #4294967295
 80003b6:	bf2c      	ite	cs
 80003b8:	f04f 0901 	movcs.w	r9, #1
 80003bc:	f04f 0900 	movcc.w	r9, #0
 80003c0:	4290      	cmp	r0, r2
 80003c2:	d903      	bls.n	80003cc <__udivmoddi4+0x124>
 80003c4:	f1b9 0f00 	cmp.w	r9, #0
 80003c8:	f000 80c8 	beq.w	800055c <__udivmoddi4+0x2b4>
 80003cc:	4644      	mov	r4, r8
 80003ce:	1a12      	subs	r2, r2, r0
 80003d0:	fa1f fc8c 	uxth.w	ip, ip
 80003d4:	fbb2 f0f7 	udiv	r0, r2, r7
 80003d8:	fb07 2210 	mls	r2, r7, r0, r2
 80003dc:	fb00 f606 	mul.w	r6, r0, r6
 80003e0:	ea4c 4c02 	orr.w	ip, ip, r2, lsl #16
 80003e4:	4566      	cmp	r6, ip
 80003e6:	d908      	bls.n	80003fa <__udivmoddi4+0x152>
 80003e8:	eb1e 0c0c 	adds.w	ip, lr, ip
 80003ec:	f100 32ff 	add.w	r2, r0, #4294967295
 80003f0:	d202      	bcs.n	80003f8 <__udivmoddi4+0x150>
 80003f2:	4566      	cmp	r6, ip
 80003f4:	f200 80bb 	bhi.w	800056e <__udivmoddi4+0x2c6>
 80003f8:	4610      	mov	r0, r2
 80003fa:	ebac 0c06 	sub.w	ip, ip, r6
 80003fe:	ea40 4004 	orr.w	r0, r0, r4, lsl #16
 8000402:	e79d      	b.n	8000340 <__udivmoddi4+0x98>
 8000404:	f1c1 0620 	rsb	r6, r1, #32
 8000408:	408b      	lsls	r3, r1
 800040a:	fa04 fe01 	lsl.w	lr, r4, r1
 800040e:	fa22 f706 	lsr.w	r7, r2, r6
 8000412:	fa20 fc06 	lsr.w	ip, r0, r6
 8000416:	40f4      	lsrs	r4, r6
 8000418:	408a      	lsls	r2, r1
 800041a:	431f      	orrs	r7, r3
 800041c:	ea4e 030c 	orr.w	r3, lr, ip
 8000420:	fa00 fe01 	lsl.w	lr, r0, r1
 8000424:	ea4f 4817 	mov.w	r8, r7, lsr #16
 8000428:	ea4f 4913 	mov.w	r9, r3, lsr #16
 800042c:	fa1f fc87 	uxth.w	ip, r7
 8000430:	fbb4 f0f8 	udiv	r0, r4, r8
 8000434:	fb08 4410 	mls	r4, r8, r0, r4
 8000438:	ea49 4404 	orr.w	r4, r9, r4, lsl #16
 800043c:	fb00 f90c 	mul.w	r9, r0, ip
 8000440:	45a1      	cmp	r9, r4
 8000442:	d90e      	bls.n	8000462 <__udivmoddi4+0x1ba>
 8000444:	193c      	adds	r4, r7, r4
 8000446:	f100 3aff 	add.w	sl, r0, #4294967295
 800044a:	bf2c      	ite	cs
 800044c:	f04f 0b01 	movcs.w	fp, #1
 8000450:	f04f 0b00 	movcc.w	fp, #0
 8000454:	45a1      	cmp	r9, r4
 8000456:	d903      	bls.n	8000460 <__udivmoddi4+0x1b8>
 8000458:	f1bb 0f00 	cmp.w	fp, #0
 800045c:	f000 8093 	beq.w	8000586 <__udivmoddi4+0x2de>
 8000460:	4650      	mov	r0, sl
 8000462:	eba4 0409 	sub.w	r4, r4, r9
 8000466:	fa1f f983 	uxth.w	r9, r3
 800046a:	fbb4 f3f8 	udiv	r3, r4, r8
 800046e:	fb08 4413 	mls	r4, r8, r3, r4
 8000472:	fb03 fc0c 	mul.w	ip, r3, ip
 8000476:	ea49 4404 	orr.w	r4, r9, r4, lsl #16
 800047a:	45a4      	cmp	ip, r4
 800047c:	d906      	bls.n	800048c <__udivmoddi4+0x1e4>
 800047e:	193c      	adds	r4, r7, r4
 8000480:	f103 38ff 	add.w	r8, r3, #4294967295
 8000484:	d201      	bcs.n	800048a <__udivmoddi4+0x1e2>
 8000486:	45a4      	cmp	ip, r4
 8000488:	d87a      	bhi.n	8000580 <__udivmoddi4+0x2d8>
 800048a:	4643      	mov	r3, r8
 800048c:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 8000490:	eba4 040c 	sub.w	r4, r4, ip
 8000494:	fba0 9802 	umull	r9, r8, r0, r2
 8000498:	4544      	cmp	r4, r8
 800049a:	46cc      	mov	ip, r9
 800049c:	4643      	mov	r3, r8
 800049e:	d302      	bcc.n	80004a6 <__udivmoddi4+0x1fe>
 80004a0:	d106      	bne.n	80004b0 <__udivmoddi4+0x208>
 80004a2:	45ce      	cmp	lr, r9
 80004a4:	d204      	bcs.n	80004b0 <__udivmoddi4+0x208>
 80004a6:	3801      	subs	r0, #1
 80004a8:	ebb9 0c02 	subs.w	ip, r9, r2
 80004ac:	eb68 0307 	sbc.w	r3, r8, r7
 80004b0:	b15d      	cbz	r5, 80004ca <__udivmoddi4+0x222>
 80004b2:	ebbe 020c 	subs.w	r2, lr, ip
 80004b6:	eb64 0403 	sbc.w	r4, r4, r3
 80004ba:	fa04 f606 	lsl.w	r6, r4, r6
 80004be:	fa22 f301 	lsr.w	r3, r2, r1
 80004c2:	40cc      	lsrs	r4, r1
 80004c4:	431e      	orrs	r6, r3
 80004c6:	e9c5 6400 	strd	r6, r4, [r5]
 80004ca:	2100      	movs	r1, #0
 80004cc:	e73e      	b.n	800034c <__udivmoddi4+0xa4>
 80004ce:	fa02 fe03 	lsl.w	lr, r2, r3
 80004d2:	f1c3 0120 	rsb	r1, r3, #32
 80004d6:	fa04 f203 	lsl.w	r2, r4, r3
 80004da:	fa00 fc03 	lsl.w	ip, r0, r3
 80004de:	40cc      	lsrs	r4, r1
 80004e0:	ea4f 471e 	mov.w	r7, lr, lsr #16
 80004e4:	fa20 f101 	lsr.w	r1, r0, r1
 80004e8:	fa1f f68e 	uxth.w	r6, lr
 80004ec:	fbb4 f0f7 	udiv	r0, r4, r7
 80004f0:	430a      	orrs	r2, r1
 80004f2:	fb07 4410 	mls	r4, r7, r0, r4
 80004f6:	0c11      	lsrs	r1, r2, #16
 80004f8:	ea41 4104 	orr.w	r1, r1, r4, lsl #16
 80004fc:	fb00 f406 	mul.w	r4, r0, r6
 8000500:	428c      	cmp	r4, r1
 8000502:	d90e      	bls.n	8000522 <__udivmoddi4+0x27a>
 8000504:	eb1e 0101 	adds.w	r1, lr, r1
 8000508:	f100 38ff 	add.w	r8, r0, #4294967295
 800050c:	bf2c      	ite	cs
 800050e:	f04f 0901 	movcs.w	r9, #1
 8000512:	f04f 0900 	movcc.w	r9, #0
 8000516:	428c      	cmp	r4, r1
 8000518:	d902      	bls.n	8000520 <__udivmoddi4+0x278>
 800051a:	f1b9 0f00 	cmp.w	r9, #0
 800051e:	d02c      	beq.n	800057a <__udivmoddi4+0x2d2>
 8000520:	4640      	mov	r0, r8
 8000522:	1b09      	subs	r1, r1, r4
 8000524:	b292      	uxth	r2, r2
 8000526:	fbb1 f4f7 	udiv	r4, r1, r7
 800052a:	fb07 1114 	mls	r1, r7, r4, r1
 800052e:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 8000532:	fb04 f106 	mul.w	r1, r4, r6
 8000536:	4291      	cmp	r1, r2
 8000538:	d907      	bls.n	800054a <__udivmoddi4+0x2a2>
 800053a:	eb1e 0202 	adds.w	r2, lr, r2
 800053e:	f104 38ff 	add.w	r8, r4, #4294967295
 8000542:	d201      	bcs.n	8000548 <__udivmoddi4+0x2a0>
 8000544:	4291      	cmp	r1, r2
 8000546:	d815      	bhi.n	8000574 <__udivmoddi4+0x2cc>
 8000548:	4644      	mov	r4, r8
 800054a:	1a52      	subs	r2, r2, r1
 800054c:	ea44 4100 	orr.w	r1, r4, r0, lsl #16
 8000550:	e721      	b.n	8000396 <__udivmoddi4+0xee>
 8000552:	1a86      	subs	r6, r0, r2
 8000554:	eb64 0303 	sbc.w	r3, r4, r3
 8000558:	2001      	movs	r0, #1
 800055a:	e70e      	b.n	800037a <__udivmoddi4+0xd2>
 800055c:	3c02      	subs	r4, #2
 800055e:	4472      	add	r2, lr
 8000560:	e735      	b.n	80003ce <__udivmoddi4+0x126>
 8000562:	3902      	subs	r1, #2
 8000564:	4472      	add	r2, lr
 8000566:	e6d0      	b.n	800030a <__udivmoddi4+0x62>
 8000568:	44f4      	add	ip, lr
 800056a:	3802      	subs	r0, #2
 800056c:	e6e3      	b.n	8000336 <__udivmoddi4+0x8e>
 800056e:	44f4      	add	ip, lr
 8000570:	3802      	subs	r0, #2
 8000572:	e742      	b.n	80003fa <__udivmoddi4+0x152>
 8000574:	3c02      	subs	r4, #2
 8000576:	4472      	add	r2, lr
 8000578:	e7e7      	b.n	800054a <__udivmoddi4+0x2a2>
 800057a:	3802      	subs	r0, #2
 800057c:	4471      	add	r1, lr
 800057e:	e7d0      	b.n	8000522 <__udivmoddi4+0x27a>
 8000580:	3b02      	subs	r3, #2
 8000582:	443c      	add	r4, r7
 8000584:	e782      	b.n	800048c <__udivmoddi4+0x1e4>
 8000586:	3802      	subs	r0, #2
 8000588:	443c      	add	r4, r7
 800058a:	e76a      	b.n	8000462 <__udivmoddi4+0x1ba>

0800058c <__aeabi_idiv0>:
 800058c:	4770      	bx	lr
 800058e:	bf00      	nop

08000590 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 8000590:	b580      	push	{r7, lr}
 8000592:	af00      	add	r7, sp, #0
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 8000594:	f000 fc38 	bl	8000e08 <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the System Power */
  SystemPower_Config();
 8000598:	f000 f88d 	bl	80006b6 <SystemPower_Config>

  /* Configure the system clock */
  SystemClock_Config();
 800059c:	f000 f82c 	bl	80005f8 <SystemClock_Config>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 80005a0:	f000 f8cc 	bl	800073c <MX_GPIO_Init>
  MX_ICACHE_Init();
 80005a4:	f000 f893 	bl	80006ce <MX_ICACHE_Init>
  MX_SDMMC1_SD_Init();
 80005a8:	f000 f8a4 	bl	80006f4 <MX_SDMMC1_SD_Init>
  MX_FileX_Init();
 80005ac:	f007 fe8a 	bl	80082c4 <MX_FileX_Init>
  /* USER CODE BEGIN 2 */
  MX_FileX_Process();
 80005b0:	f007 feb0 	bl	8008314 <MX_FileX_Process>
  /* USER CODE END 2 */

  /* Initialize led */
  BSP_LED_Init(LED_GREEN);
 80005b4:	2000      	movs	r0, #0
 80005b6:	f000 fb13 	bl	8000be0 <BSP_LED_Init>

  /* Initialize COM1 port (115200, 8 bits (7-bit data + 1 stop bit), no parity */
  BspCOMInit.BaudRate   = 115200;
 80005ba:	4b0e      	ldr	r3, [pc, #56]	@ (80005f4 <main+0x64>)
 80005bc:	f44f 32e1 	mov.w	r2, #115200	@ 0x1c200
 80005c0:	601a      	str	r2, [r3, #0]
  BspCOMInit.WordLength = COM_WORDLENGTH_8B;
 80005c2:	4b0c      	ldr	r3, [pc, #48]	@ (80005f4 <main+0x64>)
 80005c4:	2200      	movs	r2, #0
 80005c6:	605a      	str	r2, [r3, #4]
  BspCOMInit.StopBits   = COM_STOPBITS_1;
 80005c8:	4b0a      	ldr	r3, [pc, #40]	@ (80005f4 <main+0x64>)
 80005ca:	2200      	movs	r2, #0
 80005cc:	811a      	strh	r2, [r3, #8]
  BspCOMInit.Parity     = COM_PARITY_NONE;
 80005ce:	4b09      	ldr	r3, [pc, #36]	@ (80005f4 <main+0x64>)
 80005d0:	2200      	movs	r2, #0
 80005d2:	815a      	strh	r2, [r3, #10]
  BspCOMInit.HwFlowCtl  = COM_HWCONTROL_NONE;
 80005d4:	4b07      	ldr	r3, [pc, #28]	@ (80005f4 <main+0x64>)
 80005d6:	2200      	movs	r2, #0
 80005d8:	819a      	strh	r2, [r3, #12]
  if (BSP_COM_Init(COM1, &BspCOMInit) != BSP_ERROR_NONE)
 80005da:	4906      	ldr	r1, [pc, #24]	@ (80005f4 <main+0x64>)
 80005dc:	2000      	movs	r0, #0
 80005de:	f000 fb3b 	bl	8000c58 <BSP_COM_Init>
 80005e2:	4603      	mov	r3, r0
 80005e4:	2b00      	cmp	r3, #0
 80005e6:	d002      	beq.n	80005ee <main+0x5e>
  {
    Error_Handler();
 80005e8:	f000 f8e8 	bl	80007bc <Error_Handler>
  }

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
 80005ec:	bf00      	nop
 80005ee:	bf00      	nop
 80005f0:	e7fd      	b.n	80005ee <main+0x5e>
 80005f2:	bf00      	nop
 80005f4:	200000ec 	.word	0x200000ec

080005f8 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 80005f8:	b580      	push	{r7, lr}
 80005fa:	b09e      	sub	sp, #120	@ 0x78
 80005fc:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 80005fe:	f107 0318 	add.w	r3, r7, #24
 8000602:	2260      	movs	r2, #96	@ 0x60
 8000604:	2100      	movs	r1, #0
 8000606:	4618      	mov	r0, r3
 8000608:	f010 fd24 	bl	8011054 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 800060c:	463b      	mov	r3, r7
 800060e:	2200      	movs	r2, #0
 8000610:	601a      	str	r2, [r3, #0]
 8000612:	605a      	str	r2, [r3, #4]
 8000614:	609a      	str	r2, [r3, #8]
 8000616:	60da      	str	r2, [r3, #12]
 8000618:	611a      	str	r2, [r3, #16]
 800061a:	615a      	str	r2, [r3, #20]

  /** Configure the main internal regulator output voltage
  */
  if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
 800061c:	f44f 3040 	mov.w	r0, #196608	@ 0x30000
 8000620:	f001 f892 	bl	8001748 <HAL_PWREx_ControlVoltageScaling>
 8000624:	4603      	mov	r3, r0
 8000626:	2b00      	cmp	r3, #0
 8000628:	d001      	beq.n	800062e <SystemClock_Config+0x36>
  {
    Error_Handler();
 800062a:	f000 f8c7 	bl	80007bc <Error_Handler>
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48|RCC_OSCILLATORTYPE_MSI;
 800062e:	2330      	movs	r3, #48	@ 0x30
 8000630:	61bb      	str	r3, [r7, #24]
  RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
 8000632:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8000636:	647b      	str	r3, [r7, #68]	@ 0x44
  RCC_OscInitStruct.MSIState = RCC_MSI_ON;
 8000638:	2301      	movs	r3, #1
 800063a:	637b      	str	r3, [r7, #52]	@ 0x34
  RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;
 800063c:	2310      	movs	r3, #16
 800063e:	63bb      	str	r3, [r7, #56]	@ 0x38
  RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_0;
 8000640:	2300      	movs	r3, #0
 8000642:	63fb      	str	r3, [r7, #60]	@ 0x3c
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8000644:	2302      	movs	r3, #2
 8000646:	653b      	str	r3, [r7, #80]	@ 0x50
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI;
 8000648:	2301      	movs	r3, #1
 800064a:	657b      	str	r3, [r7, #84]	@ 0x54
  RCC_OscInitStruct.PLL.PLLMBOOST = RCC_PLLMBOOST_DIV4;
 800064c:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
 8000650:	65fb      	str	r3, [r7, #92]	@ 0x5c
  RCC_OscInitStruct.PLL.PLLM = 3;
 8000652:	2303      	movs	r3, #3
 8000654:	65bb      	str	r3, [r7, #88]	@ 0x58
  RCC_OscInitStruct.PLL.PLLN = 10;
 8000656:	230a      	movs	r3, #10
 8000658:	663b      	str	r3, [r7, #96]	@ 0x60
  RCC_OscInitStruct.PLL.PLLP = 4;
 800065a:	2304      	movs	r3, #4
 800065c:	667b      	str	r3, [r7, #100]	@ 0x64
  RCC_OscInitStruct.PLL.PLLQ = 2;
 800065e:	2302      	movs	r3, #2
 8000660:	66bb      	str	r3, [r7, #104]	@ 0x68
  RCC_OscInitStruct.PLL.PLLR = 1;
 8000662:	2301      	movs	r3, #1
 8000664:	66fb      	str	r3, [r7, #108]	@ 0x6c
  RCC_OscInitStruct.PLL.PLLRGE = RCC_PLLVCIRANGE_1;
 8000666:	230c      	movs	r3, #12
 8000668:	673b      	str	r3, [r7, #112]	@ 0x70
  RCC_OscInitStruct.PLL.PLLFRACN = 0;
 800066a:	2300      	movs	r3, #0
 800066c:	677b      	str	r3, [r7, #116]	@ 0x74
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 800066e:	f107 0318 	add.w	r3, r7, #24
 8000672:	4618      	mov	r0, r3
 8000674:	f001 f944 	bl	8001900 <HAL_RCC_OscConfig>
 8000678:	4603      	mov	r3, r0
 800067a:	2b00      	cmp	r3, #0
 800067c:	d001      	beq.n	8000682 <SystemClock_Config+0x8a>
  {
    Error_Handler();
 800067e:	f000 f89d 	bl	80007bc <Error_Handler>
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8000682:	231f      	movs	r3, #31
 8000684:	603b      	str	r3, [r7, #0]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2
                              |RCC_CLOCKTYPE_PCLK3;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8000686:	2303      	movs	r3, #3
 8000688:	607b      	str	r3, [r7, #4]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 800068a:	2300      	movs	r3, #0
 800068c:	60bb      	str	r3, [r7, #8]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 800068e:	2300      	movs	r3, #0
 8000690:	60fb      	str	r3, [r7, #12]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 8000692:	2300      	movs	r3, #0
 8000694:	613b      	str	r3, [r7, #16]
  RCC_ClkInitStruct.APB3CLKDivider = RCC_HCLK_DIV1;
 8000696:	2300      	movs	r3, #0
 8000698:	617b      	str	r3, [r7, #20]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
 800069a:	463b      	mov	r3, r7
 800069c:	2104      	movs	r1, #4
 800069e:	4618      	mov	r0, r3
 80006a0:	f002 f80a 	bl	80026b8 <HAL_RCC_ClockConfig>
 80006a4:	4603      	mov	r3, r0
 80006a6:	2b00      	cmp	r3, #0
 80006a8:	d001      	beq.n	80006ae <SystemClock_Config+0xb6>
  {
    Error_Handler();
 80006aa:	f000 f887 	bl	80007bc <Error_Handler>
  }
}
 80006ae:	bf00      	nop
 80006b0:	3778      	adds	r7, #120	@ 0x78
 80006b2:	46bd      	mov	sp, r7
 80006b4:	bd80      	pop	{r7, pc}

080006b6 <SystemPower_Config>:
/**
  * @brief Power Configuration
  * @retval None
  */
static void SystemPower_Config(void)
{
 80006b6:	b580      	push	{r7, lr}
 80006b8:	af00      	add	r7, sp, #0

  /*
   * Switch to SMPS regulator instead of LDO
   */
  if (HAL_PWREx_ConfigSupply(PWR_SMPS_SUPPLY) != HAL_OK)
 80006ba:	2002      	movs	r0, #2
 80006bc:	f001 f8d0 	bl	8001860 <HAL_PWREx_ConfigSupply>
 80006c0:	4603      	mov	r3, r0
 80006c2:	2b00      	cmp	r3, #0
 80006c4:	d001      	beq.n	80006ca <SystemPower_Config+0x14>
  {
    Error_Handler();
 80006c6:	f000 f879 	bl	80007bc <Error_Handler>
  }
/* USER CODE BEGIN PWR */
/* USER CODE END PWR */
}
 80006ca:	bf00      	nop
 80006cc:	bd80      	pop	{r7, pc}

080006ce <MX_ICACHE_Init>:
  * @brief ICACHE Initialization Function
  * @param None
  * @retval None
  */
static void MX_ICACHE_Init(void)
{
 80006ce:	b580      	push	{r7, lr}
 80006d0:	af00      	add	r7, sp, #0

  /* USER CODE END ICACHE_Init 1 */

  /** Enable instruction cache in 1-way (direct mapped cache)
  */
  if (HAL_ICACHE_ConfigAssociativityMode(ICACHE_1WAY) != HAL_OK)
 80006d2:	2000      	movs	r0, #0
 80006d4:	f001 f808 	bl	80016e8 <HAL_ICACHE_ConfigAssociativityMode>
 80006d8:	4603      	mov	r3, r0
 80006da:	2b00      	cmp	r3, #0
 80006dc:	d001      	beq.n	80006e2 <MX_ICACHE_Init+0x14>
  {
    Error_Handler();
 80006de:	f000 f86d 	bl	80007bc <Error_Handler>
  }
  if (HAL_ICACHE_Enable() != HAL_OK)
 80006e2:	f001 f821 	bl	8001728 <HAL_ICACHE_Enable>
 80006e6:	4603      	mov	r3, r0
 80006e8:	2b00      	cmp	r3, #0
 80006ea:	d001      	beq.n	80006f0 <MX_ICACHE_Init+0x22>
  {
    Error_Handler();
 80006ec:	f000 f866 	bl	80007bc <Error_Handler>
  }
  /* USER CODE BEGIN ICACHE_Init 2 */

  /* USER CODE END ICACHE_Init 2 */

}
 80006f0:	bf00      	nop
 80006f2:	bd80      	pop	{r7, pc}

080006f4 <MX_SDMMC1_SD_Init>:
  * @brief SDMMC1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_SDMMC1_SD_Init(void)
{
 80006f4:	b580      	push	{r7, lr}
 80006f6:	af00      	add	r7, sp, #0
  /* USER CODE END SDMMC1_Init 0 */

  /* USER CODE BEGIN SDMMC1_Init 1 */

  /* USER CODE END SDMMC1_Init 1 */
  hsd1.Instance = SDMMC1;
 80006f8:	4b0e      	ldr	r3, [pc, #56]	@ (8000734 <MX_SDMMC1_SD_Init+0x40>)
 80006fa:	4a0f      	ldr	r2, [pc, #60]	@ (8000738 <MX_SDMMC1_SD_Init+0x44>)
 80006fc:	601a      	str	r2, [r3, #0]
  hsd1.Init.ClockEdge = SDMMC_CLOCK_EDGE_RISING;
 80006fe:	4b0d      	ldr	r3, [pc, #52]	@ (8000734 <MX_SDMMC1_SD_Init+0x40>)
 8000700:	2200      	movs	r2, #0
 8000702:	605a      	str	r2, [r3, #4]
  hsd1.Init.ClockPowerSave = SDMMC_CLOCK_POWER_SAVE_DISABLE;
 8000704:	4b0b      	ldr	r3, [pc, #44]	@ (8000734 <MX_SDMMC1_SD_Init+0x40>)
 8000706:	2200      	movs	r2, #0
 8000708:	609a      	str	r2, [r3, #8]
  hsd1.Init.BusWide = SDMMC_BUS_WIDE_4B;
 800070a:	4b0a      	ldr	r3, [pc, #40]	@ (8000734 <MX_SDMMC1_SD_Init+0x40>)
 800070c:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
 8000710:	60da      	str	r2, [r3, #12]
  hsd1.Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_DISABLE;
 8000712:	4b08      	ldr	r3, [pc, #32]	@ (8000734 <MX_SDMMC1_SD_Init+0x40>)
 8000714:	2200      	movs	r2, #0
 8000716:	611a      	str	r2, [r3, #16]
  hsd1.Init.ClockDiv = 2;
 8000718:	4b06      	ldr	r3, [pc, #24]	@ (8000734 <MX_SDMMC1_SD_Init+0x40>)
 800071a:	2202      	movs	r2, #2
 800071c:	615a      	str	r2, [r3, #20]
  if (HAL_SD_Init(&hsd1) != HAL_OK)
 800071e:	4805      	ldr	r0, [pc, #20]	@ (8000734 <MX_SDMMC1_SD_Init+0x40>)
 8000720:	f004 ff58 	bl	80055d4 <HAL_SD_Init>
 8000724:	4603      	mov	r3, r0
 8000726:	2b00      	cmp	r3, #0
 8000728:	d001      	beq.n	800072e <MX_SDMMC1_SD_Init+0x3a>
  {
    Error_Handler();
 800072a:	f000 f847 	bl	80007bc <Error_Handler>
  }
  /* USER CODE BEGIN SDMMC1_Init 2 */

  /* USER CODE END SDMMC1_Init 2 */

}
 800072e:	bf00      	nop
 8000730:	bd80      	pop	{r7, pc}
 8000732:	bf00      	nop
 8000734:	200000fc 	.word	0x200000fc
 8000738:	420c8000 	.word	0x420c8000

0800073c <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
 800073c:	b580      	push	{r7, lr}
 800073e:	b088      	sub	sp, #32
 8000740:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000742:	f107 030c 	add.w	r3, r7, #12
 8000746:	2200      	movs	r2, #0
 8000748:	601a      	str	r2, [r3, #0]
 800074a:	605a      	str	r2, [r3, #4]
 800074c:	609a      	str	r2, [r3, #8]
 800074e:	60da      	str	r2, [r3, #12]
 8000750:	611a      	str	r2, [r3, #16]
/* USER CODE BEGIN MX_GPIO_Init_1 */
/* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8000752:	4b17      	ldr	r3, [pc, #92]	@ (80007b0 <MX_GPIO_Init+0x74>)
 8000754:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8000758:	4a15      	ldr	r2, [pc, #84]	@ (80007b0 <MX_GPIO_Init+0x74>)
 800075a:	f043 0304 	orr.w	r3, r3, #4
 800075e:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
 8000762:	4b13      	ldr	r3, [pc, #76]	@ (80007b0 <MX_GPIO_Init+0x74>)
 8000764:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8000768:	f003 0304 	and.w	r3, r3, #4
 800076c:	60bb      	str	r3, [r7, #8]
 800076e:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8000770:	4b0f      	ldr	r3, [pc, #60]	@ (80007b0 <MX_GPIO_Init+0x74>)
 8000772:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8000776:	4a0e      	ldr	r2, [pc, #56]	@ (80007b0 <MX_GPIO_Init+0x74>)
 8000778:	f043 0308 	orr.w	r3, r3, #8
 800077c:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
 8000780:	4b0b      	ldr	r3, [pc, #44]	@ (80007b0 <MX_GPIO_Init+0x74>)
 8000782:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8000786:	f003 0308 	and.w	r3, r3, #8
 800078a:	607b      	str	r3, [r7, #4]
 800078c:	687b      	ldr	r3, [r7, #4]

  /*Configure GPIO pin : USER_BUTTON_Pin */
  GPIO_InitStruct.Pin = USER_BUTTON_Pin;
 800078e:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
 8000792:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
 8000794:	4b07      	ldr	r3, [pc, #28]	@ (80007b4 <MX_GPIO_Init+0x78>)
 8000796:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Pull = GPIO_PULLDOWN;
 8000798:	2302      	movs	r3, #2
 800079a:	617b      	str	r3, [r7, #20]
  HAL_GPIO_Init(USER_BUTTON_GPIO_Port, &GPIO_InitStruct);
 800079c:	f107 030c 	add.w	r3, r7, #12
 80007a0:	4619      	mov	r1, r3
 80007a2:	4805      	ldr	r0, [pc, #20]	@ (80007b8 <MX_GPIO_Init+0x7c>)
 80007a4:	f000 fdae 	bl	8001304 <HAL_GPIO_Init>

/* USER CODE BEGIN MX_GPIO_Init_2 */
/* USER CODE END MX_GPIO_Init_2 */
}
 80007a8:	bf00      	nop
 80007aa:	3720      	adds	r7, #32
 80007ac:	46bd      	mov	sp, r7
 80007ae:	bd80      	pop	{r7, pc}
 80007b0:	46020c00 	.word	0x46020c00
 80007b4:	10210000 	.word	0x10210000
 80007b8:	42020800 	.word	0x42020800

080007bc <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 80007bc:	b480      	push	{r7}
 80007be:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting special-purpose register PRIMASK.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80007c0:	b672      	cpsid	i
}
 80007c2:	bf00      	nop
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 80007c4:	bf00      	nop
 80007c6:	e7fd      	b.n	80007c4 <Error_Handler+0x8>

080007c8 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 80007c8:	b480      	push	{r7}
 80007ca:	b083      	sub	sp, #12
 80007cc:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_PWR_CLK_ENABLE();
 80007ce:	4b0a      	ldr	r3, [pc, #40]	@ (80007f8 <HAL_MspInit+0x30>)
 80007d0:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 80007d4:	4a08      	ldr	r2, [pc, #32]	@ (80007f8 <HAL_MspInit+0x30>)
 80007d6:	f043 0304 	orr.w	r3, r3, #4
 80007da:	f8c2 3094 	str.w	r3, [r2, #148]	@ 0x94
 80007de:	4b06      	ldr	r3, [pc, #24]	@ (80007f8 <HAL_MspInit+0x30>)
 80007e0:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 80007e4:	f003 0304 	and.w	r3, r3, #4
 80007e8:	607b      	str	r3, [r7, #4]
 80007ea:	687b      	ldr	r3, [r7, #4]
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 80007ec:	bf00      	nop
 80007ee:	370c      	adds	r7, #12
 80007f0:	46bd      	mov	sp, r7
 80007f2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80007f6:	4770      	bx	lr
 80007f8:	46020c00 	.word	0x46020c00

080007fc <HAL_SD_MspInit>:
* This function configures the hardware resources used in this example
* @param hsd: SD handle pointer
* @retval None
*/
void HAL_SD_MspInit(SD_HandleTypeDef* hsd)
{
 80007fc:	b580      	push	{r7, lr}
 80007fe:	b0bc      	sub	sp, #240	@ 0xf0
 8000800:	af00      	add	r7, sp, #0
 8000802:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000804:	f107 03dc 	add.w	r3, r7, #220	@ 0xdc
 8000808:	2200      	movs	r2, #0
 800080a:	601a      	str	r2, [r3, #0]
 800080c:	605a      	str	r2, [r3, #4]
 800080e:	609a      	str	r2, [r3, #8]
 8000810:	60da      	str	r2, [r3, #12]
 8000812:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 8000814:	f107 0318 	add.w	r3, r7, #24
 8000818:	22c0      	movs	r2, #192	@ 0xc0
 800081a:	2100      	movs	r1, #0
 800081c:	4618      	mov	r0, r3
 800081e:	f010 fc19 	bl	8011054 <memset>
  if(hsd->Instance==SDMMC1)
 8000822:	687b      	ldr	r3, [r7, #4]
 8000824:	681b      	ldr	r3, [r3, #0]
 8000826:	4a4a      	ldr	r2, [pc, #296]	@ (8000950 <HAL_SD_MspInit+0x154>)
 8000828:	4293      	cmp	r3, r2
 800082a:	f040 808c 	bne.w	8000946 <HAL_SD_MspInit+0x14a>

  /* USER CODE END SDMMC1_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_SDMMC|RCC_PERIPHCLK_CLK48;
 800082e:	f44f 1240 	mov.w	r2, #3145728	@ 0x300000
 8000832:	f04f 0300 	mov.w	r3, #0
 8000836:	e9c7 2306 	strd	r2, r3, [r7, #24]
    PeriphClkInit.IclkClockSelection = RCC_CLK48CLKSOURCE_HSI48;
 800083a:	2300      	movs	r3, #0
 800083c:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
    PeriphClkInit.SdmmcClockSelection = RCC_SDMMCCLKSOURCE_CLK48;
 8000840:	2300      	movs	r3, #0
 8000842:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8000846:	f107 0318 	add.w	r3, r7, #24
 800084a:	4618      	mov	r0, r3
 800084c:	f002 fb04 	bl	8002e58 <HAL_RCCEx_PeriphCLKConfig>
 8000850:	4603      	mov	r3, r0
 8000852:	2b00      	cmp	r3, #0
 8000854:	d001      	beq.n	800085a <HAL_SD_MspInit+0x5e>
    {
      Error_Handler();
 8000856:	f7ff ffb1 	bl	80007bc <Error_Handler>
    }

    /* Peripheral clock enable */
    __HAL_RCC_SDMMC1_CLK_ENABLE();
 800085a:	4b3e      	ldr	r3, [pc, #248]	@ (8000954 <HAL_SD_MspInit+0x158>)
 800085c:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8000860:	4a3c      	ldr	r2, [pc, #240]	@ (8000954 <HAL_SD_MspInit+0x158>)
 8000862:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
 8000866:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
 800086a:	4b3a      	ldr	r3, [pc, #232]	@ (8000954 <HAL_SD_MspInit+0x158>)
 800086c:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8000870:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8000874:	617b      	str	r3, [r7, #20]
 8000876:	697b      	ldr	r3, [r7, #20]

    __HAL_RCC_GPIOC_CLK_ENABLE();
 8000878:	4b36      	ldr	r3, [pc, #216]	@ (8000954 <HAL_SD_MspInit+0x158>)
 800087a:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800087e:	4a35      	ldr	r2, [pc, #212]	@ (8000954 <HAL_SD_MspInit+0x158>)
 8000880:	f043 0304 	orr.w	r3, r3, #4
 8000884:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
 8000888:	4b32      	ldr	r3, [pc, #200]	@ (8000954 <HAL_SD_MspInit+0x158>)
 800088a:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800088e:	f003 0304 	and.w	r3, r3, #4
 8000892:	613b      	str	r3, [r7, #16]
 8000894:	693b      	ldr	r3, [r7, #16]
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8000896:	4b2f      	ldr	r3, [pc, #188]	@ (8000954 <HAL_SD_MspInit+0x158>)
 8000898:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800089c:	4a2d      	ldr	r2, [pc, #180]	@ (8000954 <HAL_SD_MspInit+0x158>)
 800089e:	f043 0308 	orr.w	r3, r3, #8
 80008a2:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
 80008a6:	4b2b      	ldr	r3, [pc, #172]	@ (8000954 <HAL_SD_MspInit+0x158>)
 80008a8:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 80008ac:	f003 0308 	and.w	r3, r3, #8
 80008b0:	60fb      	str	r3, [r7, #12]
 80008b2:	68fb      	ldr	r3, [r7, #12]
    PC10     ------> SDMMC1_D2
    PC11     ------> SDMMC1_D3
    PC12     ------> SDMMC1_CK
    PD2     ------> SDMMC1_CMD
    */
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11;
 80008b4:	f44f 6370 	mov.w	r3, #3840	@ 0xf00
 80008b8:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80008bc:	2302      	movs	r3, #2
 80008be:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 80008c2:	2301      	movs	r3, #1
 80008c4:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 80008c8:	2302      	movs	r3, #2
 80008ca:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    GPIO_InitStruct.Alternate = GPIO_AF12_SDMMC1;
 80008ce:	230c      	movs	r3, #12
 80008d0:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80008d4:	f107 03dc 	add.w	r3, r7, #220	@ 0xdc
 80008d8:	4619      	mov	r1, r3
 80008da:	481f      	ldr	r0, [pc, #124]	@ (8000958 <HAL_SD_MspInit+0x15c>)
 80008dc:	f000 fd12 	bl	8001304 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_12;
 80008e0:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 80008e4:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80008e8:	2302      	movs	r3, #2
 80008ea:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80008ee:	2300      	movs	r3, #0
 80008f0:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 80008f4:	2302      	movs	r3, #2
 80008f6:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    GPIO_InitStruct.Alternate = GPIO_AF12_SDMMC1;
 80008fa:	230c      	movs	r3, #12
 80008fc:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8000900:	f107 03dc 	add.w	r3, r7, #220	@ 0xdc
 8000904:	4619      	mov	r1, r3
 8000906:	4814      	ldr	r0, [pc, #80]	@ (8000958 <HAL_SD_MspInit+0x15c>)
 8000908:	f000 fcfc 	bl	8001304 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_2;
 800090c:	2304      	movs	r3, #4
 800090e:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000912:	2302      	movs	r3, #2
 8000914:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8000918:	2301      	movs	r3, #1
 800091a:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 800091e:	2302      	movs	r3, #2
 8000920:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    GPIO_InitStruct.Alternate = GPIO_AF12_SDMMC1;
 8000924:	230c      	movs	r3, #12
 8000926:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 800092a:	f107 03dc 	add.w	r3, r7, #220	@ 0xdc
 800092e:	4619      	mov	r1, r3
 8000930:	480a      	ldr	r0, [pc, #40]	@ (800095c <HAL_SD_MspInit+0x160>)
 8000932:	f000 fce7 	bl	8001304 <HAL_GPIO_Init>

    /* SDMMC1 interrupt Init */
    HAL_NVIC_SetPriority(SDMMC1_IRQn, 0, 0);
 8000936:	2200      	movs	r2, #0
 8000938:	2100      	movs	r1, #0
 800093a:	204e      	movs	r0, #78	@ 0x4e
 800093c:	f000 fc06 	bl	800114c <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(SDMMC1_IRQn);
 8000940:	204e      	movs	r0, #78	@ 0x4e
 8000942:	f000 fc1d 	bl	8001180 <HAL_NVIC_EnableIRQ>

  /* USER CODE END SDMMC1_MspInit 1 */

  }

}
 8000946:	bf00      	nop
 8000948:	37f0      	adds	r7, #240	@ 0xf0
 800094a:	46bd      	mov	sp, r7
 800094c:	bd80      	pop	{r7, pc}
 800094e:	bf00      	nop
 8000950:	420c8000 	.word	0x420c8000
 8000954:	46020c00 	.word	0x46020c00
 8000958:	42020800 	.word	0x42020800
 800095c:	42020c00 	.word	0x42020c00

08000960 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 8000960:	b480      	push	{r7}
 8000962:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
   while (1)
 8000964:	bf00      	nop
 8000966:	e7fd      	b.n	8000964 <NMI_Handler+0x4>

08000968 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 8000968:	b480      	push	{r7}
 800096a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 800096c:	bf00      	nop
 800096e:	e7fd      	b.n	800096c <HardFault_Handler+0x4>

08000970 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 8000970:	b480      	push	{r7}
 8000972:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 8000974:	bf00      	nop
 8000976:	e7fd      	b.n	8000974 <MemManage_Handler+0x4>

08000978 <BusFault_Handler>:

/**
  * @brief This function handles Prefetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 8000978:	b480      	push	{r7}
 800097a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 800097c:	bf00      	nop
 800097e:	e7fd      	b.n	800097c <BusFault_Handler+0x4>

08000980 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 8000980:	b480      	push	{r7}
 8000982:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 8000984:	bf00      	nop
 8000986:	e7fd      	b.n	8000984 <UsageFault_Handler+0x4>

08000988 <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 8000988:	b480      	push	{r7}
 800098a:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 800098c:	bf00      	nop
 800098e:	46bd      	mov	sp, r7
 8000990:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000994:	4770      	bx	lr

08000996 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 8000996:	b480      	push	{r7}
 8000998:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 800099a:	bf00      	nop
 800099c:	46bd      	mov	sp, r7
 800099e:	f85d 7b04 	ldr.w	r7, [sp], #4
 80009a2:	4770      	bx	lr

080009a4 <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 80009a4:	b480      	push	{r7}
 80009a6:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 80009a8:	bf00      	nop
 80009aa:	46bd      	mov	sp, r7
 80009ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 80009b0:	4770      	bx	lr

080009b2 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 80009b2:	b580      	push	{r7, lr}
 80009b4:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 80009b6:	f000 facd 	bl	8000f54 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 80009ba:	bf00      	nop
 80009bc:	bd80      	pop	{r7, pc}
	...

080009c0 <SDMMC1_IRQHandler>:

/**
  * @brief This function handles SDMMC1 global interrupt.
  */
void SDMMC1_IRQHandler(void)
{
 80009c0:	b580      	push	{r7, lr}
 80009c2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SDMMC1_IRQn 0 */

  /* USER CODE END SDMMC1_IRQn 0 */
  HAL_SD_IRQHandler(&hsd1);
 80009c4:	4802      	ldr	r0, [pc, #8]	@ (80009d0 <SDMMC1_IRQHandler+0x10>)
 80009c6:	f005 f875 	bl	8005ab4 <HAL_SD_IRQHandler>
  /* USER CODE BEGIN SDMMC1_IRQn 1 */

  /* USER CODE END SDMMC1_IRQn 1 */
}
 80009ca:	bf00      	nop
 80009cc:	bd80      	pop	{r7, pc}
 80009ce:	bf00      	nop
 80009d0:	200000fc 	.word	0x200000fc

080009d4 <_read>:
  _kill(status, -1);
  while (1) {}    /* Make sure we hang here */
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 80009d4:	b580      	push	{r7, lr}
 80009d6:	b086      	sub	sp, #24
 80009d8:	af00      	add	r7, sp, #0
 80009da:	60f8      	str	r0, [r7, #12]
 80009dc:	60b9      	str	r1, [r7, #8]
 80009de:	607a      	str	r2, [r7, #4]
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
 80009e0:	2300      	movs	r3, #0
 80009e2:	617b      	str	r3, [r7, #20]
 80009e4:	e00a      	b.n	80009fc <_read+0x28>
  {
    *ptr++ = __io_getchar();
 80009e6:	f3af 8000 	nop.w
 80009ea:	4601      	mov	r1, r0
 80009ec:	68bb      	ldr	r3, [r7, #8]
 80009ee:	1c5a      	adds	r2, r3, #1
 80009f0:	60ba      	str	r2, [r7, #8]
 80009f2:	b2ca      	uxtb	r2, r1
 80009f4:	701a      	strb	r2, [r3, #0]
  for (DataIdx = 0; DataIdx < len; DataIdx++)
 80009f6:	697b      	ldr	r3, [r7, #20]
 80009f8:	3301      	adds	r3, #1
 80009fa:	617b      	str	r3, [r7, #20]
 80009fc:	697a      	ldr	r2, [r7, #20]
 80009fe:	687b      	ldr	r3, [r7, #4]
 8000a00:	429a      	cmp	r2, r3
 8000a02:	dbf0      	blt.n	80009e6 <_read+0x12>
  }

  return len;
 8000a04:	687b      	ldr	r3, [r7, #4]
}
 8000a06:	4618      	mov	r0, r3
 8000a08:	3718      	adds	r7, #24
 8000a0a:	46bd      	mov	sp, r7
 8000a0c:	bd80      	pop	{r7, pc}

08000a0e <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
 8000a0e:	b580      	push	{r7, lr}
 8000a10:	b086      	sub	sp, #24
 8000a12:	af00      	add	r7, sp, #0
 8000a14:	60f8      	str	r0, [r7, #12]
 8000a16:	60b9      	str	r1, [r7, #8]
 8000a18:	607a      	str	r2, [r7, #4]
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
 8000a1a:	2300      	movs	r3, #0
 8000a1c:	617b      	str	r3, [r7, #20]
 8000a1e:	e009      	b.n	8000a34 <_write+0x26>
  {
    __io_putchar(*ptr++);
 8000a20:	68bb      	ldr	r3, [r7, #8]
 8000a22:	1c5a      	adds	r2, r3, #1
 8000a24:	60ba      	str	r2, [r7, #8]
 8000a26:	781b      	ldrb	r3, [r3, #0]
 8000a28:	4618      	mov	r0, r3
 8000a2a:	f000 f979 	bl	8000d20 <__io_putchar>
  for (DataIdx = 0; DataIdx < len; DataIdx++)
 8000a2e:	697b      	ldr	r3, [r7, #20]
 8000a30:	3301      	adds	r3, #1
 8000a32:	617b      	str	r3, [r7, #20]
 8000a34:	697a      	ldr	r2, [r7, #20]
 8000a36:	687b      	ldr	r3, [r7, #4]
 8000a38:	429a      	cmp	r2, r3
 8000a3a:	dbf1      	blt.n	8000a20 <_write+0x12>
  }
  return len;
 8000a3c:	687b      	ldr	r3, [r7, #4]
}
 8000a3e:	4618      	mov	r0, r3
 8000a40:	3718      	adds	r7, #24
 8000a42:	46bd      	mov	sp, r7
 8000a44:	bd80      	pop	{r7, pc}

08000a46 <_close>:

int _close(int file)
{
 8000a46:	b480      	push	{r7}
 8000a48:	b083      	sub	sp, #12
 8000a4a:	af00      	add	r7, sp, #0
 8000a4c:	6078      	str	r0, [r7, #4]
  (void)file;
  return -1;
 8000a4e:	f04f 33ff 	mov.w	r3, #4294967295
}
 8000a52:	4618      	mov	r0, r3
 8000a54:	370c      	adds	r7, #12
 8000a56:	46bd      	mov	sp, r7
 8000a58:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000a5c:	4770      	bx	lr

08000a5e <_fstat>:


int _fstat(int file, struct stat *st)
{
 8000a5e:	b480      	push	{r7}
 8000a60:	b083      	sub	sp, #12
 8000a62:	af00      	add	r7, sp, #0
 8000a64:	6078      	str	r0, [r7, #4]
 8000a66:	6039      	str	r1, [r7, #0]
  (void)file;
  st->st_mode = S_IFCHR;
 8000a68:	683b      	ldr	r3, [r7, #0]
 8000a6a:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
 8000a6e:	605a      	str	r2, [r3, #4]
  return 0;
 8000a70:	2300      	movs	r3, #0
}
 8000a72:	4618      	mov	r0, r3
 8000a74:	370c      	adds	r7, #12
 8000a76:	46bd      	mov	sp, r7
 8000a78:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000a7c:	4770      	bx	lr

08000a7e <_isatty>:

int _isatty(int file)
{
 8000a7e:	b480      	push	{r7}
 8000a80:	b083      	sub	sp, #12
 8000a82:	af00      	add	r7, sp, #0
 8000a84:	6078      	str	r0, [r7, #4]
  (void)file;
  return 1;
 8000a86:	2301      	movs	r3, #1
}
 8000a88:	4618      	mov	r0, r3
 8000a8a:	370c      	adds	r7, #12
 8000a8c:	46bd      	mov	sp, r7
 8000a8e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000a92:	4770      	bx	lr

08000a94 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
 8000a94:	b480      	push	{r7}
 8000a96:	b085      	sub	sp, #20
 8000a98:	af00      	add	r7, sp, #0
 8000a9a:	60f8      	str	r0, [r7, #12]
 8000a9c:	60b9      	str	r1, [r7, #8]
 8000a9e:	607a      	str	r2, [r7, #4]
  (void)file;
  (void)ptr;
  (void)dir;
  return 0;
 8000aa0:	2300      	movs	r3, #0
}
 8000aa2:	4618      	mov	r0, r3
 8000aa4:	3714      	adds	r7, #20
 8000aa6:	46bd      	mov	sp, r7
 8000aa8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000aac:	4770      	bx	lr
	...

08000ab0 <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
 8000ab0:	b580      	push	{r7, lr}
 8000ab2:	b086      	sub	sp, #24
 8000ab4:	af00      	add	r7, sp, #0
 8000ab6:	6078      	str	r0, [r7, #4]
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 8000ab8:	4a14      	ldr	r2, [pc, #80]	@ (8000b0c <_sbrk+0x5c>)
 8000aba:	4b15      	ldr	r3, [pc, #84]	@ (8000b10 <_sbrk+0x60>)
 8000abc:	1ad3      	subs	r3, r2, r3
 8000abe:	617b      	str	r3, [r7, #20]
  const uint8_t *max_heap = (uint8_t *)stack_limit;
 8000ac0:	697b      	ldr	r3, [r7, #20]
 8000ac2:	613b      	str	r3, [r7, #16]
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 8000ac4:	4b13      	ldr	r3, [pc, #76]	@ (8000b14 <_sbrk+0x64>)
 8000ac6:	681b      	ldr	r3, [r3, #0]
 8000ac8:	2b00      	cmp	r3, #0
 8000aca:	d102      	bne.n	8000ad2 <_sbrk+0x22>
  {
    __sbrk_heap_end = &_end;
 8000acc:	4b11      	ldr	r3, [pc, #68]	@ (8000b14 <_sbrk+0x64>)
 8000ace:	4a12      	ldr	r2, [pc, #72]	@ (8000b18 <_sbrk+0x68>)
 8000ad0:	601a      	str	r2, [r3, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 8000ad2:	4b10      	ldr	r3, [pc, #64]	@ (8000b14 <_sbrk+0x64>)
 8000ad4:	681a      	ldr	r2, [r3, #0]
 8000ad6:	687b      	ldr	r3, [r7, #4]
 8000ad8:	4413      	add	r3, r2
 8000ada:	693a      	ldr	r2, [r7, #16]
 8000adc:	429a      	cmp	r2, r3
 8000ade:	d207      	bcs.n	8000af0 <_sbrk+0x40>
  {
    errno = ENOMEM;
 8000ae0:	f010 fb06 	bl	80110f0 <__errno>
 8000ae4:	4603      	mov	r3, r0
 8000ae6:	220c      	movs	r2, #12
 8000ae8:	601a      	str	r2, [r3, #0]
    return (void *)-1;
 8000aea:	f04f 33ff 	mov.w	r3, #4294967295
 8000aee:	e009      	b.n	8000b04 <_sbrk+0x54>
  }

  prev_heap_end = __sbrk_heap_end;
 8000af0:	4b08      	ldr	r3, [pc, #32]	@ (8000b14 <_sbrk+0x64>)
 8000af2:	681b      	ldr	r3, [r3, #0]
 8000af4:	60fb      	str	r3, [r7, #12]
  __sbrk_heap_end += incr;
 8000af6:	4b07      	ldr	r3, [pc, #28]	@ (8000b14 <_sbrk+0x64>)
 8000af8:	681a      	ldr	r2, [r3, #0]
 8000afa:	687b      	ldr	r3, [r7, #4]
 8000afc:	4413      	add	r3, r2
 8000afe:	4a05      	ldr	r2, [pc, #20]	@ (8000b14 <_sbrk+0x64>)
 8000b00:	6013      	str	r3, [r2, #0]

  return (void *)prev_heap_end;
 8000b02:	68fb      	ldr	r3, [r7, #12]
}
 8000b04:	4618      	mov	r0, r3
 8000b06:	3718      	adds	r7, #24
 8000b08:	46bd      	mov	sp, r7
 8000b0a:	bd80      	pop	{r7, pc}
 8000b0c:	20040000 	.word	0x20040000
 8000b10:	00000400 	.word	0x00000400
 8000b14:	20000178 	.word	0x20000178
 8000b18:	20002e00 	.word	0x20002e00

08000b1c <SystemInit>:
  * @param  None
  * @retval None
  */

void SystemInit(void)
{
 8000b1c:	b480      	push	{r7}
 8000b1e:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
   SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
 8000b20:	4b18      	ldr	r3, [pc, #96]	@ (8000b84 <SystemInit+0x68>)
 8000b22:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8000b26:	4a17      	ldr	r2, [pc, #92]	@ (8000b84 <SystemInit+0x68>)
 8000b28:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
 8000b2c:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88
  #endif

  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR = RCC_CR_MSISON;
 8000b30:	4b15      	ldr	r3, [pc, #84]	@ (8000b88 <SystemInit+0x6c>)
 8000b32:	2201      	movs	r2, #1
 8000b34:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR1 = 0U;
 8000b36:	4b14      	ldr	r3, [pc, #80]	@ (8000b88 <SystemInit+0x6c>)
 8000b38:	2200      	movs	r2, #0
 8000b3a:	61da      	str	r2, [r3, #28]
  RCC->CFGR2 = 0U;
 8000b3c:	4b12      	ldr	r3, [pc, #72]	@ (8000b88 <SystemInit+0x6c>)
 8000b3e:	2200      	movs	r2, #0
 8000b40:	621a      	str	r2, [r3, #32]
  RCC->CFGR3 = 0U;
 8000b42:	4b11      	ldr	r3, [pc, #68]	@ (8000b88 <SystemInit+0x6c>)
 8000b44:	2200      	movs	r2, #0
 8000b46:	625a      	str	r2, [r3, #36]	@ 0x24

  /* Reset HSEON, CSSON , HSION, PLLxON bits */
  RCC->CR &= ~(RCC_CR_HSEON | RCC_CR_CSSON | RCC_CR_PLL1ON | RCC_CR_PLL2ON | RCC_CR_PLL3ON);
 8000b48:	4b0f      	ldr	r3, [pc, #60]	@ (8000b88 <SystemInit+0x6c>)
 8000b4a:	681b      	ldr	r3, [r3, #0]
 8000b4c:	4a0e      	ldr	r2, [pc, #56]	@ (8000b88 <SystemInit+0x6c>)
 8000b4e:	f023 53a8 	bic.w	r3, r3, #352321536	@ 0x15000000
 8000b52:	f423 2310 	bic.w	r3, r3, #589824	@ 0x90000
 8000b56:	6013      	str	r3, [r2, #0]

  /* Reset PLLCFGR register */
  RCC->PLL1CFGR = 0U;
 8000b58:	4b0b      	ldr	r3, [pc, #44]	@ (8000b88 <SystemInit+0x6c>)
 8000b5a:	2200      	movs	r2, #0
 8000b5c:	629a      	str	r2, [r3, #40]	@ 0x28

  /* Reset HSEBYP bit */
  RCC->CR &= ~(RCC_CR_HSEBYP);
 8000b5e:	4b0a      	ldr	r3, [pc, #40]	@ (8000b88 <SystemInit+0x6c>)
 8000b60:	681b      	ldr	r3, [r3, #0]
 8000b62:	4a09      	ldr	r2, [pc, #36]	@ (8000b88 <SystemInit+0x6c>)
 8000b64:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
 8000b68:	6013      	str	r3, [r2, #0]

  /* Disable all interrupts */
  RCC->CIER = 0U;
 8000b6a:	4b07      	ldr	r3, [pc, #28]	@ (8000b88 <SystemInit+0x6c>)
 8000b6c:	2200      	movs	r2, #0
 8000b6e:	651a      	str	r2, [r3, #80]	@ 0x50

  /* Configure the Vector Table location add offset address ------------------*/
  #ifdef VECT_TAB_SRAM
    SCB->VTOR = SRAM1_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
  #else
    SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8000b70:	4b04      	ldr	r3, [pc, #16]	@ (8000b84 <SystemInit+0x68>)
 8000b72:	f04f 6200 	mov.w	r2, #134217728	@ 0x8000000
 8000b76:	609a      	str	r2, [r3, #8]
  #endif
}
 8000b78:	bf00      	nop
 8000b7a:	46bd      	mov	sp, r7
 8000b7c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000b80:	4770      	bx	lr
 8000b82:	bf00      	nop
 8000b84:	e000ed00 	.word	0xe000ed00
 8000b88:	46020c00 	.word	0x46020c00

08000b8c <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 8000b8c:	480d      	ldr	r0, [pc, #52]	@ (8000bc4 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 8000b8e:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
 8000b90:	f7ff ffc4 	bl	8000b1c <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 8000b94:	480c      	ldr	r0, [pc, #48]	@ (8000bc8 <LoopForever+0x6>)
  ldr r1, =_edata
 8000b96:	490d      	ldr	r1, [pc, #52]	@ (8000bcc <LoopForever+0xa>)
  ldr r2, =_sidata
 8000b98:	4a0d      	ldr	r2, [pc, #52]	@ (8000bd0 <LoopForever+0xe>)
  movs r3, #0
 8000b9a:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8000b9c:	e002      	b.n	8000ba4 <LoopCopyDataInit>

08000b9e <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8000b9e:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8000ba0:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8000ba2:	3304      	adds	r3, #4

08000ba4 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8000ba4:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8000ba6:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8000ba8:	d3f9      	bcc.n	8000b9e <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8000baa:	4a0a      	ldr	r2, [pc, #40]	@ (8000bd4 <LoopForever+0x12>)
  ldr r4, =_ebss
 8000bac:	4c0a      	ldr	r4, [pc, #40]	@ (8000bd8 <LoopForever+0x16>)
  movs r3, #0
 8000bae:	2300      	movs	r3, #0
  b LoopFillZerobss
 8000bb0:	e001      	b.n	8000bb6 <LoopFillZerobss>

08000bb2 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8000bb2:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8000bb4:	3204      	adds	r2, #4

08000bb6 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 8000bb6:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8000bb8:	d3fb      	bcc.n	8000bb2 <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
 8000bba:	f010 fa9f 	bl	80110fc <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 8000bbe:	f7ff fce7 	bl	8000590 <main>

08000bc2 <LoopForever>:

LoopForever:
    b LoopForever
 8000bc2:	e7fe      	b.n	8000bc2 <LoopForever>
  ldr   r0, =_estack
 8000bc4:	20040000 	.word	0x20040000
  ldr r0, =_sdata
 8000bc8:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8000bcc:	200000cc 	.word	0x200000cc
  ldr r2, =_sidata
 8000bd0:	0801178c 	.word	0x0801178c
  ldr r2, =_sbss
 8000bd4:	200000d0 	.word	0x200000d0
  ldr r4, =_ebss
 8000bd8:	20002dfc 	.word	0x20002dfc

08000bdc <ADC1_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 8000bdc:	e7fe      	b.n	8000bdc <ADC1_IRQHandler>
	...

08000be0 <BSP_LED_Init>:
  *     @arg  LED2
  *     @arg  LED3
  * @retval BSP status
  */
int32_t BSP_LED_Init(Led_TypeDef Led)
{
 8000be0:	b580      	push	{r7, lr}
 8000be2:	b08a      	sub	sp, #40	@ 0x28
 8000be4:	af00      	add	r7, sp, #0
 8000be6:	4603      	mov	r3, r0
 8000be8:	71fb      	strb	r3, [r7, #7]
  int32_t ret = BSP_ERROR_NONE;
 8000bea:	2300      	movs	r3, #0
 8000bec:	627b      	str	r3, [r7, #36]	@ 0x24
  GPIO_InitTypeDef  gpio_init_structure;
#if defined (USE_NUCLEO_144)
  uint32_t pwrenabled = 0U;
#endif /* USE_NUCLEO_144 */

  if ((Led != LED2)
 8000bee:	79fb      	ldrb	r3, [r7, #7]
 8000bf0:	2b00      	cmp	r3, #0
 8000bf2:	d003      	beq.n	8000bfc <BSP_LED_Init+0x1c>
#if defined (USE_NUCLEO_144)
      && (Led != LED1) && (Led != LED3)
#endif /* defined (USE_NUCLEO_144) */
     )
  {
    ret = BSP_ERROR_WRONG_PARAM;
 8000bf4:	f06f 0301 	mvn.w	r3, #1
 8000bf8:	627b      	str	r3, [r7, #36]	@ 0x24
 8000bfa:	e023      	b.n	8000c44 <BSP_LED_Init+0x64>
  }
  else
  {
    /* Enable the GPIO LED Clock */
    if (Led == LED2)
 8000bfc:	79fb      	ldrb	r3, [r7, #7]
 8000bfe:	2b00      	cmp	r3, #0
 8000c00:	d10e      	bne.n	8000c20 <BSP_LED_Init+0x40>
    {
      LED2_GPIO_CLK_ENABLE();
 8000c02:	4b13      	ldr	r3, [pc, #76]	@ (8000c50 <BSP_LED_Init+0x70>)
 8000c04:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8000c08:	4a11      	ldr	r2, [pc, #68]	@ (8000c50 <BSP_LED_Init+0x70>)
 8000c0a:	f043 0301 	orr.w	r3, r3, #1
 8000c0e:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
 8000c12:	4b0f      	ldr	r3, [pc, #60]	@ (8000c50 <BSP_LED_Init+0x70>)
 8000c14:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8000c18:	f003 0301 	and.w	r3, r3, #1
 8000c1c:	60fb      	str	r3, [r7, #12]
 8000c1e:	68fb      	ldr	r3, [r7, #12]

      LED3_GPIO_CLK_ENABLE();
    }
#endif /* defined (USE_NUCLEO_144) */
    /* Configure the GPIO_LED pin */
    gpio_init_structure.Pin   = LED_PIN[Led];
 8000c20:	2320      	movs	r3, #32
 8000c22:	613b      	str	r3, [r7, #16]
    gpio_init_structure.Mode  = GPIO_MODE_OUTPUT_PP;
 8000c24:	2301      	movs	r3, #1
 8000c26:	617b      	str	r3, [r7, #20]
    gpio_init_structure.Pull  = GPIO_NOPULL;
 8000c28:	2300      	movs	r3, #0
 8000c2a:	61bb      	str	r3, [r7, #24]
    gpio_init_structure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8000c2c:	2303      	movs	r3, #3
 8000c2e:	61fb      	str	r3, [r7, #28]

    HAL_GPIO_Init(LED_PORT[Led], &gpio_init_structure);
 8000c30:	79fb      	ldrb	r3, [r7, #7]
 8000c32:	4a08      	ldr	r2, [pc, #32]	@ (8000c54 <BSP_LED_Init+0x74>)
 8000c34:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8000c38:	f107 0210 	add.w	r2, r7, #16
 8000c3c:	4611      	mov	r1, r2
 8000c3e:	4618      	mov	r0, r3
 8000c40:	f000 fb60 	bl	8001304 <HAL_GPIO_Init>
  }

  return ret;
 8000c44:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 8000c46:	4618      	mov	r0, r3
 8000c48:	3728      	adds	r7, #40	@ 0x28
 8000c4a:	46bd      	mov	sp, r7
 8000c4c:	bd80      	pop	{r7, pc}
 8000c4e:	bf00      	nop
 8000c50:	46020c00 	.word	0x46020c00
 8000c54:	20000008 	.word	0x20000008

08000c58 <BSP_COM_Init>:
  * @param  COM_Init Pointer to a UART_HandleTypeDef structure that contains the
  *                  configuration information for the specified USART peripheral.
  * @retval BSP error code
  */
int32_t BSP_COM_Init(COM_TypeDef COM, COM_InitTypeDef *COM_Init)
{
 8000c58:	b580      	push	{r7, lr}
 8000c5a:	b084      	sub	sp, #16
 8000c5c:	af00      	add	r7, sp, #0
 8000c5e:	4603      	mov	r3, r0
 8000c60:	6039      	str	r1, [r7, #0]
 8000c62:	71fb      	strb	r3, [r7, #7]
  int32_t ret = BSP_ERROR_NONE;
 8000c64:	2300      	movs	r3, #0
 8000c66:	60fb      	str	r3, [r7, #12]

  if (COM >= COMn)
 8000c68:	79fb      	ldrb	r3, [r7, #7]
 8000c6a:	2b00      	cmp	r3, #0
 8000c6c:	d003      	beq.n	8000c76 <BSP_COM_Init+0x1e>
  {
    ret = BSP_ERROR_WRONG_PARAM;
 8000c6e:	f06f 0301 	mvn.w	r3, #1
 8000c72:	60fb      	str	r3, [r7, #12]
 8000c74:	e018      	b.n	8000ca8 <BSP_COM_Init+0x50>
  }
  else
  {
#if (USE_HAL_UART_REGISTER_CALLBACKS == 0)
    /* Init the UART Msp */
    COM1_MspInit(&hcom_uart[COM]);
 8000c76:	79fb      	ldrb	r3, [r7, #7]
 8000c78:	2294      	movs	r2, #148	@ 0x94
 8000c7a:	fb02 f303 	mul.w	r3, r2, r3
 8000c7e:	4a0d      	ldr	r2, [pc, #52]	@ (8000cb4 <BSP_COM_Init+0x5c>)
 8000c80:	4413      	add	r3, r2
 8000c82:	4618      	mov	r0, r3
 8000c84:	f000 f868 	bl	8000d58 <COM1_MspInit>
        return BSP_ERROR_MSP_FAILURE;
      }
    }
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS == 0) */

    if (MX_USART1_Init(&hcom_uart[COM], COM_Init) != HAL_OK)
 8000c88:	79fb      	ldrb	r3, [r7, #7]
 8000c8a:	2294      	movs	r2, #148	@ 0x94
 8000c8c:	fb02 f303 	mul.w	r3, r2, r3
 8000c90:	4a08      	ldr	r2, [pc, #32]	@ (8000cb4 <BSP_COM_Init+0x5c>)
 8000c92:	4413      	add	r3, r2
 8000c94:	6839      	ldr	r1, [r7, #0]
 8000c96:	4618      	mov	r0, r3
 8000c98:	f000 f80e 	bl	8000cb8 <MX_USART1_Init>
 8000c9c:	4603      	mov	r3, r0
 8000c9e:	2b00      	cmp	r3, #0
 8000ca0:	d002      	beq.n	8000ca8 <BSP_COM_Init+0x50>
    {
      ret = BSP_ERROR_PERIPH_FAILURE;
 8000ca2:	f06f 0303 	mvn.w	r3, #3
 8000ca6:	60fb      	str	r3, [r7, #12]
    }
  }

  return ret;
 8000ca8:	68fb      	ldr	r3, [r7, #12]
}
 8000caa:	4618      	mov	r0, r3
 8000cac:	3710      	adds	r7, #16
 8000cae:	46bd      	mov	sp, r7
 8000cb0:	bd80      	pop	{r7, pc}
 8000cb2:	bf00      	nop
 8000cb4:	2000017c 	.word	0x2000017c

08000cb8 <MX_USART1_Init>:
  * @param  COM_Init Pointer to a UART_HandleTypeDef structure that contains the
  *                  configuration information for the specified USART peripheral.
  * @retval HAL error code
  */
__weak HAL_StatusTypeDef MX_USART1_Init(UART_HandleTypeDef *huart, MX_UART_InitTypeDef *COM_Init)
{
 8000cb8:	b580      	push	{r7, lr}
 8000cba:	b082      	sub	sp, #8
 8000cbc:	af00      	add	r7, sp, #0
 8000cbe:	6078      	str	r0, [r7, #4]
 8000cc0:	6039      	str	r1, [r7, #0]
  /* USART configuration */
  huart->Instance                = COM_USART[COM1];
 8000cc2:	4b16      	ldr	r3, [pc, #88]	@ (8000d1c <MX_USART1_Init+0x64>)
 8000cc4:	681a      	ldr	r2, [r3, #0]
 8000cc6:	687b      	ldr	r3, [r7, #4]
 8000cc8:	601a      	str	r2, [r3, #0]
  huart->Init.BaudRate           = COM_Init->BaudRate;
 8000cca:	683b      	ldr	r3, [r7, #0]
 8000ccc:	681a      	ldr	r2, [r3, #0]
 8000cce:	687b      	ldr	r3, [r7, #4]
 8000cd0:	605a      	str	r2, [r3, #4]
  huart->Init.Mode               = UART_MODE_TX_RX;
 8000cd2:	687b      	ldr	r3, [r7, #4]
 8000cd4:	220c      	movs	r2, #12
 8000cd6:	615a      	str	r2, [r3, #20]
  huart->Init.Parity             = (uint32_t)COM_Init->Parity;
 8000cd8:	683b      	ldr	r3, [r7, #0]
 8000cda:	895b      	ldrh	r3, [r3, #10]
 8000cdc:	461a      	mov	r2, r3
 8000cde:	687b      	ldr	r3, [r7, #4]
 8000ce0:	611a      	str	r2, [r3, #16]
  huart->Init.WordLength         = (uint32_t)COM_Init->WordLength;
 8000ce2:	683b      	ldr	r3, [r7, #0]
 8000ce4:	685a      	ldr	r2, [r3, #4]
 8000ce6:	687b      	ldr	r3, [r7, #4]
 8000ce8:	609a      	str	r2, [r3, #8]
  huart->Init.StopBits           = (uint32_t)COM_Init->StopBits;
 8000cea:	683b      	ldr	r3, [r7, #0]
 8000cec:	891b      	ldrh	r3, [r3, #8]
 8000cee:	461a      	mov	r2, r3
 8000cf0:	687b      	ldr	r3, [r7, #4]
 8000cf2:	60da      	str	r2, [r3, #12]
  huart->Init.HwFlowCtl          = (uint32_t)COM_Init->HwFlowCtl;
 8000cf4:	683b      	ldr	r3, [r7, #0]
 8000cf6:	899b      	ldrh	r3, [r3, #12]
 8000cf8:	461a      	mov	r2, r3
 8000cfa:	687b      	ldr	r3, [r7, #4]
 8000cfc:	619a      	str	r2, [r3, #24]
  huart->Init.OverSampling       = UART_OVERSAMPLING_8;
 8000cfe:	687b      	ldr	r3, [r7, #4]
 8000d00:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
 8000d04:	61da      	str	r2, [r3, #28]
  huart->Init.ClockPrescaler     = UART_PRESCALER_DIV1;
 8000d06:	687b      	ldr	r3, [r7, #4]
 8000d08:	2200      	movs	r2, #0
 8000d0a:	625a      	str	r2, [r3, #36]	@ 0x24
  return HAL_UART_Init(huart);
 8000d0c:	6878      	ldr	r0, [r7, #4]
 8000d0e:	f006 f86f 	bl	8006df0 <HAL_UART_Init>
 8000d12:	4603      	mov	r3, r0
}
 8000d14:	4618      	mov	r0, r3
 8000d16:	3708      	adds	r7, #8
 8000d18:	46bd      	mov	sp, r7
 8000d1a:	bd80      	pop	{r7, pc}
 8000d1c:	20000004 	.word	0x20000004

08000d20 <__io_putchar>:

/**
  * @brief  Redirect console output to COM
  */
PUTCHAR_PROTOTYPE
{
 8000d20:	b580      	push	{r7, lr}
 8000d22:	b082      	sub	sp, #8
 8000d24:	af00      	add	r7, sp, #0
 8000d26:	6078      	str	r0, [r7, #4]
  HAL_UART_Transmit(&hcom_uart [COM_ActiveLogPort], (uint8_t *) &ch, 1, COM_POLL_TIMEOUT);
 8000d28:	4b09      	ldr	r3, [pc, #36]	@ (8000d50 <__io_putchar+0x30>)
 8000d2a:	781b      	ldrb	r3, [r3, #0]
 8000d2c:	461a      	mov	r2, r3
 8000d2e:	2394      	movs	r3, #148	@ 0x94
 8000d30:	fb02 f303 	mul.w	r3, r2, r3
 8000d34:	4a07      	ldr	r2, [pc, #28]	@ (8000d54 <__io_putchar+0x34>)
 8000d36:	1898      	adds	r0, r3, r2
 8000d38:	1d39      	adds	r1, r7, #4
 8000d3a:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
 8000d3e:	2201      	movs	r2, #1
 8000d40:	f006 f8b0 	bl	8006ea4 <HAL_UART_Transmit>
  return ch;
 8000d44:	687b      	ldr	r3, [r7, #4]
}
 8000d46:	4618      	mov	r0, r3
 8000d48:	3708      	adds	r7, #8
 8000d4a:	46bd      	mov	sp, r7
 8000d4c:	bd80      	pop	{r7, pc}
 8000d4e:	bf00      	nop
 8000d50:	20000210 	.word	0x20000210
 8000d54:	2000017c 	.word	0x2000017c

08000d58 <COM1_MspInit>:
  * @brief  Initializes UART MSP.
  * @param  huart UART handle
  * @retval BSP status
  */
static void COM1_MspInit(UART_HandleTypeDef *huart)
{
 8000d58:	b580      	push	{r7, lr}
 8000d5a:	b08a      	sub	sp, #40	@ 0x28
 8000d5c:	af00      	add	r7, sp, #0
 8000d5e:	6078      	str	r0, [r7, #4]

  /* Prevent unused argument(s) compilation warning */
  UNUSED(huart);

  /* Enable GPIO clock */
  COM1_TX_GPIO_CLK_ENABLE();
 8000d60:	4b27      	ldr	r3, [pc, #156]	@ (8000e00 <COM1_MspInit+0xa8>)
 8000d62:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8000d66:	4a26      	ldr	r2, [pc, #152]	@ (8000e00 <COM1_MspInit+0xa8>)
 8000d68:	f043 0301 	orr.w	r3, r3, #1
 8000d6c:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
 8000d70:	4b23      	ldr	r3, [pc, #140]	@ (8000e00 <COM1_MspInit+0xa8>)
 8000d72:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8000d76:	f003 0301 	and.w	r3, r3, #1
 8000d7a:	613b      	str	r3, [r7, #16]
 8000d7c:	693b      	ldr	r3, [r7, #16]
  COM1_RX_GPIO_CLK_ENABLE();
 8000d7e:	4b20      	ldr	r3, [pc, #128]	@ (8000e00 <COM1_MspInit+0xa8>)
 8000d80:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8000d84:	4a1e      	ldr	r2, [pc, #120]	@ (8000e00 <COM1_MspInit+0xa8>)
 8000d86:	f043 0301 	orr.w	r3, r3, #1
 8000d8a:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
 8000d8e:	4b1c      	ldr	r3, [pc, #112]	@ (8000e00 <COM1_MspInit+0xa8>)
 8000d90:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8000d94:	f003 0301 	and.w	r3, r3, #1
 8000d98:	60fb      	str	r3, [r7, #12]
 8000d9a:	68fb      	ldr	r3, [r7, #12]

  /* Enable USART clock */
  COM1_CLK_ENABLE();
 8000d9c:	4b18      	ldr	r3, [pc, #96]	@ (8000e00 <COM1_MspInit+0xa8>)
 8000d9e:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
 8000da2:	4a17      	ldr	r2, [pc, #92]	@ (8000e00 <COM1_MspInit+0xa8>)
 8000da4:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 8000da8:	f8c2 30a4 	str.w	r3, [r2, #164]	@ 0xa4
 8000dac:	4b14      	ldr	r3, [pc, #80]	@ (8000e00 <COM1_MspInit+0xa8>)
 8000dae:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
 8000db2:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 8000db6:	60bb      	str	r3, [r7, #8]
 8000db8:	68bb      	ldr	r3, [r7, #8]

  /* Configure USART Tx as alternate function */
  gpio_init_structure.Pin       = COM1_TX_PIN;
 8000dba:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8000dbe:	617b      	str	r3, [r7, #20]
  gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
 8000dc0:	2302      	movs	r3, #2
 8000dc2:	61bb      	str	r3, [r7, #24]
  gpio_init_structure.Speed     = GPIO_SPEED_FREQ_HIGH;
 8000dc4:	2302      	movs	r3, #2
 8000dc6:	623b      	str	r3, [r7, #32]
  gpio_init_structure.Pull      = GPIO_PULLUP;
 8000dc8:	2301      	movs	r3, #1
 8000dca:	61fb      	str	r3, [r7, #28]
  gpio_init_structure.Alternate = COM1_TX_AF;
 8000dcc:	2307      	movs	r3, #7
 8000dce:	627b      	str	r3, [r7, #36]	@ 0x24
  HAL_GPIO_Init(COM1_TX_GPIO_PORT, &gpio_init_structure);
 8000dd0:	f107 0314 	add.w	r3, r7, #20
 8000dd4:	4619      	mov	r1, r3
 8000dd6:	480b      	ldr	r0, [pc, #44]	@ (8000e04 <COM1_MspInit+0xac>)
 8000dd8:	f000 fa94 	bl	8001304 <HAL_GPIO_Init>

  /* Configure USART Rx as alternate function */
  gpio_init_structure.Pin       = COM1_RX_PIN;
 8000ddc:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 8000de0:	617b      	str	r3, [r7, #20]
  gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
 8000de2:	2302      	movs	r3, #2
 8000de4:	61bb      	str	r3, [r7, #24]
  gpio_init_structure.Alternate = COM1_RX_AF;
 8000de6:	2307      	movs	r3, #7
 8000de8:	627b      	str	r3, [r7, #36]	@ 0x24
  HAL_GPIO_Init(COM1_RX_GPIO_PORT, &gpio_init_structure);
 8000dea:	f107 0314 	add.w	r3, r7, #20
 8000dee:	4619      	mov	r1, r3
 8000df0:	4804      	ldr	r0, [pc, #16]	@ (8000e04 <COM1_MspInit+0xac>)
 8000df2:	f000 fa87 	bl	8001304 <HAL_GPIO_Init>
}
 8000df6:	bf00      	nop
 8000df8:	3728      	adds	r7, #40	@ 0x28
 8000dfa:	46bd      	mov	sp, r7
 8000dfc:	bd80      	pop	{r7, pc}
 8000dfe:	bf00      	nop
 8000e00:	46020c00 	.word	0x46020c00
 8000e04:	42020000 	.word	0x42020000

08000e08 <HAL_Init>:
  *         each 1ms in the SysTick_Handler() interrupt handler.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8000e08:	b580      	push	{r7, lr}
 8000e0a:	af00      	add	r7, sp, #0
  /* Configure Flash prefetch */
#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8000e0c:	4b12      	ldr	r3, [pc, #72]	@ (8000e58 <HAL_Init+0x50>)
 8000e0e:	681b      	ldr	r3, [r3, #0]
 8000e10:	4a11      	ldr	r2, [pc, #68]	@ (8000e58 <HAL_Init+0x50>)
 8000e12:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8000e16:	6013      	str	r3, [r2, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8000e18:	2003      	movs	r0, #3
 8000e1a:	f000 f98c 	bl	8001136 <HAL_NVIC_SetPriorityGrouping>

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR2 & RCC_CFGR2_HPRE) >> RCC_CFGR2_HPRE_Pos];
 8000e1e:	f001 fe3d 	bl	8002a9c <HAL_RCC_GetSysClockFreq>
 8000e22:	4602      	mov	r2, r0
 8000e24:	4b0d      	ldr	r3, [pc, #52]	@ (8000e5c <HAL_Init+0x54>)
 8000e26:	6a1b      	ldr	r3, [r3, #32]
 8000e28:	f003 030f 	and.w	r3, r3, #15
 8000e2c:	490c      	ldr	r1, [pc, #48]	@ (8000e60 <HAL_Init+0x58>)
 8000e2e:	5ccb      	ldrb	r3, [r1, r3]
 8000e30:	fa22 f303 	lsr.w	r3, r2, r3
 8000e34:	4a0b      	ldr	r2, [pc, #44]	@ (8000e64 <HAL_Init+0x5c>)
 8000e36:	6013      	str	r3, [r2, #0]

  /* Select HCLK as SysTick clock source */
  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
 8000e38:	2004      	movs	r0, #4
 8000e3a:	f000 f9d1 	bl	80011e0 <HAL_SYSTICK_CLKSourceConfig>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 8000e3e:	200f      	movs	r0, #15
 8000e40:	f000 f812 	bl	8000e68 <HAL_InitTick>
 8000e44:	4603      	mov	r3, r0
 8000e46:	2b00      	cmp	r3, #0
 8000e48:	d001      	beq.n	8000e4e <HAL_Init+0x46>
  {
    return HAL_ERROR;
 8000e4a:	2301      	movs	r3, #1
 8000e4c:	e002      	b.n	8000e54 <HAL_Init+0x4c>
  }

  /* Init the low level hardware */
  HAL_MspInit();
 8000e4e:	f7ff fcbb 	bl	80007c8 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
 8000e52:	2300      	movs	r3, #0
}
 8000e54:	4618      	mov	r0, r3
 8000e56:	bd80      	pop	{r7, pc}
 8000e58:	40022000 	.word	0x40022000
 8000e5c:	46020c00 	.word	0x46020c00
 8000e60:	0801168c 	.word	0x0801168c
 8000e64:	20000000 	.word	0x20000000

08000e68 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8000e68:	b580      	push	{r7, lr}
 8000e6a:	b084      	sub	sp, #16
 8000e6c:	af00      	add	r7, sp, #0
 8000e6e:	6078      	str	r0, [r7, #4]
  uint32_t ticknumber = 0U;
 8000e70:	2300      	movs	r3, #0
 8000e72:	60fb      	str	r3, [r7, #12]
  uint32_t systicksel;

  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/
  if ((uint32_t)uwTickFreq == 0UL)
 8000e74:	4b33      	ldr	r3, [pc, #204]	@ (8000f44 <HAL_InitTick+0xdc>)
 8000e76:	781b      	ldrb	r3, [r3, #0]
 8000e78:	2b00      	cmp	r3, #0
 8000e7a:	d101      	bne.n	8000e80 <HAL_InitTick+0x18>
  {
    return HAL_ERROR;
 8000e7c:	2301      	movs	r3, #1
 8000e7e:	e05c      	b.n	8000f3a <HAL_InitTick+0xd2>
  }

  /* Check Clock source to calculate the tickNumber */
  if (READ_BIT(SysTick->CTRL, SysTick_CTRL_CLKSOURCE_Msk) == SysTick_CTRL_CLKSOURCE_Msk)
 8000e80:	4b31      	ldr	r3, [pc, #196]	@ (8000f48 <HAL_InitTick+0xe0>)
 8000e82:	681b      	ldr	r3, [r3, #0]
 8000e84:	f003 0304 	and.w	r3, r3, #4
 8000e88:	2b04      	cmp	r3, #4
 8000e8a:	d10c      	bne.n	8000ea6 <HAL_InitTick+0x3e>
  {
    /* HCLK selected as SysTick clock source */
    ticknumber = SystemCoreClock / (1000UL / (uint32_t)uwTickFreq);
 8000e8c:	4b2f      	ldr	r3, [pc, #188]	@ (8000f4c <HAL_InitTick+0xe4>)
 8000e8e:	681a      	ldr	r2, [r3, #0]
 8000e90:	4b2c      	ldr	r3, [pc, #176]	@ (8000f44 <HAL_InitTick+0xdc>)
 8000e92:	781b      	ldrb	r3, [r3, #0]
 8000e94:	4619      	mov	r1, r3
 8000e96:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
 8000e9a:	fbb3 f3f1 	udiv	r3, r3, r1
 8000e9e:	fbb2 f3f3 	udiv	r3, r2, r3
 8000ea2:	60fb      	str	r3, [r7, #12]
 8000ea4:	e037      	b.n	8000f16 <HAL_InitTick+0xae>
  }
  else
  {
    systicksel = HAL_SYSTICK_GetCLKSourceConfig();
 8000ea6:	f000 f9f3 	bl	8001290 <HAL_SYSTICK_GetCLKSourceConfig>
 8000eaa:	60b8      	str	r0, [r7, #8]
    switch (systicksel)
 8000eac:	68bb      	ldr	r3, [r7, #8]
 8000eae:	2b02      	cmp	r3, #2
 8000eb0:	d023      	beq.n	8000efa <HAL_InitTick+0x92>
 8000eb2:	68bb      	ldr	r3, [r7, #8]
 8000eb4:	2b02      	cmp	r3, #2
 8000eb6:	d82d      	bhi.n	8000f14 <HAL_InitTick+0xac>
 8000eb8:	68bb      	ldr	r3, [r7, #8]
 8000eba:	2b00      	cmp	r3, #0
 8000ebc:	d003      	beq.n	8000ec6 <HAL_InitTick+0x5e>
 8000ebe:	68bb      	ldr	r3, [r7, #8]
 8000ec0:	2b01      	cmp	r3, #1
 8000ec2:	d00d      	beq.n	8000ee0 <HAL_InitTick+0x78>
        /* Calculate tick value */
        ticknumber = (LSE_VALUE / (1000UL / (uint32_t)uwTickFreq));
        break;
      default:
        /* Nothing to do */
        break;
 8000ec4:	e026      	b.n	8000f14 <HAL_InitTick+0xac>
        ticknumber = (SystemCoreClock / (8000UL / (uint32_t)uwTickFreq));
 8000ec6:	4b21      	ldr	r3, [pc, #132]	@ (8000f4c <HAL_InitTick+0xe4>)
 8000ec8:	681a      	ldr	r2, [r3, #0]
 8000eca:	4b1e      	ldr	r3, [pc, #120]	@ (8000f44 <HAL_InitTick+0xdc>)
 8000ecc:	781b      	ldrb	r3, [r3, #0]
 8000ece:	4619      	mov	r1, r3
 8000ed0:	f44f 53fa 	mov.w	r3, #8000	@ 0x1f40
 8000ed4:	fbb3 f3f1 	udiv	r3, r3, r1
 8000ed8:	fbb2 f3f3 	udiv	r3, r2, r3
 8000edc:	60fb      	str	r3, [r7, #12]
        break;
 8000ede:	e01a      	b.n	8000f16 <HAL_InitTick+0xae>
        ticknumber = (LSI_VALUE / (1000UL / (uint32_t)uwTickFreq));
 8000ee0:	4b18      	ldr	r3, [pc, #96]	@ (8000f44 <HAL_InitTick+0xdc>)
 8000ee2:	781b      	ldrb	r3, [r3, #0]
 8000ee4:	461a      	mov	r2, r3
 8000ee6:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
 8000eea:	fbb3 f3f2 	udiv	r3, r3, r2
 8000eee:	f44f 42fa 	mov.w	r2, #32000	@ 0x7d00
 8000ef2:	fbb2 f3f3 	udiv	r3, r2, r3
 8000ef6:	60fb      	str	r3, [r7, #12]
        break;
 8000ef8:	e00d      	b.n	8000f16 <HAL_InitTick+0xae>
        ticknumber = (LSE_VALUE / (1000UL / (uint32_t)uwTickFreq));
 8000efa:	4b12      	ldr	r3, [pc, #72]	@ (8000f44 <HAL_InitTick+0xdc>)
 8000efc:	781b      	ldrb	r3, [r3, #0]
 8000efe:	461a      	mov	r2, r3
 8000f00:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
 8000f04:	fbb3 f3f2 	udiv	r3, r3, r2
 8000f08:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
 8000f0c:	fbb2 f3f3 	udiv	r3, r2, r3
 8000f10:	60fb      	str	r3, [r7, #12]
        break;
 8000f12:	e000      	b.n	8000f16 <HAL_InitTick+0xae>
        break;
 8000f14:	bf00      	nop
    }
  }

  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(ticknumber) > 0U)
 8000f16:	68f8      	ldr	r0, [r7, #12]
 8000f18:	f000 f940 	bl	800119c <HAL_SYSTICK_Config>
 8000f1c:	4603      	mov	r3, r0
 8000f1e:	2b00      	cmp	r3, #0
 8000f20:	d001      	beq.n	8000f26 <HAL_InitTick+0xbe>
  {
    return HAL_ERROR;
 8000f22:	2301      	movs	r3, #1
 8000f24:	e009      	b.n	8000f3a <HAL_InitTick+0xd2>
  }

  /* Configure the SysTick IRQ priority */
  HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 8000f26:	2200      	movs	r2, #0
 8000f28:	6879      	ldr	r1, [r7, #4]
 8000f2a:	f04f 30ff 	mov.w	r0, #4294967295
 8000f2e:	f000 f90d 	bl	800114c <HAL_NVIC_SetPriority>
  uwTickPrio = TickPriority;
 8000f32:	4a07      	ldr	r2, [pc, #28]	@ (8000f50 <HAL_InitTick+0xe8>)
 8000f34:	687b      	ldr	r3, [r7, #4]
 8000f36:	6013      	str	r3, [r2, #0]

  /* Return function status */
  return HAL_OK;
 8000f38:	2300      	movs	r3, #0
}
 8000f3a:	4618      	mov	r0, r3
 8000f3c:	3710      	adds	r7, #16
 8000f3e:	46bd      	mov	sp, r7
 8000f40:	bd80      	pop	{r7, pc}
 8000f42:	bf00      	nop
 8000f44:	20000010 	.word	0x20000010
 8000f48:	e000e010 	.word	0xe000e010
 8000f4c:	20000000 	.word	0x20000000
 8000f50:	2000000c 	.word	0x2000000c

08000f54 <HAL_IncTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 8000f54:	b480      	push	{r7}
 8000f56:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
 8000f58:	4b06      	ldr	r3, [pc, #24]	@ (8000f74 <HAL_IncTick+0x20>)
 8000f5a:	781b      	ldrb	r3, [r3, #0]
 8000f5c:	461a      	mov	r2, r3
 8000f5e:	4b06      	ldr	r3, [pc, #24]	@ (8000f78 <HAL_IncTick+0x24>)
 8000f60:	681b      	ldr	r3, [r3, #0]
 8000f62:	4413      	add	r3, r2
 8000f64:	4a04      	ldr	r2, [pc, #16]	@ (8000f78 <HAL_IncTick+0x24>)
 8000f66:	6013      	str	r3, [r2, #0]
}
 8000f68:	bf00      	nop
 8000f6a:	46bd      	mov	sp, r7
 8000f6c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000f70:	4770      	bx	lr
 8000f72:	bf00      	nop
 8000f74:	20000010 	.word	0x20000010
 8000f78:	20000214 	.word	0x20000214

08000f7c <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 8000f7c:	b480      	push	{r7}
 8000f7e:	af00      	add	r7, sp, #0
  return uwTick;
 8000f80:	4b03      	ldr	r3, [pc, #12]	@ (8000f90 <HAL_GetTick+0x14>)
 8000f82:	681b      	ldr	r3, [r3, #0]
}
 8000f84:	4618      	mov	r0, r3
 8000f86:	46bd      	mov	sp, r7
 8000f88:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000f8c:	4770      	bx	lr
 8000f8e:	bf00      	nop
 8000f90:	20000214 	.word	0x20000214

08000f94 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8000f94:	b580      	push	{r7, lr}
 8000f96:	b084      	sub	sp, #16
 8000f98:	af00      	add	r7, sp, #0
 8000f9a:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
 8000f9c:	f7ff ffee 	bl	8000f7c <HAL_GetTick>
 8000fa0:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
 8000fa2:	687b      	ldr	r3, [r7, #4]
 8000fa4:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 8000fa6:	68fb      	ldr	r3, [r7, #12]
 8000fa8:	f1b3 3fff 	cmp.w	r3, #4294967295
 8000fac:	d005      	beq.n	8000fba <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
 8000fae:	4b0a      	ldr	r3, [pc, #40]	@ (8000fd8 <HAL_Delay+0x44>)
 8000fb0:	781b      	ldrb	r3, [r3, #0]
 8000fb2:	461a      	mov	r2, r3
 8000fb4:	68fb      	ldr	r3, [r7, #12]
 8000fb6:	4413      	add	r3, r2
 8000fb8:	60fb      	str	r3, [r7, #12]
  }

  while ((HAL_GetTick() - tickstart) < wait)
 8000fba:	bf00      	nop
 8000fbc:	f7ff ffde 	bl	8000f7c <HAL_GetTick>
 8000fc0:	4602      	mov	r2, r0
 8000fc2:	68bb      	ldr	r3, [r7, #8]
 8000fc4:	1ad3      	subs	r3, r2, r3
 8000fc6:	68fa      	ldr	r2, [r7, #12]
 8000fc8:	429a      	cmp	r2, r3
 8000fca:	d8f7      	bhi.n	8000fbc <HAL_Delay+0x28>
  {
  }
}
 8000fcc:	bf00      	nop
 8000fce:	bf00      	nop
 8000fd0:	3710      	adds	r7, #16
 8000fd2:	46bd      	mov	sp, r7
 8000fd4:	bd80      	pop	{r7, pc}
 8000fd6:	bf00      	nop
 8000fd8:	20000010 	.word	0x20000010

08000fdc <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8000fdc:	b480      	push	{r7}
 8000fde:	b085      	sub	sp, #20
 8000fe0:	af00      	add	r7, sp, #0
 8000fe2:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 8000fe4:	687b      	ldr	r3, [r7, #4]
 8000fe6:	f003 0307 	and.w	r3, r3, #7
 8000fea:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000fec:	4b0c      	ldr	r3, [pc, #48]	@ (8001020 <__NVIC_SetPriorityGrouping+0x44>)
 8000fee:	68db      	ldr	r3, [r3, #12]
 8000ff0:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8000ff2:	68ba      	ldr	r2, [r7, #8]
 8000ff4:	f64f 03ff 	movw	r3, #63743	@ 0xf8ff
 8000ff8:	4013      	ands	r3, r2
 8000ffa:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8000ffc:	68fb      	ldr	r3, [r7, #12]
 8000ffe:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8001000:	68bb      	ldr	r3, [r7, #8]
 8001002:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 8001004:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
 8001008:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 800100c:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 800100e:	4a04      	ldr	r2, [pc, #16]	@ (8001020 <__NVIC_SetPriorityGrouping+0x44>)
 8001010:	68bb      	ldr	r3, [r7, #8]
 8001012:	60d3      	str	r3, [r2, #12]
}
 8001014:	bf00      	nop
 8001016:	3714      	adds	r7, #20
 8001018:	46bd      	mov	sp, r7
 800101a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800101e:	4770      	bx	lr
 8001020:	e000ed00 	.word	0xe000ed00

08001024 <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
 8001024:	b480      	push	{r7}
 8001026:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8001028:	4b04      	ldr	r3, [pc, #16]	@ (800103c <__NVIC_GetPriorityGrouping+0x18>)
 800102a:	68db      	ldr	r3, [r3, #12]
 800102c:	0a1b      	lsrs	r3, r3, #8
 800102e:	f003 0307 	and.w	r3, r3, #7
}
 8001032:	4618      	mov	r0, r3
 8001034:	46bd      	mov	sp, r7
 8001036:	f85d 7b04 	ldr.w	r7, [sp], #4
 800103a:	4770      	bx	lr
 800103c:	e000ed00 	.word	0xe000ed00

08001040 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8001040:	b480      	push	{r7}
 8001042:	b083      	sub	sp, #12
 8001044:	af00      	add	r7, sp, #0
 8001046:	4603      	mov	r3, r0
 8001048:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 800104a:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800104e:	2b00      	cmp	r3, #0
 8001050:	db0b      	blt.n	800106a <__NVIC_EnableIRQ+0x2a>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8001052:	79fb      	ldrb	r3, [r7, #7]
 8001054:	f003 021f 	and.w	r2, r3, #31
 8001058:	4907      	ldr	r1, [pc, #28]	@ (8001078 <__NVIC_EnableIRQ+0x38>)
 800105a:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800105e:	095b      	lsrs	r3, r3, #5
 8001060:	2001      	movs	r0, #1
 8001062:	fa00 f202 	lsl.w	r2, r0, r2
 8001066:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
 800106a:	bf00      	nop
 800106c:	370c      	adds	r7, #12
 800106e:	46bd      	mov	sp, r7
 8001070:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001074:	4770      	bx	lr
 8001076:	bf00      	nop
 8001078:	e000e100 	.word	0xe000e100

0800107c <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 800107c:	b480      	push	{r7}
 800107e:	b083      	sub	sp, #12
 8001080:	af00      	add	r7, sp, #0
 8001082:	4603      	mov	r3, r0
 8001084:	6039      	str	r1, [r7, #0]
 8001086:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8001088:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800108c:	2b00      	cmp	r3, #0
 800108e:	db0a      	blt.n	80010a6 <__NVIC_SetPriority+0x2a>
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001090:	683b      	ldr	r3, [r7, #0]
 8001092:	b2da      	uxtb	r2, r3
 8001094:	490c      	ldr	r1, [pc, #48]	@ (80010c8 <__NVIC_SetPriority+0x4c>)
 8001096:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800109a:	0112      	lsls	r2, r2, #4
 800109c:	b2d2      	uxtb	r2, r2
 800109e:	440b      	add	r3, r1
 80010a0:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 80010a4:	e00a      	b.n	80010bc <__NVIC_SetPriority+0x40>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80010a6:	683b      	ldr	r3, [r7, #0]
 80010a8:	b2da      	uxtb	r2, r3
 80010aa:	4908      	ldr	r1, [pc, #32]	@ (80010cc <__NVIC_SetPriority+0x50>)
 80010ac:	79fb      	ldrb	r3, [r7, #7]
 80010ae:	f003 030f 	and.w	r3, r3, #15
 80010b2:	3b04      	subs	r3, #4
 80010b4:	0112      	lsls	r2, r2, #4
 80010b6:	b2d2      	uxtb	r2, r2
 80010b8:	440b      	add	r3, r1
 80010ba:	761a      	strb	r2, [r3, #24]
}
 80010bc:	bf00      	nop
 80010be:	370c      	adds	r7, #12
 80010c0:	46bd      	mov	sp, r7
 80010c2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80010c6:	4770      	bx	lr
 80010c8:	e000e100 	.word	0xe000e100
 80010cc:	e000ed00 	.word	0xe000ed00

080010d0 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 80010d0:	b480      	push	{r7}
 80010d2:	b089      	sub	sp, #36	@ 0x24
 80010d4:	af00      	add	r7, sp, #0
 80010d6:	60f8      	str	r0, [r7, #12]
 80010d8:	60b9      	str	r1, [r7, #8]
 80010da:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 80010dc:	68fb      	ldr	r3, [r7, #12]
 80010de:	f003 0307 	and.w	r3, r3, #7
 80010e2:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80010e4:	69fb      	ldr	r3, [r7, #28]
 80010e6:	f1c3 0307 	rsb	r3, r3, #7
 80010ea:	2b04      	cmp	r3, #4
 80010ec:	bf28      	it	cs
 80010ee:	2304      	movcs	r3, #4
 80010f0:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80010f2:	69fb      	ldr	r3, [r7, #28]
 80010f4:	3304      	adds	r3, #4
 80010f6:	2b06      	cmp	r3, #6
 80010f8:	d902      	bls.n	8001100 <NVIC_EncodePriority+0x30>
 80010fa:	69fb      	ldr	r3, [r7, #28]
 80010fc:	3b03      	subs	r3, #3
 80010fe:	e000      	b.n	8001102 <NVIC_EncodePriority+0x32>
 8001100:	2300      	movs	r3, #0
 8001102:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8001104:	f04f 32ff 	mov.w	r2, #4294967295
 8001108:	69bb      	ldr	r3, [r7, #24]
 800110a:	fa02 f303 	lsl.w	r3, r2, r3
 800110e:	43da      	mvns	r2, r3
 8001110:	68bb      	ldr	r3, [r7, #8]
 8001112:	401a      	ands	r2, r3
 8001114:	697b      	ldr	r3, [r7, #20]
 8001116:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8001118:	f04f 31ff 	mov.w	r1, #4294967295
 800111c:	697b      	ldr	r3, [r7, #20]
 800111e:	fa01 f303 	lsl.w	r3, r1, r3
 8001122:	43d9      	mvns	r1, r3
 8001124:	687b      	ldr	r3, [r7, #4]
 8001126:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8001128:	4313      	orrs	r3, r2
         );
}
 800112a:	4618      	mov	r0, r3
 800112c:	3724      	adds	r7, #36	@ 0x24
 800112e:	46bd      	mov	sp, r7
 8001130:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001134:	4770      	bx	lr

08001136 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ pre-emption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8001136:	b580      	push	{r7, lr}
 8001138:	b082      	sub	sp, #8
 800113a:	af00      	add	r7, sp, #0
 800113c:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 800113e:	6878      	ldr	r0, [r7, #4]
 8001140:	f7ff ff4c 	bl	8000fdc <__NVIC_SetPriorityGrouping>
}
 8001144:	bf00      	nop
 8001146:	3708      	adds	r7, #8
 8001148:	46bd      	mov	sp, r7
 800114a:	bd80      	pop	{r7, pc}

0800114c <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 800114c:	b580      	push	{r7, lr}
 800114e:	b086      	sub	sp, #24
 8001150:	af00      	add	r7, sp, #0
 8001152:	4603      	mov	r3, r0
 8001154:	60b9      	str	r1, [r7, #8]
 8001156:	607a      	str	r2, [r7, #4]
 8001158:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();
 800115a:	f7ff ff63 	bl	8001024 <__NVIC_GetPriorityGrouping>
 800115e:	6178      	str	r0, [r7, #20]

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 8001160:	687a      	ldr	r2, [r7, #4]
 8001162:	68b9      	ldr	r1, [r7, #8]
 8001164:	6978      	ldr	r0, [r7, #20]
 8001166:	f7ff ffb3 	bl	80010d0 <NVIC_EncodePriority>
 800116a:	4602      	mov	r2, r0
 800116c:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8001170:	4611      	mov	r1, r2
 8001172:	4618      	mov	r0, r3
 8001174:	f7ff ff82 	bl	800107c <__NVIC_SetPriority>
}
 8001178:	bf00      	nop
 800117a:	3718      	adds	r7, #24
 800117c:	46bd      	mov	sp, r7
 800117e:	bd80      	pop	{r7, pc}

08001180 <HAL_NVIC_EnableIRQ>:
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate
  *          CMSIS device file (stm32u5xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8001180:	b580      	push	{r7, lr}
 8001182:	b082      	sub	sp, #8
 8001184:	af00      	add	r7, sp, #0
 8001186:	4603      	mov	r3, r0
 8001188:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 800118a:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800118e:	4618      	mov	r0, r3
 8001190:	f7ff ff56 	bl	8001040 <__NVIC_EnableIRQ>
}
 8001194:	bf00      	nop
 8001196:	3708      	adds	r7, #8
 8001198:	46bd      	mov	sp, r7
 800119a:	bd80      	pop	{r7, pc}

0800119c <HAL_SYSTICK_Config>:
  * @param  TicksNumb: Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 800119c:	b480      	push	{r7}
 800119e:	b083      	sub	sp, #12
 80011a0:	af00      	add	r7, sp, #0
 80011a2:	6078      	str	r0, [r7, #4]
  if ((TicksNumb - 1UL) > SysTick_LOAD_RELOAD_Msk)
 80011a4:	687b      	ldr	r3, [r7, #4]
 80011a6:	3b01      	subs	r3, #1
 80011a8:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 80011ac:	d301      	bcc.n	80011b2 <HAL_SYSTICK_Config+0x16>
  {
    /* Reload value impossible */
    return (1UL);
 80011ae:	2301      	movs	r3, #1
 80011b0:	e00d      	b.n	80011ce <HAL_SYSTICK_Config+0x32>
  }

  /* Set reload register */
  WRITE_REG(SysTick->LOAD, (uint32_t)(TicksNumb - 1UL));
 80011b2:	4a0a      	ldr	r2, [pc, #40]	@ (80011dc <HAL_SYSTICK_Config+0x40>)
 80011b4:	687b      	ldr	r3, [r7, #4]
 80011b6:	3b01      	subs	r3, #1
 80011b8:	6053      	str	r3, [r2, #4]

  /* Load the SysTick Counter Value */
  WRITE_REG(SysTick->VAL, 0UL);
 80011ba:	4b08      	ldr	r3, [pc, #32]	@ (80011dc <HAL_SYSTICK_Config+0x40>)
 80011bc:	2200      	movs	r2, #0
 80011be:	609a      	str	r2, [r3, #8]

  /* Enable SysTick IRQ and SysTick Timer */
  SET_BIT(SysTick->CTRL, (SysTick_CTRL_TICKINT_Msk | SysTick_CTRL_ENABLE_Msk));
 80011c0:	4b06      	ldr	r3, [pc, #24]	@ (80011dc <HAL_SYSTICK_Config+0x40>)
 80011c2:	681b      	ldr	r3, [r3, #0]
 80011c4:	4a05      	ldr	r2, [pc, #20]	@ (80011dc <HAL_SYSTICK_Config+0x40>)
 80011c6:	f043 0303 	orr.w	r3, r3, #3
 80011ca:	6013      	str	r3, [r2, #0]

  /* Function successful */
  return (0UL);
 80011cc:	2300      	movs	r3, #0
}
 80011ce:	4618      	mov	r0, r3
 80011d0:	370c      	adds	r7, #12
 80011d2:	46bd      	mov	sp, r7
 80011d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80011d8:	4770      	bx	lr
 80011da:	bf00      	nop
 80011dc:	e000e010 	.word	0xe000e010

080011e0 <HAL_SYSTICK_CLKSourceConfig>:
  *             @arg SYSTICK_CLKSOURCE_HCLK: AHB clock selected as SysTick clock source.
  *             @arg SYSTICK_CLKSOURCE_HCLK_DIV8: AHB clock divided by 8 selected as SysTick clock source.
  * @retval None
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
 80011e0:	b480      	push	{r7}
 80011e2:	b083      	sub	sp, #12
 80011e4:	af00      	add	r7, sp, #0
 80011e6:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  switch (CLKSource)
 80011e8:	687b      	ldr	r3, [r7, #4]
 80011ea:	2b04      	cmp	r3, #4
 80011ec:	d844      	bhi.n	8001278 <HAL_SYSTICK_CLKSourceConfig+0x98>
 80011ee:	a201      	add	r2, pc, #4	@ (adr r2, 80011f4 <HAL_SYSTICK_CLKSourceConfig+0x14>)
 80011f0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80011f4:	08001217 	.word	0x08001217
 80011f8:	08001235 	.word	0x08001235
 80011fc:	08001257 	.word	0x08001257
 8001200:	08001279 	.word	0x08001279
 8001204:	08001209 	.word	0x08001209
  {
    /* Select HCLK as Systick clock source */
    case SYSTICK_CLKSOURCE_HCLK:
      SET_BIT(SysTick->CTRL, SysTick_CTRL_CLKSOURCE_Msk);
 8001208:	4b1f      	ldr	r3, [pc, #124]	@ (8001288 <HAL_SYSTICK_CLKSourceConfig+0xa8>)
 800120a:	681b      	ldr	r3, [r3, #0]
 800120c:	4a1e      	ldr	r2, [pc, #120]	@ (8001288 <HAL_SYSTICK_CLKSourceConfig+0xa8>)
 800120e:	f043 0304 	orr.w	r3, r3, #4
 8001212:	6013      	str	r3, [r2, #0]
      break;
 8001214:	e031      	b.n	800127a <HAL_SYSTICK_CLKSourceConfig+0x9a>
    /* Select HCLK_DIV8 as Systick clock source */
    case SYSTICK_CLKSOURCE_HCLK_DIV8:
      CLEAR_BIT(SysTick->CTRL, SysTick_CTRL_CLKSOURCE_Msk);
 8001216:	4b1c      	ldr	r3, [pc, #112]	@ (8001288 <HAL_SYSTICK_CLKSourceConfig+0xa8>)
 8001218:	681b      	ldr	r3, [r3, #0]
 800121a:	4a1b      	ldr	r2, [pc, #108]	@ (8001288 <HAL_SYSTICK_CLKSourceConfig+0xa8>)
 800121c:	f023 0304 	bic.w	r3, r3, #4
 8001220:	6013      	str	r3, [r2, #0]
      MODIFY_REG(RCC->CCIPR1, RCC_CCIPR1_SYSTICKSEL, (0x00000000U));
 8001222:	4b1a      	ldr	r3, [pc, #104]	@ (800128c <HAL_SYSTICK_CLKSourceConfig+0xac>)
 8001224:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8001228:	4a18      	ldr	r2, [pc, #96]	@ (800128c <HAL_SYSTICK_CLKSourceConfig+0xac>)
 800122a:	f423 0340 	bic.w	r3, r3, #12582912	@ 0xc00000
 800122e:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
      break;
 8001232:	e022      	b.n	800127a <HAL_SYSTICK_CLKSourceConfig+0x9a>
    /* Select LSI as Systick clock source */
    case SYSTICK_CLKSOURCE_LSI:
      CLEAR_BIT(SysTick->CTRL, SysTick_CTRL_CLKSOURCE_Msk);
 8001234:	4b14      	ldr	r3, [pc, #80]	@ (8001288 <HAL_SYSTICK_CLKSourceConfig+0xa8>)
 8001236:	681b      	ldr	r3, [r3, #0]
 8001238:	4a13      	ldr	r2, [pc, #76]	@ (8001288 <HAL_SYSTICK_CLKSourceConfig+0xa8>)
 800123a:	f023 0304 	bic.w	r3, r3, #4
 800123e:	6013      	str	r3, [r2, #0]
      MODIFY_REG(RCC->CCIPR1, RCC_CCIPR1_SYSTICKSEL, RCC_CCIPR1_SYSTICKSEL_0);
 8001240:	4b12      	ldr	r3, [pc, #72]	@ (800128c <HAL_SYSTICK_CLKSourceConfig+0xac>)
 8001242:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8001246:	f423 0340 	bic.w	r3, r3, #12582912	@ 0xc00000
 800124a:	4a10      	ldr	r2, [pc, #64]	@ (800128c <HAL_SYSTICK_CLKSourceConfig+0xac>)
 800124c:	f443 0380 	orr.w	r3, r3, #4194304	@ 0x400000
 8001250:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
      break;
 8001254:	e011      	b.n	800127a <HAL_SYSTICK_CLKSourceConfig+0x9a>
    /* Select LSE as Systick clock source */
    case SYSTICK_CLKSOURCE_LSE:
      CLEAR_BIT(SysTick->CTRL, SysTick_CTRL_CLKSOURCE_Msk);
 8001256:	4b0c      	ldr	r3, [pc, #48]	@ (8001288 <HAL_SYSTICK_CLKSourceConfig+0xa8>)
 8001258:	681b      	ldr	r3, [r3, #0]
 800125a:	4a0b      	ldr	r2, [pc, #44]	@ (8001288 <HAL_SYSTICK_CLKSourceConfig+0xa8>)
 800125c:	f023 0304 	bic.w	r3, r3, #4
 8001260:	6013      	str	r3, [r2, #0]
      MODIFY_REG(RCC->CCIPR1, RCC_CCIPR1_SYSTICKSEL, RCC_CCIPR1_SYSTICKSEL_1);
 8001262:	4b0a      	ldr	r3, [pc, #40]	@ (800128c <HAL_SYSTICK_CLKSourceConfig+0xac>)
 8001264:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8001268:	f423 0340 	bic.w	r3, r3, #12582912	@ 0xc00000
 800126c:	4a07      	ldr	r2, [pc, #28]	@ (800128c <HAL_SYSTICK_CLKSourceConfig+0xac>)
 800126e:	f443 0300 	orr.w	r3, r3, #8388608	@ 0x800000
 8001272:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
      break;
 8001276:	e000      	b.n	800127a <HAL_SYSTICK_CLKSourceConfig+0x9a>
    default:
      /* Nothing to do */
      break;
 8001278:	bf00      	nop
  }
}
 800127a:	bf00      	nop
 800127c:	370c      	adds	r7, #12
 800127e:	46bd      	mov	sp, r7
 8001280:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001284:	4770      	bx	lr
 8001286:	bf00      	nop
 8001288:	e000e010 	.word	0xe000e010
 800128c:	46020c00 	.word	0x46020c00

08001290 <HAL_SYSTICK_GetCLKSourceConfig>:
  *             @arg SYSTICK_CLKSOURCE_LSE: LSE clock selected as SysTick clock source.
  *             @arg SYSTICK_CLKSOURCE_HCLK: AHB clock selected as SysTick clock source.
  *             @arg SYSTICK_CLKSOURCE_HCLK_DIV8: AHB clock divided by 8 selected as SysTick clock source.
  */
uint32_t HAL_SYSTICK_GetCLKSourceConfig(void)
{
 8001290:	b480      	push	{r7}
 8001292:	b083      	sub	sp, #12
 8001294:	af00      	add	r7, sp, #0
  uint32_t systick_source;
  uint32_t systick_rcc_source;

  /* Read SysTick->CTRL register for internal or external clock source */
  if (READ_BIT(SysTick->CTRL, SysTick_CTRL_CLKSOURCE_Msk) != 0U)
 8001296:	4b19      	ldr	r3, [pc, #100]	@ (80012fc <HAL_SYSTICK_GetCLKSourceConfig+0x6c>)
 8001298:	681b      	ldr	r3, [r3, #0]
 800129a:	f003 0304 	and.w	r3, r3, #4
 800129e:	2b00      	cmp	r3, #0
 80012a0:	d002      	beq.n	80012a8 <HAL_SYSTICK_GetCLKSourceConfig+0x18>
  {
    /* Internal clock source */
    systick_source = SYSTICK_CLKSOURCE_HCLK;
 80012a2:	2304      	movs	r3, #4
 80012a4:	607b      	str	r3, [r7, #4]
 80012a6:	e021      	b.n	80012ec <HAL_SYSTICK_GetCLKSourceConfig+0x5c>
  }
  else
  {
    /* External clock source, check the selected one in RCC */
    systick_rcc_source = READ_BIT(RCC->CCIPR1, RCC_CCIPR1_SYSTICKSEL);
 80012a8:	4b15      	ldr	r3, [pc, #84]	@ (8001300 <HAL_SYSTICK_GetCLKSourceConfig+0x70>)
 80012aa:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 80012ae:	f403 0340 	and.w	r3, r3, #12582912	@ 0xc00000
 80012b2:	603b      	str	r3, [r7, #0]

    switch (systick_rcc_source)
 80012b4:	683b      	ldr	r3, [r7, #0]
 80012b6:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
 80012ba:	d011      	beq.n	80012e0 <HAL_SYSTICK_GetCLKSourceConfig+0x50>
 80012bc:	683b      	ldr	r3, [r7, #0]
 80012be:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
 80012c2:	d810      	bhi.n	80012e6 <HAL_SYSTICK_GetCLKSourceConfig+0x56>
 80012c4:	683b      	ldr	r3, [r7, #0]
 80012c6:	2b00      	cmp	r3, #0
 80012c8:	d004      	beq.n	80012d4 <HAL_SYSTICK_GetCLKSourceConfig+0x44>
 80012ca:	683b      	ldr	r3, [r7, #0]
 80012cc:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
 80012d0:	d003      	beq.n	80012da <HAL_SYSTICK_GetCLKSourceConfig+0x4a>
 80012d2:	e008      	b.n	80012e6 <HAL_SYSTICK_GetCLKSourceConfig+0x56>
    {
      case (0x00000000U):
        systick_source = SYSTICK_CLKSOURCE_HCLK_DIV8;
 80012d4:	2300      	movs	r3, #0
 80012d6:	607b      	str	r3, [r7, #4]
        break;
 80012d8:	e008      	b.n	80012ec <HAL_SYSTICK_GetCLKSourceConfig+0x5c>

      case (RCC_CCIPR1_SYSTICKSEL_0):
        systick_source = SYSTICK_CLKSOURCE_LSI;
 80012da:	2301      	movs	r3, #1
 80012dc:	607b      	str	r3, [r7, #4]
        break;
 80012de:	e005      	b.n	80012ec <HAL_SYSTICK_GetCLKSourceConfig+0x5c>

      case (RCC_CCIPR1_SYSTICKSEL_1):
        systick_source = SYSTICK_CLKSOURCE_LSE;
 80012e0:	2302      	movs	r3, #2
 80012e2:	607b      	str	r3, [r7, #4]
        break;
 80012e4:	e002      	b.n	80012ec <HAL_SYSTICK_GetCLKSourceConfig+0x5c>

      default:
        systick_source = SYSTICK_CLKSOURCE_HCLK_DIV8;
 80012e6:	2300      	movs	r3, #0
 80012e8:	607b      	str	r3, [r7, #4]
        break;
 80012ea:	bf00      	nop
    }
  }
  return systick_source;
 80012ec:	687b      	ldr	r3, [r7, #4]
}
 80012ee:	4618      	mov	r0, r3
 80012f0:	370c      	adds	r7, #12
 80012f2:	46bd      	mov	sp, r7
 80012f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80012f8:	4770      	bx	lr
 80012fa:	bf00      	nop
 80012fc:	e000e010 	.word	0xe000e010
 8001300:	46020c00 	.word	0x46020c00

08001304 <HAL_GPIO_Init>:
  * @param  pGPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, const GPIO_InitTypeDef *pGPIO_Init)
{
 8001304:	b480      	push	{r7}
 8001306:	b089      	sub	sp, #36	@ 0x24
 8001308:	af00      	add	r7, sp, #0
 800130a:	6078      	str	r0, [r7, #4]
 800130c:	6039      	str	r1, [r7, #0]
  uint32_t tmp;
  uint32_t iocurrent;
  uint32_t pin_position;
  uint32_t position = 0U;
 800130e:	2300      	movs	r3, #0
 8001310:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(pGPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(pGPIO_Init->Mode));

  /* Save GPIO port address */
  p_gpio = GPIOx;
 8001312:	687b      	ldr	r3, [r7, #4]
 8001314:	613b      	str	r3, [r7, #16]

  /* Configure the port pins */
  while (((pGPIO_Init->Pin) >> position) != 0U)
 8001316:	e1ba      	b.n	800168e <HAL_GPIO_Init+0x38a>
  {
    /* Get current io position */
    iocurrent = (pGPIO_Init->Pin) & (1UL << position);
 8001318:	683b      	ldr	r3, [r7, #0]
 800131a:	681a      	ldr	r2, [r3, #0]
 800131c:	2101      	movs	r1, #1
 800131e:	697b      	ldr	r3, [r7, #20]
 8001320:	fa01 f303 	lsl.w	r3, r1, r3
 8001324:	4013      	ands	r3, r2
 8001326:	60fb      	str	r3, [r7, #12]

    /* Save Pin Position */
    pin_position = position;
 8001328:	697b      	ldr	r3, [r7, #20]
 800132a:	61bb      	str	r3, [r7, #24]

    if (iocurrent != 0U)
 800132c:	68fb      	ldr	r3, [r7, #12]
 800132e:	2b00      	cmp	r3, #0
 8001330:	f000 81aa 	beq.w	8001688 <HAL_GPIO_Init+0x384>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Alternate function mode selection */
      if (GPIOx == LPGPIO1)
 8001334:	687b      	ldr	r3, [r7, #4]
 8001336:	4a55      	ldr	r2, [pc, #340]	@ (800148c <HAL_GPIO_Init+0x188>)
 8001338:	4293      	cmp	r3, r2
 800133a:	d15d      	bne.n	80013f8 <HAL_GPIO_Init+0xf4>
      {
        /* MODER configuration */
        tmp = GPIOx->MODER;
 800133c:	687b      	ldr	r3, [r7, #4]
 800133e:	681b      	ldr	r3, [r3, #0]
 8001340:	61fb      	str	r3, [r7, #28]
        tmp &= ~(LPGPIO_MODER_MOD0 << position);
 8001342:	2201      	movs	r2, #1
 8001344:	697b      	ldr	r3, [r7, #20]
 8001346:	fa02 f303 	lsl.w	r3, r2, r3
 800134a:	43db      	mvns	r3, r3
 800134c:	69fa      	ldr	r2, [r7, #28]
 800134e:	4013      	ands	r3, r2
 8001350:	61fb      	str	r3, [r7, #28]
        tmp |= ((pGPIO_Init->Mode & GPIO_MODE_OUTPUT_PP) << position);
 8001352:	683b      	ldr	r3, [r7, #0]
 8001354:	685b      	ldr	r3, [r3, #4]
 8001356:	f003 0201 	and.w	r2, r3, #1
 800135a:	697b      	ldr	r3, [r7, #20]
 800135c:	fa02 f303 	lsl.w	r3, r2, r3
 8001360:	69fa      	ldr	r2, [r7, #28]
 8001362:	4313      	orrs	r3, r2
 8001364:	61fb      	str	r3, [r7, #28]
        GPIOx->MODER = tmp;
 8001366:	687b      	ldr	r3, [r7, #4]
 8001368:	69fa      	ldr	r2, [r7, #28]
 800136a:	601a      	str	r2, [r3, #0]

        /* Save GPIO Port and pin index */
        p_gpio = LPGPIO_Map[position].GPIO_PORT;
 800136c:	4a48      	ldr	r2, [pc, #288]	@ (8001490 <HAL_GPIO_Init+0x18c>)
 800136e:	697b      	ldr	r3, [r7, #20]
 8001370:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 8001374:	613b      	str	r3, [r7, #16]
        pin_position = LPGPIO_Map[position].Pin_Pos;
 8001376:	4a46      	ldr	r2, [pc, #280]	@ (8001490 <HAL_GPIO_Init+0x18c>)
 8001378:	697b      	ldr	r3, [r7, #20]
 800137a:	00db      	lsls	r3, r3, #3
 800137c:	4413      	add	r3, r2
 800137e:	685b      	ldr	r3, [r3, #4]
 8001380:	61bb      	str	r3, [r7, #24]

        /* Configure Alternate function mapped with the current IO */
        tmp = p_gpio->AFR[(pin_position) >> 3U];
 8001382:	69bb      	ldr	r3, [r7, #24]
 8001384:	08da      	lsrs	r2, r3, #3
 8001386:	693b      	ldr	r3, [r7, #16]
 8001388:	3208      	adds	r2, #8
 800138a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800138e:	61fb      	str	r3, [r7, #28]
        tmp &= ~(0x0FUL << (((pin_position) & 0x07U) * 4U));
 8001390:	69bb      	ldr	r3, [r7, #24]
 8001392:	f003 0307 	and.w	r3, r3, #7
 8001396:	009b      	lsls	r3, r3, #2
 8001398:	220f      	movs	r2, #15
 800139a:	fa02 f303 	lsl.w	r3, r2, r3
 800139e:	43db      	mvns	r3, r3
 80013a0:	69fa      	ldr	r2, [r7, #28]
 80013a2:	4013      	ands	r3, r2
 80013a4:	61fb      	str	r3, [r7, #28]
        tmp |= ((GPIO_AF11_LPGPIO1 & 0x0FUL) << (((pin_position) & 0x07U) * 4U));
 80013a6:	69bb      	ldr	r3, [r7, #24]
 80013a8:	f003 0307 	and.w	r3, r3, #7
 80013ac:	009b      	lsls	r3, r3, #2
 80013ae:	220b      	movs	r2, #11
 80013b0:	fa02 f303 	lsl.w	r3, r2, r3
 80013b4:	69fa      	ldr	r2, [r7, #28]
 80013b6:	4313      	orrs	r3, r2
 80013b8:	61fb      	str	r3, [r7, #28]
        p_gpio->AFR[(pin_position) >> 3U] = tmp;
 80013ba:	69bb      	ldr	r3, [r7, #24]
 80013bc:	08da      	lsrs	r2, r3, #3
 80013be:	693b      	ldr	r3, [r7, #16]
 80013c0:	3208      	adds	r2, #8
 80013c2:	69f9      	ldr	r1, [r7, #28]
 80013c4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

        /* Configure IO Direction mode (Alternate) */
        tmp = p_gpio->MODER;
 80013c8:	693b      	ldr	r3, [r7, #16]
 80013ca:	681b      	ldr	r3, [r3, #0]
 80013cc:	61fb      	str	r3, [r7, #28]
        tmp &= ~(GPIO_MODER_MODE0 << (pin_position * GPIO_MODER_MODE1_Pos));
 80013ce:	69bb      	ldr	r3, [r7, #24]
 80013d0:	005b      	lsls	r3, r3, #1
 80013d2:	2203      	movs	r2, #3
 80013d4:	fa02 f303 	lsl.w	r3, r2, r3
 80013d8:	43db      	mvns	r3, r3
 80013da:	69fa      	ldr	r2, [r7, #28]
 80013dc:	4013      	ands	r3, r2
 80013de:	61fb      	str	r3, [r7, #28]
        tmp |= ((GPIO_MODE_AF_PP & 0x0FUL) << (pin_position * GPIO_MODER_MODE1_Pos));
 80013e0:	69bb      	ldr	r3, [r7, #24]
 80013e2:	005b      	lsls	r3, r3, #1
 80013e4:	2202      	movs	r2, #2
 80013e6:	fa02 f303 	lsl.w	r3, r2, r3
 80013ea:	69fa      	ldr	r2, [r7, #28]
 80013ec:	4313      	orrs	r3, r2
 80013ee:	61fb      	str	r3, [r7, #28]
        p_gpio->MODER = tmp;
 80013f0:	693b      	ldr	r3, [r7, #16]
 80013f2:	69fa      	ldr	r2, [r7, #28]
 80013f4:	601a      	str	r2, [r3, #0]
 80013f6:	e067      	b.n	80014c8 <HAL_GPIO_Init+0x1c4>
      }
      else if ((pGPIO_Init->Mode == GPIO_MODE_AF_PP) || (pGPIO_Init->Mode == GPIO_MODE_AF_OD))
 80013f8:	683b      	ldr	r3, [r7, #0]
 80013fa:	685b      	ldr	r3, [r3, #4]
 80013fc:	2b02      	cmp	r3, #2
 80013fe:	d003      	beq.n	8001408 <HAL_GPIO_Init+0x104>
 8001400:	683b      	ldr	r3, [r7, #0]
 8001402:	685b      	ldr	r3, [r3, #4]
 8001404:	2b12      	cmp	r3, #18
 8001406:	d145      	bne.n	8001494 <HAL_GPIO_Init+0x190>
        assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(pGPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        tmp = GPIOx->AFR[position >> 3U];
 8001408:	697b      	ldr	r3, [r7, #20]
 800140a:	08da      	lsrs	r2, r3, #3
 800140c:	687b      	ldr	r3, [r7, #4]
 800140e:	3208      	adds	r2, #8
 8001410:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8001414:	61fb      	str	r3, [r7, #28]
        tmp &= ~(0x0FUL << ((position & 0x07U) * GPIO_AFRL_AFSEL1_Pos));
 8001416:	697b      	ldr	r3, [r7, #20]
 8001418:	f003 0307 	and.w	r3, r3, #7
 800141c:	009b      	lsls	r3, r3, #2
 800141e:	220f      	movs	r2, #15
 8001420:	fa02 f303 	lsl.w	r3, r2, r3
 8001424:	43db      	mvns	r3, r3
 8001426:	69fa      	ldr	r2, [r7, #28]
 8001428:	4013      	ands	r3, r2
 800142a:	61fb      	str	r3, [r7, #28]
        tmp |= ((pGPIO_Init->Alternate & 0x0FUL) << ((position & 0x07U) * GPIO_AFRL_AFSEL1_Pos));
 800142c:	683b      	ldr	r3, [r7, #0]
 800142e:	691b      	ldr	r3, [r3, #16]
 8001430:	f003 020f 	and.w	r2, r3, #15
 8001434:	697b      	ldr	r3, [r7, #20]
 8001436:	f003 0307 	and.w	r3, r3, #7
 800143a:	009b      	lsls	r3, r3, #2
 800143c:	fa02 f303 	lsl.w	r3, r2, r3
 8001440:	69fa      	ldr	r2, [r7, #28]
 8001442:	4313      	orrs	r3, r2
 8001444:	61fb      	str	r3, [r7, #28]
        GPIOx->AFR[position >> 3U] = tmp;
 8001446:	697b      	ldr	r3, [r7, #20]
 8001448:	08da      	lsrs	r2, r3, #3
 800144a:	687b      	ldr	r3, [r7, #4]
 800144c:	3208      	adds	r2, #8
 800144e:	69f9      	ldr	r1, [r7, #28]
 8001450:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

        /* Configure IO Direction mode (Alternate) */
        tmp = p_gpio->MODER;
 8001454:	693b      	ldr	r3, [r7, #16]
 8001456:	681b      	ldr	r3, [r3, #0]
 8001458:	61fb      	str	r3, [r7, #28]
        tmp &= ~(GPIO_MODER_MODE0 << (pin_position * GPIO_MODER_MODE1_Pos));
 800145a:	69bb      	ldr	r3, [r7, #24]
 800145c:	005b      	lsls	r3, r3, #1
 800145e:	2203      	movs	r2, #3
 8001460:	fa02 f303 	lsl.w	r3, r2, r3
 8001464:	43db      	mvns	r3, r3
 8001466:	69fa      	ldr	r2, [r7, #28]
 8001468:	4013      	ands	r3, r2
 800146a:	61fb      	str	r3, [r7, #28]
        tmp |= ((pGPIO_Init->Mode & GPIO_MODE) << (pin_position * GPIO_MODER_MODE1_Pos));
 800146c:	683b      	ldr	r3, [r7, #0]
 800146e:	685b      	ldr	r3, [r3, #4]
 8001470:	f003 0203 	and.w	r2, r3, #3
 8001474:	69bb      	ldr	r3, [r7, #24]
 8001476:	005b      	lsls	r3, r3, #1
 8001478:	fa02 f303 	lsl.w	r3, r2, r3
 800147c:	69fa      	ldr	r2, [r7, #28]
 800147e:	4313      	orrs	r3, r2
 8001480:	61fb      	str	r3, [r7, #28]
        p_gpio->MODER = tmp;
 8001482:	693b      	ldr	r3, [r7, #16]
 8001484:	69fa      	ldr	r2, [r7, #28]
 8001486:	601a      	str	r2, [r3, #0]
 8001488:	e01e      	b.n	80014c8 <HAL_GPIO_Init+0x1c4>
 800148a:	bf00      	nop
 800148c:	46020000 	.word	0x46020000
 8001490:	080116e4 	.word	0x080116e4
      {
        /* Check the parameters */
        assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));

        /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
        tmp = p_gpio->MODER;
 8001494:	693b      	ldr	r3, [r7, #16]
 8001496:	681b      	ldr	r3, [r3, #0]
 8001498:	61fb      	str	r3, [r7, #28]
        tmp &= ~(GPIO_MODER_MODE0 << (pin_position * GPIO_MODER_MODE1_Pos));
 800149a:	69bb      	ldr	r3, [r7, #24]
 800149c:	005b      	lsls	r3, r3, #1
 800149e:	2203      	movs	r2, #3
 80014a0:	fa02 f303 	lsl.w	r3, r2, r3
 80014a4:	43db      	mvns	r3, r3
 80014a6:	69fa      	ldr	r2, [r7, #28]
 80014a8:	4013      	ands	r3, r2
 80014aa:	61fb      	str	r3, [r7, #28]
        tmp |= ((pGPIO_Init->Mode & GPIO_MODE) << (pin_position * GPIO_MODER_MODE1_Pos));
 80014ac:	683b      	ldr	r3, [r7, #0]
 80014ae:	685b      	ldr	r3, [r3, #4]
 80014b0:	f003 0203 	and.w	r2, r3, #3
 80014b4:	69bb      	ldr	r3, [r7, #24]
 80014b6:	005b      	lsls	r3, r3, #1
 80014b8:	fa02 f303 	lsl.w	r3, r2, r3
 80014bc:	69fa      	ldr	r2, [r7, #28]
 80014be:	4313      	orrs	r3, r2
 80014c0:	61fb      	str	r3, [r7, #28]
        p_gpio->MODER = tmp;
 80014c2:	693b      	ldr	r3, [r7, #16]
 80014c4:	69fa      	ldr	r2, [r7, #28]
 80014c6:	601a      	str	r2, [r3, #0]
      }

      /* In case of Output or Alternate function mode selection */
      if ((pGPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (pGPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 80014c8:	683b      	ldr	r3, [r7, #0]
 80014ca:	685b      	ldr	r3, [r3, #4]
 80014cc:	2b01      	cmp	r3, #1
 80014ce:	d00b      	beq.n	80014e8 <HAL_GPIO_Init+0x1e4>
 80014d0:	683b      	ldr	r3, [r7, #0]
 80014d2:	685b      	ldr	r3, [r3, #4]
 80014d4:	2b02      	cmp	r3, #2
 80014d6:	d007      	beq.n	80014e8 <HAL_GPIO_Init+0x1e4>
          (pGPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (pGPIO_Init->Mode == GPIO_MODE_AF_OD))
 80014d8:	683b      	ldr	r3, [r7, #0]
 80014da:	685b      	ldr	r3, [r3, #4]
      if ((pGPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (pGPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 80014dc:	2b11      	cmp	r3, #17
 80014de:	d003      	beq.n	80014e8 <HAL_GPIO_Init+0x1e4>
          (pGPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (pGPIO_Init->Mode == GPIO_MODE_AF_OD))
 80014e0:	683b      	ldr	r3, [r7, #0]
 80014e2:	685b      	ldr	r3, [r3, #4]
 80014e4:	2b12      	cmp	r3, #18
 80014e6:	d130      	bne.n	800154a <HAL_GPIO_Init+0x246>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(pGPIO_Init->Speed));

        /* Configure the IO Speed */
        tmp = p_gpio->OSPEEDR;
 80014e8:	693b      	ldr	r3, [r7, #16]
 80014ea:	689b      	ldr	r3, [r3, #8]
 80014ec:	61fb      	str	r3, [r7, #28]
        tmp &= ~(GPIO_OSPEEDR_OSPEED0 << (pin_position * GPIO_OSPEEDR_OSPEED1_Pos));
 80014ee:	69bb      	ldr	r3, [r7, #24]
 80014f0:	005b      	lsls	r3, r3, #1
 80014f2:	2203      	movs	r2, #3
 80014f4:	fa02 f303 	lsl.w	r3, r2, r3
 80014f8:	43db      	mvns	r3, r3
 80014fa:	69fa      	ldr	r2, [r7, #28]
 80014fc:	4013      	ands	r3, r2
 80014fe:	61fb      	str	r3, [r7, #28]
        tmp |= (pGPIO_Init->Speed << (pin_position * GPIO_OSPEEDR_OSPEED1_Pos));
 8001500:	683b      	ldr	r3, [r7, #0]
 8001502:	68da      	ldr	r2, [r3, #12]
 8001504:	69bb      	ldr	r3, [r7, #24]
 8001506:	005b      	lsls	r3, r3, #1
 8001508:	fa02 f303 	lsl.w	r3, r2, r3
 800150c:	69fa      	ldr	r2, [r7, #28]
 800150e:	4313      	orrs	r3, r2
 8001510:	61fb      	str	r3, [r7, #28]
        p_gpio->OSPEEDR = tmp;
 8001512:	693b      	ldr	r3, [r7, #16]
 8001514:	69fa      	ldr	r2, [r7, #28]
 8001516:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        tmp = p_gpio->OTYPER;
 8001518:	693b      	ldr	r3, [r7, #16]
 800151a:	685b      	ldr	r3, [r3, #4]
 800151c:	61fb      	str	r3, [r7, #28]
        tmp &= ~(GPIO_OTYPER_OT0 << pin_position);
 800151e:	2201      	movs	r2, #1
 8001520:	69bb      	ldr	r3, [r7, #24]
 8001522:	fa02 f303 	lsl.w	r3, r2, r3
 8001526:	43db      	mvns	r3, r3
 8001528:	69fa      	ldr	r2, [r7, #28]
 800152a:	4013      	ands	r3, r2
 800152c:	61fb      	str	r3, [r7, #28]
        tmp |= (((pGPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << pin_position);
 800152e:	683b      	ldr	r3, [r7, #0]
 8001530:	685b      	ldr	r3, [r3, #4]
 8001532:	091b      	lsrs	r3, r3, #4
 8001534:	f003 0201 	and.w	r2, r3, #1
 8001538:	69bb      	ldr	r3, [r7, #24]
 800153a:	fa02 f303 	lsl.w	r3, r2, r3
 800153e:	69fa      	ldr	r2, [r7, #28]
 8001540:	4313      	orrs	r3, r2
 8001542:	61fb      	str	r3, [r7, #28]
        p_gpio->OTYPER = tmp;
 8001544:	693b      	ldr	r3, [r7, #16]
 8001546:	69fa      	ldr	r2, [r7, #28]
 8001548:	605a      	str	r2, [r3, #4]
      }

      if (pGPIO_Init->Mode != GPIO_MODE_ANALOG)
 800154a:	683b      	ldr	r3, [r7, #0]
 800154c:	685b      	ldr	r3, [r3, #4]
 800154e:	2b03      	cmp	r3, #3
 8001550:	d017      	beq.n	8001582 <HAL_GPIO_Init+0x27e>
      {
        /* Check the Pull parameters */
        assert_param(IS_GPIO_PULL(pGPIO_Init->Pull));

        /* Activate the Pull-up or Pull down resistor for the current IO */
        tmp = p_gpio->PUPDR;
 8001552:	693b      	ldr	r3, [r7, #16]
 8001554:	68db      	ldr	r3, [r3, #12]
 8001556:	61fb      	str	r3, [r7, #28]
        tmp &= ~(GPIO_PUPDR_PUPD0 << (pin_position * GPIO_PUPDR_PUPD1_Pos));
 8001558:	69bb      	ldr	r3, [r7, #24]
 800155a:	005b      	lsls	r3, r3, #1
 800155c:	2203      	movs	r2, #3
 800155e:	fa02 f303 	lsl.w	r3, r2, r3
 8001562:	43db      	mvns	r3, r3
 8001564:	69fa      	ldr	r2, [r7, #28]
 8001566:	4013      	ands	r3, r2
 8001568:	61fb      	str	r3, [r7, #28]
        tmp |= ((pGPIO_Init->Pull) << (pin_position * GPIO_PUPDR_PUPD1_Pos));
 800156a:	683b      	ldr	r3, [r7, #0]
 800156c:	689a      	ldr	r2, [r3, #8]
 800156e:	69bb      	ldr	r3, [r7, #24]
 8001570:	005b      	lsls	r3, r3, #1
 8001572:	fa02 f303 	lsl.w	r3, r2, r3
 8001576:	69fa      	ldr	r2, [r7, #28]
 8001578:	4313      	orrs	r3, r2
 800157a:	61fb      	str	r3, [r7, #28]
        p_gpio->PUPDR = tmp;
 800157c:	693b      	ldr	r3, [r7, #16]
 800157e:	69fa      	ldr	r2, [r7, #28]
 8001580:	60da      	str	r2, [r3, #12]
      }

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((pGPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8001582:	683b      	ldr	r3, [r7, #0]
 8001584:	685b      	ldr	r3, [r3, #4]
 8001586:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 800158a:	2b00      	cmp	r3, #0
 800158c:	d07c      	beq.n	8001688 <HAL_GPIO_Init+0x384>
      {
        tmp = EXTI->EXTICR[position >> 2U];
 800158e:	4a47      	ldr	r2, [pc, #284]	@ (80016ac <HAL_GPIO_Init+0x3a8>)
 8001590:	697b      	ldr	r3, [r7, #20]
 8001592:	089b      	lsrs	r3, r3, #2
 8001594:	3318      	adds	r3, #24
 8001596:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800159a:	61fb      	str	r3, [r7, #28]
        tmp &= ~((0x0FUL) << (EXTI_EXTICR1_EXTI1_Pos * (position & 0x03U)));
 800159c:	697b      	ldr	r3, [r7, #20]
 800159e:	f003 0303 	and.w	r3, r3, #3
 80015a2:	00db      	lsls	r3, r3, #3
 80015a4:	220f      	movs	r2, #15
 80015a6:	fa02 f303 	lsl.w	r3, r2, r3
 80015aa:	43db      	mvns	r3, r3
 80015ac:	69fa      	ldr	r2, [r7, #28]
 80015ae:	4013      	ands	r3, r2
 80015b0:	61fb      	str	r3, [r7, #28]
        tmp |= (GPIO_GET_INDEX(GPIOx) << (EXTI_EXTICR1_EXTI1_Pos * (position & 0x03U)));
 80015b2:	687b      	ldr	r3, [r7, #4]
 80015b4:	0a9a      	lsrs	r2, r3, #10
 80015b6:	4b3e      	ldr	r3, [pc, #248]	@ (80016b0 <HAL_GPIO_Init+0x3ac>)
 80015b8:	4013      	ands	r3, r2
 80015ba:	697a      	ldr	r2, [r7, #20]
 80015bc:	f002 0203 	and.w	r2, r2, #3
 80015c0:	00d2      	lsls	r2, r2, #3
 80015c2:	4093      	lsls	r3, r2
 80015c4:	69fa      	ldr	r2, [r7, #28]
 80015c6:	4313      	orrs	r3, r2
 80015c8:	61fb      	str	r3, [r7, #28]
        EXTI->EXTICR[position >> 2U] = tmp;
 80015ca:	4938      	ldr	r1, [pc, #224]	@ (80016ac <HAL_GPIO_Init+0x3a8>)
 80015cc:	697b      	ldr	r3, [r7, #20]
 80015ce:	089b      	lsrs	r3, r3, #2
 80015d0:	3318      	adds	r3, #24
 80015d2:	69fa      	ldr	r2, [r7, #28]
 80015d4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear Rising Falling edge configuration */
        tmp = EXTI->RTSR1;
 80015d8:	4b34      	ldr	r3, [pc, #208]	@ (80016ac <HAL_GPIO_Init+0x3a8>)
 80015da:	681b      	ldr	r3, [r3, #0]
 80015dc:	61fb      	str	r3, [r7, #28]
        tmp &= ~((uint32_t)iocurrent);
 80015de:	68fb      	ldr	r3, [r7, #12]
 80015e0:	43db      	mvns	r3, r3
 80015e2:	69fa      	ldr	r2, [r7, #28]
 80015e4:	4013      	ands	r3, r2
 80015e6:	61fb      	str	r3, [r7, #28]
        if ((pGPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 80015e8:	683b      	ldr	r3, [r7, #0]
 80015ea:	685b      	ldr	r3, [r3, #4]
 80015ec:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
 80015f0:	2b00      	cmp	r3, #0
 80015f2:	d003      	beq.n	80015fc <HAL_GPIO_Init+0x2f8>
        {
          tmp |= iocurrent;
 80015f4:	69fa      	ldr	r2, [r7, #28]
 80015f6:	68fb      	ldr	r3, [r7, #12]
 80015f8:	4313      	orrs	r3, r2
 80015fa:	61fb      	str	r3, [r7, #28]
        }
        EXTI->RTSR1 = tmp;
 80015fc:	4a2b      	ldr	r2, [pc, #172]	@ (80016ac <HAL_GPIO_Init+0x3a8>)
 80015fe:	69fb      	ldr	r3, [r7, #28]
 8001600:	6013      	str	r3, [r2, #0]

        tmp = EXTI->FTSR1;
 8001602:	4b2a      	ldr	r3, [pc, #168]	@ (80016ac <HAL_GPIO_Init+0x3a8>)
 8001604:	685b      	ldr	r3, [r3, #4]
 8001606:	61fb      	str	r3, [r7, #28]
        tmp &= ~((uint32_t)iocurrent);
 8001608:	68fb      	ldr	r3, [r7, #12]
 800160a:	43db      	mvns	r3, r3
 800160c:	69fa      	ldr	r2, [r7, #28]
 800160e:	4013      	ands	r3, r2
 8001610:	61fb      	str	r3, [r7, #28]
        if ((pGPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8001612:	683b      	ldr	r3, [r7, #0]
 8001614:	685b      	ldr	r3, [r3, #4]
 8001616:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 800161a:	2b00      	cmp	r3, #0
 800161c:	d003      	beq.n	8001626 <HAL_GPIO_Init+0x322>
        {
          tmp |= iocurrent;
 800161e:	69fa      	ldr	r2, [r7, #28]
 8001620:	68fb      	ldr	r3, [r7, #12]
 8001622:	4313      	orrs	r3, r2
 8001624:	61fb      	str	r3, [r7, #28]
        }
        EXTI->FTSR1 = tmp;
 8001626:	4a21      	ldr	r2, [pc, #132]	@ (80016ac <HAL_GPIO_Init+0x3a8>)
 8001628:	69fb      	ldr	r3, [r7, #28]
 800162a:	6053      	str	r3, [r2, #4]

        /* Clear EXTI line configuration */
        tmp = EXTI->EMR1;
 800162c:	4b1f      	ldr	r3, [pc, #124]	@ (80016ac <HAL_GPIO_Init+0x3a8>)
 800162e:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 8001632:	61fb      	str	r3, [r7, #28]
        tmp &= ~((uint32_t)iocurrent);
 8001634:	68fb      	ldr	r3, [r7, #12]
 8001636:	43db      	mvns	r3, r3
 8001638:	69fa      	ldr	r2, [r7, #28]
 800163a:	4013      	ands	r3, r2
 800163c:	61fb      	str	r3, [r7, #28]
        if ((pGPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 800163e:	683b      	ldr	r3, [r7, #0]
 8001640:	685b      	ldr	r3, [r3, #4]
 8001642:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8001646:	2b00      	cmp	r3, #0
 8001648:	d003      	beq.n	8001652 <HAL_GPIO_Init+0x34e>
        {
          tmp |= iocurrent;
 800164a:	69fa      	ldr	r2, [r7, #28]
 800164c:	68fb      	ldr	r3, [r7, #12]
 800164e:	4313      	orrs	r3, r2
 8001650:	61fb      	str	r3, [r7, #28]
        }
        EXTI->EMR1 = tmp;
 8001652:	4a16      	ldr	r2, [pc, #88]	@ (80016ac <HAL_GPIO_Init+0x3a8>)
 8001654:	69fb      	ldr	r3, [r7, #28]
 8001656:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84

        tmp = EXTI->IMR1;
 800165a:	4b14      	ldr	r3, [pc, #80]	@ (80016ac <HAL_GPIO_Init+0x3a8>)
 800165c:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 8001660:	61fb      	str	r3, [r7, #28]
        tmp &= ~((uint32_t)iocurrent);
 8001662:	68fb      	ldr	r3, [r7, #12]
 8001664:	43db      	mvns	r3, r3
 8001666:	69fa      	ldr	r2, [r7, #28]
 8001668:	4013      	ands	r3, r2
 800166a:	61fb      	str	r3, [r7, #28]
        if ((pGPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 800166c:	683b      	ldr	r3, [r7, #0]
 800166e:	685b      	ldr	r3, [r3, #4]
 8001670:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 8001674:	2b00      	cmp	r3, #0
 8001676:	d003      	beq.n	8001680 <HAL_GPIO_Init+0x37c>
        {
          tmp |= iocurrent;
 8001678:	69fa      	ldr	r2, [r7, #28]
 800167a:	68fb      	ldr	r3, [r7, #12]
 800167c:	4313      	orrs	r3, r2
 800167e:	61fb      	str	r3, [r7, #28]
        }
        EXTI->IMR1 = tmp;
 8001680:	4a0a      	ldr	r2, [pc, #40]	@ (80016ac <HAL_GPIO_Init+0x3a8>)
 8001682:	69fb      	ldr	r3, [r7, #28]
 8001684:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80
      }
    }
    position++;
 8001688:	697b      	ldr	r3, [r7, #20]
 800168a:	3301      	adds	r3, #1
 800168c:	617b      	str	r3, [r7, #20]
  while (((pGPIO_Init->Pin) >> position) != 0U)
 800168e:	683b      	ldr	r3, [r7, #0]
 8001690:	681a      	ldr	r2, [r3, #0]
 8001692:	697b      	ldr	r3, [r7, #20]
 8001694:	fa22 f303 	lsr.w	r3, r2, r3
 8001698:	2b00      	cmp	r3, #0
 800169a:	f47f ae3d 	bne.w	8001318 <HAL_GPIO_Init+0x14>
  }
}
 800169e:	bf00      	nop
 80016a0:	bf00      	nop
 80016a2:	3724      	adds	r7, #36	@ 0x24
 80016a4:	46bd      	mov	sp, r7
 80016a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80016aa:	4770      	bx	lr
 80016ac:	46022000 	.word	0x46022000
 80016b0:	002f7f7f 	.word	0x002f7f7f

080016b4 <HAL_GPIO_TogglePin>:
  * @param  GPIO_Pin specifies the pin to be toggled.
  *         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
 80016b4:	b480      	push	{r7}
 80016b6:	b085      	sub	sp, #20
 80016b8:	af00      	add	r7, sp, #0
 80016ba:	6078      	str	r0, [r7, #4]
 80016bc:	460b      	mov	r3, r1
 80016be:	807b      	strh	r3, [r7, #2]

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* get current Output Data Register value */
  odr = GPIOx->ODR;
 80016c0:	687b      	ldr	r3, [r7, #4]
 80016c2:	695b      	ldr	r3, [r3, #20]
 80016c4:	60fb      	str	r3, [r7, #12]

  /* Set selected pins that were at low level, and reset ones that were high */
  GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
 80016c6:	887a      	ldrh	r2, [r7, #2]
 80016c8:	68fb      	ldr	r3, [r7, #12]
 80016ca:	4013      	ands	r3, r2
 80016cc:	041a      	lsls	r2, r3, #16
 80016ce:	68fb      	ldr	r3, [r7, #12]
 80016d0:	43d9      	mvns	r1, r3
 80016d2:	887b      	ldrh	r3, [r7, #2]
 80016d4:	400b      	ands	r3, r1
 80016d6:	431a      	orrs	r2, r3
 80016d8:	687b      	ldr	r3, [r7, #4]
 80016da:	619a      	str	r2, [r3, #24]
}
 80016dc:	bf00      	nop
 80016de:	3714      	adds	r7, #20
 80016e0:	46bd      	mov	sp, r7
 80016e2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80016e6:	4770      	bx	lr

080016e8 <HAL_ICACHE_ConfigAssociativityMode>:
  *            @arg ICACHE_1WAY   1-way cache (direct mapped cache)
  *            @arg ICACHE_2WAYS  2-ways set associative cache (default)
  * @retval HAL status (HAL_OK/HAL_ERROR)
  */
HAL_StatusTypeDef HAL_ICACHE_ConfigAssociativityMode(uint32_t AssociativityMode)
{
 80016e8:	b480      	push	{r7}
 80016ea:	b085      	sub	sp, #20
 80016ec:	af00      	add	r7, sp, #0
 80016ee:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 80016f0:	2300      	movs	r3, #0
 80016f2:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_ICACHE_ASSOCIATIVITY_MODE(AssociativityMode));

  /* Check cache is not enabled */
  if (READ_BIT(ICACHE->CR, ICACHE_CR_EN) != 0U)
 80016f4:	4b0b      	ldr	r3, [pc, #44]	@ (8001724 <HAL_ICACHE_ConfigAssociativityMode+0x3c>)
 80016f6:	681b      	ldr	r3, [r3, #0]
 80016f8:	f003 0301 	and.w	r3, r3, #1
 80016fc:	2b00      	cmp	r3, #0
 80016fe:	d002      	beq.n	8001706 <HAL_ICACHE_ConfigAssociativityMode+0x1e>
  {
    status = HAL_ERROR;
 8001700:	2301      	movs	r3, #1
 8001702:	73fb      	strb	r3, [r7, #15]
 8001704:	e007      	b.n	8001716 <HAL_ICACHE_ConfigAssociativityMode+0x2e>
  }
  else
  {
    MODIFY_REG(ICACHE->CR, ICACHE_CR_WAYSEL, AssociativityMode);
 8001706:	4b07      	ldr	r3, [pc, #28]	@ (8001724 <HAL_ICACHE_ConfigAssociativityMode+0x3c>)
 8001708:	681b      	ldr	r3, [r3, #0]
 800170a:	f023 0204 	bic.w	r2, r3, #4
 800170e:	4905      	ldr	r1, [pc, #20]	@ (8001724 <HAL_ICACHE_ConfigAssociativityMode+0x3c>)
 8001710:	687b      	ldr	r3, [r7, #4]
 8001712:	4313      	orrs	r3, r2
 8001714:	600b      	str	r3, [r1, #0]
  }

  return status;
 8001716:	7bfb      	ldrb	r3, [r7, #15]
}
 8001718:	4618      	mov	r0, r3
 800171a:	3714      	adds	r7, #20
 800171c:	46bd      	mov	sp, r7
 800171e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001722:	4770      	bx	lr
 8001724:	40030400 	.word	0x40030400

08001728 <HAL_ICACHE_Enable>:
  *         cache operation. The Instruction Cache is bypassed until the
  *         cache operation completes.
  * @retval HAL status (HAL_OK)
  */
HAL_StatusTypeDef HAL_ICACHE_Enable(void)
{
 8001728:	b480      	push	{r7}
 800172a:	af00      	add	r7, sp, #0
  SET_BIT(ICACHE->CR, ICACHE_CR_EN);
 800172c:	4b05      	ldr	r3, [pc, #20]	@ (8001744 <HAL_ICACHE_Enable+0x1c>)
 800172e:	681b      	ldr	r3, [r3, #0]
 8001730:	4a04      	ldr	r2, [pc, #16]	@ (8001744 <HAL_ICACHE_Enable+0x1c>)
 8001732:	f043 0301 	orr.w	r3, r3, #1
 8001736:	6013      	str	r3, [r2, #0]

  return HAL_OK;
 8001738:	2300      	movs	r3, #0
}
 800173a:	4618      	mov	r0, r3
 800173c:	46bd      	mov	sp, r7
 800173e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001742:	4770      	bx	lr
 8001744:	40030400 	.word	0x40030400

08001748 <HAL_PWREx_ControlVoltageScaling>:
  * @note  Before moving to voltage scaling 4, it is mandatory to ensure that
  *        the system frequency is below 24 MHz.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling)
{
 8001748:	b480      	push	{r7}
 800174a:	b085      	sub	sp, #20
 800174c:	af00      	add	r7, sp, #0
 800174e:	6078      	str	r0, [r7, #4]

  /* Check the parameter */
  assert_param(IS_PWR_VOLTAGE_SCALING_RANGE(VoltageScaling));

  /* Get the current voltage scale applied */
  vos_old = READ_BIT(PWR->SVMSR, PWR_SVMSR_ACTVOS);
 8001750:	4b39      	ldr	r3, [pc, #228]	@ (8001838 <HAL_PWREx_ControlVoltageScaling+0xf0>)
 8001752:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8001754:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
 8001758:	60bb      	str	r3, [r7, #8]

  /* No change, nothing to do */
  if (vos_old == VoltageScaling)
 800175a:	68ba      	ldr	r2, [r7, #8]
 800175c:	687b      	ldr	r3, [r7, #4]
 800175e:	429a      	cmp	r2, r3
 8001760:	d10b      	bne.n	800177a <HAL_PWREx_ControlVoltageScaling+0x32>
  {
    /* Enable USB BOOST after wake up from Stop mode */
    if (VoltageScaling > PWR_REGULATOR_VOLTAGE_SCALE3)
 8001762:	687b      	ldr	r3, [r7, #4]
 8001764:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8001768:	d905      	bls.n	8001776 <HAL_PWREx_ControlVoltageScaling+0x2e>
    {
      /* Enable USB BOOST */
      SET_BIT(PWR->VOSR, PWR_VOSR_BOOSTEN);
 800176a:	4b33      	ldr	r3, [pc, #204]	@ (8001838 <HAL_PWREx_ControlVoltageScaling+0xf0>)
 800176c:	68db      	ldr	r3, [r3, #12]
 800176e:	4a32      	ldr	r2, [pc, #200]	@ (8001838 <HAL_PWREx_ControlVoltageScaling+0xf0>)
 8001770:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 8001774:	60d3      	str	r3, [r2, #12]
    }

    return HAL_OK;
 8001776:	2300      	movs	r3, #0
 8001778:	e057      	b.n	800182a <HAL_PWREx_ControlVoltageScaling+0xe2>
  /* Check voltage scaling level */
  /*
   *  The Embedded power distribution (EPOD) must be enabled before switching to
   *  voltage scale 1 / 2 from voltage scale lower.
   */
  if (VoltageScaling > PWR_REGULATOR_VOLTAGE_SCALE3)
 800177a:	687b      	ldr	r3, [r7, #4]
 800177c:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8001780:	d90a      	bls.n	8001798 <HAL_PWREx_ControlVoltageScaling+0x50>
  {
    MODIFY_REG(PWR->VOSR, (PWR_VOSR_VOS | PWR_VOSR_BOOSTEN), (VoltageScaling | PWR_VOSR_BOOSTEN));
 8001782:	4b2d      	ldr	r3, [pc, #180]	@ (8001838 <HAL_PWREx_ControlVoltageScaling+0xf0>)
 8001784:	68db      	ldr	r3, [r3, #12]
 8001786:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
 800178a:	687b      	ldr	r3, [r7, #4]
 800178c:	4313      	orrs	r3, r2
 800178e:	4a2a      	ldr	r2, [pc, #168]	@ (8001838 <HAL_PWREx_ControlVoltageScaling+0xf0>)
 8001790:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 8001794:	60d3      	str	r3, [r2, #12]
 8001796:	e007      	b.n	80017a8 <HAL_PWREx_ControlVoltageScaling+0x60>
  }
  else
  {
    MODIFY_REG(PWR->VOSR, (PWR_VOSR_VOS | PWR_VOSR_BOOSTEN), VoltageScaling);
 8001798:	4b27      	ldr	r3, [pc, #156]	@ (8001838 <HAL_PWREx_ControlVoltageScaling+0xf0>)
 800179a:	68db      	ldr	r3, [r3, #12]
 800179c:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
 80017a0:	4925      	ldr	r1, [pc, #148]	@ (8001838 <HAL_PWREx_ControlVoltageScaling+0xf0>)
 80017a2:	687b      	ldr	r3, [r7, #4]
 80017a4:	4313      	orrs	r3, r2
 80017a6:	60cb      	str	r3, [r1, #12]
  }

  /* Wait until VOSRDY is raised */
  timeout = ((PWR_FLAG_SETTING_DELAY * (SystemCoreClock / 1000U)) / 1000U) + 1U;
 80017a8:	4b24      	ldr	r3, [pc, #144]	@ (800183c <HAL_PWREx_ControlVoltageScaling+0xf4>)
 80017aa:	681b      	ldr	r3, [r3, #0]
 80017ac:	4a24      	ldr	r2, [pc, #144]	@ (8001840 <HAL_PWREx_ControlVoltageScaling+0xf8>)
 80017ae:	fba2 2303 	umull	r2, r3, r2, r3
 80017b2:	099b      	lsrs	r3, r3, #6
 80017b4:	2232      	movs	r2, #50	@ 0x32
 80017b6:	fb02 f303 	mul.w	r3, r2, r3
 80017ba:	4a21      	ldr	r2, [pc, #132]	@ (8001840 <HAL_PWREx_ControlVoltageScaling+0xf8>)
 80017bc:	fba2 2303 	umull	r2, r3, r2, r3
 80017c0:	099b      	lsrs	r3, r3, #6
 80017c2:	3301      	adds	r3, #1
 80017c4:	60fb      	str	r3, [r7, #12]
  while (HAL_IS_BIT_CLR(PWR->VOSR, PWR_VOSR_VOSRDY) && (timeout != 0U))
 80017c6:	e002      	b.n	80017ce <HAL_PWREx_ControlVoltageScaling+0x86>
  {
    timeout--;
 80017c8:	68fb      	ldr	r3, [r7, #12]
 80017ca:	3b01      	subs	r3, #1
 80017cc:	60fb      	str	r3, [r7, #12]
  while (HAL_IS_BIT_CLR(PWR->VOSR, PWR_VOSR_VOSRDY) && (timeout != 0U))
 80017ce:	4b1a      	ldr	r3, [pc, #104]	@ (8001838 <HAL_PWREx_ControlVoltageScaling+0xf0>)
 80017d0:	68db      	ldr	r3, [r3, #12]
 80017d2:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 80017d6:	2b00      	cmp	r3, #0
 80017d8:	d102      	bne.n	80017e0 <HAL_PWREx_ControlVoltageScaling+0x98>
 80017da:	68fb      	ldr	r3, [r7, #12]
 80017dc:	2b00      	cmp	r3, #0
 80017de:	d1f3      	bne.n	80017c8 <HAL_PWREx_ControlVoltageScaling+0x80>
  }

  /* Check time out */
  if (timeout != 0U)
 80017e0:	68fb      	ldr	r3, [r7, #12]
 80017e2:	2b00      	cmp	r3, #0
 80017e4:	d01b      	beq.n	800181e <HAL_PWREx_ControlVoltageScaling+0xd6>
  {
    /* Wait until ACTVOSRDY is raised */
    timeout = ((PWR_FLAG_SETTING_DELAY * (SystemCoreClock / 1000U)) / 1000U) + 1U;
 80017e6:	4b15      	ldr	r3, [pc, #84]	@ (800183c <HAL_PWREx_ControlVoltageScaling+0xf4>)
 80017e8:	681b      	ldr	r3, [r3, #0]
 80017ea:	4a15      	ldr	r2, [pc, #84]	@ (8001840 <HAL_PWREx_ControlVoltageScaling+0xf8>)
 80017ec:	fba2 2303 	umull	r2, r3, r2, r3
 80017f0:	099b      	lsrs	r3, r3, #6
 80017f2:	2232      	movs	r2, #50	@ 0x32
 80017f4:	fb02 f303 	mul.w	r3, r2, r3
 80017f8:	4a11      	ldr	r2, [pc, #68]	@ (8001840 <HAL_PWREx_ControlVoltageScaling+0xf8>)
 80017fa:	fba2 2303 	umull	r2, r3, r2, r3
 80017fe:	099b      	lsrs	r3, r3, #6
 8001800:	3301      	adds	r3, #1
 8001802:	60fb      	str	r3, [r7, #12]
    while ((HAL_IS_BIT_CLR(PWR->SVMSR, PWR_SVMSR_ACTVOSRDY)) && (timeout != 0U))
 8001804:	e002      	b.n	800180c <HAL_PWREx_ControlVoltageScaling+0xc4>
    {
      timeout--;
 8001806:	68fb      	ldr	r3, [r7, #12]
 8001808:	3b01      	subs	r3, #1
 800180a:	60fb      	str	r3, [r7, #12]
    while ((HAL_IS_BIT_CLR(PWR->SVMSR, PWR_SVMSR_ACTVOSRDY)) && (timeout != 0U))
 800180c:	4b0a      	ldr	r3, [pc, #40]	@ (8001838 <HAL_PWREx_ControlVoltageScaling+0xf0>)
 800180e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8001810:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 8001814:	2b00      	cmp	r3, #0
 8001816:	d102      	bne.n	800181e <HAL_PWREx_ControlVoltageScaling+0xd6>
 8001818:	68fb      	ldr	r3, [r7, #12]
 800181a:	2b00      	cmp	r3, #0
 800181c:	d1f3      	bne.n	8001806 <HAL_PWREx_ControlVoltageScaling+0xbe>
    }
  }

  /* Check time out */
  if (timeout == 0U)
 800181e:	68fb      	ldr	r3, [r7, #12]
 8001820:	2b00      	cmp	r3, #0
 8001822:	d101      	bne.n	8001828 <HAL_PWREx_ControlVoltageScaling+0xe0>
  {
    return HAL_TIMEOUT;
 8001824:	2303      	movs	r3, #3
 8001826:	e000      	b.n	800182a <HAL_PWREx_ControlVoltageScaling+0xe2>
  }

  return HAL_OK;
 8001828:	2300      	movs	r3, #0
}
 800182a:	4618      	mov	r0, r3
 800182c:	3714      	adds	r7, #20
 800182e:	46bd      	mov	sp, r7
 8001830:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001834:	4770      	bx	lr
 8001836:	bf00      	nop
 8001838:	46020800 	.word	0x46020800
 800183c:	20000000 	.word	0x20000000
 8001840:	10624dd3 	.word	0x10624dd3

08001844 <HAL_PWREx_GetVoltageRange>:
/**
  * @brief  Return Voltage Scaling Range.
  * @retval Applied voltage scaling value.
  */
uint32_t HAL_PWREx_GetVoltageRange(void)
{
 8001844:	b480      	push	{r7}
 8001846:	af00      	add	r7, sp, #0
  return (PWR->SVMSR & PWR_SVMSR_ACTVOS);
 8001848:	4b04      	ldr	r3, [pc, #16]	@ (800185c <HAL_PWREx_GetVoltageRange+0x18>)
 800184a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800184c:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
}
 8001850:	4618      	mov	r0, r3
 8001852:	46bd      	mov	sp, r7
 8001854:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001858:	4770      	bx	lr
 800185a:	bf00      	nop
 800185c:	46020800 	.word	0x46020800

08001860 <HAL_PWREx_ConfigSupply>:
  *                        @arg PWR_LDO_SUPPLY  : The LDO regulator supplies the Vcore Power Domains.
  *                        @arg PWR_SMPS_SUPPLY : The SMPS regulator supplies the Vcore Power Domains.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_PWREx_ConfigSupply(uint32_t SupplySource)
{
 8001860:	b480      	push	{r7}
 8001862:	b085      	sub	sp, #20
 8001864:	af00      	add	r7, sp, #0
 8001866:	6078      	str	r0, [r7, #4]

  /* Check the parameter */
  assert_param(IS_PWR_SUPPLY(SupplySource));

  /* Set maximum time out */
  timeout = ((PWR_FLAG_SETTING_DELAY * (SystemCoreClock / 1000U)) / 1000U) + 1U;
 8001868:	4b22      	ldr	r3, [pc, #136]	@ (80018f4 <HAL_PWREx_ConfigSupply+0x94>)
 800186a:	681b      	ldr	r3, [r3, #0]
 800186c:	4a22      	ldr	r2, [pc, #136]	@ (80018f8 <HAL_PWREx_ConfigSupply+0x98>)
 800186e:	fba2 2303 	umull	r2, r3, r2, r3
 8001872:	099b      	lsrs	r3, r3, #6
 8001874:	2232      	movs	r2, #50	@ 0x32
 8001876:	fb02 f303 	mul.w	r3, r2, r3
 800187a:	4a1f      	ldr	r2, [pc, #124]	@ (80018f8 <HAL_PWREx_ConfigSupply+0x98>)
 800187c:	fba2 2303 	umull	r2, r3, r2, r3
 8001880:	099b      	lsrs	r3, r3, #6
 8001882:	3301      	adds	r3, #1
 8001884:	60fb      	str	r3, [r7, #12]

  /* Configure the LDO as system regulator supply */
  if (SupplySource == PWR_LDO_SUPPLY)
 8001886:	687b      	ldr	r3, [r7, #4]
 8001888:	2b00      	cmp	r3, #0
 800188a:	d113      	bne.n	80018b4 <HAL_PWREx_ConfigSupply+0x54>
  {
    /* Set the power supply configuration */
    CLEAR_BIT(PWR->CR3, PWR_CR3_REGSEL);
 800188c:	4b1b      	ldr	r3, [pc, #108]	@ (80018fc <HAL_PWREx_ConfigSupply+0x9c>)
 800188e:	689b      	ldr	r3, [r3, #8]
 8001890:	4a1a      	ldr	r2, [pc, #104]	@ (80018fc <HAL_PWREx_ConfigSupply+0x9c>)
 8001892:	f023 0302 	bic.w	r3, r3, #2
 8001896:	6093      	str	r3, [r2, #8]

    /* Wait until system switch on new regulator */
    while (HAL_IS_BIT_SET(PWR->SVMSR, PWR_SVMSR_REGS) && (timeout != 0U))
 8001898:	e002      	b.n	80018a0 <HAL_PWREx_ConfigSupply+0x40>
    {
      timeout--;
 800189a:	68fb      	ldr	r3, [r7, #12]
 800189c:	3b01      	subs	r3, #1
 800189e:	60fb      	str	r3, [r7, #12]
    while (HAL_IS_BIT_SET(PWR->SVMSR, PWR_SVMSR_REGS) && (timeout != 0U))
 80018a0:	4b16      	ldr	r3, [pc, #88]	@ (80018fc <HAL_PWREx_ConfigSupply+0x9c>)
 80018a2:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80018a4:	f003 0302 	and.w	r3, r3, #2
 80018a8:	2b02      	cmp	r3, #2
 80018aa:	d116      	bne.n	80018da <HAL_PWREx_ConfigSupply+0x7a>
 80018ac:	68fb      	ldr	r3, [r7, #12]
 80018ae:	2b00      	cmp	r3, #0
 80018b0:	d1f3      	bne.n	800189a <HAL_PWREx_ConfigSupply+0x3a>
 80018b2:	e012      	b.n	80018da <HAL_PWREx_ConfigSupply+0x7a>
  }
  /* Configure the SMPS as system regulator supply */
  else
  {
    /* Set the power supply configuration */
    SET_BIT(PWR->CR3, PWR_CR3_REGSEL);
 80018b4:	4b11      	ldr	r3, [pc, #68]	@ (80018fc <HAL_PWREx_ConfigSupply+0x9c>)
 80018b6:	689b      	ldr	r3, [r3, #8]
 80018b8:	4a10      	ldr	r2, [pc, #64]	@ (80018fc <HAL_PWREx_ConfigSupply+0x9c>)
 80018ba:	f043 0302 	orr.w	r3, r3, #2
 80018be:	6093      	str	r3, [r2, #8]

    /* Wait until system switch on new regulator */
    while (HAL_IS_BIT_CLR(PWR->SVMSR, PWR_SVMSR_REGS) && (timeout != 0U))
 80018c0:	e002      	b.n	80018c8 <HAL_PWREx_ConfigSupply+0x68>
    {
      timeout--;
 80018c2:	68fb      	ldr	r3, [r7, #12]
 80018c4:	3b01      	subs	r3, #1
 80018c6:	60fb      	str	r3, [r7, #12]
    while (HAL_IS_BIT_CLR(PWR->SVMSR, PWR_SVMSR_REGS) && (timeout != 0U))
 80018c8:	4b0c      	ldr	r3, [pc, #48]	@ (80018fc <HAL_PWREx_ConfigSupply+0x9c>)
 80018ca:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80018cc:	f003 0302 	and.w	r3, r3, #2
 80018d0:	2b00      	cmp	r3, #0
 80018d2:	d102      	bne.n	80018da <HAL_PWREx_ConfigSupply+0x7a>
 80018d4:	68fb      	ldr	r3, [r7, #12]
 80018d6:	2b00      	cmp	r3, #0
 80018d8:	d1f3      	bne.n	80018c2 <HAL_PWREx_ConfigSupply+0x62>
    }
  }

  /* Check time out */
  if (timeout == 0U)
 80018da:	68fb      	ldr	r3, [r7, #12]
 80018dc:	2b00      	cmp	r3, #0
 80018de:	d101      	bne.n	80018e4 <HAL_PWREx_ConfigSupply+0x84>
  {
    return HAL_TIMEOUT;
 80018e0:	2303      	movs	r3, #3
 80018e2:	e000      	b.n	80018e6 <HAL_PWREx_ConfigSupply+0x86>
  }

  return HAL_OK;
 80018e4:	2300      	movs	r3, #0
}
 80018e6:	4618      	mov	r0, r3
 80018e8:	3714      	adds	r7, #20
 80018ea:	46bd      	mov	sp, r7
 80018ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 80018f0:	4770      	bx	lr
 80018f2:	bf00      	nop
 80018f4:	20000000 	.word	0x20000000
 80018f8:	10624dd3 	.word	0x10624dd3
 80018fc:	46020800 	.word	0x46020800

08001900 <HAL_RCC_OscConfig>:
  *         supported by this function. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(const RCC_OscInitTypeDef  *pRCC_OscInitStruct)
{
 8001900:	b580      	push	{r7, lr}
 8001902:	b08e      	sub	sp, #56	@ 0x38
 8001904:	af00      	add	r7, sp, #0
 8001906:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  HAL_StatusTypeDef status;
  uint32_t sysclk_source;
  uint32_t pll_config;
  FlagStatus pwrboosten = RESET;
 8001908:	2300      	movs	r3, #0
 800190a:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
  uint32_t temp1_pllckcfg;
  uint32_t temp2_pllckcfg;

  /* Check Null pointer */
  if (pRCC_OscInitStruct == NULL)
 800190e:	687b      	ldr	r3, [r7, #4]
 8001910:	2b00      	cmp	r3, #0
 8001912:	d102      	bne.n	800191a <HAL_RCC_OscConfig+0x1a>
  {
    return HAL_ERROR;
 8001914:	2301      	movs	r3, #1
 8001916:	f000 bec8 	b.w	80026aa <HAL_RCC_OscConfig+0xdaa>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(pRCC_OscInitStruct->OscillatorType));

  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 800191a:	4b99      	ldr	r3, [pc, #612]	@ (8001b80 <HAL_RCC_OscConfig+0x280>)
 800191c:	69db      	ldr	r3, [r3, #28]
 800191e:	f003 030c 	and.w	r3, r3, #12
 8001922:	633b      	str	r3, [r7, #48]	@ 0x30
  pll_config = __HAL_RCC_GET_PLL_OSCSOURCE();
 8001924:	4b96      	ldr	r3, [pc, #600]	@ (8001b80 <HAL_RCC_OscConfig+0x280>)
 8001926:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001928:	f003 0303 	and.w	r3, r3, #3
 800192c:	62fb      	str	r3, [r7, #44]	@ 0x2c

  /*----------------------------- MSI Configuration --------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 800192e:	687b      	ldr	r3, [r7, #4]
 8001930:	681b      	ldr	r3, [r3, #0]
 8001932:	f003 0310 	and.w	r3, r3, #16
 8001936:	2b00      	cmp	r3, #0
 8001938:	f000 816c 	beq.w	8001c14 <HAL_RCC_OscConfig+0x314>
    assert_param(IS_RCC_MSICALIBRATION_VALUE(pRCC_OscInitStruct->MSICalibrationValue));
    assert_param(IS_RCC_MSI_CLOCK_RANGE(pRCC_OscInitStruct->MSIClockRange));

    /*Check if MSI is used as system clock or as PLL source when PLL is selected as system clock*/

    if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 800193c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800193e:	2b00      	cmp	r3, #0
 8001940:	d007      	beq.n	8001952 <HAL_RCC_OscConfig+0x52>
 8001942:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8001944:	2b0c      	cmp	r3, #12
 8001946:	f040 80de 	bne.w	8001b06 <HAL_RCC_OscConfig+0x206>
        ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_MSI)))
 800194a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800194c:	2b01      	cmp	r3, #1
 800194e:	f040 80da 	bne.w	8001b06 <HAL_RCC_OscConfig+0x206>
    {
      if (pRCC_OscInitStruct->MSIState == RCC_MSI_OFF)
 8001952:	687b      	ldr	r3, [r7, #4]
 8001954:	69db      	ldr	r3, [r3, #28]
 8001956:	2b00      	cmp	r3, #0
 8001958:	d102      	bne.n	8001960 <HAL_RCC_OscConfig+0x60>
      {
        return HAL_ERROR;
 800195a:	2301      	movs	r3, #1
 800195c:	f000 bea5 	b.w	80026aa <HAL_RCC_OscConfig+0xdaa>
      else
      {
        /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
           must be correctly programmed according to the frequency of the CPU clock
           (HCLK) and the supply voltage of the device */
        if (pRCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 8001960:	687b      	ldr	r3, [r7, #4]
 8001962:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8001964:	4b86      	ldr	r3, [pc, #536]	@ (8001b80 <HAL_RCC_OscConfig+0x280>)
 8001966:	689b      	ldr	r3, [r3, #8]
 8001968:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 800196c:	2b00      	cmp	r3, #0
 800196e:	d004      	beq.n	800197a <HAL_RCC_OscConfig+0x7a>
 8001970:	4b83      	ldr	r3, [pc, #524]	@ (8001b80 <HAL_RCC_OscConfig+0x280>)
 8001972:	689b      	ldr	r3, [r3, #8]
 8001974:	f003 4370 	and.w	r3, r3, #4026531840	@ 0xf0000000
 8001978:	e005      	b.n	8001986 <HAL_RCC_OscConfig+0x86>
 800197a:	4b81      	ldr	r3, [pc, #516]	@ (8001b80 <HAL_RCC_OscConfig+0x280>)
 800197c:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8001980:	041b      	lsls	r3, r3, #16
 8001982:	f003 4370 	and.w	r3, r3, #4026531840	@ 0xf0000000
 8001986:	4293      	cmp	r3, r2
 8001988:	d255      	bcs.n	8001a36 <HAL_RCC_OscConfig+0x136>
        {
          /* Decrease number of wait states update if necessary */
          /* Only possible when MSI is the System clock source  */
          if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI)
 800198a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800198c:	2b00      	cmp	r3, #0
 800198e:	d10a      	bne.n	80019a6 <HAL_RCC_OscConfig+0xa6>
          {
            if (RCC_SetFlashLatencyFromMSIRange(pRCC_OscInitStruct->MSIClockRange) != HAL_OK)
 8001990:	687b      	ldr	r3, [r7, #4]
 8001992:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8001994:	4618      	mov	r0, r3
 8001996:	f001 f9d9 	bl	8002d4c <RCC_SetFlashLatencyFromMSIRange>
 800199a:	4603      	mov	r3, r0
 800199c:	2b00      	cmp	r3, #0
 800199e:	d002      	beq.n	80019a6 <HAL_RCC_OscConfig+0xa6>
            {
              return HAL_ERROR;
 80019a0:	2301      	movs	r3, #1
 80019a2:	f000 be82 	b.w	80026aa <HAL_RCC_OscConfig+0xdaa>
            }
          }

          /* Selects the Multiple Speed oscillator (MSI) clock range */
          __HAL_RCC_MSI_RANGE_CONFIG(pRCC_OscInitStruct->MSIClockRange);
 80019a6:	4b76      	ldr	r3, [pc, #472]	@ (8001b80 <HAL_RCC_OscConfig+0x280>)
 80019a8:	689b      	ldr	r3, [r3, #8]
 80019aa:	4a75      	ldr	r2, [pc, #468]	@ (8001b80 <HAL_RCC_OscConfig+0x280>)
 80019ac:	f443 0300 	orr.w	r3, r3, #8388608	@ 0x800000
 80019b0:	6093      	str	r3, [r2, #8]
 80019b2:	4b73      	ldr	r3, [pc, #460]	@ (8001b80 <HAL_RCC_OscConfig+0x280>)
 80019b4:	689b      	ldr	r3, [r3, #8]
 80019b6:	f023 4270 	bic.w	r2, r3, #4026531840	@ 0xf0000000
 80019ba:	687b      	ldr	r3, [r7, #4]
 80019bc:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80019be:	4970      	ldr	r1, [pc, #448]	@ (8001b80 <HAL_RCC_OscConfig+0x280>)
 80019c0:	4313      	orrs	r3, r2
 80019c2:	608b      	str	r3, [r1, #8]
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value */
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST((pRCC_OscInitStruct->MSICalibrationValue), \
 80019c4:	687b      	ldr	r3, [r7, #4]
 80019c6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80019c8:	f1b3 4f40 	cmp.w	r3, #3221225472	@ 0xc0000000
 80019cc:	d309      	bcc.n	80019e2 <HAL_RCC_OscConfig+0xe2>
 80019ce:	4b6c      	ldr	r3, [pc, #432]	@ (8001b80 <HAL_RCC_OscConfig+0x280>)
 80019d0:	68db      	ldr	r3, [r3, #12]
 80019d2:	f023 021f 	bic.w	r2, r3, #31
 80019d6:	687b      	ldr	r3, [r7, #4]
 80019d8:	6a1b      	ldr	r3, [r3, #32]
 80019da:	4969      	ldr	r1, [pc, #420]	@ (8001b80 <HAL_RCC_OscConfig+0x280>)
 80019dc:	4313      	orrs	r3, r2
 80019de:	60cb      	str	r3, [r1, #12]
 80019e0:	e07e      	b.n	8001ae0 <HAL_RCC_OscConfig+0x1e0>
 80019e2:	687b      	ldr	r3, [r7, #4]
 80019e4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80019e6:	2b00      	cmp	r3, #0
 80019e8:	da0a      	bge.n	8001a00 <HAL_RCC_OscConfig+0x100>
 80019ea:	4b65      	ldr	r3, [pc, #404]	@ (8001b80 <HAL_RCC_OscConfig+0x280>)
 80019ec:	68db      	ldr	r3, [r3, #12]
 80019ee:	f423 7278 	bic.w	r2, r3, #992	@ 0x3e0
 80019f2:	687b      	ldr	r3, [r7, #4]
 80019f4:	6a1b      	ldr	r3, [r3, #32]
 80019f6:	015b      	lsls	r3, r3, #5
 80019f8:	4961      	ldr	r1, [pc, #388]	@ (8001b80 <HAL_RCC_OscConfig+0x280>)
 80019fa:	4313      	orrs	r3, r2
 80019fc:	60cb      	str	r3, [r1, #12]
 80019fe:	e06f      	b.n	8001ae0 <HAL_RCC_OscConfig+0x1e0>
 8001a00:	687b      	ldr	r3, [r7, #4]
 8001a02:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8001a04:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8001a08:	d30a      	bcc.n	8001a20 <HAL_RCC_OscConfig+0x120>
 8001a0a:	4b5d      	ldr	r3, [pc, #372]	@ (8001b80 <HAL_RCC_OscConfig+0x280>)
 8001a0c:	68db      	ldr	r3, [r3, #12]
 8001a0e:	f423 42f8 	bic.w	r2, r3, #31744	@ 0x7c00
 8001a12:	687b      	ldr	r3, [r7, #4]
 8001a14:	6a1b      	ldr	r3, [r3, #32]
 8001a16:	029b      	lsls	r3, r3, #10
 8001a18:	4959      	ldr	r1, [pc, #356]	@ (8001b80 <HAL_RCC_OscConfig+0x280>)
 8001a1a:	4313      	orrs	r3, r2
 8001a1c:	60cb      	str	r3, [r1, #12]
 8001a1e:	e05f      	b.n	8001ae0 <HAL_RCC_OscConfig+0x1e0>
 8001a20:	4b57      	ldr	r3, [pc, #348]	@ (8001b80 <HAL_RCC_OscConfig+0x280>)
 8001a22:	68db      	ldr	r3, [r3, #12]
 8001a24:	f423 2278 	bic.w	r2, r3, #1015808	@ 0xf8000
 8001a28:	687b      	ldr	r3, [r7, #4]
 8001a2a:	6a1b      	ldr	r3, [r3, #32]
 8001a2c:	03db      	lsls	r3, r3, #15
 8001a2e:	4954      	ldr	r1, [pc, #336]	@ (8001b80 <HAL_RCC_OscConfig+0x280>)
 8001a30:	4313      	orrs	r3, r2
 8001a32:	60cb      	str	r3, [r1, #12]
 8001a34:	e054      	b.n	8001ae0 <HAL_RCC_OscConfig+0x1e0>
        }
        else
        {
          /* Else, keep current flash latency while decreasing applies */
          /* Selects the Multiple Speed oscillator (MSI) clock range */
          __HAL_RCC_MSI_RANGE_CONFIG(pRCC_OscInitStruct->MSIClockRange);
 8001a36:	4b52      	ldr	r3, [pc, #328]	@ (8001b80 <HAL_RCC_OscConfig+0x280>)
 8001a38:	689b      	ldr	r3, [r3, #8]
 8001a3a:	4a51      	ldr	r2, [pc, #324]	@ (8001b80 <HAL_RCC_OscConfig+0x280>)
 8001a3c:	f443 0300 	orr.w	r3, r3, #8388608	@ 0x800000
 8001a40:	6093      	str	r3, [r2, #8]
 8001a42:	4b4f      	ldr	r3, [pc, #316]	@ (8001b80 <HAL_RCC_OscConfig+0x280>)
 8001a44:	689b      	ldr	r3, [r3, #8]
 8001a46:	f023 4270 	bic.w	r2, r3, #4026531840	@ 0xf0000000
 8001a4a:	687b      	ldr	r3, [r7, #4]
 8001a4c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8001a4e:	494c      	ldr	r1, [pc, #304]	@ (8001b80 <HAL_RCC_OscConfig+0x280>)
 8001a50:	4313      	orrs	r3, r2
 8001a52:	608b      	str	r3, [r1, #8]
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value */
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST((pRCC_OscInitStruct->MSICalibrationValue), \
 8001a54:	687b      	ldr	r3, [r7, #4]
 8001a56:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8001a58:	f1b3 4f40 	cmp.w	r3, #3221225472	@ 0xc0000000
 8001a5c:	d309      	bcc.n	8001a72 <HAL_RCC_OscConfig+0x172>
 8001a5e:	4b48      	ldr	r3, [pc, #288]	@ (8001b80 <HAL_RCC_OscConfig+0x280>)
 8001a60:	68db      	ldr	r3, [r3, #12]
 8001a62:	f023 021f 	bic.w	r2, r3, #31
 8001a66:	687b      	ldr	r3, [r7, #4]
 8001a68:	6a1b      	ldr	r3, [r3, #32]
 8001a6a:	4945      	ldr	r1, [pc, #276]	@ (8001b80 <HAL_RCC_OscConfig+0x280>)
 8001a6c:	4313      	orrs	r3, r2
 8001a6e:	60cb      	str	r3, [r1, #12]
 8001a70:	e028      	b.n	8001ac4 <HAL_RCC_OscConfig+0x1c4>
 8001a72:	687b      	ldr	r3, [r7, #4]
 8001a74:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8001a76:	2b00      	cmp	r3, #0
 8001a78:	da0a      	bge.n	8001a90 <HAL_RCC_OscConfig+0x190>
 8001a7a:	4b41      	ldr	r3, [pc, #260]	@ (8001b80 <HAL_RCC_OscConfig+0x280>)
 8001a7c:	68db      	ldr	r3, [r3, #12]
 8001a7e:	f423 7278 	bic.w	r2, r3, #992	@ 0x3e0
 8001a82:	687b      	ldr	r3, [r7, #4]
 8001a84:	6a1b      	ldr	r3, [r3, #32]
 8001a86:	015b      	lsls	r3, r3, #5
 8001a88:	493d      	ldr	r1, [pc, #244]	@ (8001b80 <HAL_RCC_OscConfig+0x280>)
 8001a8a:	4313      	orrs	r3, r2
 8001a8c:	60cb      	str	r3, [r1, #12]
 8001a8e:	e019      	b.n	8001ac4 <HAL_RCC_OscConfig+0x1c4>
 8001a90:	687b      	ldr	r3, [r7, #4]
 8001a92:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8001a94:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8001a98:	d30a      	bcc.n	8001ab0 <HAL_RCC_OscConfig+0x1b0>
 8001a9a:	4b39      	ldr	r3, [pc, #228]	@ (8001b80 <HAL_RCC_OscConfig+0x280>)
 8001a9c:	68db      	ldr	r3, [r3, #12]
 8001a9e:	f423 42f8 	bic.w	r2, r3, #31744	@ 0x7c00
 8001aa2:	687b      	ldr	r3, [r7, #4]
 8001aa4:	6a1b      	ldr	r3, [r3, #32]
 8001aa6:	029b      	lsls	r3, r3, #10
 8001aa8:	4935      	ldr	r1, [pc, #212]	@ (8001b80 <HAL_RCC_OscConfig+0x280>)
 8001aaa:	4313      	orrs	r3, r2
 8001aac:	60cb      	str	r3, [r1, #12]
 8001aae:	e009      	b.n	8001ac4 <HAL_RCC_OscConfig+0x1c4>
 8001ab0:	4b33      	ldr	r3, [pc, #204]	@ (8001b80 <HAL_RCC_OscConfig+0x280>)
 8001ab2:	68db      	ldr	r3, [r3, #12]
 8001ab4:	f423 2278 	bic.w	r2, r3, #1015808	@ 0xf8000
 8001ab8:	687b      	ldr	r3, [r7, #4]
 8001aba:	6a1b      	ldr	r3, [r3, #32]
 8001abc:	03db      	lsls	r3, r3, #15
 8001abe:	4930      	ldr	r1, [pc, #192]	@ (8001b80 <HAL_RCC_OscConfig+0x280>)
 8001ac0:	4313      	orrs	r3, r2
 8001ac2:	60cb      	str	r3, [r1, #12]
                                                (pRCC_OscInitStruct->MSIClockRange));

          if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI)
 8001ac4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8001ac6:	2b00      	cmp	r3, #0
 8001ac8:	d10a      	bne.n	8001ae0 <HAL_RCC_OscConfig+0x1e0>
          {
            if (RCC_SetFlashLatencyFromMSIRange(pRCC_OscInitStruct->MSIClockRange) != HAL_OK)
 8001aca:	687b      	ldr	r3, [r7, #4]
 8001acc:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8001ace:	4618      	mov	r0, r3
 8001ad0:	f001 f93c 	bl	8002d4c <RCC_SetFlashLatencyFromMSIRange>
 8001ad4:	4603      	mov	r3, r0
 8001ad6:	2b00      	cmp	r3, #0
 8001ad8:	d002      	beq.n	8001ae0 <HAL_RCC_OscConfig+0x1e0>
            {
              return HAL_ERROR;
 8001ada:	2301      	movs	r3, #1
 8001adc:	f000 bde5 	b.w	80026aa <HAL_RCC_OscConfig+0xdaa>
            }
          }
        }

        /* Update the SystemCoreClock global variable */
        (void) HAL_RCC_GetHCLKFreq();
 8001ae0:	f001 f8de 	bl	8002ca0 <HAL_RCC_GetHCLKFreq>
        /* Configure the source of time base considering new system clocks settings*/
        status = HAL_InitTick(uwTickPrio);
 8001ae4:	4b27      	ldr	r3, [pc, #156]	@ (8001b84 <HAL_RCC_OscConfig+0x284>)
 8001ae6:	681b      	ldr	r3, [r3, #0]
 8001ae8:	4618      	mov	r0, r3
 8001aea:	f7ff f9bd 	bl	8000e68 <HAL_InitTick>
 8001aee:	4603      	mov	r3, r0
 8001af0:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
        if (status != HAL_OK)
 8001af4:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8001af8:	2b00      	cmp	r3, #0
 8001afa:	f000 808a 	beq.w	8001c12 <HAL_RCC_OscConfig+0x312>
        {
          return status;
 8001afe:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8001b02:	f000 bdd2 	b.w	80026aa <HAL_RCC_OscConfig+0xdaa>
      }
    }
    else
    {
      /* Check the MSI State */
      if (pRCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 8001b06:	687b      	ldr	r3, [r7, #4]
 8001b08:	69db      	ldr	r3, [r3, #28]
 8001b0a:	2b00      	cmp	r3, #0
 8001b0c:	d066      	beq.n	8001bdc <HAL_RCC_OscConfig+0x2dc>
      {
        /* Enable the Internal High Speed oscillator (MSI) */
        __HAL_RCC_MSI_ENABLE();
 8001b0e:	4b1c      	ldr	r3, [pc, #112]	@ (8001b80 <HAL_RCC_OscConfig+0x280>)
 8001b10:	681b      	ldr	r3, [r3, #0]
 8001b12:	4a1b      	ldr	r2, [pc, #108]	@ (8001b80 <HAL_RCC_OscConfig+0x280>)
 8001b14:	f043 0301 	orr.w	r3, r3, #1
 8001b18:	6013      	str	r3, [r2, #0]

        tickstart = HAL_GetTick();
 8001b1a:	f7ff fa2f 	bl	8000f7c <HAL_GetTick>
 8001b1e:	62b8      	str	r0, [r7, #40]	@ 0x28

        /* Wait till MSI is ready */
        while (READ_BIT(RCC->CR, RCC_CR_MSISRDY) == 0U)
 8001b20:	e009      	b.n	8001b36 <HAL_RCC_OscConfig+0x236>
        {
          if ((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 8001b22:	f7ff fa2b 	bl	8000f7c <HAL_GetTick>
 8001b26:	4602      	mov	r2, r0
 8001b28:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8001b2a:	1ad3      	subs	r3, r2, r3
 8001b2c:	2b02      	cmp	r3, #2
 8001b2e:	d902      	bls.n	8001b36 <HAL_RCC_OscConfig+0x236>
          {
            return HAL_TIMEOUT;
 8001b30:	2303      	movs	r3, #3
 8001b32:	f000 bdba 	b.w	80026aa <HAL_RCC_OscConfig+0xdaa>
        while (READ_BIT(RCC->CR, RCC_CR_MSISRDY) == 0U)
 8001b36:	4b12      	ldr	r3, [pc, #72]	@ (8001b80 <HAL_RCC_OscConfig+0x280>)
 8001b38:	681b      	ldr	r3, [r3, #0]
 8001b3a:	f003 0304 	and.w	r3, r3, #4
 8001b3e:	2b00      	cmp	r3, #0
 8001b40:	d0ef      	beq.n	8001b22 <HAL_RCC_OscConfig+0x222>
          }
        }
        /* Selects the Multiple Speed oscillator (MSI) clock range */
        __HAL_RCC_MSI_RANGE_CONFIG(pRCC_OscInitStruct->MSIClockRange);
 8001b42:	4b0f      	ldr	r3, [pc, #60]	@ (8001b80 <HAL_RCC_OscConfig+0x280>)
 8001b44:	689b      	ldr	r3, [r3, #8]
 8001b46:	4a0e      	ldr	r2, [pc, #56]	@ (8001b80 <HAL_RCC_OscConfig+0x280>)
 8001b48:	f443 0300 	orr.w	r3, r3, #8388608	@ 0x800000
 8001b4c:	6093      	str	r3, [r2, #8]
 8001b4e:	4b0c      	ldr	r3, [pc, #48]	@ (8001b80 <HAL_RCC_OscConfig+0x280>)
 8001b50:	689b      	ldr	r3, [r3, #8]
 8001b52:	f023 4270 	bic.w	r2, r3, #4026531840	@ 0xf0000000
 8001b56:	687b      	ldr	r3, [r7, #4]
 8001b58:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8001b5a:	4909      	ldr	r1, [pc, #36]	@ (8001b80 <HAL_RCC_OscConfig+0x280>)
 8001b5c:	4313      	orrs	r3, r2
 8001b5e:	608b      	str	r3, [r1, #8]
        /* Adjusts the Multiple Speed oscillator (MSI) calibration value */
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST((pRCC_OscInitStruct->MSICalibrationValue), \
 8001b60:	687b      	ldr	r3, [r7, #4]
 8001b62:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8001b64:	f1b3 4f40 	cmp.w	r3, #3221225472	@ 0xc0000000
 8001b68:	d30e      	bcc.n	8001b88 <HAL_RCC_OscConfig+0x288>
 8001b6a:	4b05      	ldr	r3, [pc, #20]	@ (8001b80 <HAL_RCC_OscConfig+0x280>)
 8001b6c:	68db      	ldr	r3, [r3, #12]
 8001b6e:	f023 021f 	bic.w	r2, r3, #31
 8001b72:	687b      	ldr	r3, [r7, #4]
 8001b74:	6a1b      	ldr	r3, [r3, #32]
 8001b76:	4902      	ldr	r1, [pc, #8]	@ (8001b80 <HAL_RCC_OscConfig+0x280>)
 8001b78:	4313      	orrs	r3, r2
 8001b7a:	60cb      	str	r3, [r1, #12]
 8001b7c:	e04a      	b.n	8001c14 <HAL_RCC_OscConfig+0x314>
 8001b7e:	bf00      	nop
 8001b80:	46020c00 	.word	0x46020c00
 8001b84:	2000000c 	.word	0x2000000c
 8001b88:	687b      	ldr	r3, [r7, #4]
 8001b8a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8001b8c:	2b00      	cmp	r3, #0
 8001b8e:	da0a      	bge.n	8001ba6 <HAL_RCC_OscConfig+0x2a6>
 8001b90:	4b98      	ldr	r3, [pc, #608]	@ (8001df4 <HAL_RCC_OscConfig+0x4f4>)
 8001b92:	68db      	ldr	r3, [r3, #12]
 8001b94:	f423 7278 	bic.w	r2, r3, #992	@ 0x3e0
 8001b98:	687b      	ldr	r3, [r7, #4]
 8001b9a:	6a1b      	ldr	r3, [r3, #32]
 8001b9c:	015b      	lsls	r3, r3, #5
 8001b9e:	4995      	ldr	r1, [pc, #596]	@ (8001df4 <HAL_RCC_OscConfig+0x4f4>)
 8001ba0:	4313      	orrs	r3, r2
 8001ba2:	60cb      	str	r3, [r1, #12]
 8001ba4:	e036      	b.n	8001c14 <HAL_RCC_OscConfig+0x314>
 8001ba6:	687b      	ldr	r3, [r7, #4]
 8001ba8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8001baa:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8001bae:	d30a      	bcc.n	8001bc6 <HAL_RCC_OscConfig+0x2c6>
 8001bb0:	4b90      	ldr	r3, [pc, #576]	@ (8001df4 <HAL_RCC_OscConfig+0x4f4>)
 8001bb2:	68db      	ldr	r3, [r3, #12]
 8001bb4:	f423 42f8 	bic.w	r2, r3, #31744	@ 0x7c00
 8001bb8:	687b      	ldr	r3, [r7, #4]
 8001bba:	6a1b      	ldr	r3, [r3, #32]
 8001bbc:	029b      	lsls	r3, r3, #10
 8001bbe:	498d      	ldr	r1, [pc, #564]	@ (8001df4 <HAL_RCC_OscConfig+0x4f4>)
 8001bc0:	4313      	orrs	r3, r2
 8001bc2:	60cb      	str	r3, [r1, #12]
 8001bc4:	e026      	b.n	8001c14 <HAL_RCC_OscConfig+0x314>
 8001bc6:	4b8b      	ldr	r3, [pc, #556]	@ (8001df4 <HAL_RCC_OscConfig+0x4f4>)
 8001bc8:	68db      	ldr	r3, [r3, #12]
 8001bca:	f423 2278 	bic.w	r2, r3, #1015808	@ 0xf8000
 8001bce:	687b      	ldr	r3, [r7, #4]
 8001bd0:	6a1b      	ldr	r3, [r3, #32]
 8001bd2:	03db      	lsls	r3, r3, #15
 8001bd4:	4987      	ldr	r1, [pc, #540]	@ (8001df4 <HAL_RCC_OscConfig+0x4f4>)
 8001bd6:	4313      	orrs	r3, r2
 8001bd8:	60cb      	str	r3, [r1, #12]
 8001bda:	e01b      	b.n	8001c14 <HAL_RCC_OscConfig+0x314>

      }
      else
      {
        /* Disable the Internal High Speed oscillator (MSI) */
        __HAL_RCC_MSI_DISABLE();
 8001bdc:	4b85      	ldr	r3, [pc, #532]	@ (8001df4 <HAL_RCC_OscConfig+0x4f4>)
 8001bde:	681b      	ldr	r3, [r3, #0]
 8001be0:	4a84      	ldr	r2, [pc, #528]	@ (8001df4 <HAL_RCC_OscConfig+0x4f4>)
 8001be2:	f023 0301 	bic.w	r3, r3, #1
 8001be6:	6013      	str	r3, [r2, #0]

        tickstart = HAL_GetTick();
 8001be8:	f7ff f9c8 	bl	8000f7c <HAL_GetTick>
 8001bec:	62b8      	str	r0, [r7, #40]	@ 0x28

        /* Wait till MSI is ready */
        while (READ_BIT(RCC->CR, RCC_CR_MSISRDY) != 0U)
 8001bee:	e009      	b.n	8001c04 <HAL_RCC_OscConfig+0x304>
        {
          if ((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 8001bf0:	f7ff f9c4 	bl	8000f7c <HAL_GetTick>
 8001bf4:	4602      	mov	r2, r0
 8001bf6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8001bf8:	1ad3      	subs	r3, r2, r3
 8001bfa:	2b02      	cmp	r3, #2
 8001bfc:	d902      	bls.n	8001c04 <HAL_RCC_OscConfig+0x304>
          {
            return HAL_TIMEOUT;
 8001bfe:	2303      	movs	r3, #3
 8001c00:	f000 bd53 	b.w	80026aa <HAL_RCC_OscConfig+0xdaa>
        while (READ_BIT(RCC->CR, RCC_CR_MSISRDY) != 0U)
 8001c04:	4b7b      	ldr	r3, [pc, #492]	@ (8001df4 <HAL_RCC_OscConfig+0x4f4>)
 8001c06:	681b      	ldr	r3, [r3, #0]
 8001c08:	f003 0304 	and.w	r3, r3, #4
 8001c0c:	2b00      	cmp	r3, #0
 8001c0e:	d1ef      	bne.n	8001bf0 <HAL_RCC_OscConfig+0x2f0>
 8001c10:	e000      	b.n	8001c14 <HAL_RCC_OscConfig+0x314>
      if (pRCC_OscInitStruct->MSIState == RCC_MSI_OFF)
 8001c12:	bf00      	nop
        }
      }
    }
  }
  /*------------------------------- HSE Configuration ------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8001c14:	687b      	ldr	r3, [r7, #4]
 8001c16:	681b      	ldr	r3, [r3, #0]
 8001c18:	f003 0301 	and.w	r3, r3, #1
 8001c1c:	2b00      	cmp	r3, #0
 8001c1e:	f000 808b 	beq.w	8001d38 <HAL_RCC_OscConfig+0x438>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(pRCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE) ||
 8001c22:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8001c24:	2b08      	cmp	r3, #8
 8001c26:	d005      	beq.n	8001c34 <HAL_RCC_OscConfig+0x334>
 8001c28:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8001c2a:	2b0c      	cmp	r3, #12
 8001c2c:	d109      	bne.n	8001c42 <HAL_RCC_OscConfig+0x342>
        ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSE)))
 8001c2e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8001c30:	2b03      	cmp	r3, #3
 8001c32:	d106      	bne.n	8001c42 <HAL_RCC_OscConfig+0x342>
    {
      if (pRCC_OscInitStruct->HSEState == RCC_HSE_OFF)
 8001c34:	687b      	ldr	r3, [r7, #4]
 8001c36:	685b      	ldr	r3, [r3, #4]
 8001c38:	2b00      	cmp	r3, #0
 8001c3a:	d17d      	bne.n	8001d38 <HAL_RCC_OscConfig+0x438>
      {
        return HAL_ERROR;
 8001c3c:	2301      	movs	r3, #1
 8001c3e:	f000 bd34 	b.w	80026aa <HAL_RCC_OscConfig+0xdaa>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(pRCC_OscInitStruct->HSEState);
 8001c42:	687b      	ldr	r3, [r7, #4]
 8001c44:	685b      	ldr	r3, [r3, #4]
 8001c46:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8001c4a:	d106      	bne.n	8001c5a <HAL_RCC_OscConfig+0x35a>
 8001c4c:	4b69      	ldr	r3, [pc, #420]	@ (8001df4 <HAL_RCC_OscConfig+0x4f4>)
 8001c4e:	681b      	ldr	r3, [r3, #0]
 8001c50:	4a68      	ldr	r2, [pc, #416]	@ (8001df4 <HAL_RCC_OscConfig+0x4f4>)
 8001c52:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8001c56:	6013      	str	r3, [r2, #0]
 8001c58:	e041      	b.n	8001cde <HAL_RCC_OscConfig+0x3de>
 8001c5a:	687b      	ldr	r3, [r7, #4]
 8001c5c:	685b      	ldr	r3, [r3, #4]
 8001c5e:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
 8001c62:	d112      	bne.n	8001c8a <HAL_RCC_OscConfig+0x38a>
 8001c64:	4b63      	ldr	r3, [pc, #396]	@ (8001df4 <HAL_RCC_OscConfig+0x4f4>)
 8001c66:	681b      	ldr	r3, [r3, #0]
 8001c68:	4a62      	ldr	r2, [pc, #392]	@ (8001df4 <HAL_RCC_OscConfig+0x4f4>)
 8001c6a:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 8001c6e:	6013      	str	r3, [r2, #0]
 8001c70:	4b60      	ldr	r3, [pc, #384]	@ (8001df4 <HAL_RCC_OscConfig+0x4f4>)
 8001c72:	681b      	ldr	r3, [r3, #0]
 8001c74:	4a5f      	ldr	r2, [pc, #380]	@ (8001df4 <HAL_RCC_OscConfig+0x4f4>)
 8001c76:	f423 1380 	bic.w	r3, r3, #1048576	@ 0x100000
 8001c7a:	6013      	str	r3, [r2, #0]
 8001c7c:	4b5d      	ldr	r3, [pc, #372]	@ (8001df4 <HAL_RCC_OscConfig+0x4f4>)
 8001c7e:	681b      	ldr	r3, [r3, #0]
 8001c80:	4a5c      	ldr	r2, [pc, #368]	@ (8001df4 <HAL_RCC_OscConfig+0x4f4>)
 8001c82:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8001c86:	6013      	str	r3, [r2, #0]
 8001c88:	e029      	b.n	8001cde <HAL_RCC_OscConfig+0x3de>
 8001c8a:	687b      	ldr	r3, [r7, #4]
 8001c8c:	685b      	ldr	r3, [r3, #4]
 8001c8e:	f5b3 1fa8 	cmp.w	r3, #1376256	@ 0x150000
 8001c92:	d112      	bne.n	8001cba <HAL_RCC_OscConfig+0x3ba>
 8001c94:	4b57      	ldr	r3, [pc, #348]	@ (8001df4 <HAL_RCC_OscConfig+0x4f4>)
 8001c96:	681b      	ldr	r3, [r3, #0]
 8001c98:	4a56      	ldr	r2, [pc, #344]	@ (8001df4 <HAL_RCC_OscConfig+0x4f4>)
 8001c9a:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 8001c9e:	6013      	str	r3, [r2, #0]
 8001ca0:	4b54      	ldr	r3, [pc, #336]	@ (8001df4 <HAL_RCC_OscConfig+0x4f4>)
 8001ca2:	681b      	ldr	r3, [r3, #0]
 8001ca4:	4a53      	ldr	r2, [pc, #332]	@ (8001df4 <HAL_RCC_OscConfig+0x4f4>)
 8001ca6:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
 8001caa:	6013      	str	r3, [r2, #0]
 8001cac:	4b51      	ldr	r3, [pc, #324]	@ (8001df4 <HAL_RCC_OscConfig+0x4f4>)
 8001cae:	681b      	ldr	r3, [r3, #0]
 8001cb0:	4a50      	ldr	r2, [pc, #320]	@ (8001df4 <HAL_RCC_OscConfig+0x4f4>)
 8001cb2:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8001cb6:	6013      	str	r3, [r2, #0]
 8001cb8:	e011      	b.n	8001cde <HAL_RCC_OscConfig+0x3de>
 8001cba:	4b4e      	ldr	r3, [pc, #312]	@ (8001df4 <HAL_RCC_OscConfig+0x4f4>)
 8001cbc:	681b      	ldr	r3, [r3, #0]
 8001cbe:	4a4d      	ldr	r2, [pc, #308]	@ (8001df4 <HAL_RCC_OscConfig+0x4f4>)
 8001cc0:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 8001cc4:	6013      	str	r3, [r2, #0]
 8001cc6:	4b4b      	ldr	r3, [pc, #300]	@ (8001df4 <HAL_RCC_OscConfig+0x4f4>)
 8001cc8:	681b      	ldr	r3, [r3, #0]
 8001cca:	4a4a      	ldr	r2, [pc, #296]	@ (8001df4 <HAL_RCC_OscConfig+0x4f4>)
 8001ccc:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
 8001cd0:	6013      	str	r3, [r2, #0]
 8001cd2:	4b48      	ldr	r3, [pc, #288]	@ (8001df4 <HAL_RCC_OscConfig+0x4f4>)
 8001cd4:	681b      	ldr	r3, [r3, #0]
 8001cd6:	4a47      	ldr	r2, [pc, #284]	@ (8001df4 <HAL_RCC_OscConfig+0x4f4>)
 8001cd8:	f423 1380 	bic.w	r3, r3, #1048576	@ 0x100000
 8001cdc:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if (pRCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8001cde:	687b      	ldr	r3, [r7, #4]
 8001ce0:	685b      	ldr	r3, [r3, #4]
 8001ce2:	2b00      	cmp	r3, #0
 8001ce4:	d014      	beq.n	8001d10 <HAL_RCC_OscConfig+0x410>
      {
        tickstart = HAL_GetTick();
 8001ce6:	f7ff f949 	bl	8000f7c <HAL_GetTick>
 8001cea:	62b8      	str	r0, [r7, #40]	@ 0x28

        /* Wait till HSE is ready */
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8001cec:	e009      	b.n	8001d02 <HAL_RCC_OscConfig+0x402>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8001cee:	f7ff f945 	bl	8000f7c <HAL_GetTick>
 8001cf2:	4602      	mov	r2, r0
 8001cf4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8001cf6:	1ad3      	subs	r3, r2, r3
 8001cf8:	2b64      	cmp	r3, #100	@ 0x64
 8001cfa:	d902      	bls.n	8001d02 <HAL_RCC_OscConfig+0x402>
          {
            return HAL_TIMEOUT;
 8001cfc:	2303      	movs	r3, #3
 8001cfe:	f000 bcd4 	b.w	80026aa <HAL_RCC_OscConfig+0xdaa>
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8001d02:	4b3c      	ldr	r3, [pc, #240]	@ (8001df4 <HAL_RCC_OscConfig+0x4f4>)
 8001d04:	681b      	ldr	r3, [r3, #0]
 8001d06:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8001d0a:	2b00      	cmp	r3, #0
 8001d0c:	d0ef      	beq.n	8001cee <HAL_RCC_OscConfig+0x3ee>
 8001d0e:	e013      	b.n	8001d38 <HAL_RCC_OscConfig+0x438>
          }
        }
      }
      else
      {
        tickstart = HAL_GetTick();
 8001d10:	f7ff f934 	bl	8000f7c <HAL_GetTick>
 8001d14:	62b8      	str	r0, [r7, #40]	@ 0x28

        /* Wait till HSE is disabled */
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 8001d16:	e009      	b.n	8001d2c <HAL_RCC_OscConfig+0x42c>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8001d18:	f7ff f930 	bl	8000f7c <HAL_GetTick>
 8001d1c:	4602      	mov	r2, r0
 8001d1e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8001d20:	1ad3      	subs	r3, r2, r3
 8001d22:	2b64      	cmp	r3, #100	@ 0x64
 8001d24:	d902      	bls.n	8001d2c <HAL_RCC_OscConfig+0x42c>
          {
            return HAL_TIMEOUT;
 8001d26:	2303      	movs	r3, #3
 8001d28:	f000 bcbf 	b.w	80026aa <HAL_RCC_OscConfig+0xdaa>
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 8001d2c:	4b31      	ldr	r3, [pc, #196]	@ (8001df4 <HAL_RCC_OscConfig+0x4f4>)
 8001d2e:	681b      	ldr	r3, [r3, #0]
 8001d30:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8001d34:	2b00      	cmp	r3, #0
 8001d36:	d1ef      	bne.n	8001d18 <HAL_RCC_OscConfig+0x418>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8001d38:	687b      	ldr	r3, [r7, #4]
 8001d3a:	681b      	ldr	r3, [r3, #0]
 8001d3c:	f003 0302 	and.w	r3, r3, #2
 8001d40:	2b00      	cmp	r3, #0
 8001d42:	d05f      	beq.n	8001e04 <HAL_RCC_OscConfig+0x504>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(pRCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_HSI_CALIBRATION_VALUE(pRCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI) ||
 8001d44:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8001d46:	2b04      	cmp	r3, #4
 8001d48:	d005      	beq.n	8001d56 <HAL_RCC_OscConfig+0x456>
 8001d4a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8001d4c:	2b0c      	cmp	r3, #12
 8001d4e:	d114      	bne.n	8001d7a <HAL_RCC_OscConfig+0x47a>
        ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSI)))
 8001d50:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8001d52:	2b02      	cmp	r3, #2
 8001d54:	d111      	bne.n	8001d7a <HAL_RCC_OscConfig+0x47a>
    {
      /* When HSI is used as system clock it will not be disabled */
      if (pRCC_OscInitStruct->HSIState == RCC_HSI_OFF)
 8001d56:	687b      	ldr	r3, [r7, #4]
 8001d58:	68db      	ldr	r3, [r3, #12]
 8001d5a:	2b00      	cmp	r3, #0
 8001d5c:	d102      	bne.n	8001d64 <HAL_RCC_OscConfig+0x464>
      {
        return HAL_ERROR;
 8001d5e:	2301      	movs	r3, #1
 8001d60:	f000 bca3 	b.w	80026aa <HAL_RCC_OscConfig+0xdaa>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value */
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(pRCC_OscInitStruct->HSICalibrationValue);
 8001d64:	4b23      	ldr	r3, [pc, #140]	@ (8001df4 <HAL_RCC_OscConfig+0x4f4>)
 8001d66:	691b      	ldr	r3, [r3, #16]
 8001d68:	f423 12f8 	bic.w	r2, r3, #2031616	@ 0x1f0000
 8001d6c:	687b      	ldr	r3, [r7, #4]
 8001d6e:	691b      	ldr	r3, [r3, #16]
 8001d70:	041b      	lsls	r3, r3, #16
 8001d72:	4920      	ldr	r1, [pc, #128]	@ (8001df4 <HAL_RCC_OscConfig+0x4f4>)
 8001d74:	4313      	orrs	r3, r2
 8001d76:	610b      	str	r3, [r1, #16]
      if (pRCC_OscInitStruct->HSIState == RCC_HSI_OFF)
 8001d78:	e044      	b.n	8001e04 <HAL_RCC_OscConfig+0x504>
      }
    }
    else
    {
      /* Check the HSI State */
      if (pRCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 8001d7a:	687b      	ldr	r3, [r7, #4]
 8001d7c:	68db      	ldr	r3, [r3, #12]
 8001d7e:	2b00      	cmp	r3, #0
 8001d80:	d024      	beq.n	8001dcc <HAL_RCC_OscConfig+0x4cc>
      {
        /* Enable the Internal High Speed oscillator (HSI) */
        __HAL_RCC_HSI_ENABLE();
 8001d82:	4b1c      	ldr	r3, [pc, #112]	@ (8001df4 <HAL_RCC_OscConfig+0x4f4>)
 8001d84:	681b      	ldr	r3, [r3, #0]
 8001d86:	4a1b      	ldr	r2, [pc, #108]	@ (8001df4 <HAL_RCC_OscConfig+0x4f4>)
 8001d88:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8001d8c:	6013      	str	r3, [r2, #0]

        tickstart = HAL_GetTick();
 8001d8e:	f7ff f8f5 	bl	8000f7c <HAL_GetTick>
 8001d92:	62b8      	str	r0, [r7, #40]	@ 0x28

        /* Wait till HSI is ready */
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8001d94:	e009      	b.n	8001daa <HAL_RCC_OscConfig+0x4aa>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8001d96:	f7ff f8f1 	bl	8000f7c <HAL_GetTick>
 8001d9a:	4602      	mov	r2, r0
 8001d9c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8001d9e:	1ad3      	subs	r3, r2, r3
 8001da0:	2b02      	cmp	r3, #2
 8001da2:	d902      	bls.n	8001daa <HAL_RCC_OscConfig+0x4aa>
          {
            return HAL_TIMEOUT;
 8001da4:	2303      	movs	r3, #3
 8001da6:	f000 bc80 	b.w	80026aa <HAL_RCC_OscConfig+0xdaa>
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8001daa:	4b12      	ldr	r3, [pc, #72]	@ (8001df4 <HAL_RCC_OscConfig+0x4f4>)
 8001dac:	681b      	ldr	r3, [r3, #0]
 8001dae:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8001db2:	2b00      	cmp	r3, #0
 8001db4:	d0ef      	beq.n	8001d96 <HAL_RCC_OscConfig+0x496>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value */
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(pRCC_OscInitStruct->HSICalibrationValue);
 8001db6:	4b0f      	ldr	r3, [pc, #60]	@ (8001df4 <HAL_RCC_OscConfig+0x4f4>)
 8001db8:	691b      	ldr	r3, [r3, #16]
 8001dba:	f423 12f8 	bic.w	r2, r3, #2031616	@ 0x1f0000
 8001dbe:	687b      	ldr	r3, [r7, #4]
 8001dc0:	691b      	ldr	r3, [r3, #16]
 8001dc2:	041b      	lsls	r3, r3, #16
 8001dc4:	490b      	ldr	r1, [pc, #44]	@ (8001df4 <HAL_RCC_OscConfig+0x4f4>)
 8001dc6:	4313      	orrs	r3, r2
 8001dc8:	610b      	str	r3, [r1, #16]
 8001dca:	e01b      	b.n	8001e04 <HAL_RCC_OscConfig+0x504>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI) */
        __HAL_RCC_HSI_DISABLE();
 8001dcc:	4b09      	ldr	r3, [pc, #36]	@ (8001df4 <HAL_RCC_OscConfig+0x4f4>)
 8001dce:	681b      	ldr	r3, [r3, #0]
 8001dd0:	4a08      	ldr	r2, [pc, #32]	@ (8001df4 <HAL_RCC_OscConfig+0x4f4>)
 8001dd2:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 8001dd6:	6013      	str	r3, [r2, #0]

        tickstart = HAL_GetTick();
 8001dd8:	f7ff f8d0 	bl	8000f7c <HAL_GetTick>
 8001ddc:	62b8      	str	r0, [r7, #40]	@ 0x28

        /* Wait till HSI is disabled */
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 8001dde:	e00b      	b.n	8001df8 <HAL_RCC_OscConfig+0x4f8>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8001de0:	f7ff f8cc 	bl	8000f7c <HAL_GetTick>
 8001de4:	4602      	mov	r2, r0
 8001de6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8001de8:	1ad3      	subs	r3, r2, r3
 8001dea:	2b02      	cmp	r3, #2
 8001dec:	d904      	bls.n	8001df8 <HAL_RCC_OscConfig+0x4f8>
          {
            return HAL_TIMEOUT;
 8001dee:	2303      	movs	r3, #3
 8001df0:	f000 bc5b 	b.w	80026aa <HAL_RCC_OscConfig+0xdaa>
 8001df4:	46020c00 	.word	0x46020c00
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 8001df8:	4baf      	ldr	r3, [pc, #700]	@ (80020b8 <HAL_RCC_OscConfig+0x7b8>)
 8001dfa:	681b      	ldr	r3, [r3, #0]
 8001dfc:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8001e00:	2b00      	cmp	r3, #0
 8001e02:	d1ed      	bne.n	8001de0 <HAL_RCC_OscConfig+0x4e0>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8001e04:	687b      	ldr	r3, [r7, #4]
 8001e06:	681b      	ldr	r3, [r3, #0]
 8001e08:	f003 0308 	and.w	r3, r3, #8
 8001e0c:	2b00      	cmp	r3, #0
 8001e0e:	f000 80c8 	beq.w	8001fa2 <HAL_RCC_OscConfig+0x6a2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(pRCC_OscInitStruct->LSIState));

    FlagStatus  pwrclkchanged = RESET;
 8001e12:	2300      	movs	r3, #0
 8001e14:	f887 3036 	strb.w	r3, [r7, #54]	@ 0x36

    /* Update LSI configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 8001e18:	4ba7      	ldr	r3, [pc, #668]	@ (80020b8 <HAL_RCC_OscConfig+0x7b8>)
 8001e1a:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8001e1e:	f003 0304 	and.w	r3, r3, #4
 8001e22:	2b00      	cmp	r3, #0
 8001e24:	d111      	bne.n	8001e4a <HAL_RCC_OscConfig+0x54a>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8001e26:	4ba4      	ldr	r3, [pc, #656]	@ (80020b8 <HAL_RCC_OscConfig+0x7b8>)
 8001e28:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8001e2c:	4aa2      	ldr	r2, [pc, #648]	@ (80020b8 <HAL_RCC_OscConfig+0x7b8>)
 8001e2e:	f043 0304 	orr.w	r3, r3, #4
 8001e32:	f8c2 3094 	str.w	r3, [r2, #148]	@ 0x94
 8001e36:	4ba0      	ldr	r3, [pc, #640]	@ (80020b8 <HAL_RCC_OscConfig+0x7b8>)
 8001e38:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8001e3c:	f003 0304 	and.w	r3, r3, #4
 8001e40:	617b      	str	r3, [r7, #20]
 8001e42:	697b      	ldr	r3, [r7, #20]
      pwrclkchanged = SET;
 8001e44:	2301      	movs	r3, #1
 8001e46:	f887 3036 	strb.w	r3, [r7, #54]	@ 0x36
    }

    if (HAL_IS_BIT_CLR(PWR->DBPR, PWR_DBPR_DBP))
 8001e4a:	4b9c      	ldr	r3, [pc, #624]	@ (80020bc <HAL_RCC_OscConfig+0x7bc>)
 8001e4c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001e4e:	f003 0301 	and.w	r3, r3, #1
 8001e52:	2b00      	cmp	r3, #0
 8001e54:	d119      	bne.n	8001e8a <HAL_RCC_OscConfig+0x58a>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->DBPR, PWR_DBPR_DBP);
 8001e56:	4b99      	ldr	r3, [pc, #612]	@ (80020bc <HAL_RCC_OscConfig+0x7bc>)
 8001e58:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001e5a:	4a98      	ldr	r2, [pc, #608]	@ (80020bc <HAL_RCC_OscConfig+0x7bc>)
 8001e5c:	f043 0301 	orr.w	r3, r3, #1
 8001e60:	6293      	str	r3, [r2, #40]	@ 0x28

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 8001e62:	f7ff f88b 	bl	8000f7c <HAL_GetTick>
 8001e66:	62b8      	str	r0, [r7, #40]	@ 0x28

      while (HAL_IS_BIT_CLR(PWR->DBPR, PWR_DBPR_DBP))
 8001e68:	e009      	b.n	8001e7e <HAL_RCC_OscConfig+0x57e>
      {
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8001e6a:	f7ff f887 	bl	8000f7c <HAL_GetTick>
 8001e6e:	4602      	mov	r2, r0
 8001e70:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8001e72:	1ad3      	subs	r3, r2, r3
 8001e74:	2b02      	cmp	r3, #2
 8001e76:	d902      	bls.n	8001e7e <HAL_RCC_OscConfig+0x57e>
        {
          return HAL_TIMEOUT;
 8001e78:	2303      	movs	r3, #3
 8001e7a:	f000 bc16 	b.w	80026aa <HAL_RCC_OscConfig+0xdaa>
      while (HAL_IS_BIT_CLR(PWR->DBPR, PWR_DBPR_DBP))
 8001e7e:	4b8f      	ldr	r3, [pc, #572]	@ (80020bc <HAL_RCC_OscConfig+0x7bc>)
 8001e80:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001e82:	f003 0301 	and.w	r3, r3, #1
 8001e86:	2b00      	cmp	r3, #0
 8001e88:	d0ef      	beq.n	8001e6a <HAL_RCC_OscConfig+0x56a>
        }
      }
    }
    /* Check the LSI State */
    if (pRCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8001e8a:	687b      	ldr	r3, [r7, #4]
 8001e8c:	695b      	ldr	r3, [r3, #20]
 8001e8e:	2b00      	cmp	r3, #0
 8001e90:	d05f      	beq.n	8001f52 <HAL_RCC_OscConfig+0x652>
    {
      uint32_t bdcr_temp = RCC->BDCR;
 8001e92:	4b89      	ldr	r3, [pc, #548]	@ (80020b8 <HAL_RCC_OscConfig+0x7b8>)
 8001e94:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8001e98:	623b      	str	r3, [r7, #32]

      /* Check LSI division factor */
      assert_param(IS_RCC_LSIDIV(pRCC_OscInitStruct->LSIDiv));

      if (pRCC_OscInitStruct->LSIDiv != (bdcr_temp & RCC_BDCR_LSIPREDIV))
 8001e9a:	687b      	ldr	r3, [r7, #4]
 8001e9c:	699a      	ldr	r2, [r3, #24]
 8001e9e:	6a3b      	ldr	r3, [r7, #32]
 8001ea0:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 8001ea4:	429a      	cmp	r2, r3
 8001ea6:	d037      	beq.n	8001f18 <HAL_RCC_OscConfig+0x618>
      {
        if (((bdcr_temp & RCC_BDCR_LSIRDY) == RCC_BDCR_LSIRDY) && \
 8001ea8:	6a3b      	ldr	r3, [r7, #32]
 8001eaa:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8001eae:	2b00      	cmp	r3, #0
 8001eb0:	d006      	beq.n	8001ec0 <HAL_RCC_OscConfig+0x5c0>
            ((bdcr_temp & RCC_BDCR_LSION) != RCC_BDCR_LSION))
 8001eb2:	6a3b      	ldr	r3, [r7, #32]
 8001eb4:	f003 6380 	and.w	r3, r3, #67108864	@ 0x4000000
        if (((bdcr_temp & RCC_BDCR_LSIRDY) == RCC_BDCR_LSIRDY) && \
 8001eb8:	2b00      	cmp	r3, #0
 8001eba:	d101      	bne.n	8001ec0 <HAL_RCC_OscConfig+0x5c0>
        {
          /* If LSIRDY is set while LSION is not enabled, LSIPREDIV can't be updated */
          /* The LSIPREDIV cannot be changed if the LSI is used by the IWDG or by the RTC */
          return HAL_ERROR;
 8001ebc:	2301      	movs	r3, #1
 8001ebe:	e3f4      	b.n	80026aa <HAL_RCC_OscConfig+0xdaa>
        }

        /* Turn off LSI before changing RCC_BDCR_LSIPREDIV */
        if ((bdcr_temp & RCC_BDCR_LSION) == RCC_BDCR_LSION)
 8001ec0:	6a3b      	ldr	r3, [r7, #32]
 8001ec2:	f003 6380 	and.w	r3, r3, #67108864	@ 0x4000000
 8001ec6:	2b00      	cmp	r3, #0
 8001ec8:	d01b      	beq.n	8001f02 <HAL_RCC_OscConfig+0x602>
        {
          __HAL_RCC_LSI_DISABLE();
 8001eca:	4b7b      	ldr	r3, [pc, #492]	@ (80020b8 <HAL_RCC_OscConfig+0x7b8>)
 8001ecc:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8001ed0:	4a79      	ldr	r2, [pc, #484]	@ (80020b8 <HAL_RCC_OscConfig+0x7b8>)
 8001ed2:	f023 53a0 	bic.w	r3, r3, #335544320	@ 0x14000000
 8001ed6:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0

          tickstart = HAL_GetTick();
 8001eda:	f7ff f84f 	bl	8000f7c <HAL_GetTick>
 8001ede:	62b8      	str	r0, [r7, #40]	@ 0x28

          /* Wait till LSI is disabled */
          while (READ_BIT(RCC->BDCR, RCC_BDCR_LSIRDY) != 0U)
 8001ee0:	e008      	b.n	8001ef4 <HAL_RCC_OscConfig+0x5f4>
          {
            if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8001ee2:	f7ff f84b 	bl	8000f7c <HAL_GetTick>
 8001ee6:	4602      	mov	r2, r0
 8001ee8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8001eea:	1ad3      	subs	r3, r2, r3
 8001eec:	2b05      	cmp	r3, #5
 8001eee:	d901      	bls.n	8001ef4 <HAL_RCC_OscConfig+0x5f4>
            {
              return HAL_TIMEOUT;
 8001ef0:	2303      	movs	r3, #3
 8001ef2:	e3da      	b.n	80026aa <HAL_RCC_OscConfig+0xdaa>
          while (READ_BIT(RCC->BDCR, RCC_BDCR_LSIRDY) != 0U)
 8001ef4:	4b70      	ldr	r3, [pc, #448]	@ (80020b8 <HAL_RCC_OscConfig+0x7b8>)
 8001ef6:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8001efa:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8001efe:	2b00      	cmp	r3, #0
 8001f00:	d1ef      	bne.n	8001ee2 <HAL_RCC_OscConfig+0x5e2>
            }
          }
        }

        /* Set LSI division factor */
        MODIFY_REG(RCC->BDCR, RCC_BDCR_LSIPREDIV, pRCC_OscInitStruct->LSIDiv);
 8001f02:	4b6d      	ldr	r3, [pc, #436]	@ (80020b8 <HAL_RCC_OscConfig+0x7b8>)
 8001f04:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8001f08:	f023 5280 	bic.w	r2, r3, #268435456	@ 0x10000000
 8001f0c:	687b      	ldr	r3, [r7, #4]
 8001f0e:	699b      	ldr	r3, [r3, #24]
 8001f10:	4969      	ldr	r1, [pc, #420]	@ (80020b8 <HAL_RCC_OscConfig+0x7b8>)
 8001f12:	4313      	orrs	r3, r2
 8001f14:	f8c1 30f0 	str.w	r3, [r1, #240]	@ 0xf0
      }

      /* Enable the Internal Low Speed oscillator (LSI) */
      __HAL_RCC_LSI_ENABLE();
 8001f18:	4b67      	ldr	r3, [pc, #412]	@ (80020b8 <HAL_RCC_OscConfig+0x7b8>)
 8001f1a:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8001f1e:	4a66      	ldr	r2, [pc, #408]	@ (80020b8 <HAL_RCC_OscConfig+0x7b8>)
 8001f20:	f043 6380 	orr.w	r3, r3, #67108864	@ 0x4000000
 8001f24:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0

      tickstart = HAL_GetTick();
 8001f28:	f7ff f828 	bl	8000f7c <HAL_GetTick>
 8001f2c:	62b8      	str	r0, [r7, #40]	@ 0x28

      /* Wait till LSI is ready */
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSIRDY) == 0U)
 8001f2e:	e008      	b.n	8001f42 <HAL_RCC_OscConfig+0x642>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8001f30:	f7ff f824 	bl	8000f7c <HAL_GetTick>
 8001f34:	4602      	mov	r2, r0
 8001f36:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8001f38:	1ad3      	subs	r3, r2, r3
 8001f3a:	2b05      	cmp	r3, #5
 8001f3c:	d901      	bls.n	8001f42 <HAL_RCC_OscConfig+0x642>
        {
          return HAL_TIMEOUT;
 8001f3e:	2303      	movs	r3, #3
 8001f40:	e3b3      	b.n	80026aa <HAL_RCC_OscConfig+0xdaa>
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSIRDY) == 0U)
 8001f42:	4b5d      	ldr	r3, [pc, #372]	@ (80020b8 <HAL_RCC_OscConfig+0x7b8>)
 8001f44:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8001f48:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8001f4c:	2b00      	cmp	r3, #0
 8001f4e:	d0ef      	beq.n	8001f30 <HAL_RCC_OscConfig+0x630>
 8001f50:	e01b      	b.n	8001f8a <HAL_RCC_OscConfig+0x68a>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI) */
      __HAL_RCC_LSI_DISABLE();
 8001f52:	4b59      	ldr	r3, [pc, #356]	@ (80020b8 <HAL_RCC_OscConfig+0x7b8>)
 8001f54:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8001f58:	4a57      	ldr	r2, [pc, #348]	@ (80020b8 <HAL_RCC_OscConfig+0x7b8>)
 8001f5a:	f023 53a0 	bic.w	r3, r3, #335544320	@ 0x14000000
 8001f5e:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0

      tickstart = HAL_GetTick();
 8001f62:	f7ff f80b 	bl	8000f7c <HAL_GetTick>
 8001f66:	62b8      	str	r0, [r7, #40]	@ 0x28

      /* Wait till LSI is disabled */
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSIRDY) != 0U)
 8001f68:	e008      	b.n	8001f7c <HAL_RCC_OscConfig+0x67c>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8001f6a:	f7ff f807 	bl	8000f7c <HAL_GetTick>
 8001f6e:	4602      	mov	r2, r0
 8001f70:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8001f72:	1ad3      	subs	r3, r2, r3
 8001f74:	2b05      	cmp	r3, #5
 8001f76:	d901      	bls.n	8001f7c <HAL_RCC_OscConfig+0x67c>
        {
          return HAL_TIMEOUT;
 8001f78:	2303      	movs	r3, #3
 8001f7a:	e396      	b.n	80026aa <HAL_RCC_OscConfig+0xdaa>
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSIRDY) != 0U)
 8001f7c:	4b4e      	ldr	r3, [pc, #312]	@ (80020b8 <HAL_RCC_OscConfig+0x7b8>)
 8001f7e:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8001f82:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8001f86:	2b00      	cmp	r3, #0
 8001f88:	d1ef      	bne.n	8001f6a <HAL_RCC_OscConfig+0x66a>
        }
      }
    }
    /* Restore clock configuration if changed */
    if (pwrclkchanged == SET)
 8001f8a:	f897 3036 	ldrb.w	r3, [r7, #54]	@ 0x36
 8001f8e:	2b01      	cmp	r3, #1
 8001f90:	d107      	bne.n	8001fa2 <HAL_RCC_OscConfig+0x6a2>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8001f92:	4b49      	ldr	r3, [pc, #292]	@ (80020b8 <HAL_RCC_OscConfig+0x7b8>)
 8001f94:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8001f98:	4a47      	ldr	r2, [pc, #284]	@ (80020b8 <HAL_RCC_OscConfig+0x7b8>)
 8001f9a:	f023 0304 	bic.w	r3, r3, #4
 8001f9e:	f8c2 3094 	str.w	r3, [r2, #148]	@ 0x94
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8001fa2:	687b      	ldr	r3, [r7, #4]
 8001fa4:	681b      	ldr	r3, [r3, #0]
 8001fa6:	f003 0304 	and.w	r3, r3, #4
 8001faa:	2b00      	cmp	r3, #0
 8001fac:	f000 8111 	beq.w	80021d2 <HAL_RCC_OscConfig+0x8d2>
  {
    FlagStatus pwrclkchanged = RESET;
 8001fb0:	2300      	movs	r3, #0
 8001fb2:	f887 3035 	strb.w	r3, [r7, #53]	@ 0x35
    /* Check the parameters */
    assert_param(IS_RCC_LSE(pRCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 8001fb6:	4b40      	ldr	r3, [pc, #256]	@ (80020b8 <HAL_RCC_OscConfig+0x7b8>)
 8001fb8:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8001fbc:	f003 0304 	and.w	r3, r3, #4
 8001fc0:	2b00      	cmp	r3, #0
 8001fc2:	d111      	bne.n	8001fe8 <HAL_RCC_OscConfig+0x6e8>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8001fc4:	4b3c      	ldr	r3, [pc, #240]	@ (80020b8 <HAL_RCC_OscConfig+0x7b8>)
 8001fc6:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8001fca:	4a3b      	ldr	r2, [pc, #236]	@ (80020b8 <HAL_RCC_OscConfig+0x7b8>)
 8001fcc:	f043 0304 	orr.w	r3, r3, #4
 8001fd0:	f8c2 3094 	str.w	r3, [r2, #148]	@ 0x94
 8001fd4:	4b38      	ldr	r3, [pc, #224]	@ (80020b8 <HAL_RCC_OscConfig+0x7b8>)
 8001fd6:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8001fda:	f003 0304 	and.w	r3, r3, #4
 8001fde:	613b      	str	r3, [r7, #16]
 8001fe0:	693b      	ldr	r3, [r7, #16]
      pwrclkchanged = SET;
 8001fe2:	2301      	movs	r3, #1
 8001fe4:	f887 3035 	strb.w	r3, [r7, #53]	@ 0x35
    }

    if (HAL_IS_BIT_CLR(PWR->DBPR, PWR_DBPR_DBP))
 8001fe8:	4b34      	ldr	r3, [pc, #208]	@ (80020bc <HAL_RCC_OscConfig+0x7bc>)
 8001fea:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001fec:	f003 0301 	and.w	r3, r3, #1
 8001ff0:	2b00      	cmp	r3, #0
 8001ff2:	d118      	bne.n	8002026 <HAL_RCC_OscConfig+0x726>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->DBPR, PWR_DBPR_DBP);
 8001ff4:	4b31      	ldr	r3, [pc, #196]	@ (80020bc <HAL_RCC_OscConfig+0x7bc>)
 8001ff6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001ff8:	4a30      	ldr	r2, [pc, #192]	@ (80020bc <HAL_RCC_OscConfig+0x7bc>)
 8001ffa:	f043 0301 	orr.w	r3, r3, #1
 8001ffe:	6293      	str	r3, [r2, #40]	@ 0x28

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 8002000:	f7fe ffbc 	bl	8000f7c <HAL_GetTick>
 8002004:	62b8      	str	r0, [r7, #40]	@ 0x28

      while (HAL_IS_BIT_CLR(PWR->DBPR, PWR_DBPR_DBP))
 8002006:	e008      	b.n	800201a <HAL_RCC_OscConfig+0x71a>
      {
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8002008:	f7fe ffb8 	bl	8000f7c <HAL_GetTick>
 800200c:	4602      	mov	r2, r0
 800200e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8002010:	1ad3      	subs	r3, r2, r3
 8002012:	2b02      	cmp	r3, #2
 8002014:	d901      	bls.n	800201a <HAL_RCC_OscConfig+0x71a>
        {
          return HAL_TIMEOUT;
 8002016:	2303      	movs	r3, #3
 8002018:	e347      	b.n	80026aa <HAL_RCC_OscConfig+0xdaa>
      while (HAL_IS_BIT_CLR(PWR->DBPR, PWR_DBPR_DBP))
 800201a:	4b28      	ldr	r3, [pc, #160]	@ (80020bc <HAL_RCC_OscConfig+0x7bc>)
 800201c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800201e:	f003 0301 	and.w	r3, r3, #1
 8002022:	2b00      	cmp	r3, #0
 8002024:	d0f0      	beq.n	8002008 <HAL_RCC_OscConfig+0x708>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    if ((pRCC_OscInitStruct->LSEState & RCC_BDCR_LSEON) != 0U)
 8002026:	687b      	ldr	r3, [r7, #4]
 8002028:	689b      	ldr	r3, [r3, #8]
 800202a:	f003 0301 	and.w	r3, r3, #1
 800202e:	2b00      	cmp	r3, #0
 8002030:	d01f      	beq.n	8002072 <HAL_RCC_OscConfig+0x772>
    {
      if ((pRCC_OscInitStruct->LSEState & RCC_BDCR_LSEBYP) != 0U)
 8002032:	687b      	ldr	r3, [r7, #4]
 8002034:	689b      	ldr	r3, [r3, #8]
 8002036:	f003 0304 	and.w	r3, r3, #4
 800203a:	2b00      	cmp	r3, #0
 800203c:	d010      	beq.n	8002060 <HAL_RCC_OscConfig+0x760>
      {
        /* LSE oscillator bypass enable */
        SET_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
 800203e:	4b1e      	ldr	r3, [pc, #120]	@ (80020b8 <HAL_RCC_OscConfig+0x7b8>)
 8002040:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8002044:	4a1c      	ldr	r2, [pc, #112]	@ (80020b8 <HAL_RCC_OscConfig+0x7b8>)
 8002046:	f043 0304 	orr.w	r3, r3, #4
 800204a:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
        SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 800204e:	4b1a      	ldr	r3, [pc, #104]	@ (80020b8 <HAL_RCC_OscConfig+0x7b8>)
 8002050:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8002054:	4a18      	ldr	r2, [pc, #96]	@ (80020b8 <HAL_RCC_OscConfig+0x7b8>)
 8002056:	f043 0301 	orr.w	r3, r3, #1
 800205a:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
 800205e:	e018      	b.n	8002092 <HAL_RCC_OscConfig+0x792>
      }
      else
      {
        /* LSE oscillator enable */
        SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 8002060:	4b15      	ldr	r3, [pc, #84]	@ (80020b8 <HAL_RCC_OscConfig+0x7b8>)
 8002062:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8002066:	4a14      	ldr	r2, [pc, #80]	@ (80020b8 <HAL_RCC_OscConfig+0x7b8>)
 8002068:	f043 0301 	orr.w	r3, r3, #1
 800206c:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
 8002070:	e00f      	b.n	8002092 <HAL_RCC_OscConfig+0x792>
      }
    }
    else
    {
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 8002072:	4b11      	ldr	r3, [pc, #68]	@ (80020b8 <HAL_RCC_OscConfig+0x7b8>)
 8002074:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8002078:	4a0f      	ldr	r2, [pc, #60]	@ (80020b8 <HAL_RCC_OscConfig+0x7b8>)
 800207a:	f023 0301 	bic.w	r3, r3, #1
 800207e:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
 8002082:	4b0d      	ldr	r3, [pc, #52]	@ (80020b8 <HAL_RCC_OscConfig+0x7b8>)
 8002084:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8002088:	4a0b      	ldr	r2, [pc, #44]	@ (80020b8 <HAL_RCC_OscConfig+0x7b8>)
 800208a:	f023 0304 	bic.w	r3, r3, #4
 800208e:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
    }

    /* Check the LSE State */
    if (pRCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 8002092:	687b      	ldr	r3, [r7, #4]
 8002094:	689b      	ldr	r3, [r3, #8]
 8002096:	2b00      	cmp	r3, #0
 8002098:	d057      	beq.n	800214a <HAL_RCC_OscConfig+0x84a>
    {
      tickstart = HAL_GetTick();
 800209a:	f7fe ff6f 	bl	8000f7c <HAL_GetTick>
 800209e:	62b8      	str	r0, [r7, #40]	@ 0x28

      /* Wait till LSE is ready */
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 80020a0:	e00e      	b.n	80020c0 <HAL_RCC_OscConfig+0x7c0>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80020a2:	f7fe ff6b 	bl	8000f7c <HAL_GetTick>
 80020a6:	4602      	mov	r2, r0
 80020a8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80020aa:	1ad3      	subs	r3, r2, r3
 80020ac:	f241 3288 	movw	r2, #5000	@ 0x1388
 80020b0:	4293      	cmp	r3, r2
 80020b2:	d905      	bls.n	80020c0 <HAL_RCC_OscConfig+0x7c0>
        {
          return HAL_TIMEOUT;
 80020b4:	2303      	movs	r3, #3
 80020b6:	e2f8      	b.n	80026aa <HAL_RCC_OscConfig+0xdaa>
 80020b8:	46020c00 	.word	0x46020c00
 80020bc:	46020800 	.word	0x46020800
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 80020c0:	4b9c      	ldr	r3, [pc, #624]	@ (8002334 <HAL_RCC_OscConfig+0xa34>)
 80020c2:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 80020c6:	f003 0302 	and.w	r3, r3, #2
 80020ca:	2b00      	cmp	r3, #0
 80020cc:	d0e9      	beq.n	80020a2 <HAL_RCC_OscConfig+0x7a2>
        }
      }

      /* Enable LSESYS additionally if requested */
      if ((pRCC_OscInitStruct->LSEState & RCC_BDCR_LSESYSEN) != 0U)
 80020ce:	687b      	ldr	r3, [r7, #4]
 80020d0:	689b      	ldr	r3, [r3, #8]
 80020d2:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 80020d6:	2b00      	cmp	r3, #0
 80020d8:	d01b      	beq.n	8002112 <HAL_RCC_OscConfig+0x812>
      {
        SET_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 80020da:	4b96      	ldr	r3, [pc, #600]	@ (8002334 <HAL_RCC_OscConfig+0xa34>)
 80020dc:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 80020e0:	4a94      	ldr	r2, [pc, #592]	@ (8002334 <HAL_RCC_OscConfig+0xa34>)
 80020e2:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 80020e6:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0

        /* Wait till LSESYS is ready */
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) == 0U)
 80020ea:	e00a      	b.n	8002102 <HAL_RCC_OscConfig+0x802>
        {
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80020ec:	f7fe ff46 	bl	8000f7c <HAL_GetTick>
 80020f0:	4602      	mov	r2, r0
 80020f2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80020f4:	1ad3      	subs	r3, r2, r3
 80020f6:	f241 3288 	movw	r2, #5000	@ 0x1388
 80020fa:	4293      	cmp	r3, r2
 80020fc:	d901      	bls.n	8002102 <HAL_RCC_OscConfig+0x802>
          {
            return HAL_TIMEOUT;
 80020fe:	2303      	movs	r3, #3
 8002100:	e2d3      	b.n	80026aa <HAL_RCC_OscConfig+0xdaa>
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) == 0U)
 8002102:	4b8c      	ldr	r3, [pc, #560]	@ (8002334 <HAL_RCC_OscConfig+0xa34>)
 8002104:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8002108:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 800210c:	2b00      	cmp	r3, #0
 800210e:	d0ed      	beq.n	80020ec <HAL_RCC_OscConfig+0x7ec>
 8002110:	e053      	b.n	80021ba <HAL_RCC_OscConfig+0x8ba>
        }
      }
      else
      {
        /* Make sure LSESYSEN/LSESYSRDY are reset */
        CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 8002112:	4b88      	ldr	r3, [pc, #544]	@ (8002334 <HAL_RCC_OscConfig+0xa34>)
 8002114:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8002118:	4a86      	ldr	r2, [pc, #536]	@ (8002334 <HAL_RCC_OscConfig+0xa34>)
 800211a:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 800211e:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0

        /* Wait till LSESYSRDY is cleared */
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 8002122:	e00a      	b.n	800213a <HAL_RCC_OscConfig+0x83a>
        {
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8002124:	f7fe ff2a 	bl	8000f7c <HAL_GetTick>
 8002128:	4602      	mov	r2, r0
 800212a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800212c:	1ad3      	subs	r3, r2, r3
 800212e:	f241 3288 	movw	r2, #5000	@ 0x1388
 8002132:	4293      	cmp	r3, r2
 8002134:	d901      	bls.n	800213a <HAL_RCC_OscConfig+0x83a>
          {
            return HAL_TIMEOUT;
 8002136:	2303      	movs	r3, #3
 8002138:	e2b7      	b.n	80026aa <HAL_RCC_OscConfig+0xdaa>
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 800213a:	4b7e      	ldr	r3, [pc, #504]	@ (8002334 <HAL_RCC_OscConfig+0xa34>)
 800213c:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8002140:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 8002144:	2b00      	cmp	r3, #0
 8002146:	d1ed      	bne.n	8002124 <HAL_RCC_OscConfig+0x824>
 8002148:	e037      	b.n	80021ba <HAL_RCC_OscConfig+0x8ba>
        }
      }
    }
    else
    {
      tickstart = HAL_GetTick();
 800214a:	f7fe ff17 	bl	8000f7c <HAL_GetTick>
 800214e:	62b8      	str	r0, [r7, #40]	@ 0x28

      /* Wait till LSE is disabled */
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
 8002150:	e00a      	b.n	8002168 <HAL_RCC_OscConfig+0x868>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8002152:	f7fe ff13 	bl	8000f7c <HAL_GetTick>
 8002156:	4602      	mov	r2, r0
 8002158:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800215a:	1ad3      	subs	r3, r2, r3
 800215c:	f241 3288 	movw	r2, #5000	@ 0x1388
 8002160:	4293      	cmp	r3, r2
 8002162:	d901      	bls.n	8002168 <HAL_RCC_OscConfig+0x868>
        {
          return HAL_TIMEOUT;
 8002164:	2303      	movs	r3, #3
 8002166:	e2a0      	b.n	80026aa <HAL_RCC_OscConfig+0xdaa>
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
 8002168:	4b72      	ldr	r3, [pc, #456]	@ (8002334 <HAL_RCC_OscConfig+0xa34>)
 800216a:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 800216e:	f003 0302 	and.w	r3, r3, #2
 8002172:	2b00      	cmp	r3, #0
 8002174:	d1ed      	bne.n	8002152 <HAL_RCC_OscConfig+0x852>
        }
      }

      if (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN) != 0U)
 8002176:	4b6f      	ldr	r3, [pc, #444]	@ (8002334 <HAL_RCC_OscConfig+0xa34>)
 8002178:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 800217c:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8002180:	2b00      	cmp	r3, #0
 8002182:	d01a      	beq.n	80021ba <HAL_RCC_OscConfig+0x8ba>
      {
        /* Reset LSESYSEN once LSE is disabled */
        CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 8002184:	4b6b      	ldr	r3, [pc, #428]	@ (8002334 <HAL_RCC_OscConfig+0xa34>)
 8002186:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 800218a:	4a6a      	ldr	r2, [pc, #424]	@ (8002334 <HAL_RCC_OscConfig+0xa34>)
 800218c:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 8002190:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0

        /* Wait till LSESYSRDY is cleared */
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 8002194:	e00a      	b.n	80021ac <HAL_RCC_OscConfig+0x8ac>
        {
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8002196:	f7fe fef1 	bl	8000f7c <HAL_GetTick>
 800219a:	4602      	mov	r2, r0
 800219c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800219e:	1ad3      	subs	r3, r2, r3
 80021a0:	f241 3288 	movw	r2, #5000	@ 0x1388
 80021a4:	4293      	cmp	r3, r2
 80021a6:	d901      	bls.n	80021ac <HAL_RCC_OscConfig+0x8ac>
          {
            return HAL_TIMEOUT;
 80021a8:	2303      	movs	r3, #3
 80021aa:	e27e      	b.n	80026aa <HAL_RCC_OscConfig+0xdaa>
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 80021ac:	4b61      	ldr	r3, [pc, #388]	@ (8002334 <HAL_RCC_OscConfig+0xa34>)
 80021ae:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 80021b2:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 80021b6:	2b00      	cmp	r3, #0
 80021b8:	d1ed      	bne.n	8002196 <HAL_RCC_OscConfig+0x896>
        }
      }
    }

    /* Restore clock configuration if changed */
    if (pwrclkchanged == SET)
 80021ba:	f897 3035 	ldrb.w	r3, [r7, #53]	@ 0x35
 80021be:	2b01      	cmp	r3, #1
 80021c0:	d107      	bne.n	80021d2 <HAL_RCC_OscConfig+0x8d2>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 80021c2:	4b5c      	ldr	r3, [pc, #368]	@ (8002334 <HAL_RCC_OscConfig+0xa34>)
 80021c4:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 80021c8:	4a5a      	ldr	r2, [pc, #360]	@ (8002334 <HAL_RCC_OscConfig+0xa34>)
 80021ca:	f023 0304 	bic.w	r3, r3, #4
 80021ce:	f8c2 3094 	str.w	r3, [r2, #148]	@ 0x94
    }
  }
  /*------------------------------ HSI48 Configuration -----------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 80021d2:	687b      	ldr	r3, [r7, #4]
 80021d4:	681b      	ldr	r3, [r3, #0]
 80021d6:	f003 0320 	and.w	r3, r3, #32
 80021da:	2b00      	cmp	r3, #0
 80021dc:	d036      	beq.n	800224c <HAL_RCC_OscConfig+0x94c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI48(pRCC_OscInitStruct->HSI48State));

    /* Check the HSI48 State */
    if (pRCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 80021de:	687b      	ldr	r3, [r7, #4]
 80021e0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80021e2:	2b00      	cmp	r3, #0
 80021e4:	d019      	beq.n	800221a <HAL_RCC_OscConfig+0x91a>
    {
      /* Enable the Internal High Speed oscillator (HSI48) */
      __HAL_RCC_HSI48_ENABLE();
 80021e6:	4b53      	ldr	r3, [pc, #332]	@ (8002334 <HAL_RCC_OscConfig+0xa34>)
 80021e8:	681b      	ldr	r3, [r3, #0]
 80021ea:	4a52      	ldr	r2, [pc, #328]	@ (8002334 <HAL_RCC_OscConfig+0xa34>)
 80021ec:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
 80021f0:	6013      	str	r3, [r2, #0]

      tickstart = HAL_GetTick();
 80021f2:	f7fe fec3 	bl	8000f7c <HAL_GetTick>
 80021f6:	62b8      	str	r0, [r7, #40]	@ 0x28

      /* Wait till HSI48 is ready */
      while (READ_BIT(RCC->CR, RCC_CR_HSI48RDY) == 0U)
 80021f8:	e008      	b.n	800220c <HAL_RCC_OscConfig+0x90c>
      {
        if ((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 80021fa:	f7fe febf 	bl	8000f7c <HAL_GetTick>
 80021fe:	4602      	mov	r2, r0
 8002200:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8002202:	1ad3      	subs	r3, r2, r3
 8002204:	2b02      	cmp	r3, #2
 8002206:	d901      	bls.n	800220c <HAL_RCC_OscConfig+0x90c>
        {
          return HAL_TIMEOUT;
 8002208:	2303      	movs	r3, #3
 800220a:	e24e      	b.n	80026aa <HAL_RCC_OscConfig+0xdaa>
      while (READ_BIT(RCC->CR, RCC_CR_HSI48RDY) == 0U)
 800220c:	4b49      	ldr	r3, [pc, #292]	@ (8002334 <HAL_RCC_OscConfig+0xa34>)
 800220e:	681b      	ldr	r3, [r3, #0]
 8002210:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 8002214:	2b00      	cmp	r3, #0
 8002216:	d0f0      	beq.n	80021fa <HAL_RCC_OscConfig+0x8fa>
 8002218:	e018      	b.n	800224c <HAL_RCC_OscConfig+0x94c>
      }
    }
    else
    {
      /* Disable the Internal High Speed oscillator (HSI48) */
      __HAL_RCC_HSI48_DISABLE();
 800221a:	4b46      	ldr	r3, [pc, #280]	@ (8002334 <HAL_RCC_OscConfig+0xa34>)
 800221c:	681b      	ldr	r3, [r3, #0]
 800221e:	4a45      	ldr	r2, [pc, #276]	@ (8002334 <HAL_RCC_OscConfig+0xa34>)
 8002220:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 8002224:	6013      	str	r3, [r2, #0]

      tickstart = HAL_GetTick();
 8002226:	f7fe fea9 	bl	8000f7c <HAL_GetTick>
 800222a:	62b8      	str	r0, [r7, #40]	@ 0x28

      /* Wait till HSI48 is disabled */
      while (READ_BIT(RCC->CR, RCC_CR_HSI48RDY) != 0U)
 800222c:	e008      	b.n	8002240 <HAL_RCC_OscConfig+0x940>
      {
        if ((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 800222e:	f7fe fea5 	bl	8000f7c <HAL_GetTick>
 8002232:	4602      	mov	r2, r0
 8002234:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8002236:	1ad3      	subs	r3, r2, r3
 8002238:	2b02      	cmp	r3, #2
 800223a:	d901      	bls.n	8002240 <HAL_RCC_OscConfig+0x940>
        {
          return HAL_TIMEOUT;
 800223c:	2303      	movs	r3, #3
 800223e:	e234      	b.n	80026aa <HAL_RCC_OscConfig+0xdaa>
      while (READ_BIT(RCC->CR, RCC_CR_HSI48RDY) != 0U)
 8002240:	4b3c      	ldr	r3, [pc, #240]	@ (8002334 <HAL_RCC_OscConfig+0xa34>)
 8002242:	681b      	ldr	r3, [r3, #0]
 8002244:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 8002248:	2b00      	cmp	r3, #0
 800224a:	d1f0      	bne.n	800222e <HAL_RCC_OscConfig+0x92e>
      }
    }
  }

  /*------------------------------ SHSI Configuration -----------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_SHSI) == RCC_OSCILLATORTYPE_SHSI)
 800224c:	687b      	ldr	r3, [r7, #4]
 800224e:	681b      	ldr	r3, [r3, #0]
 8002250:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8002254:	2b00      	cmp	r3, #0
 8002256:	d036      	beq.n	80022c6 <HAL_RCC_OscConfig+0x9c6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SHSI(pRCC_OscInitStruct->SHSIState));

    /* Check the SHSI State */
    if (pRCC_OscInitStruct->SHSIState != RCC_SHSI_OFF)
 8002258:	687b      	ldr	r3, [r7, #4]
 800225a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800225c:	2b00      	cmp	r3, #0
 800225e:	d019      	beq.n	8002294 <HAL_RCC_OscConfig+0x994>
    {
      /* Enable the Secure Internal High Speed oscillator (SHSI) */
      __HAL_RCC_SHSI_ENABLE();
 8002260:	4b34      	ldr	r3, [pc, #208]	@ (8002334 <HAL_RCC_OscConfig+0xa34>)
 8002262:	681b      	ldr	r3, [r3, #0]
 8002264:	4a33      	ldr	r2, [pc, #204]	@ (8002334 <HAL_RCC_OscConfig+0xa34>)
 8002266:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 800226a:	6013      	str	r3, [r2, #0]

      tickstart = HAL_GetTick();
 800226c:	f7fe fe86 	bl	8000f7c <HAL_GetTick>
 8002270:	62b8      	str	r0, [r7, #40]	@ 0x28

      /* Wait till SHSI is ready */
      while (READ_BIT(RCC->CR, RCC_CR_SHSIRDY) == 0U)
 8002272:	e008      	b.n	8002286 <HAL_RCC_OscConfig+0x986>
      {
        if ((HAL_GetTick() - tickstart) > SHSI_TIMEOUT_VALUE)
 8002274:	f7fe fe82 	bl	8000f7c <HAL_GetTick>
 8002278:	4602      	mov	r2, r0
 800227a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800227c:	1ad3      	subs	r3, r2, r3
 800227e:	2b02      	cmp	r3, #2
 8002280:	d901      	bls.n	8002286 <HAL_RCC_OscConfig+0x986>
        {
          return HAL_TIMEOUT;
 8002282:	2303      	movs	r3, #3
 8002284:	e211      	b.n	80026aa <HAL_RCC_OscConfig+0xdaa>
      while (READ_BIT(RCC->CR, RCC_CR_SHSIRDY) == 0U)
 8002286:	4b2b      	ldr	r3, [pc, #172]	@ (8002334 <HAL_RCC_OscConfig+0xa34>)
 8002288:	681b      	ldr	r3, [r3, #0]
 800228a:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 800228e:	2b00      	cmp	r3, #0
 8002290:	d0f0      	beq.n	8002274 <HAL_RCC_OscConfig+0x974>
 8002292:	e018      	b.n	80022c6 <HAL_RCC_OscConfig+0x9c6>
      }
    }
    else
    {
      /* Disable the Secure Internal High Speed oscillator (SHSI) */
      __HAL_RCC_SHSI_DISABLE();
 8002294:	4b27      	ldr	r3, [pc, #156]	@ (8002334 <HAL_RCC_OscConfig+0xa34>)
 8002296:	681b      	ldr	r3, [r3, #0]
 8002298:	4a26      	ldr	r2, [pc, #152]	@ (8002334 <HAL_RCC_OscConfig+0xa34>)
 800229a:	f423 4380 	bic.w	r3, r3, #16384	@ 0x4000
 800229e:	6013      	str	r3, [r2, #0]

      tickstart = HAL_GetTick();
 80022a0:	f7fe fe6c 	bl	8000f7c <HAL_GetTick>
 80022a4:	62b8      	str	r0, [r7, #40]	@ 0x28

      /* Wait till SHSI is disabled */
      while (READ_BIT(RCC->CR, RCC_CR_SHSIRDY) != 0U)
 80022a6:	e008      	b.n	80022ba <HAL_RCC_OscConfig+0x9ba>
      {
        if ((HAL_GetTick() - tickstart) > SHSI_TIMEOUT_VALUE)
 80022a8:	f7fe fe68 	bl	8000f7c <HAL_GetTick>
 80022ac:	4602      	mov	r2, r0
 80022ae:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80022b0:	1ad3      	subs	r3, r2, r3
 80022b2:	2b02      	cmp	r3, #2
 80022b4:	d901      	bls.n	80022ba <HAL_RCC_OscConfig+0x9ba>
        {
          return HAL_TIMEOUT;
 80022b6:	2303      	movs	r3, #3
 80022b8:	e1f7      	b.n	80026aa <HAL_RCC_OscConfig+0xdaa>
      while (READ_BIT(RCC->CR, RCC_CR_SHSIRDY) != 0U)
 80022ba:	4b1e      	ldr	r3, [pc, #120]	@ (8002334 <HAL_RCC_OscConfig+0xa34>)
 80022bc:	681b      	ldr	r3, [r3, #0]
 80022be:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 80022c2:	2b00      	cmp	r3, #0
 80022c4:	d1f0      	bne.n	80022a8 <HAL_RCC_OscConfig+0x9a8>
        }
      }
    }
  }
  /*------------------------------ MSIK Configuration -----------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSIK) == RCC_OSCILLATORTYPE_MSIK)
 80022c6:	687b      	ldr	r3, [r7, #4]
 80022c8:	681b      	ldr	r3, [r3, #0]
 80022ca:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 80022ce:	2b00      	cmp	r3, #0
 80022d0:	d07f      	beq.n	80023d2 <HAL_RCC_OscConfig+0xad2>
    assert_param(IS_RCC_MSIK(pRCC_OscInitStruct->MSIKState));
    assert_param(IS_RCC_MSIK_CLOCK_RANGE(pRCC_OscInitStruct->MSIKClockRange));
    assert_param(IS_RCC_MSICALIBRATION_VALUE(pRCC_OscInitStruct->MSICalibrationValue));

    /* Check the MSIK State */
    if (pRCC_OscInitStruct->MSIKState != RCC_MSIK_OFF)
 80022d2:	687b      	ldr	r3, [r7, #4]
 80022d4:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80022d6:	2b00      	cmp	r3, #0
 80022d8:	d062      	beq.n	80023a0 <HAL_RCC_OscConfig+0xaa0>
    {

      /* Selects the Multiple Speed of kernel high speed oscillator (MSIK) clock range .*/
      __HAL_RCC_MSIK_RANGE_CONFIG(pRCC_OscInitStruct->MSIKClockRange);
 80022da:	4b16      	ldr	r3, [pc, #88]	@ (8002334 <HAL_RCC_OscConfig+0xa34>)
 80022dc:	689b      	ldr	r3, [r3, #8]
 80022de:	4a15      	ldr	r2, [pc, #84]	@ (8002334 <HAL_RCC_OscConfig+0xa34>)
 80022e0:	f443 0300 	orr.w	r3, r3, #8388608	@ 0x800000
 80022e4:	6093      	str	r3, [r2, #8]
 80022e6:	4b13      	ldr	r3, [pc, #76]	@ (8002334 <HAL_RCC_OscConfig+0xa34>)
 80022e8:	689b      	ldr	r3, [r3, #8]
 80022ea:	f023 6270 	bic.w	r2, r3, #251658240	@ 0xf000000
 80022ee:	687b      	ldr	r3, [r7, #4]
 80022f0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80022f2:	4910      	ldr	r1, [pc, #64]	@ (8002334 <HAL_RCC_OscConfig+0xa34>)
 80022f4:	4313      	orrs	r3, r2
 80022f6:	608b      	str	r3, [r1, #8]
      /* Adjusts the Multiple Speed of kernel high speed oscillator (MSIK) calibration value.*/
      __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST((pRCC_OscInitStruct->MSICalibrationValue), \
 80022f8:	687b      	ldr	r3, [r7, #4]
 80022fa:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80022fc:	f1b3 4f40 	cmp.w	r3, #3221225472	@ 0xc0000000
 8002300:	d309      	bcc.n	8002316 <HAL_RCC_OscConfig+0xa16>
 8002302:	4b0c      	ldr	r3, [pc, #48]	@ (8002334 <HAL_RCC_OscConfig+0xa34>)
 8002304:	68db      	ldr	r3, [r3, #12]
 8002306:	f023 021f 	bic.w	r2, r3, #31
 800230a:	687b      	ldr	r3, [r7, #4]
 800230c:	6a1b      	ldr	r3, [r3, #32]
 800230e:	4909      	ldr	r1, [pc, #36]	@ (8002334 <HAL_RCC_OscConfig+0xa34>)
 8002310:	4313      	orrs	r3, r2
 8002312:	60cb      	str	r3, [r1, #12]
 8002314:	e02a      	b.n	800236c <HAL_RCC_OscConfig+0xa6c>
 8002316:	687b      	ldr	r3, [r7, #4]
 8002318:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800231a:	2b00      	cmp	r3, #0
 800231c:	da0c      	bge.n	8002338 <HAL_RCC_OscConfig+0xa38>
 800231e:	4b05      	ldr	r3, [pc, #20]	@ (8002334 <HAL_RCC_OscConfig+0xa34>)
 8002320:	68db      	ldr	r3, [r3, #12]
 8002322:	f423 7278 	bic.w	r2, r3, #992	@ 0x3e0
 8002326:	687b      	ldr	r3, [r7, #4]
 8002328:	6a1b      	ldr	r3, [r3, #32]
 800232a:	015b      	lsls	r3, r3, #5
 800232c:	4901      	ldr	r1, [pc, #4]	@ (8002334 <HAL_RCC_OscConfig+0xa34>)
 800232e:	4313      	orrs	r3, r2
 8002330:	60cb      	str	r3, [r1, #12]
 8002332:	e01b      	b.n	800236c <HAL_RCC_OscConfig+0xa6c>
 8002334:	46020c00 	.word	0x46020c00
 8002338:	687b      	ldr	r3, [r7, #4]
 800233a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800233c:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8002340:	d30a      	bcc.n	8002358 <HAL_RCC_OscConfig+0xa58>
 8002342:	4ba1      	ldr	r3, [pc, #644]	@ (80025c8 <HAL_RCC_OscConfig+0xcc8>)
 8002344:	68db      	ldr	r3, [r3, #12]
 8002346:	f423 42f8 	bic.w	r2, r3, #31744	@ 0x7c00
 800234a:	687b      	ldr	r3, [r7, #4]
 800234c:	6a1b      	ldr	r3, [r3, #32]
 800234e:	029b      	lsls	r3, r3, #10
 8002350:	499d      	ldr	r1, [pc, #628]	@ (80025c8 <HAL_RCC_OscConfig+0xcc8>)
 8002352:	4313      	orrs	r3, r2
 8002354:	60cb      	str	r3, [r1, #12]
 8002356:	e009      	b.n	800236c <HAL_RCC_OscConfig+0xa6c>
 8002358:	4b9b      	ldr	r3, [pc, #620]	@ (80025c8 <HAL_RCC_OscConfig+0xcc8>)
 800235a:	68db      	ldr	r3, [r3, #12]
 800235c:	f423 2278 	bic.w	r2, r3, #1015808	@ 0xf8000
 8002360:	687b      	ldr	r3, [r7, #4]
 8002362:	6a1b      	ldr	r3, [r3, #32]
 8002364:	03db      	lsls	r3, r3, #15
 8002366:	4998      	ldr	r1, [pc, #608]	@ (80025c8 <HAL_RCC_OscConfig+0xcc8>)
 8002368:	4313      	orrs	r3, r2
 800236a:	60cb      	str	r3, [r1, #12]
                                            (pRCC_OscInitStruct->MSIClockRange));

      /* Enable the Internal kernel High Speed oscillator (MSIK) */
      __HAL_RCC_MSIK_ENABLE();
 800236c:	4b96      	ldr	r3, [pc, #600]	@ (80025c8 <HAL_RCC_OscConfig+0xcc8>)
 800236e:	681b      	ldr	r3, [r3, #0]
 8002370:	4a95      	ldr	r2, [pc, #596]	@ (80025c8 <HAL_RCC_OscConfig+0xcc8>)
 8002372:	f043 0310 	orr.w	r3, r3, #16
 8002376:	6013      	str	r3, [r2, #0]

      tickstart = HAL_GetTick();
 8002378:	f7fe fe00 	bl	8000f7c <HAL_GetTick>
 800237c:	62b8      	str	r0, [r7, #40]	@ 0x28

      /* Wait till MSIK is ready */
      while (READ_BIT(RCC->CR, RCC_CR_MSIKRDY) == 0U)
 800237e:	e008      	b.n	8002392 <HAL_RCC_OscConfig+0xa92>
      {
        if ((HAL_GetTick() - tickstart) > MSIK_TIMEOUT_VALUE)
 8002380:	f7fe fdfc 	bl	8000f7c <HAL_GetTick>
 8002384:	4602      	mov	r2, r0
 8002386:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8002388:	1ad3      	subs	r3, r2, r3
 800238a:	2b02      	cmp	r3, #2
 800238c:	d901      	bls.n	8002392 <HAL_RCC_OscConfig+0xa92>
        {
          return HAL_TIMEOUT;
 800238e:	2303      	movs	r3, #3
 8002390:	e18b      	b.n	80026aa <HAL_RCC_OscConfig+0xdaa>
      while (READ_BIT(RCC->CR, RCC_CR_MSIKRDY) == 0U)
 8002392:	4b8d      	ldr	r3, [pc, #564]	@ (80025c8 <HAL_RCC_OscConfig+0xcc8>)
 8002394:	681b      	ldr	r3, [r3, #0]
 8002396:	f003 0320 	and.w	r3, r3, #32
 800239a:	2b00      	cmp	r3, #0
 800239c:	d0f0      	beq.n	8002380 <HAL_RCC_OscConfig+0xa80>
 800239e:	e018      	b.n	80023d2 <HAL_RCC_OscConfig+0xad2>
      }
    }
    else
    {
      /* Disable the Internal High Speed Kernel oscillator (MSIK) */
      __HAL_RCC_MSIK_DISABLE();
 80023a0:	4b89      	ldr	r3, [pc, #548]	@ (80025c8 <HAL_RCC_OscConfig+0xcc8>)
 80023a2:	681b      	ldr	r3, [r3, #0]
 80023a4:	4a88      	ldr	r2, [pc, #544]	@ (80025c8 <HAL_RCC_OscConfig+0xcc8>)
 80023a6:	f023 0310 	bic.w	r3, r3, #16
 80023aa:	6013      	str	r3, [r2, #0]

      tickstart = HAL_GetTick();
 80023ac:	f7fe fde6 	bl	8000f7c <HAL_GetTick>
 80023b0:	62b8      	str	r0, [r7, #40]	@ 0x28

      /* Wait till MSIK is disabled */
      while (READ_BIT(RCC->CR, RCC_CR_MSIKRDY) != 0U)
 80023b2:	e008      	b.n	80023c6 <HAL_RCC_OscConfig+0xac6>
      {
        if ((HAL_GetTick() - tickstart) > MSIK_TIMEOUT_VALUE)
 80023b4:	f7fe fde2 	bl	8000f7c <HAL_GetTick>
 80023b8:	4602      	mov	r2, r0
 80023ba:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80023bc:	1ad3      	subs	r3, r2, r3
 80023be:	2b02      	cmp	r3, #2
 80023c0:	d901      	bls.n	80023c6 <HAL_RCC_OscConfig+0xac6>
        {
          return HAL_TIMEOUT;
 80023c2:	2303      	movs	r3, #3
 80023c4:	e171      	b.n	80026aa <HAL_RCC_OscConfig+0xdaa>
      while (READ_BIT(RCC->CR, RCC_CR_MSIKRDY) != 0U)
 80023c6:	4b80      	ldr	r3, [pc, #512]	@ (80025c8 <HAL_RCC_OscConfig+0xcc8>)
 80023c8:	681b      	ldr	r3, [r3, #0]
 80023ca:	f003 0320 	and.w	r3, r3, #32
 80023ce:	2b00      	cmp	r3, #0
 80023d0:	d1f0      	bne.n	80023b4 <HAL_RCC_OscConfig+0xab4>
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL.PLLState));

  if ((pRCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 80023d2:	687b      	ldr	r3, [r7, #4]
 80023d4:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80023d6:	2b00      	cmp	r3, #0
 80023d8:	f000 8166 	beq.w	80026a8 <HAL_RCC_OscConfig+0xda8>
  {
    FlagStatus  pwrclkchanged = RESET;
 80023dc:	2300      	movs	r3, #0
 80023de:	f887 3034 	strb.w	r3, [r7, #52]	@ 0x34

    /* Check if the PLL is used as system clock or not */
    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 80023e2:	4b79      	ldr	r3, [pc, #484]	@ (80025c8 <HAL_RCC_OscConfig+0xcc8>)
 80023e4:	69db      	ldr	r3, [r3, #28]
 80023e6:	f003 030c 	and.w	r3, r3, #12
 80023ea:	2b0c      	cmp	r3, #12
 80023ec:	f000 80f2 	beq.w	80025d4 <HAL_RCC_OscConfig+0xcd4>
    {
      if ((pRCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 80023f0:	687b      	ldr	r3, [r7, #4]
 80023f2:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80023f4:	2b02      	cmp	r3, #2
 80023f6:	f040 80c5 	bne.w	8002584 <HAL_RCC_OscConfig+0xc84>
        assert_param(IS_RCC_PLLP_VALUE(pRCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(pRCC_OscInitStruct->PLL.PLLQ));
        assert_param(IS_RCC_PLLR_VALUE(pRCC_OscInitStruct->PLL.PLLR));

        /* Disable the main PLL */
        __HAL_RCC_PLL_DISABLE();
 80023fa:	4b73      	ldr	r3, [pc, #460]	@ (80025c8 <HAL_RCC_OscConfig+0xcc8>)
 80023fc:	681b      	ldr	r3, [r3, #0]
 80023fe:	4a72      	ldr	r2, [pc, #456]	@ (80025c8 <HAL_RCC_OscConfig+0xcc8>)
 8002400:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
 8002404:	6013      	str	r3, [r2, #0]

        tickstart = HAL_GetTick();
 8002406:	f7fe fdb9 	bl	8000f7c <HAL_GetTick>
 800240a:	62b8      	str	r0, [r7, #40]	@ 0x28

        /* Wait till PLL is disabled */
        while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) != 0U)
 800240c:	e008      	b.n	8002420 <HAL_RCC_OscConfig+0xb20>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800240e:	f7fe fdb5 	bl	8000f7c <HAL_GetTick>
 8002412:	4602      	mov	r2, r0
 8002414:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8002416:	1ad3      	subs	r3, r2, r3
 8002418:	2b02      	cmp	r3, #2
 800241a:	d901      	bls.n	8002420 <HAL_RCC_OscConfig+0xb20>
          {
            return HAL_TIMEOUT;
 800241c:	2303      	movs	r3, #3
 800241e:	e144      	b.n	80026aa <HAL_RCC_OscConfig+0xdaa>
        while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) != 0U)
 8002420:	4b69      	ldr	r3, [pc, #420]	@ (80025c8 <HAL_RCC_OscConfig+0xcc8>)
 8002422:	681b      	ldr	r3, [r3, #0]
 8002424:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 8002428:	2b00      	cmp	r3, #0
 800242a:	d1f0      	bne.n	800240e <HAL_RCC_OscConfig+0xb0e>
          }
        }

        /* Requires to enable write access to Backup Domain of necessary */
        if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 800242c:	4b66      	ldr	r3, [pc, #408]	@ (80025c8 <HAL_RCC_OscConfig+0xcc8>)
 800242e:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8002432:	f003 0304 	and.w	r3, r3, #4
 8002436:	2b00      	cmp	r3, #0
 8002438:	d111      	bne.n	800245e <HAL_RCC_OscConfig+0xb5e>
        {
          __HAL_RCC_PWR_CLK_ENABLE();
 800243a:	4b63      	ldr	r3, [pc, #396]	@ (80025c8 <HAL_RCC_OscConfig+0xcc8>)
 800243c:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8002440:	4a61      	ldr	r2, [pc, #388]	@ (80025c8 <HAL_RCC_OscConfig+0xcc8>)
 8002442:	f043 0304 	orr.w	r3, r3, #4
 8002446:	f8c2 3094 	str.w	r3, [r2, #148]	@ 0x94
 800244a:	4b5f      	ldr	r3, [pc, #380]	@ (80025c8 <HAL_RCC_OscConfig+0xcc8>)
 800244c:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8002450:	f003 0304 	and.w	r3, r3, #4
 8002454:	60fb      	str	r3, [r7, #12]
 8002456:	68fb      	ldr	r3, [r7, #12]
          pwrclkchanged = SET;
 8002458:	2301      	movs	r3, #1
 800245a:	f887 3034 	strb.w	r3, [r7, #52]	@ 0x34
        }

        /*Disable EPOD to configure PLL1MBOOST*/
        if (READ_BIT(PWR->VOSR, PWR_VOSR_BOOSTEN) == PWR_VOSR_BOOSTEN)
 800245e:	4b5b      	ldr	r3, [pc, #364]	@ (80025cc <HAL_RCC_OscConfig+0xccc>)
 8002460:	68db      	ldr	r3, [r3, #12]
 8002462:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
 8002466:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 800246a:	d102      	bne.n	8002472 <HAL_RCC_OscConfig+0xb72>
        {
          pwrboosten = SET;
 800246c:	2301      	movs	r3, #1
 800246e:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
        }
        CLEAR_BIT(PWR->VOSR, PWR_VOSR_BOOSTEN);
 8002472:	4b56      	ldr	r3, [pc, #344]	@ (80025cc <HAL_RCC_OscConfig+0xccc>)
 8002474:	68db      	ldr	r3, [r3, #12]
 8002476:	4a55      	ldr	r2, [pc, #340]	@ (80025cc <HAL_RCC_OscConfig+0xccc>)
 8002478:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
 800247c:	60d3      	str	r3, [r2, #12]

        /* Configure the main PLL clock source, multiplication and division factors */
        __HAL_RCC_PLL_CONFIG(pRCC_OscInitStruct->PLL.PLLSource,
 800247e:	4b52      	ldr	r3, [pc, #328]	@ (80025c8 <HAL_RCC_OscConfig+0xcc8>)
 8002480:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8002482:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
 8002486:	f023 0303 	bic.w	r3, r3, #3
 800248a:	687a      	ldr	r2, [r7, #4]
 800248c:	6bd1      	ldr	r1, [r2, #60]	@ 0x3c
 800248e:	687a      	ldr	r2, [r7, #4]
 8002490:	6c12      	ldr	r2, [r2, #64]	@ 0x40
 8002492:	3a01      	subs	r2, #1
 8002494:	0212      	lsls	r2, r2, #8
 8002496:	4311      	orrs	r1, r2
 8002498:	687a      	ldr	r2, [r7, #4]
 800249a:	6c52      	ldr	r2, [r2, #68]	@ 0x44
 800249c:	430a      	orrs	r2, r1
 800249e:	494a      	ldr	r1, [pc, #296]	@ (80025c8 <HAL_RCC_OscConfig+0xcc8>)
 80024a0:	4313      	orrs	r3, r2
 80024a2:	628b      	str	r3, [r1, #40]	@ 0x28
 80024a4:	4b48      	ldr	r3, [pc, #288]	@ (80025c8 <HAL_RCC_OscConfig+0xcc8>)
 80024a6:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 80024a8:	4b49      	ldr	r3, [pc, #292]	@ (80025d0 <HAL_RCC_OscConfig+0xcd0>)
 80024aa:	4013      	ands	r3, r2
 80024ac:	687a      	ldr	r2, [r7, #4]
 80024ae:	6c92      	ldr	r2, [r2, #72]	@ 0x48
 80024b0:	3a01      	subs	r2, #1
 80024b2:	f3c2 0108 	ubfx	r1, r2, #0, #9
 80024b6:	687a      	ldr	r2, [r7, #4]
 80024b8:	6cd2      	ldr	r2, [r2, #76]	@ 0x4c
 80024ba:	3a01      	subs	r2, #1
 80024bc:	0252      	lsls	r2, r2, #9
 80024be:	b292      	uxth	r2, r2
 80024c0:	4311      	orrs	r1, r2
 80024c2:	687a      	ldr	r2, [r7, #4]
 80024c4:	6d12      	ldr	r2, [r2, #80]	@ 0x50
 80024c6:	3a01      	subs	r2, #1
 80024c8:	0412      	lsls	r2, r2, #16
 80024ca:	f402 02fe 	and.w	r2, r2, #8323072	@ 0x7f0000
 80024ce:	4311      	orrs	r1, r2
 80024d0:	687a      	ldr	r2, [r7, #4]
 80024d2:	6d52      	ldr	r2, [r2, #84]	@ 0x54
 80024d4:	3a01      	subs	r2, #1
 80024d6:	0612      	lsls	r2, r2, #24
 80024d8:	f002 42fe 	and.w	r2, r2, #2130706432	@ 0x7f000000
 80024dc:	430a      	orrs	r2, r1
 80024de:	493a      	ldr	r1, [pc, #232]	@ (80025c8 <HAL_RCC_OscConfig+0xcc8>)
 80024e0:	4313      	orrs	r3, r2
 80024e2:	634b      	str	r3, [r1, #52]	@ 0x34
                             pRCC_OscInitStruct->PLL.PLLR);

        assert_param(IS_RCC_PLL_FRACN_VALUE(pRCC_OscInitStruct->PLL.PLLFRACN));

        /* Disable PLL1FRACN  */
        __HAL_RCC_PLL_FRACN_DISABLE();
 80024e4:	4b38      	ldr	r3, [pc, #224]	@ (80025c8 <HAL_RCC_OscConfig+0xcc8>)
 80024e6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80024e8:	4a37      	ldr	r2, [pc, #220]	@ (80025c8 <HAL_RCC_OscConfig+0xcc8>)
 80024ea:	f023 0310 	bic.w	r3, r3, #16
 80024ee:	6293      	str	r3, [r2, #40]	@ 0x28

        /* Configure PLL  PLL1FRACN */
        __HAL_RCC_PLL_FRACN_CONFIG(pRCC_OscInitStruct->PLL.PLLFRACN);
 80024f0:	687b      	ldr	r3, [r7, #4]
 80024f2:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 80024f4:	4a34      	ldr	r2, [pc, #208]	@ (80025c8 <HAL_RCC_OscConfig+0xcc8>)
 80024f6:	00db      	lsls	r3, r3, #3
 80024f8:	6393      	str	r3, [r2, #56]	@ 0x38

        /* Enable PLL1FRACN  */
        __HAL_RCC_PLL_FRACN_ENABLE();
 80024fa:	4b33      	ldr	r3, [pc, #204]	@ (80025c8 <HAL_RCC_OscConfig+0xcc8>)
 80024fc:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80024fe:	4a32      	ldr	r2, [pc, #200]	@ (80025c8 <HAL_RCC_OscConfig+0xcc8>)
 8002500:	f043 0310 	orr.w	r3, r3, #16
 8002504:	6293      	str	r3, [r2, #40]	@ 0x28

        assert_param(IS_RCC_PLLRGE_VALUE(pRCC_OscInitStruct->PLL.PLLRGE));

        /* Select PLL1 input reference frequency range: VCI */
        __HAL_RCC_PLL_VCIRANGE(pRCC_OscInitStruct->PLL.PLLRGE);
 8002506:	4b30      	ldr	r3, [pc, #192]	@ (80025c8 <HAL_RCC_OscConfig+0xcc8>)
 8002508:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800250a:	f023 020c 	bic.w	r2, r3, #12
 800250e:	687b      	ldr	r3, [r7, #4]
 8002510:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8002512:	492d      	ldr	r1, [pc, #180]	@ (80025c8 <HAL_RCC_OscConfig+0xcc8>)
 8002514:	4313      	orrs	r3, r2
 8002516:	628b      	str	r3, [r1, #40]	@ 0x28

        if (pwrboosten == SET)
 8002518:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
 800251c:	2b01      	cmp	r3, #1
 800251e:	d105      	bne.n	800252c <HAL_RCC_OscConfig+0xc2c>
        {
          /* Enable the EPOD to reach max frequency */
          SET_BIT(PWR->VOSR, PWR_VOSR_BOOSTEN);
 8002520:	4b2a      	ldr	r3, [pc, #168]	@ (80025cc <HAL_RCC_OscConfig+0xccc>)
 8002522:	68db      	ldr	r3, [r3, #12]
 8002524:	4a29      	ldr	r2, [pc, #164]	@ (80025cc <HAL_RCC_OscConfig+0xccc>)
 8002526:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 800252a:	60d3      	str	r3, [r2, #12]
        }

        /* Restore clock configuration if changed */
        if (pwrclkchanged == SET)
 800252c:	f897 3034 	ldrb.w	r3, [r7, #52]	@ 0x34
 8002530:	2b01      	cmp	r3, #1
 8002532:	d107      	bne.n	8002544 <HAL_RCC_OscConfig+0xc44>
        {
          __HAL_RCC_PWR_CLK_DISABLE();
 8002534:	4b24      	ldr	r3, [pc, #144]	@ (80025c8 <HAL_RCC_OscConfig+0xcc8>)
 8002536:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 800253a:	4a23      	ldr	r2, [pc, #140]	@ (80025c8 <HAL_RCC_OscConfig+0xcc8>)
 800253c:	f023 0304 	bic.w	r3, r3, #4
 8002540:	f8c2 3094 	str.w	r3, [r2, #148]	@ 0x94
        }

        /* Enable the main PLL */
        __HAL_RCC_PLL_ENABLE();
 8002544:	4b20      	ldr	r3, [pc, #128]	@ (80025c8 <HAL_RCC_OscConfig+0xcc8>)
 8002546:	681b      	ldr	r3, [r3, #0]
 8002548:	4a1f      	ldr	r2, [pc, #124]	@ (80025c8 <HAL_RCC_OscConfig+0xcc8>)
 800254a:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 800254e:	6013      	str	r3, [r2, #0]

        tickstart = HAL_GetTick();
 8002550:	f7fe fd14 	bl	8000f7c <HAL_GetTick>
 8002554:	62b8      	str	r0, [r7, #40]	@ 0x28

        /* Wait till PLL is ready */
        while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) == 0U)
 8002556:	e008      	b.n	800256a <HAL_RCC_OscConfig+0xc6a>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8002558:	f7fe fd10 	bl	8000f7c <HAL_GetTick>
 800255c:	4602      	mov	r2, r0
 800255e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8002560:	1ad3      	subs	r3, r2, r3
 8002562:	2b02      	cmp	r3, #2
 8002564:	d901      	bls.n	800256a <HAL_RCC_OscConfig+0xc6a>
          {
            return HAL_TIMEOUT;
 8002566:	2303      	movs	r3, #3
 8002568:	e09f      	b.n	80026aa <HAL_RCC_OscConfig+0xdaa>
        while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) == 0U)
 800256a:	4b17      	ldr	r3, [pc, #92]	@ (80025c8 <HAL_RCC_OscConfig+0xcc8>)
 800256c:	681b      	ldr	r3, [r3, #0]
 800256e:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 8002572:	2b00      	cmp	r3, #0
 8002574:	d0f0      	beq.n	8002558 <HAL_RCC_OscConfig+0xc58>
          }
        }

        /* Enable PLL System Clock output */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVR);
 8002576:	4b14      	ldr	r3, [pc, #80]	@ (80025c8 <HAL_RCC_OscConfig+0xcc8>)
 8002578:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800257a:	4a13      	ldr	r2, [pc, #76]	@ (80025c8 <HAL_RCC_OscConfig+0xcc8>)
 800257c:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 8002580:	6293      	str	r3, [r2, #40]	@ 0x28
 8002582:	e091      	b.n	80026a8 <HAL_RCC_OscConfig+0xda8>

      }
      else
      {
        /* Disable the main PLL */
        __HAL_RCC_PLL_DISABLE();
 8002584:	4b10      	ldr	r3, [pc, #64]	@ (80025c8 <HAL_RCC_OscConfig+0xcc8>)
 8002586:	681b      	ldr	r3, [r3, #0]
 8002588:	4a0f      	ldr	r2, [pc, #60]	@ (80025c8 <HAL_RCC_OscConfig+0xcc8>)
 800258a:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
 800258e:	6013      	str	r3, [r2, #0]

        tickstart = HAL_GetTick();
 8002590:	f7fe fcf4 	bl	8000f7c <HAL_GetTick>
 8002594:	62b8      	str	r0, [r7, #40]	@ 0x28

        /* Wait till PLL is disabled */
        while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) != 0U)
 8002596:	e008      	b.n	80025aa <HAL_RCC_OscConfig+0xcaa>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8002598:	f7fe fcf0 	bl	8000f7c <HAL_GetTick>
 800259c:	4602      	mov	r2, r0
 800259e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80025a0:	1ad3      	subs	r3, r2, r3
 80025a2:	2b02      	cmp	r3, #2
 80025a4:	d901      	bls.n	80025aa <HAL_RCC_OscConfig+0xcaa>
          {
            return HAL_TIMEOUT;
 80025a6:	2303      	movs	r3, #3
 80025a8:	e07f      	b.n	80026aa <HAL_RCC_OscConfig+0xdaa>
        while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) != 0U)
 80025aa:	4b07      	ldr	r3, [pc, #28]	@ (80025c8 <HAL_RCC_OscConfig+0xcc8>)
 80025ac:	681b      	ldr	r3, [r3, #0]
 80025ae:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 80025b2:	2b00      	cmp	r3, #0
 80025b4:	d1f0      	bne.n	8002598 <HAL_RCC_OscConfig+0xc98>
          }
        }

        /* Unselect main PLL clock source and disable main PLL outputs to save power */
        RCC->PLL1CFGR &= ~(RCC_PLL1CFGR_PLL1SRC | RCC_PLL1CFGR_PLL1PEN | RCC_PLL1CFGR_PLL1QEN | RCC_PLL1CFGR_PLL1REN);
 80025b6:	4b04      	ldr	r3, [pc, #16]	@ (80025c8 <HAL_RCC_OscConfig+0xcc8>)
 80025b8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80025ba:	4a03      	ldr	r2, [pc, #12]	@ (80025c8 <HAL_RCC_OscConfig+0xcc8>)
 80025bc:	f423 23e0 	bic.w	r3, r3, #458752	@ 0x70000
 80025c0:	f023 0303 	bic.w	r3, r3, #3
 80025c4:	6293      	str	r3, [r2, #40]	@ 0x28
 80025c6:	e06f      	b.n	80026a8 <HAL_RCC_OscConfig+0xda8>
 80025c8:	46020c00 	.word	0x46020c00
 80025cc:	46020800 	.word	0x46020800
 80025d0:	80800000 	.word	0x80800000
      }
    }
    else
    {
      /* Do not return HAL_ERROR if request repeats the current configuration */
      temp1_pllckcfg = RCC->PLL1CFGR;
 80025d4:	4b37      	ldr	r3, [pc, #220]	@ (80026b4 <HAL_RCC_OscConfig+0xdb4>)
 80025d6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80025d8:	61fb      	str	r3, [r7, #28]
      temp2_pllckcfg = RCC->PLL1DIVR;
 80025da:	4b36      	ldr	r3, [pc, #216]	@ (80026b4 <HAL_RCC_OscConfig+0xdb4>)
 80025dc:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80025de:	61bb      	str	r3, [r7, #24]
      if (((pRCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 80025e0:	687b      	ldr	r3, [r7, #4]
 80025e2:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80025e4:	2b01      	cmp	r3, #1
 80025e6:	d039      	beq.n	800265c <HAL_RCC_OscConfig+0xd5c>
          (READ_BIT(temp1_pllckcfg, RCC_PLL1CFGR_PLL1SRC) != pRCC_OscInitStruct->PLL.PLLSource) ||
 80025e8:	69fb      	ldr	r3, [r7, #28]
 80025ea:	f003 0203 	and.w	r2, r3, #3
 80025ee:	687b      	ldr	r3, [r7, #4]
 80025f0:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
      if (((pRCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 80025f2:	429a      	cmp	r2, r3
 80025f4:	d132      	bne.n	800265c <HAL_RCC_OscConfig+0xd5c>
          ((READ_BIT(temp1_pllckcfg, RCC_PLL1CFGR_PLL1M) >> \
 80025f6:	69fb      	ldr	r3, [r7, #28]
 80025f8:	0a1b      	lsrs	r3, r3, #8
 80025fa:	f003 020f 	and.w	r2, r3, #15
            RCC_PLL1CFGR_PLL1M_Pos) != (pRCC_OscInitStruct->PLL.PLLM - 1U)) ||
 80025fe:	687b      	ldr	r3, [r7, #4]
 8002600:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8002602:	3b01      	subs	r3, #1
          (READ_BIT(temp1_pllckcfg, RCC_PLL1CFGR_PLL1SRC) != pRCC_OscInitStruct->PLL.PLLSource) ||
 8002604:	429a      	cmp	r2, r3
 8002606:	d129      	bne.n	800265c <HAL_RCC_OscConfig+0xd5c>
          (READ_BIT(temp1_pllckcfg, RCC_PLL1CFGR_PLL1MBOOST) != pRCC_OscInitStruct->PLL.PLLMBOOST) ||
 8002608:	69fb      	ldr	r3, [r7, #28]
 800260a:	f403 4270 	and.w	r2, r3, #61440	@ 0xf000
 800260e:	687b      	ldr	r3, [r7, #4]
 8002610:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
            RCC_PLL1CFGR_PLL1M_Pos) != (pRCC_OscInitStruct->PLL.PLLM - 1U)) ||
 8002612:	429a      	cmp	r2, r3
 8002614:	d122      	bne.n	800265c <HAL_RCC_OscConfig+0xd5c>
          (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_PLL1N) != (pRCC_OscInitStruct->PLL.PLLN - 1U)) ||
 8002616:	69bb      	ldr	r3, [r7, #24]
 8002618:	f3c3 0208 	ubfx	r2, r3, #0, #9
 800261c:	687b      	ldr	r3, [r7, #4]
 800261e:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8002620:	3b01      	subs	r3, #1
          (READ_BIT(temp1_pllckcfg, RCC_PLL1CFGR_PLL1MBOOST) != pRCC_OscInitStruct->PLL.PLLMBOOST) ||
 8002622:	429a      	cmp	r2, r3
 8002624:	d11a      	bne.n	800265c <HAL_RCC_OscConfig+0xd5c>
          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_PLL1P) >> \
 8002626:	69bb      	ldr	r3, [r7, #24]
 8002628:	0a5b      	lsrs	r3, r3, #9
 800262a:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
            RCC_PLL1DIVR_PLL1P_Pos) != (pRCC_OscInitStruct->PLL.PLLP - 1U)) ||
 800262e:	687b      	ldr	r3, [r7, #4]
 8002630:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8002632:	3b01      	subs	r3, #1
          (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_PLL1N) != (pRCC_OscInitStruct->PLL.PLLN - 1U)) ||
 8002634:	429a      	cmp	r2, r3
 8002636:	d111      	bne.n	800265c <HAL_RCC_OscConfig+0xd5c>
          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_PLL1Q) >> \
 8002638:	69bb      	ldr	r3, [r7, #24]
 800263a:	0c1b      	lsrs	r3, r3, #16
 800263c:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
            RCC_PLL1DIVR_PLL1Q_Pos) != (pRCC_OscInitStruct->PLL.PLLQ - 1U)) ||
 8002640:	687b      	ldr	r3, [r7, #4]
 8002642:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8002644:	3b01      	subs	r3, #1
            RCC_PLL1DIVR_PLL1P_Pos) != (pRCC_OscInitStruct->PLL.PLLP - 1U)) ||
 8002646:	429a      	cmp	r2, r3
 8002648:	d108      	bne.n	800265c <HAL_RCC_OscConfig+0xd5c>
          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_PLL1R) >> \
 800264a:	69bb      	ldr	r3, [r7, #24]
 800264c:	0e1b      	lsrs	r3, r3, #24
 800264e:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
            RCC_PLL1DIVR_PLL1R_Pos) != (pRCC_OscInitStruct->PLL.PLLR - 1U)))
 8002652:	687b      	ldr	r3, [r7, #4]
 8002654:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8002656:	3b01      	subs	r3, #1
            RCC_PLL1DIVR_PLL1Q_Pos) != (pRCC_OscInitStruct->PLL.PLLQ - 1U)) ||
 8002658:	429a      	cmp	r2, r3
 800265a:	d001      	beq.n	8002660 <HAL_RCC_OscConfig+0xd60>
      {
        return HAL_ERROR;
 800265c:	2301      	movs	r3, #1
 800265e:	e024      	b.n	80026aa <HAL_RCC_OscConfig+0xdaa>
      }

      /* FRACN1 on-the-fly value update */
      if ((READ_BIT(RCC->PLL1FRACR, RCC_PLL1FRACR_PLL1FRACN) >> \
 8002660:	4b14      	ldr	r3, [pc, #80]	@ (80026b4 <HAL_RCC_OscConfig+0xdb4>)
 8002662:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8002664:	08db      	lsrs	r3, r3, #3
 8002666:	f3c3 020c 	ubfx	r2, r3, #0, #13
           RCC_PLL1FRACR_PLL1FRACN_Pos) != (pRCC_OscInitStruct->PLL.PLLFRACN))
 800266a:	687b      	ldr	r3, [r7, #4]
 800266c:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
      if ((READ_BIT(RCC->PLL1FRACR, RCC_PLL1FRACR_PLL1FRACN) >> \
 800266e:	429a      	cmp	r2, r3
 8002670:	d01a      	beq.n	80026a8 <HAL_RCC_OscConfig+0xda8>
      {
        assert_param(IS_RCC_PLL_FRACN_VALUE(pRCC_OscInitStruct->PLL.PLLFRACN));

        /* Disable PLL1FRACN. */
        __HAL_RCC_PLL_FRACN_DISABLE();
 8002672:	4b10      	ldr	r3, [pc, #64]	@ (80026b4 <HAL_RCC_OscConfig+0xdb4>)
 8002674:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8002676:	4a0f      	ldr	r2, [pc, #60]	@ (80026b4 <HAL_RCC_OscConfig+0xdb4>)
 8002678:	f023 0310 	bic.w	r3, r3, #16
 800267c:	6293      	str	r3, [r2, #40]	@ 0x28

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800267e:	f7fe fc7d 	bl	8000f7c <HAL_GetTick>
 8002682:	62b8      	str	r0, [r7, #40]	@ 0x28

        /* Wait at least 2 CK_REF (PLL1 input source divided by M) period to make sure next latched value
           will be taken into account. */
        while ((HAL_GetTick() - tickstart) < PLL_FRAC_WAIT_VALUE)
 8002684:	bf00      	nop
 8002686:	f7fe fc79 	bl	8000f7c <HAL_GetTick>
 800268a:	4602      	mov	r2, r0
 800268c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800268e:	4293      	cmp	r3, r2
 8002690:	d0f9      	beq.n	8002686 <HAL_RCC_OscConfig+0xd86>
        {
        }

        /* Configure PLL PLL1FRACN */
        __HAL_RCC_PLL_FRACN_CONFIG(pRCC_OscInitStruct->PLL.PLLFRACN);
 8002692:	687b      	ldr	r3, [r7, #4]
 8002694:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8002696:	4a07      	ldr	r2, [pc, #28]	@ (80026b4 <HAL_RCC_OscConfig+0xdb4>)
 8002698:	00db      	lsls	r3, r3, #3
 800269a:	6393      	str	r3, [r2, #56]	@ 0x38

        /* Enable PLL1FRACN to latch the new value. */
        __HAL_RCC_PLL_FRACN_ENABLE();
 800269c:	4b05      	ldr	r3, [pc, #20]	@ (80026b4 <HAL_RCC_OscConfig+0xdb4>)
 800269e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80026a0:	4a04      	ldr	r2, [pc, #16]	@ (80026b4 <HAL_RCC_OscConfig+0xdb4>)
 80026a2:	f043 0310 	orr.w	r3, r3, #16
 80026a6:	6293      	str	r3, [r2, #40]	@ 0x28
      }
    }
  }
  return HAL_OK;
 80026a8:	2300      	movs	r3, #0
}
 80026aa:	4618      	mov	r0, r3
 80026ac:	3738      	adds	r7, #56	@ 0x38
 80026ae:	46bd      	mov	sp, r7
 80026b0:	bd80      	pop	{r7, pc}
 80026b2:	bf00      	nop
 80026b4:	46020c00 	.word	0x46020c00

080026b8 <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(const RCC_ClkInitTypeDef   *const pRCC_ClkInitStruct, uint32_t FLatency)
{
 80026b8:	b580      	push	{r7, lr}
 80026ba:	b086      	sub	sp, #24
 80026bc:	af00      	add	r7, sp, #0
 80026be:	6078      	str	r0, [r7, #4]
 80026c0:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status;
  uint32_t tickstart;

  /* Check Null pointer */
  if (pRCC_ClkInitStruct == NULL)
 80026c2:	687b      	ldr	r3, [r7, #4]
 80026c4:	2b00      	cmp	r3, #0
 80026c6:	d101      	bne.n	80026cc <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
 80026c8:	2301      	movs	r3, #1
 80026ca:	e1d9      	b.n	8002a80 <HAL_RCC_ClockConfig+0x3c8>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
   must be correctly programmed according to the frequency of the CPU clock
   (HCLK) and the supply voltage of the device */

  /* Increasing the number of wait states because of higher CPU frequency */
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 80026cc:	4b9b      	ldr	r3, [pc, #620]	@ (800293c <HAL_RCC_ClockConfig+0x284>)
 80026ce:	681b      	ldr	r3, [r3, #0]
 80026d0:	f003 030f 	and.w	r3, r3, #15
 80026d4:	683a      	ldr	r2, [r7, #0]
 80026d6:	429a      	cmp	r2, r3
 80026d8:	d910      	bls.n	80026fc <HAL_RCC_ClockConfig+0x44>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 80026da:	4b98      	ldr	r3, [pc, #608]	@ (800293c <HAL_RCC_ClockConfig+0x284>)
 80026dc:	681b      	ldr	r3, [r3, #0]
 80026de:	f023 020f 	bic.w	r2, r3, #15
 80026e2:	4996      	ldr	r1, [pc, #600]	@ (800293c <HAL_RCC_ClockConfig+0x284>)
 80026e4:	683b      	ldr	r3, [r7, #0]
 80026e6:	4313      	orrs	r3, r2
 80026e8:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 80026ea:	4b94      	ldr	r3, [pc, #592]	@ (800293c <HAL_RCC_ClockConfig+0x284>)
 80026ec:	681b      	ldr	r3, [r3, #0]
 80026ee:	f003 030f 	and.w	r3, r3, #15
 80026f2:	683a      	ldr	r2, [r7, #0]
 80026f4:	429a      	cmp	r2, r3
 80026f6:	d001      	beq.n	80026fc <HAL_RCC_ClockConfig+0x44>
    {
      return HAL_ERROR;
 80026f8:	2301      	movs	r3, #1
 80026fa:	e1c1      	b.n	8002a80 <HAL_RCC_ClockConfig+0x3c8>
    }
  }

  /* Increasing the BUS frequency divider */
  /*-------------------------- PCLK3 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK3) == RCC_CLOCKTYPE_PCLK3)
 80026fc:	687b      	ldr	r3, [r7, #4]
 80026fe:	681b      	ldr	r3, [r3, #0]
 8002700:	f003 0310 	and.w	r3, r3, #16
 8002704:	2b00      	cmp	r3, #0
 8002706:	d010      	beq.n	800272a <HAL_RCC_ClockConfig+0x72>
  {
    if ((pRCC_ClkInitStruct->APB3CLKDivider) > (RCC->CFGR3 & RCC_CFGR3_PPRE3))
 8002708:	687b      	ldr	r3, [r7, #4]
 800270a:	695a      	ldr	r2, [r3, #20]
 800270c:	4b8c      	ldr	r3, [pc, #560]	@ (8002940 <HAL_RCC_ClockConfig+0x288>)
 800270e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8002710:	f003 0370 	and.w	r3, r3, #112	@ 0x70
 8002714:	429a      	cmp	r2, r3
 8002716:	d908      	bls.n	800272a <HAL_RCC_ClockConfig+0x72>
    {
      assert_param(IS_RCC_PCLK(pRCC_ClkInitStruct->APB3CLKDivider));
      MODIFY_REG(RCC->CFGR3, RCC_CFGR3_PPRE3, pRCC_ClkInitStruct->APB3CLKDivider);
 8002718:	4b89      	ldr	r3, [pc, #548]	@ (8002940 <HAL_RCC_ClockConfig+0x288>)
 800271a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800271c:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
 8002720:	687b      	ldr	r3, [r7, #4]
 8002722:	695b      	ldr	r3, [r3, #20]
 8002724:	4986      	ldr	r1, [pc, #536]	@ (8002940 <HAL_RCC_ClockConfig+0x288>)
 8002726:	4313      	orrs	r3, r2
 8002728:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }
  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800272a:	687b      	ldr	r3, [r7, #4]
 800272c:	681b      	ldr	r3, [r3, #0]
 800272e:	f003 0308 	and.w	r3, r3, #8
 8002732:	2b00      	cmp	r3, #0
 8002734:	d012      	beq.n	800275c <HAL_RCC_ClockConfig+0xa4>
  {
    if ((pRCC_ClkInitStruct->APB2CLKDivider) > ((RCC->CFGR2 & RCC_CFGR2_PPRE2) >> 4))
 8002736:	687b      	ldr	r3, [r7, #4]
 8002738:	691a      	ldr	r2, [r3, #16]
 800273a:	4b81      	ldr	r3, [pc, #516]	@ (8002940 <HAL_RCC_ClockConfig+0x288>)
 800273c:	6a1b      	ldr	r3, [r3, #32]
 800273e:	091b      	lsrs	r3, r3, #4
 8002740:	f003 0370 	and.w	r3, r3, #112	@ 0x70
 8002744:	429a      	cmp	r2, r3
 8002746:	d909      	bls.n	800275c <HAL_RCC_ClockConfig+0xa4>
    {
      assert_param(IS_RCC_PCLK(pRCC_ClkInitStruct->APB2CLKDivider));
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE2, ((pRCC_ClkInitStruct->APB2CLKDivider) << 4));
 8002748:	4b7d      	ldr	r3, [pc, #500]	@ (8002940 <HAL_RCC_ClockConfig+0x288>)
 800274a:	6a1b      	ldr	r3, [r3, #32]
 800274c:	f423 62e0 	bic.w	r2, r3, #1792	@ 0x700
 8002750:	687b      	ldr	r3, [r7, #4]
 8002752:	691b      	ldr	r3, [r3, #16]
 8002754:	011b      	lsls	r3, r3, #4
 8002756:	497a      	ldr	r1, [pc, #488]	@ (8002940 <HAL_RCC_ClockConfig+0x288>)
 8002758:	4313      	orrs	r3, r2
 800275a:	620b      	str	r3, [r1, #32]
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800275c:	687b      	ldr	r3, [r7, #4]
 800275e:	681b      	ldr	r3, [r3, #0]
 8002760:	f003 0304 	and.w	r3, r3, #4
 8002764:	2b00      	cmp	r3, #0
 8002766:	d010      	beq.n	800278a <HAL_RCC_ClockConfig+0xd2>
  {
    if ((pRCC_ClkInitStruct->APB1CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE1))
 8002768:	687b      	ldr	r3, [r7, #4]
 800276a:	68da      	ldr	r2, [r3, #12]
 800276c:	4b74      	ldr	r3, [pc, #464]	@ (8002940 <HAL_RCC_ClockConfig+0x288>)
 800276e:	6a1b      	ldr	r3, [r3, #32]
 8002770:	f003 0370 	and.w	r3, r3, #112	@ 0x70
 8002774:	429a      	cmp	r2, r3
 8002776:	d908      	bls.n	800278a <HAL_RCC_ClockConfig+0xd2>
    {
      assert_param(IS_RCC_PCLK(pRCC_ClkInitStruct->APB1CLKDivider));
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE1, pRCC_ClkInitStruct->APB1CLKDivider);
 8002778:	4b71      	ldr	r3, [pc, #452]	@ (8002940 <HAL_RCC_ClockConfig+0x288>)
 800277a:	6a1b      	ldr	r3, [r3, #32]
 800277c:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
 8002780:	687b      	ldr	r3, [r7, #4]
 8002782:	68db      	ldr	r3, [r3, #12]
 8002784:	496e      	ldr	r1, [pc, #440]	@ (8002940 <HAL_RCC_ClockConfig+0x288>)
 8002786:	4313      	orrs	r3, r2
 8002788:	620b      	str	r3, [r1, #32]
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800278a:	687b      	ldr	r3, [r7, #4]
 800278c:	681b      	ldr	r3, [r3, #0]
 800278e:	f003 0302 	and.w	r3, r3, #2
 8002792:	2b00      	cmp	r3, #0
 8002794:	d010      	beq.n	80027b8 <HAL_RCC_ClockConfig+0x100>
  {
    if ((pRCC_ClkInitStruct->AHBCLKDivider) > (RCC->CFGR2 & RCC_CFGR2_HPRE))
 8002796:	687b      	ldr	r3, [r7, #4]
 8002798:	689a      	ldr	r2, [r3, #8]
 800279a:	4b69      	ldr	r3, [pc, #420]	@ (8002940 <HAL_RCC_ClockConfig+0x288>)
 800279c:	6a1b      	ldr	r3, [r3, #32]
 800279e:	f003 030f 	and.w	r3, r3, #15
 80027a2:	429a      	cmp	r2, r3
 80027a4:	d908      	bls.n	80027b8 <HAL_RCC_ClockConfig+0x100>
    {
      assert_param(IS_RCC_HCLK(pRCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_HPRE, pRCC_ClkInitStruct->AHBCLKDivider);
 80027a6:	4b66      	ldr	r3, [pc, #408]	@ (8002940 <HAL_RCC_ClockConfig+0x288>)
 80027a8:	6a1b      	ldr	r3, [r3, #32]
 80027aa:	f023 020f 	bic.w	r2, r3, #15
 80027ae:	687b      	ldr	r3, [r7, #4]
 80027b0:	689b      	ldr	r3, [r3, #8]
 80027b2:	4963      	ldr	r1, [pc, #396]	@ (8002940 <HAL_RCC_ClockConfig+0x288>)
 80027b4:	4313      	orrs	r3, r2
 80027b6:	620b      	str	r3, [r1, #32]
    }
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 80027b8:	687b      	ldr	r3, [r7, #4]
 80027ba:	681b      	ldr	r3, [r3, #0]
 80027bc:	f003 0301 	and.w	r3, r3, #1
 80027c0:	2b00      	cmp	r3, #0
 80027c2:	f000 80d2 	beq.w	800296a <HAL_RCC_ClockConfig+0x2b2>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(pRCC_ClkInitStruct->SYSCLKSource));
    FlagStatus  pwrclkchanged = RESET;
 80027c6:	2300      	movs	r3, #0
 80027c8:	75fb      	strb	r3, [r7, #23]

    /* PLL is selected as System Clock Source */
    if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 80027ca:	687b      	ldr	r3, [r7, #4]
 80027cc:	685b      	ldr	r3, [r3, #4]
 80027ce:	2b03      	cmp	r3, #3
 80027d0:	d143      	bne.n	800285a <HAL_RCC_ClockConfig+0x1a2>
    {
      if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 80027d2:	4b5b      	ldr	r3, [pc, #364]	@ (8002940 <HAL_RCC_ClockConfig+0x288>)
 80027d4:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 80027d8:	f003 0304 	and.w	r3, r3, #4
 80027dc:	2b00      	cmp	r3, #0
 80027de:	d110      	bne.n	8002802 <HAL_RCC_ClockConfig+0x14a>
      {
        __HAL_RCC_PWR_CLK_ENABLE();
 80027e0:	4b57      	ldr	r3, [pc, #348]	@ (8002940 <HAL_RCC_ClockConfig+0x288>)
 80027e2:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 80027e6:	4a56      	ldr	r2, [pc, #344]	@ (8002940 <HAL_RCC_ClockConfig+0x288>)
 80027e8:	f043 0304 	orr.w	r3, r3, #4
 80027ec:	f8c2 3094 	str.w	r3, [r2, #148]	@ 0x94
 80027f0:	4b53      	ldr	r3, [pc, #332]	@ (8002940 <HAL_RCC_ClockConfig+0x288>)
 80027f2:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 80027f6:	f003 0304 	and.w	r3, r3, #4
 80027fa:	60bb      	str	r3, [r7, #8]
 80027fc:	68bb      	ldr	r3, [r7, #8]
        pwrclkchanged = SET;
 80027fe:	2301      	movs	r3, #1
 8002800:	75fb      	strb	r3, [r7, #23]
      }
      tickstart = HAL_GetTick();
 8002802:	f7fe fbbb 	bl	8000f7c <HAL_GetTick>
 8002806:	6138      	str	r0, [r7, #16]
      /* Check if EPOD is enabled */
      if (READ_BIT(PWR->VOSR, PWR_VOSR_BOOSTEN) != 0U)
 8002808:	4b4e      	ldr	r3, [pc, #312]	@ (8002944 <HAL_RCC_ClockConfig+0x28c>)
 800280a:	68db      	ldr	r3, [r3, #12]
 800280c:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
 8002810:	2b00      	cmp	r3, #0
 8002812:	d00f      	beq.n	8002834 <HAL_RCC_ClockConfig+0x17c>
      {
        /* Wait till BOOST is ready */
        while (READ_BIT(PWR->VOSR, PWR_VOSR_BOOSTRDY) == 0U)
 8002814:	e008      	b.n	8002828 <HAL_RCC_ClockConfig+0x170>
        {
          if ((HAL_GetTick() - tickstart) > EPOD_TIMEOUT_VALUE)
 8002816:	f7fe fbb1 	bl	8000f7c <HAL_GetTick>
 800281a:	4602      	mov	r2, r0
 800281c:	693b      	ldr	r3, [r7, #16]
 800281e:	1ad3      	subs	r3, r2, r3
 8002820:	2b02      	cmp	r3, #2
 8002822:	d901      	bls.n	8002828 <HAL_RCC_ClockConfig+0x170>
          {
            return HAL_TIMEOUT;
 8002824:	2303      	movs	r3, #3
 8002826:	e12b      	b.n	8002a80 <HAL_RCC_ClockConfig+0x3c8>
        while (READ_BIT(PWR->VOSR, PWR_VOSR_BOOSTRDY) == 0U)
 8002828:	4b46      	ldr	r3, [pc, #280]	@ (8002944 <HAL_RCC_ClockConfig+0x28c>)
 800282a:	68db      	ldr	r3, [r3, #12]
 800282c:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 8002830:	2b00      	cmp	r3, #0
 8002832:	d0f0      	beq.n	8002816 <HAL_RCC_ClockConfig+0x15e>
          }
        }
      }

      /* Restore clock configuration if changed */
      if (pwrclkchanged == SET)
 8002834:	7dfb      	ldrb	r3, [r7, #23]
 8002836:	2b01      	cmp	r3, #1
 8002838:	d107      	bne.n	800284a <HAL_RCC_ClockConfig+0x192>
      {
        __HAL_RCC_PWR_CLK_DISABLE();
 800283a:	4b41      	ldr	r3, [pc, #260]	@ (8002940 <HAL_RCC_ClockConfig+0x288>)
 800283c:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8002840:	4a3f      	ldr	r2, [pc, #252]	@ (8002940 <HAL_RCC_ClockConfig+0x288>)
 8002842:	f023 0304 	bic.w	r3, r3, #4
 8002846:	f8c2 3094 	str.w	r3, [r2, #148]	@ 0x94
      }

      /* Check the PLL ready flag */
      if (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) == 0U)
 800284a:	4b3d      	ldr	r3, [pc, #244]	@ (8002940 <HAL_RCC_ClockConfig+0x288>)
 800284c:	681b      	ldr	r3, [r3, #0]
 800284e:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 8002852:	2b00      	cmp	r3, #0
 8002854:	d121      	bne.n	800289a <HAL_RCC_ClockConfig+0x1e2>
      {
        return HAL_ERROR;
 8002856:	2301      	movs	r3, #1
 8002858:	e112      	b.n	8002a80 <HAL_RCC_ClockConfig+0x3c8>
      }
    }
    else
    {
      /* HSE is selected as System Clock Source */
      if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800285a:	687b      	ldr	r3, [r7, #4]
 800285c:	685b      	ldr	r3, [r3, #4]
 800285e:	2b02      	cmp	r3, #2
 8002860:	d107      	bne.n	8002872 <HAL_RCC_ClockConfig+0x1ba>
      {
        /* Check the HSE ready flag */
        if (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8002862:	4b37      	ldr	r3, [pc, #220]	@ (8002940 <HAL_RCC_ClockConfig+0x288>)
 8002864:	681b      	ldr	r3, [r3, #0]
 8002866:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 800286a:	2b00      	cmp	r3, #0
 800286c:	d115      	bne.n	800289a <HAL_RCC_ClockConfig+0x1e2>
        {
          return HAL_ERROR;
 800286e:	2301      	movs	r3, #1
 8002870:	e106      	b.n	8002a80 <HAL_RCC_ClockConfig+0x3c8>
        }
      }
      /* MSI is selected as System Clock Source */
      else if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 8002872:	687b      	ldr	r3, [r7, #4]
 8002874:	685b      	ldr	r3, [r3, #4]
 8002876:	2b00      	cmp	r3, #0
 8002878:	d107      	bne.n	800288a <HAL_RCC_ClockConfig+0x1d2>
      {
        /* Check the MSI ready flag */
        if (READ_BIT(RCC->CR, RCC_CR_MSISRDY) == 0U)
 800287a:	4b31      	ldr	r3, [pc, #196]	@ (8002940 <HAL_RCC_ClockConfig+0x288>)
 800287c:	681b      	ldr	r3, [r3, #0]
 800287e:	f003 0304 	and.w	r3, r3, #4
 8002882:	2b00      	cmp	r3, #0
 8002884:	d109      	bne.n	800289a <HAL_RCC_ClockConfig+0x1e2>
        {
          return HAL_ERROR;
 8002886:	2301      	movs	r3, #1
 8002888:	e0fa      	b.n	8002a80 <HAL_RCC_ClockConfig+0x3c8>
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */
        if (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 800288a:	4b2d      	ldr	r3, [pc, #180]	@ (8002940 <HAL_RCC_ClockConfig+0x288>)
 800288c:	681b      	ldr	r3, [r3, #0]
 800288e:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8002892:	2b00      	cmp	r3, #0
 8002894:	d101      	bne.n	800289a <HAL_RCC_ClockConfig+0x1e2>
        {
          return HAL_ERROR;
 8002896:	2301      	movs	r3, #1
 8002898:	e0f2      	b.n	8002a80 <HAL_RCC_ClockConfig+0x3c8>
        }
      }
    }

    MODIFY_REG(RCC->CFGR1, RCC_CFGR1_SW, pRCC_ClkInitStruct->SYSCLKSource);
 800289a:	4b29      	ldr	r3, [pc, #164]	@ (8002940 <HAL_RCC_ClockConfig+0x288>)
 800289c:	69db      	ldr	r3, [r3, #28]
 800289e:	f023 0203 	bic.w	r2, r3, #3
 80028a2:	687b      	ldr	r3, [r7, #4]
 80028a4:	685b      	ldr	r3, [r3, #4]
 80028a6:	4926      	ldr	r1, [pc, #152]	@ (8002940 <HAL_RCC_ClockConfig+0x288>)
 80028a8:	4313      	orrs	r3, r2
 80028aa:	61cb      	str	r3, [r1, #28]

    tickstart = HAL_GetTick();
 80028ac:	f7fe fb66 	bl	8000f7c <HAL_GetTick>
 80028b0:	6138      	str	r0, [r7, #16]

    if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 80028b2:	687b      	ldr	r3, [r7, #4]
 80028b4:	685b      	ldr	r3, [r3, #4]
 80028b6:	2b03      	cmp	r3, #3
 80028b8:	d112      	bne.n	80028e0 <HAL_RCC_ClockConfig+0x228>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 80028ba:	e00a      	b.n	80028d2 <HAL_RCC_ClockConfig+0x21a>
      {
        if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80028bc:	f7fe fb5e 	bl	8000f7c <HAL_GetTick>
 80028c0:	4602      	mov	r2, r0
 80028c2:	693b      	ldr	r3, [r7, #16]
 80028c4:	1ad3      	subs	r3, r2, r3
 80028c6:	f241 3288 	movw	r2, #5000	@ 0x1388
 80028ca:	4293      	cmp	r3, r2
 80028cc:	d901      	bls.n	80028d2 <HAL_RCC_ClockConfig+0x21a>
        {
          return HAL_TIMEOUT;
 80028ce:	2303      	movs	r3, #3
 80028d0:	e0d6      	b.n	8002a80 <HAL_RCC_ClockConfig+0x3c8>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 80028d2:	4b1b      	ldr	r3, [pc, #108]	@ (8002940 <HAL_RCC_ClockConfig+0x288>)
 80028d4:	69db      	ldr	r3, [r3, #28]
 80028d6:	f003 030c 	and.w	r3, r3, #12
 80028da:	2b0c      	cmp	r3, #12
 80028dc:	d1ee      	bne.n	80028bc <HAL_RCC_ClockConfig+0x204>
 80028de:	e044      	b.n	800296a <HAL_RCC_ClockConfig+0x2b2>
        }
      }
    }
    else
    {
      if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80028e0:	687b      	ldr	r3, [r7, #4]
 80028e2:	685b      	ldr	r3, [r3, #4]
 80028e4:	2b02      	cmp	r3, #2
 80028e6:	d112      	bne.n	800290e <HAL_RCC_ClockConfig+0x256>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 80028e8:	e00a      	b.n	8002900 <HAL_RCC_ClockConfig+0x248>
        {
          if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80028ea:	f7fe fb47 	bl	8000f7c <HAL_GetTick>
 80028ee:	4602      	mov	r2, r0
 80028f0:	693b      	ldr	r3, [r7, #16]
 80028f2:	1ad3      	subs	r3, r2, r3
 80028f4:	f241 3288 	movw	r2, #5000	@ 0x1388
 80028f8:	4293      	cmp	r3, r2
 80028fa:	d901      	bls.n	8002900 <HAL_RCC_ClockConfig+0x248>
          {
            return HAL_TIMEOUT;
 80028fc:	2303      	movs	r3, #3
 80028fe:	e0bf      	b.n	8002a80 <HAL_RCC_ClockConfig+0x3c8>
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 8002900:	4b0f      	ldr	r3, [pc, #60]	@ (8002940 <HAL_RCC_ClockConfig+0x288>)
 8002902:	69db      	ldr	r3, [r3, #28]
 8002904:	f003 030c 	and.w	r3, r3, #12
 8002908:	2b08      	cmp	r3, #8
 800290a:	d1ee      	bne.n	80028ea <HAL_RCC_ClockConfig+0x232>
 800290c:	e02d      	b.n	800296a <HAL_RCC_ClockConfig+0x2b2>
          }
        }
      }
      else if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 800290e:	687b      	ldr	r3, [r7, #4]
 8002910:	685b      	ldr	r3, [r3, #4]
 8002912:	2b00      	cmp	r3, #0
 8002914:	d123      	bne.n	800295e <HAL_RCC_ClockConfig+0x2a6>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_MSI)
 8002916:	e00a      	b.n	800292e <HAL_RCC_ClockConfig+0x276>
        {
          if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8002918:	f7fe fb30 	bl	8000f7c <HAL_GetTick>
 800291c:	4602      	mov	r2, r0
 800291e:	693b      	ldr	r3, [r7, #16]
 8002920:	1ad3      	subs	r3, r2, r3
 8002922:	f241 3288 	movw	r2, #5000	@ 0x1388
 8002926:	4293      	cmp	r3, r2
 8002928:	d901      	bls.n	800292e <HAL_RCC_ClockConfig+0x276>
          {
            return HAL_TIMEOUT;
 800292a:	2303      	movs	r3, #3
 800292c:	e0a8      	b.n	8002a80 <HAL_RCC_ClockConfig+0x3c8>
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_MSI)
 800292e:	4b04      	ldr	r3, [pc, #16]	@ (8002940 <HAL_RCC_ClockConfig+0x288>)
 8002930:	69db      	ldr	r3, [r3, #28]
 8002932:	f003 030c 	and.w	r3, r3, #12
 8002936:	2b00      	cmp	r3, #0
 8002938:	d1ee      	bne.n	8002918 <HAL_RCC_ClockConfig+0x260>
 800293a:	e016      	b.n	800296a <HAL_RCC_ClockConfig+0x2b2>
 800293c:	40022000 	.word	0x40022000
 8002940:	46020c00 	.word	0x46020c00
 8002944:	46020800 	.word	0x46020800
      }
      else
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
        {
          if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8002948:	f7fe fb18 	bl	8000f7c <HAL_GetTick>
 800294c:	4602      	mov	r2, r0
 800294e:	693b      	ldr	r3, [r7, #16]
 8002950:	1ad3      	subs	r3, r2, r3
 8002952:	f241 3288 	movw	r2, #5000	@ 0x1388
 8002956:	4293      	cmp	r3, r2
 8002958:	d901      	bls.n	800295e <HAL_RCC_ClockConfig+0x2a6>
          {
            return HAL_TIMEOUT;
 800295a:	2303      	movs	r3, #3
 800295c:	e090      	b.n	8002a80 <HAL_RCC_ClockConfig+0x3c8>
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 800295e:	4b4a      	ldr	r3, [pc, #296]	@ (8002a88 <HAL_RCC_ClockConfig+0x3d0>)
 8002960:	69db      	ldr	r3, [r3, #28]
 8002962:	f003 030c 	and.w	r3, r3, #12
 8002966:	2b04      	cmp	r3, #4
 8002968:	d1ee      	bne.n	8002948 <HAL_RCC_ClockConfig+0x290>
    }
  }

  /* Decreasing the BUS frequency divider */
  /*-------------------------- HCLK Configuration --------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800296a:	687b      	ldr	r3, [r7, #4]
 800296c:	681b      	ldr	r3, [r3, #0]
 800296e:	f003 0302 	and.w	r3, r3, #2
 8002972:	2b00      	cmp	r3, #0
 8002974:	d010      	beq.n	8002998 <HAL_RCC_ClockConfig+0x2e0>
  {
    if ((pRCC_ClkInitStruct->AHBCLKDivider) < (RCC->CFGR2 & RCC_CFGR2_HPRE))
 8002976:	687b      	ldr	r3, [r7, #4]
 8002978:	689a      	ldr	r2, [r3, #8]
 800297a:	4b43      	ldr	r3, [pc, #268]	@ (8002a88 <HAL_RCC_ClockConfig+0x3d0>)
 800297c:	6a1b      	ldr	r3, [r3, #32]
 800297e:	f003 030f 	and.w	r3, r3, #15
 8002982:	429a      	cmp	r2, r3
 8002984:	d208      	bcs.n	8002998 <HAL_RCC_ClockConfig+0x2e0>
    {
      assert_param(IS_RCC_HCLK(pRCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_HPRE, pRCC_ClkInitStruct->AHBCLKDivider);
 8002986:	4b40      	ldr	r3, [pc, #256]	@ (8002a88 <HAL_RCC_ClockConfig+0x3d0>)
 8002988:	6a1b      	ldr	r3, [r3, #32]
 800298a:	f023 020f 	bic.w	r2, r3, #15
 800298e:	687b      	ldr	r3, [r7, #4]
 8002990:	689b      	ldr	r3, [r3, #8]
 8002992:	493d      	ldr	r1, [pc, #244]	@ (8002a88 <HAL_RCC_ClockConfig+0x3d0>)
 8002994:	4313      	orrs	r3, r2
 8002996:	620b      	str	r3, [r1, #32]
    }
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 8002998:	4b3c      	ldr	r3, [pc, #240]	@ (8002a8c <HAL_RCC_ClockConfig+0x3d4>)
 800299a:	681b      	ldr	r3, [r3, #0]
 800299c:	f003 030f 	and.w	r3, r3, #15
 80029a0:	683a      	ldr	r2, [r7, #0]
 80029a2:	429a      	cmp	r2, r3
 80029a4:	d210      	bcs.n	80029c8 <HAL_RCC_ClockConfig+0x310>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 80029a6:	4b39      	ldr	r3, [pc, #228]	@ (8002a8c <HAL_RCC_ClockConfig+0x3d4>)
 80029a8:	681b      	ldr	r3, [r3, #0]
 80029aa:	f023 020f 	bic.w	r2, r3, #15
 80029ae:	4937      	ldr	r1, [pc, #220]	@ (8002a8c <HAL_RCC_ClockConfig+0x3d4>)
 80029b0:	683b      	ldr	r3, [r7, #0]
 80029b2:	4313      	orrs	r3, r2
 80029b4:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 80029b6:	4b35      	ldr	r3, [pc, #212]	@ (8002a8c <HAL_RCC_ClockConfig+0x3d4>)
 80029b8:	681b      	ldr	r3, [r3, #0]
 80029ba:	f003 030f 	and.w	r3, r3, #15
 80029be:	683a      	ldr	r2, [r7, #0]
 80029c0:	429a      	cmp	r2, r3
 80029c2:	d001      	beq.n	80029c8 <HAL_RCC_ClockConfig+0x310>
    {
      return HAL_ERROR;
 80029c4:	2301      	movs	r3, #1
 80029c6:	e05b      	b.n	8002a80 <HAL_RCC_ClockConfig+0x3c8>
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80029c8:	687b      	ldr	r3, [r7, #4]
 80029ca:	681b      	ldr	r3, [r3, #0]
 80029cc:	f003 0304 	and.w	r3, r3, #4
 80029d0:	2b00      	cmp	r3, #0
 80029d2:	d010      	beq.n	80029f6 <HAL_RCC_ClockConfig+0x33e>
  {
    if ((pRCC_ClkInitStruct->APB1CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE1))
 80029d4:	687b      	ldr	r3, [r7, #4]
 80029d6:	68da      	ldr	r2, [r3, #12]
 80029d8:	4b2b      	ldr	r3, [pc, #172]	@ (8002a88 <HAL_RCC_ClockConfig+0x3d0>)
 80029da:	6a1b      	ldr	r3, [r3, #32]
 80029dc:	f003 0370 	and.w	r3, r3, #112	@ 0x70
 80029e0:	429a      	cmp	r2, r3
 80029e2:	d208      	bcs.n	80029f6 <HAL_RCC_ClockConfig+0x33e>
    {
      assert_param(IS_RCC_PCLK(pRCC_ClkInitStruct->APB1CLKDivider));
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE1, pRCC_ClkInitStruct->APB1CLKDivider);
 80029e4:	4b28      	ldr	r3, [pc, #160]	@ (8002a88 <HAL_RCC_ClockConfig+0x3d0>)
 80029e6:	6a1b      	ldr	r3, [r3, #32]
 80029e8:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
 80029ec:	687b      	ldr	r3, [r7, #4]
 80029ee:	68db      	ldr	r3, [r3, #12]
 80029f0:	4925      	ldr	r1, [pc, #148]	@ (8002a88 <HAL_RCC_ClockConfig+0x3d0>)
 80029f2:	4313      	orrs	r3, r2
 80029f4:	620b      	str	r3, [r1, #32]
    }
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 80029f6:	687b      	ldr	r3, [r7, #4]
 80029f8:	681b      	ldr	r3, [r3, #0]
 80029fa:	f003 0308 	and.w	r3, r3, #8
 80029fe:	2b00      	cmp	r3, #0
 8002a00:	d012      	beq.n	8002a28 <HAL_RCC_ClockConfig+0x370>
  {
    if ((pRCC_ClkInitStruct->APB2CLKDivider) < ((RCC->CFGR2 & RCC_CFGR2_PPRE2) >> 4))
 8002a02:	687b      	ldr	r3, [r7, #4]
 8002a04:	691a      	ldr	r2, [r3, #16]
 8002a06:	4b20      	ldr	r3, [pc, #128]	@ (8002a88 <HAL_RCC_ClockConfig+0x3d0>)
 8002a08:	6a1b      	ldr	r3, [r3, #32]
 8002a0a:	091b      	lsrs	r3, r3, #4
 8002a0c:	f003 0370 	and.w	r3, r3, #112	@ 0x70
 8002a10:	429a      	cmp	r2, r3
 8002a12:	d209      	bcs.n	8002a28 <HAL_RCC_ClockConfig+0x370>
    {
      assert_param(IS_RCC_PCLK(pRCC_ClkInitStruct->APB2CLKDivider));
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE2, ((pRCC_ClkInitStruct->APB2CLKDivider) << 4));
 8002a14:	4b1c      	ldr	r3, [pc, #112]	@ (8002a88 <HAL_RCC_ClockConfig+0x3d0>)
 8002a16:	6a1b      	ldr	r3, [r3, #32]
 8002a18:	f423 62e0 	bic.w	r2, r3, #1792	@ 0x700
 8002a1c:	687b      	ldr	r3, [r7, #4]
 8002a1e:	691b      	ldr	r3, [r3, #16]
 8002a20:	011b      	lsls	r3, r3, #4
 8002a22:	4919      	ldr	r1, [pc, #100]	@ (8002a88 <HAL_RCC_ClockConfig+0x3d0>)
 8002a24:	4313      	orrs	r3, r2
 8002a26:	620b      	str	r3, [r1, #32]
    }
  }

  /*-------------------------- PCLK3 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK3) == RCC_CLOCKTYPE_PCLK3)
 8002a28:	687b      	ldr	r3, [r7, #4]
 8002a2a:	681b      	ldr	r3, [r3, #0]
 8002a2c:	f003 0310 	and.w	r3, r3, #16
 8002a30:	2b00      	cmp	r3, #0
 8002a32:	d010      	beq.n	8002a56 <HAL_RCC_ClockConfig+0x39e>
  {
    if ((pRCC_ClkInitStruct->APB3CLKDivider) < (RCC->CFGR3 & RCC_CFGR3_PPRE3))
 8002a34:	687b      	ldr	r3, [r7, #4]
 8002a36:	695a      	ldr	r2, [r3, #20]
 8002a38:	4b13      	ldr	r3, [pc, #76]	@ (8002a88 <HAL_RCC_ClockConfig+0x3d0>)
 8002a3a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8002a3c:	f003 0370 	and.w	r3, r3, #112	@ 0x70
 8002a40:	429a      	cmp	r2, r3
 8002a42:	d208      	bcs.n	8002a56 <HAL_RCC_ClockConfig+0x39e>
    {
      assert_param(IS_RCC_PCLK(pRCC_ClkInitStruct->APB3CLKDivider));
      MODIFY_REG(RCC->CFGR3, RCC_CFGR3_PPRE3, (pRCC_ClkInitStruct->APB3CLKDivider));
 8002a44:	4b10      	ldr	r3, [pc, #64]	@ (8002a88 <HAL_RCC_ClockConfig+0x3d0>)
 8002a46:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8002a48:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
 8002a4c:	687b      	ldr	r3, [r7, #4]
 8002a4e:	695b      	ldr	r3, [r3, #20]
 8002a50:	490d      	ldr	r1, [pc, #52]	@ (8002a88 <HAL_RCC_ClockConfig+0x3d0>)
 8002a52:	4313      	orrs	r3, r2
 8002a54:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR2 & RCC_CFGR2_HPRE) >> RCC_CFGR2_HPRE_Pos];
 8002a56:	f000 f821 	bl	8002a9c <HAL_RCC_GetSysClockFreq>
 8002a5a:	4602      	mov	r2, r0
 8002a5c:	4b0a      	ldr	r3, [pc, #40]	@ (8002a88 <HAL_RCC_ClockConfig+0x3d0>)
 8002a5e:	6a1b      	ldr	r3, [r3, #32]
 8002a60:	f003 030f 	and.w	r3, r3, #15
 8002a64:	490a      	ldr	r1, [pc, #40]	@ (8002a90 <HAL_RCC_ClockConfig+0x3d8>)
 8002a66:	5ccb      	ldrb	r3, [r1, r3]
 8002a68:	fa22 f303 	lsr.w	r3, r2, r3
 8002a6c:	4a09      	ldr	r2, [pc, #36]	@ (8002a94 <HAL_RCC_ClockConfig+0x3dc>)
 8002a6e:	6013      	str	r3, [r2, #0]

  /* Configure the source of time base considering new system clocks settings*/
  status = HAL_InitTick(uwTickPrio);
 8002a70:	4b09      	ldr	r3, [pc, #36]	@ (8002a98 <HAL_RCC_ClockConfig+0x3e0>)
 8002a72:	681b      	ldr	r3, [r3, #0]
 8002a74:	4618      	mov	r0, r3
 8002a76:	f7fe f9f7 	bl	8000e68 <HAL_InitTick>
 8002a7a:	4603      	mov	r3, r0
 8002a7c:	73fb      	strb	r3, [r7, #15]

  return status;
 8002a7e:	7bfb      	ldrb	r3, [r7, #15]
}
 8002a80:	4618      	mov	r0, r3
 8002a82:	3718      	adds	r7, #24
 8002a84:	46bd      	mov	sp, r7
 8002a86:	bd80      	pop	{r7, pc}
 8002a88:	46020c00 	.word	0x46020c00
 8002a8c:	40022000 	.word	0x40022000
 8002a90:	0801168c 	.word	0x0801168c
 8002a94:	20000000 	.word	0x20000000
 8002a98:	2000000c 	.word	0x2000000c

08002a9c <HAL_RCC_GetSysClockFreq>:
  * @note   Each time SYSCLK changes, this function must be called to update the
  *         right SYSCLK value. Otherwise, any configuration based on this function will be incorrect.
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 8002a9c:	b480      	push	{r7}
 8002a9e:	b08b      	sub	sp, #44	@ 0x2c
 8002aa0:	af00      	add	r7, sp, #0
  uint32_t msirange = 0U;
 8002aa2:	2300      	movs	r3, #0
 8002aa4:	627b      	str	r3, [r7, #36]	@ 0x24
  uint32_t pllsource;
  uint32_t pllr;
  uint32_t pllm;
  uint32_t pllfracen;
  uint32_t sysclockfreq = 0U;
 8002aa6:	2300      	movs	r3, #0
 8002aa8:	623b      	str	r3, [r7, #32]
  uint32_t sysclk_source;
  uint32_t pll_oscsource;
  float_t fracn1;
  float_t pllvco;

  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 8002aaa:	4b78      	ldr	r3, [pc, #480]	@ (8002c8c <HAL_RCC_GetSysClockFreq+0x1f0>)
 8002aac:	69db      	ldr	r3, [r3, #28]
 8002aae:	f003 030c 	and.w	r3, r3, #12
 8002ab2:	61bb      	str	r3, [r7, #24]
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 8002ab4:	4b75      	ldr	r3, [pc, #468]	@ (8002c8c <HAL_RCC_GetSysClockFreq+0x1f0>)
 8002ab6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8002ab8:	f003 0303 	and.w	r3, r3, #3
 8002abc:	617b      	str	r3, [r7, #20]

  if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 8002abe:	69bb      	ldr	r3, [r7, #24]
 8002ac0:	2b00      	cmp	r3, #0
 8002ac2:	d005      	beq.n	8002ad0 <HAL_RCC_GetSysClockFreq+0x34>
 8002ac4:	69bb      	ldr	r3, [r7, #24]
 8002ac6:	2b0c      	cmp	r3, #12
 8002ac8:	d121      	bne.n	8002b0e <HAL_RCC_GetSysClockFreq+0x72>
      ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_oscsource == RCC_PLLSOURCE_MSI)))
 8002aca:	697b      	ldr	r3, [r7, #20]
 8002acc:	2b01      	cmp	r3, #1
 8002ace:	d11e      	bne.n	8002b0e <HAL_RCC_GetSysClockFreq+0x72>
  {
    /* MSI or PLL with MSI source used as system clock source */

    /* Get SYSCLK source */
    if (READ_BIT(RCC->ICSCR1, RCC_ICSCR1_MSIRGSEL) == 0U)
 8002ad0:	4b6e      	ldr	r3, [pc, #440]	@ (8002c8c <HAL_RCC_GetSysClockFreq+0x1f0>)
 8002ad2:	689b      	ldr	r3, [r3, #8]
 8002ad4:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 8002ad8:	2b00      	cmp	r3, #0
 8002ada:	d107      	bne.n	8002aec <HAL_RCC_GetSysClockFreq+0x50>
    {
      /* MSISRANGE from RCC_CSR applies */
      msirange = (RCC->CSR & RCC_CSR_MSISSRANGE) >> RCC_CSR_MSISSRANGE_Pos;
 8002adc:	4b6b      	ldr	r3, [pc, #428]	@ (8002c8c <HAL_RCC_GetSysClockFreq+0x1f0>)
 8002ade:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8002ae2:	0b1b      	lsrs	r3, r3, #12
 8002ae4:	f003 030f 	and.w	r3, r3, #15
 8002ae8:	627b      	str	r3, [r7, #36]	@ 0x24
 8002aea:	e005      	b.n	8002af8 <HAL_RCC_GetSysClockFreq+0x5c>
    }
    else
    {
      /* MSIRANGE from RCC_CR applies */
      msirange = (RCC->ICSCR1 & RCC_ICSCR1_MSISRANGE) >> RCC_ICSCR1_MSISRANGE_Pos;
 8002aec:	4b67      	ldr	r3, [pc, #412]	@ (8002c8c <HAL_RCC_GetSysClockFreq+0x1f0>)
 8002aee:	689b      	ldr	r3, [r3, #8]
 8002af0:	0f1b      	lsrs	r3, r3, #28
 8002af2:	f003 030f 	and.w	r3, r3, #15
 8002af6:	627b      	str	r3, [r7, #36]	@ 0x24
    }
    /*MSI frequency range in HZ*/
    msirange = MSIRangeTable[msirange];
 8002af8:	4a65      	ldr	r2, [pc, #404]	@ (8002c90 <HAL_RCC_GetSysClockFreq+0x1f4>)
 8002afa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8002afc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8002b00:	627b      	str	r3, [r7, #36]	@ 0x24

    if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI)
 8002b02:	69bb      	ldr	r3, [r7, #24]
 8002b04:	2b00      	cmp	r3, #0
 8002b06:	d110      	bne.n	8002b2a <HAL_RCC_GetSysClockFreq+0x8e>
    {
      /* MSI used as system clock source */
      sysclockfreq = msirange;
 8002b08:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8002b0a:	623b      	str	r3, [r7, #32]
    if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI)
 8002b0c:	e00d      	b.n	8002b2a <HAL_RCC_GetSysClockFreq+0x8e>
    }
  }
  else if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI)
 8002b0e:	4b5f      	ldr	r3, [pc, #380]	@ (8002c8c <HAL_RCC_GetSysClockFreq+0x1f0>)
 8002b10:	69db      	ldr	r3, [r3, #28]
 8002b12:	f003 030c 	and.w	r3, r3, #12
 8002b16:	2b04      	cmp	r3, #4
 8002b18:	d102      	bne.n	8002b20 <HAL_RCC_GetSysClockFreq+0x84>
  {
    /* HSI used as system clock source */
    sysclockfreq = HSI_VALUE;
 8002b1a:	4b5e      	ldr	r3, [pc, #376]	@ (8002c94 <HAL_RCC_GetSysClockFreq+0x1f8>)
 8002b1c:	623b      	str	r3, [r7, #32]
 8002b1e:	e004      	b.n	8002b2a <HAL_RCC_GetSysClockFreq+0x8e>
  }
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE)
 8002b20:	69bb      	ldr	r3, [r7, #24]
 8002b22:	2b08      	cmp	r3, #8
 8002b24:	d101      	bne.n	8002b2a <HAL_RCC_GetSysClockFreq+0x8e>
  {
    /* HSE used as system clock source */
    sysclockfreq = HSE_VALUE;
 8002b26:	4b5b      	ldr	r3, [pc, #364]	@ (8002c94 <HAL_RCC_GetSysClockFreq+0x1f8>)
 8002b28:	623b      	str	r3, [r7, #32]
  else
  {
    /* Nothing to do */
  }

  if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8002b2a:	69bb      	ldr	r3, [r7, #24]
 8002b2c:	2b0c      	cmp	r3, #12
 8002b2e:	f040 80a5 	bne.w	8002c7c <HAL_RCC_GetSysClockFreq+0x1e0>
  {
    /* PLL used as system clock  source
       PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLN
       SYSCLK = PLL_VCO / PLLR
    */
    pllsource = (RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1SRC);
 8002b32:	4b56      	ldr	r3, [pc, #344]	@ (8002c8c <HAL_RCC_GetSysClockFreq+0x1f0>)
 8002b34:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8002b36:	f003 0303 	and.w	r3, r3, #3
 8002b3a:	613b      	str	r3, [r7, #16]
    pllm = ((RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1M) >> RCC_PLL1CFGR_PLL1M_Pos) + 1U;
 8002b3c:	4b53      	ldr	r3, [pc, #332]	@ (8002c8c <HAL_RCC_GetSysClockFreq+0x1f0>)
 8002b3e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8002b40:	0a1b      	lsrs	r3, r3, #8
 8002b42:	f003 030f 	and.w	r3, r3, #15
 8002b46:	3301      	adds	r3, #1
 8002b48:	60fb      	str	r3, [r7, #12]
    pllfracen = ((RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1FRACEN) >> RCC_PLL1CFGR_PLL1FRACEN_Pos);
 8002b4a:	4b50      	ldr	r3, [pc, #320]	@ (8002c8c <HAL_RCC_GetSysClockFreq+0x1f0>)
 8002b4c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8002b4e:	091b      	lsrs	r3, r3, #4
 8002b50:	f003 0301 	and.w	r3, r3, #1
 8002b54:	60bb      	str	r3, [r7, #8]
    fracn1 = (float_t)(uint32_t)(pllfracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_PLL1FRACN) >> \
 8002b56:	4b4d      	ldr	r3, [pc, #308]	@ (8002c8c <HAL_RCC_GetSysClockFreq+0x1f0>)
 8002b58:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8002b5a:	08db      	lsrs	r3, r3, #3
 8002b5c:	f3c3 030c 	ubfx	r3, r3, #0, #13
 8002b60:	68ba      	ldr	r2, [r7, #8]
 8002b62:	fb02 f303 	mul.w	r3, r2, r3
 8002b66:	ee07 3a90 	vmov	s15, r3
 8002b6a:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8002b6e:	edc7 7a01 	vstr	s15, [r7, #4]
                                              RCC_PLL1FRACR_PLL1FRACN_Pos));

    switch (pllsource)
 8002b72:	693b      	ldr	r3, [r7, #16]
 8002b74:	2b02      	cmp	r3, #2
 8002b76:	d003      	beq.n	8002b80 <HAL_RCC_GetSysClockFreq+0xe4>
 8002b78:	693b      	ldr	r3, [r7, #16]
 8002b7a:	2b03      	cmp	r3, #3
 8002b7c:	d022      	beq.n	8002bc4 <HAL_RCC_GetSysClockFreq+0x128>
 8002b7e:	e043      	b.n	8002c08 <HAL_RCC_GetSysClockFreq+0x16c>
    {
      case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
        pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 8002b80:	68fb      	ldr	r3, [r7, #12]
 8002b82:	ee07 3a90 	vmov	s15, r3
 8002b86:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8002b8a:	eddf 6a43 	vldr	s13, [pc, #268]	@ 8002c98 <HAL_RCC_GetSysClockFreq+0x1fc>
 8002b8e:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8002b92:	4b3e      	ldr	r3, [pc, #248]	@ (8002c8c <HAL_RCC_GetSysClockFreq+0x1f0>)
 8002b94:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8002b96:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8002b9a:	ee07 3a90 	vmov	s15, r3
 8002b9e:	eef8 6a67 	vcvt.f32.u32	s13, s15
                                                         (fracn1 / (float_t)0x2000) + (float_t)1U);
 8002ba2:	ed97 6a01 	vldr	s12, [r7, #4]
 8002ba6:	eddf 5a3d 	vldr	s11, [pc, #244]	@ 8002c9c <HAL_RCC_GetSysClockFreq+0x200>
 8002baa:	eec6 7a25 	vdiv.f32	s15, s12, s11
        pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 8002bae:	ee76 7aa7 	vadd.f32	s15, s13, s15
                                                         (fracn1 / (float_t)0x2000) + (float_t)1U);
 8002bb2:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8002bb6:	ee77 7aa6 	vadd.f32	s15, s15, s13
        pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 8002bba:	ee67 7a27 	vmul.f32	s15, s14, s15
 8002bbe:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 8002bc2:	e046      	b.n	8002c52 <HAL_RCC_GetSysClockFreq+0x1b6>

      case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
        pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 8002bc4:	68fb      	ldr	r3, [r7, #12]
 8002bc6:	ee07 3a90 	vmov	s15, r3
 8002bca:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8002bce:	eddf 6a32 	vldr	s13, [pc, #200]	@ 8002c98 <HAL_RCC_GetSysClockFreq+0x1fc>
 8002bd2:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8002bd6:	4b2d      	ldr	r3, [pc, #180]	@ (8002c8c <HAL_RCC_GetSysClockFreq+0x1f0>)
 8002bd8:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8002bda:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8002bde:	ee07 3a90 	vmov	s15, r3
 8002be2:	eef8 6a67 	vcvt.f32.u32	s13, s15
                                                         (fracn1 / (float_t)0x2000) + (float_t)1U);
 8002be6:	ed97 6a01 	vldr	s12, [r7, #4]
 8002bea:	eddf 5a2c 	vldr	s11, [pc, #176]	@ 8002c9c <HAL_RCC_GetSysClockFreq+0x200>
 8002bee:	eec6 7a25 	vdiv.f32	s15, s12, s11
        pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 8002bf2:	ee76 7aa7 	vadd.f32	s15, s13, s15
                                                         (fracn1 / (float_t)0x2000) + (float_t)1U);
 8002bf6:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8002bfa:	ee77 7aa6 	vadd.f32	s15, s15, s13
        pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 8002bfe:	ee67 7a27 	vmul.f32	s15, s14, s15
 8002c02:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 8002c06:	e024      	b.n	8002c52 <HAL_RCC_GetSysClockFreq+0x1b6>

      case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
      default:
        pllvco = ((float_t) msirange / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 8002c08:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8002c0a:	ee07 3a90 	vmov	s15, r3
 8002c0e:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8002c12:	68fb      	ldr	r3, [r7, #12]
 8002c14:	ee07 3a90 	vmov	s15, r3
 8002c18:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8002c1c:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8002c20:	4b1a      	ldr	r3, [pc, #104]	@ (8002c8c <HAL_RCC_GetSysClockFreq+0x1f0>)
 8002c22:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8002c24:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8002c28:	ee07 3a90 	vmov	s15, r3
 8002c2c:	eef8 6a67 	vcvt.f32.u32	s13, s15
                                                         (fracn1 / (float_t)0x2000) + (float_t)1U);
 8002c30:	ed97 6a01 	vldr	s12, [r7, #4]
 8002c34:	eddf 5a19 	vldr	s11, [pc, #100]	@ 8002c9c <HAL_RCC_GetSysClockFreq+0x200>
 8002c38:	eec6 7a25 	vdiv.f32	s15, s12, s11
        pllvco = ((float_t) msirange / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 8002c3c:	ee76 7aa7 	vadd.f32	s15, s13, s15
                                                         (fracn1 / (float_t)0x2000) + (float_t)1U);
 8002c40:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8002c44:	ee77 7aa6 	vadd.f32	s15, s15, s13
        pllvco = ((float_t) msirange / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 8002c48:	ee67 7a27 	vmul.f32	s15, s14, s15
 8002c4c:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 8002c50:	bf00      	nop
    }

    pllr = (((RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1R) >> RCC_PLL1DIVR_PLL1R_Pos) + 1U);
 8002c52:	4b0e      	ldr	r3, [pc, #56]	@ (8002c8c <HAL_RCC_GetSysClockFreq+0x1f0>)
 8002c54:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8002c56:	0e1b      	lsrs	r3, r3, #24
 8002c58:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8002c5c:	3301      	adds	r3, #1
 8002c5e:	603b      	str	r3, [r7, #0]
    sysclockfreq = (uint32_t)(float_t)((float_t)pllvco / (float_t)pllr);
 8002c60:	683b      	ldr	r3, [r7, #0]
 8002c62:	ee07 3a90 	vmov	s15, r3
 8002c66:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 8002c6a:	edd7 6a07 	vldr	s13, [r7, #28]
 8002c6e:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8002c72:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8002c76:	ee17 3a90 	vmov	r3, s15
 8002c7a:	623b      	str	r3, [r7, #32]
  }

  return sysclockfreq;
 8002c7c:	6a3b      	ldr	r3, [r7, #32]
}
 8002c7e:	4618      	mov	r0, r3
 8002c80:	372c      	adds	r7, #44	@ 0x2c
 8002c82:	46bd      	mov	sp, r7
 8002c84:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002c88:	4770      	bx	lr
 8002c8a:	bf00      	nop
 8002c8c:	46020c00 	.word	0x46020c00
 8002c90:	080116a4 	.word	0x080116a4
 8002c94:	00f42400 	.word	0x00f42400
 8002c98:	4b742400 	.word	0x4b742400
 8002c9c:	46000000 	.word	0x46000000

08002ca0 <HAL_RCC_GetHCLKFreq>:
  *
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency.
  * @retval HCLK frequency in Hz
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 8002ca0:	b580      	push	{r7, lr}
 8002ca2:	af00      	add	r7, sp, #0
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR2 & RCC_CFGR2_HPRE) >> RCC_CFGR2_HPRE_Pos];
 8002ca4:	f7ff fefa 	bl	8002a9c <HAL_RCC_GetSysClockFreq>
 8002ca8:	4602      	mov	r2, r0
 8002caa:	4b07      	ldr	r3, [pc, #28]	@ (8002cc8 <HAL_RCC_GetHCLKFreq+0x28>)
 8002cac:	6a1b      	ldr	r3, [r3, #32]
 8002cae:	f003 030f 	and.w	r3, r3, #15
 8002cb2:	4906      	ldr	r1, [pc, #24]	@ (8002ccc <HAL_RCC_GetHCLKFreq+0x2c>)
 8002cb4:	5ccb      	ldrb	r3, [r1, r3]
 8002cb6:	fa22 f303 	lsr.w	r3, r2, r3
 8002cba:	4a05      	ldr	r2, [pc, #20]	@ (8002cd0 <HAL_RCC_GetHCLKFreq+0x30>)
 8002cbc:	6013      	str	r3, [r2, #0]
  return SystemCoreClock;
 8002cbe:	4b04      	ldr	r3, [pc, #16]	@ (8002cd0 <HAL_RCC_GetHCLKFreq+0x30>)
 8002cc0:	681b      	ldr	r3, [r3, #0]
}
 8002cc2:	4618      	mov	r0, r3
 8002cc4:	bd80      	pop	{r7, pc}
 8002cc6:	bf00      	nop
 8002cc8:	46020c00 	.word	0x46020c00
 8002ccc:	0801168c 	.word	0x0801168c
 8002cd0:	20000000 	.word	0x20000000

08002cd4 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 8002cd4:	b580      	push	{r7, lr}
 8002cd6:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR2 & RCC_CFGR2_PPRE1) >> RCC_CFGR2_PPRE1_Pos]);
 8002cd8:	f7ff ffe2 	bl	8002ca0 <HAL_RCC_GetHCLKFreq>
 8002cdc:	4602      	mov	r2, r0
 8002cde:	4b05      	ldr	r3, [pc, #20]	@ (8002cf4 <HAL_RCC_GetPCLK1Freq+0x20>)
 8002ce0:	6a1b      	ldr	r3, [r3, #32]
 8002ce2:	091b      	lsrs	r3, r3, #4
 8002ce4:	f003 0307 	and.w	r3, r3, #7
 8002ce8:	4903      	ldr	r1, [pc, #12]	@ (8002cf8 <HAL_RCC_GetPCLK1Freq+0x24>)
 8002cea:	5ccb      	ldrb	r3, [r1, r3]
 8002cec:	fa22 f303 	lsr.w	r3, r2, r3
}
 8002cf0:	4618      	mov	r0, r3
 8002cf2:	bd80      	pop	{r7, pc}
 8002cf4:	46020c00 	.word	0x46020c00
 8002cf8:	0801169c 	.word	0x0801169c

08002cfc <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 8002cfc:	b580      	push	{r7, lr}
 8002cfe:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR2 & RCC_CFGR2_PPRE2) >> RCC_CFGR2_PPRE2_Pos]);
 8002d00:	f7ff ffce 	bl	8002ca0 <HAL_RCC_GetHCLKFreq>
 8002d04:	4602      	mov	r2, r0
 8002d06:	4b05      	ldr	r3, [pc, #20]	@ (8002d1c <HAL_RCC_GetPCLK2Freq+0x20>)
 8002d08:	6a1b      	ldr	r3, [r3, #32]
 8002d0a:	0a1b      	lsrs	r3, r3, #8
 8002d0c:	f003 0307 	and.w	r3, r3, #7
 8002d10:	4903      	ldr	r1, [pc, #12]	@ (8002d20 <HAL_RCC_GetPCLK2Freq+0x24>)
 8002d12:	5ccb      	ldrb	r3, [r1, r3]
 8002d14:	fa22 f303 	lsr.w	r3, r2, r3
}
 8002d18:	4618      	mov	r0, r3
 8002d1a:	bd80      	pop	{r7, pc}
 8002d1c:	46020c00 	.word	0x46020c00
 8002d20:	0801169c 	.word	0x0801169c

08002d24 <HAL_RCC_GetPCLK3Freq>:
  * @note   Each time PCLK3 changes, this function must be called to update the
  *         right PCLK3 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK3 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK3Freq(void)
{
 8002d24:	b580      	push	{r7, lr}
 8002d26:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR3 & RCC_CFGR3_PPRE3) >> RCC_CFGR3_PPRE3_Pos]);
 8002d28:	f7ff ffba 	bl	8002ca0 <HAL_RCC_GetHCLKFreq>
 8002d2c:	4602      	mov	r2, r0
 8002d2e:	4b05      	ldr	r3, [pc, #20]	@ (8002d44 <HAL_RCC_GetPCLK3Freq+0x20>)
 8002d30:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8002d32:	091b      	lsrs	r3, r3, #4
 8002d34:	f003 0307 	and.w	r3, r3, #7
 8002d38:	4903      	ldr	r1, [pc, #12]	@ (8002d48 <HAL_RCC_GetPCLK3Freq+0x24>)
 8002d3a:	5ccb      	ldrb	r3, [r1, r3]
 8002d3c:	fa22 f303 	lsr.w	r3, r2, r3
}
 8002d40:	4618      	mov	r0, r3
 8002d42:	bd80      	pop	{r7, pc}
 8002d44:	46020c00 	.word	0x46020c00
 8002d48:	0801169c 	.word	0x0801169c

08002d4c <RCC_SetFlashLatencyFromMSIRange>:
            voltage range.
  * @param  msirange  MSI range value from RCC_MSIRANGE_0 to RCC_MSIRANGE_15
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
{
 8002d4c:	b580      	push	{r7, lr}
 8002d4e:	b086      	sub	sp, #24
 8002d50:	af00      	add	r7, sp, #0
 8002d52:	6078      	str	r0, [r7, #4]
  uint32_t vos;
  uint32_t latency;  /* default value 0WS */

  if (__HAL_RCC_PWR_IS_CLK_ENABLED())
 8002d54:	4b3e      	ldr	r3, [pc, #248]	@ (8002e50 <RCC_SetFlashLatencyFromMSIRange+0x104>)
 8002d56:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8002d5a:	f003 0304 	and.w	r3, r3, #4
 8002d5e:	2b00      	cmp	r3, #0
 8002d60:	d003      	beq.n	8002d6a <RCC_SetFlashLatencyFromMSIRange+0x1e>
  {
    vos = HAL_PWREx_GetVoltageRange();
 8002d62:	f7fe fd6f 	bl	8001844 <HAL_PWREx_GetVoltageRange>
 8002d66:	6178      	str	r0, [r7, #20]
 8002d68:	e019      	b.n	8002d9e <RCC_SetFlashLatencyFromMSIRange+0x52>
  }
  else
  {
    __HAL_RCC_PWR_CLK_ENABLE();
 8002d6a:	4b39      	ldr	r3, [pc, #228]	@ (8002e50 <RCC_SetFlashLatencyFromMSIRange+0x104>)
 8002d6c:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8002d70:	4a37      	ldr	r2, [pc, #220]	@ (8002e50 <RCC_SetFlashLatencyFromMSIRange+0x104>)
 8002d72:	f043 0304 	orr.w	r3, r3, #4
 8002d76:	f8c2 3094 	str.w	r3, [r2, #148]	@ 0x94
 8002d7a:	4b35      	ldr	r3, [pc, #212]	@ (8002e50 <RCC_SetFlashLatencyFromMSIRange+0x104>)
 8002d7c:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8002d80:	f003 0304 	and.w	r3, r3, #4
 8002d84:	60fb      	str	r3, [r7, #12]
 8002d86:	68fb      	ldr	r3, [r7, #12]
    vos = HAL_PWREx_GetVoltageRange();
 8002d88:	f7fe fd5c 	bl	8001844 <HAL_PWREx_GetVoltageRange>
 8002d8c:	6178      	str	r0, [r7, #20]
    __HAL_RCC_PWR_CLK_DISABLE();
 8002d8e:	4b30      	ldr	r3, [pc, #192]	@ (8002e50 <RCC_SetFlashLatencyFromMSIRange+0x104>)
 8002d90:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8002d94:	4a2e      	ldr	r2, [pc, #184]	@ (8002e50 <RCC_SetFlashLatencyFromMSIRange+0x104>)
 8002d96:	f023 0304 	bic.w	r3, r3, #4
 8002d9a:	f8c2 3094 	str.w	r3, [r2, #148]	@ 0x94
  }

  if ((vos == PWR_REGULATOR_VOLTAGE_SCALE1) || (vos == PWR_REGULATOR_VOLTAGE_SCALE2))
 8002d9e:	697b      	ldr	r3, [r7, #20]
 8002da0:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
 8002da4:	d003      	beq.n	8002dae <RCC_SetFlashLatencyFromMSIRange+0x62>
 8002da6:	697b      	ldr	r3, [r7, #20]
 8002da8:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8002dac:	d109      	bne.n	8002dc2 <RCC_SetFlashLatencyFromMSIRange+0x76>
  {

    if (msirange < RCC_MSIRANGE_1)
 8002dae:	687b      	ldr	r3, [r7, #4]
 8002db0:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 8002db4:	d202      	bcs.n	8002dbc <RCC_SetFlashLatencyFromMSIRange+0x70>
    {
      /* MSI = 48Mhz */
      latency = FLASH_LATENCY_1; /* 1WS */
 8002db6:	2301      	movs	r3, #1
 8002db8:	613b      	str	r3, [r7, #16]
    if (msirange < RCC_MSIRANGE_1)
 8002dba:	e033      	b.n	8002e24 <RCC_SetFlashLatencyFromMSIRange+0xd8>
    }
    else
    {
      /*  MSI < 48Mhz */
      latency = FLASH_LATENCY_0; /* 0WS */
 8002dbc:	2300      	movs	r3, #0
 8002dbe:	613b      	str	r3, [r7, #16]
    if (msirange < RCC_MSIRANGE_1)
 8002dc0:	e030      	b.n	8002e24 <RCC_SetFlashLatencyFromMSIRange+0xd8>
    }
  }
  else
  {
    if (msirange < RCC_MSIRANGE_1)
 8002dc2:	687b      	ldr	r3, [r7, #4]
 8002dc4:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 8002dc8:	d208      	bcs.n	8002ddc <RCC_SetFlashLatencyFromMSIRange+0x90>
    {
      /* MSI = 48Mhz */
      if (vos == PWR_REGULATOR_VOLTAGE_SCALE3)
 8002dca:	697b      	ldr	r3, [r7, #20]
 8002dcc:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8002dd0:	d102      	bne.n	8002dd8 <RCC_SetFlashLatencyFromMSIRange+0x8c>
      {
        latency = FLASH_LATENCY_3; /* 3WS */
 8002dd2:	2303      	movs	r3, #3
 8002dd4:	613b      	str	r3, [r7, #16]
 8002dd6:	e025      	b.n	8002e24 <RCC_SetFlashLatencyFromMSIRange+0xd8>
      }
      else
      {
        return HAL_ERROR;
 8002dd8:	2301      	movs	r3, #1
 8002dda:	e035      	b.n	8002e48 <RCC_SetFlashLatencyFromMSIRange+0xfc>
      }
    }
    else
    {
      if (msirange > RCC_MSIRANGE_2)
 8002ddc:	687b      	ldr	r3, [r7, #4]
 8002dde:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8002de2:	d90f      	bls.n	8002e04 <RCC_SetFlashLatencyFromMSIRange+0xb8>
      {
        if (vos == PWR_REGULATOR_VOLTAGE_SCALE4)
 8002de4:	697b      	ldr	r3, [r7, #20]
 8002de6:	2b00      	cmp	r3, #0
 8002de8:	d109      	bne.n	8002dfe <RCC_SetFlashLatencyFromMSIRange+0xb2>
        {
          if (msirange > RCC_MSIRANGE_3)
 8002dea:	687b      	ldr	r3, [r7, #4]
 8002dec:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
 8002df0:	d902      	bls.n	8002df8 <RCC_SetFlashLatencyFromMSIRange+0xac>
          {
            latency = FLASH_LATENCY_0; /* 1WS */
 8002df2:	2300      	movs	r3, #0
 8002df4:	613b      	str	r3, [r7, #16]
 8002df6:	e015      	b.n	8002e24 <RCC_SetFlashLatencyFromMSIRange+0xd8>
          }
          else
          {
            latency = FLASH_LATENCY_1; /* 0WS */
 8002df8:	2301      	movs	r3, #1
 8002dfa:	613b      	str	r3, [r7, #16]
 8002dfc:	e012      	b.n	8002e24 <RCC_SetFlashLatencyFromMSIRange+0xd8>
          }
        }
        else
        {
          latency = FLASH_LATENCY_0; /* 0WS */
 8002dfe:	2300      	movs	r3, #0
 8002e00:	613b      	str	r3, [r7, #16]
 8002e02:	e00f      	b.n	8002e24 <RCC_SetFlashLatencyFromMSIRange+0xd8>
        }
      }
      else
      {
        if (msirange == RCC_MSIRANGE_1)
 8002e04:	687b      	ldr	r3, [r7, #4]
 8002e06:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 8002e0a:	d109      	bne.n	8002e20 <RCC_SetFlashLatencyFromMSIRange+0xd4>
        {
          if (vos == PWR_REGULATOR_VOLTAGE_SCALE3)
 8002e0c:	697b      	ldr	r3, [r7, #20]
 8002e0e:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8002e12:	d102      	bne.n	8002e1a <RCC_SetFlashLatencyFromMSIRange+0xce>
          {
            latency = FLASH_LATENCY_1; /* 1WS */
 8002e14:	2301      	movs	r3, #1
 8002e16:	613b      	str	r3, [r7, #16]
 8002e18:	e004      	b.n	8002e24 <RCC_SetFlashLatencyFromMSIRange+0xd8>
          }
          else
          {
            latency = FLASH_LATENCY_2; /* 2WS */
 8002e1a:	2302      	movs	r3, #2
 8002e1c:	613b      	str	r3, [r7, #16]
 8002e1e:	e001      	b.n	8002e24 <RCC_SetFlashLatencyFromMSIRange+0xd8>
          }
        }
        else
        {
          latency = FLASH_LATENCY_1; /* 1WS */
 8002e20:	2301      	movs	r3, #1
 8002e22:	613b      	str	r3, [r7, #16]
        }
      }
    }
  }

  __HAL_FLASH_SET_LATENCY(latency);
 8002e24:	4b0b      	ldr	r3, [pc, #44]	@ (8002e54 <RCC_SetFlashLatencyFromMSIRange+0x108>)
 8002e26:	681b      	ldr	r3, [r3, #0]
 8002e28:	f023 020f 	bic.w	r2, r3, #15
 8002e2c:	4909      	ldr	r1, [pc, #36]	@ (8002e54 <RCC_SetFlashLatencyFromMSIRange+0x108>)
 8002e2e:	693b      	ldr	r3, [r7, #16]
 8002e30:	4313      	orrs	r3, r2
 8002e32:	600b      	str	r3, [r1, #0]

  /* Check that the new number of wait states is taken into account to access the Flash
  memory by reading the FLASH_ACR register */
  if ((FLASH->ACR & FLASH_ACR_LATENCY) != latency)
 8002e34:	4b07      	ldr	r3, [pc, #28]	@ (8002e54 <RCC_SetFlashLatencyFromMSIRange+0x108>)
 8002e36:	681b      	ldr	r3, [r3, #0]
 8002e38:	f003 030f 	and.w	r3, r3, #15
 8002e3c:	693a      	ldr	r2, [r7, #16]
 8002e3e:	429a      	cmp	r2, r3
 8002e40:	d001      	beq.n	8002e46 <RCC_SetFlashLatencyFromMSIRange+0xfa>
  {
    return HAL_ERROR;
 8002e42:	2301      	movs	r3, #1
 8002e44:	e000      	b.n	8002e48 <RCC_SetFlashLatencyFromMSIRange+0xfc>
  }

  return HAL_OK;
 8002e46:	2300      	movs	r3, #0
}
 8002e48:	4618      	mov	r0, r3
 8002e4a:	3718      	adds	r7, #24
 8002e4c:	46bd      	mov	sp, r7
 8002e4e:	bd80      	pop	{r7, pc}
 8002e50:	46020c00 	.word	0x46020c00
 8002e54:	40022000 	.word	0x40022000

08002e58 <HAL_RCCEx_PeriphCLKConfig>:
  * @retval HAL status
  *
  *         (*) value not defined in all devices.
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(const RCC_PeriphCLKInitTypeDef  *pPeriphClkInit)
{
 8002e58:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8002e5c:	b0b6      	sub	sp, #216	@ 0xd8
 8002e5e:	af00      	add	r7, sp, #0
 8002e60:	f8c7 00c4 	str.w	r0, [r7, #196]	@ 0xc4
  uint32_t tmpregister;
  uint32_t tickstart;
  HAL_StatusTypeDef ret = HAL_OK;      /* Intermediate status */
 8002e64:	2300      	movs	r3, #0
 8002e66:	f887 30d3 	strb.w	r3, [r7, #211]	@ 0xd3
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
 8002e6a:	2300      	movs	r3, #0
 8002e6c:	f887 30d2 	strb.w	r3, [r7, #210]	@ 0xd2

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(pPeriphClkInit->PeriphClockSelection));

  /*-------------------------- USART1 clock source configuration -------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8002e70:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8002e74:	e9d3 2300 	ldrd	r2, r3, [r3]
 8002e78:	f002 0401 	and.w	r4, r2, #1
 8002e7c:	2500      	movs	r5, #0
 8002e7e:	ea54 0305 	orrs.w	r3, r4, r5
 8002e82:	d00b      	beq.n	8002e9c <HAL_RCCEx_PeriphCLKConfig+0x44>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(pPeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(pPeriphClkInit->Usart1ClockSelection);
 8002e84:	4bc5      	ldr	r3, [pc, #788]	@ (800319c <HAL_RCCEx_PeriphCLKConfig+0x344>)
 8002e86:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8002e8a:	f023 0103 	bic.w	r1, r3, #3
 8002e8e:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8002e92:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8002e94:	4ac1      	ldr	r2, [pc, #772]	@ (800319c <HAL_RCCEx_PeriphCLKConfig+0x344>)
 8002e96:	430b      	orrs	r3, r1
 8002e98:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
    __HAL_RCC_USART2_CONFIG(pPeriphClkInit->Usart2ClockSelection);
  }
#endif /* USART2 */

  /*-------------------------- USART3 clock source configuration -------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 8002e9c:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8002ea0:	e9d3 2300 	ldrd	r2, r3, [r3]
 8002ea4:	f002 0804 	and.w	r8, r2, #4
 8002ea8:	f04f 0900 	mov.w	r9, #0
 8002eac:	ea58 0309 	orrs.w	r3, r8, r9
 8002eb0:	d00b      	beq.n	8002eca <HAL_RCCEx_PeriphCLKConfig+0x72>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(pPeriphClkInit->Usart3ClockSelection));

    /* Configure the USART3 clock source */
    __HAL_RCC_USART3_CONFIG(pPeriphClkInit->Usart3ClockSelection);
 8002eb2:	4bba      	ldr	r3, [pc, #744]	@ (800319c <HAL_RCCEx_PeriphCLKConfig+0x344>)
 8002eb4:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8002eb8:	f023 0130 	bic.w	r1, r3, #48	@ 0x30
 8002ebc:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8002ec0:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8002ec2:	4ab6      	ldr	r2, [pc, #728]	@ (800319c <HAL_RCCEx_PeriphCLKConfig+0x344>)
 8002ec4:	430b      	orrs	r3, r1
 8002ec6:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  }

  /*-------------------------- UART4 clock source configuration --------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 8002eca:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8002ece:	e9d3 2300 	ldrd	r2, r3, [r3]
 8002ed2:	f002 0a08 	and.w	sl, r2, #8
 8002ed6:	f04f 0b00 	mov.w	fp, #0
 8002eda:	ea5a 030b 	orrs.w	r3, sl, fp
 8002ede:	d00b      	beq.n	8002ef8 <HAL_RCCEx_PeriphCLKConfig+0xa0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(pPeriphClkInit->Uart4ClockSelection));

    /* Configure the UART4 clock source */
    __HAL_RCC_UART4_CONFIG(pPeriphClkInit->Uart4ClockSelection);
 8002ee0:	4bae      	ldr	r3, [pc, #696]	@ (800319c <HAL_RCCEx_PeriphCLKConfig+0x344>)
 8002ee2:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8002ee6:	f023 01c0 	bic.w	r1, r3, #192	@ 0xc0
 8002eea:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8002eee:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8002ef0:	4aaa      	ldr	r2, [pc, #680]	@ (800319c <HAL_RCCEx_PeriphCLKConfig+0x344>)
 8002ef2:	430b      	orrs	r3, r1
 8002ef4:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  }

  /*-------------------------- UART5 clock source configuration --------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
 8002ef8:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8002efc:	e9d3 2300 	ldrd	r2, r3, [r3]
 8002f00:	f002 0310 	and.w	r3, r2, #16
 8002f04:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
 8002f08:	2300      	movs	r3, #0
 8002f0a:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
 8002f0e:	e9d7 122e 	ldrd	r1, r2, [r7, #184]	@ 0xb8
 8002f12:	460b      	mov	r3, r1
 8002f14:	4313      	orrs	r3, r2
 8002f16:	d00b      	beq.n	8002f30 <HAL_RCCEx_PeriphCLKConfig+0xd8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(pPeriphClkInit->Uart5ClockSelection));

    /* Configure the UART5 clock source */
    __HAL_RCC_UART5_CONFIG(pPeriphClkInit->Uart5ClockSelection);
 8002f18:	4ba0      	ldr	r3, [pc, #640]	@ (800319c <HAL_RCCEx_PeriphCLKConfig+0x344>)
 8002f1a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8002f1e:	f423 7140 	bic.w	r1, r3, #768	@ 0x300
 8002f22:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8002f26:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8002f28:	4a9c      	ldr	r2, [pc, #624]	@ (800319c <HAL_RCCEx_PeriphCLKConfig+0x344>)
 8002f2a:	430b      	orrs	r3, r1
 8002f2c:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
    __HAL_RCC_USART6_CONFIG(pPeriphClkInit->Usart6ClockSelection);
  }
#endif /* USART6 */

  /*-------------------------- LPUART1 clock source configuration ------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 8002f30:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8002f34:	e9d3 2300 	ldrd	r2, r3, [r3]
 8002f38:	f002 0320 	and.w	r3, r2, #32
 8002f3c:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
 8002f40:	2300      	movs	r3, #0
 8002f42:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
 8002f46:	e9d7 122c 	ldrd	r1, r2, [r7, #176]	@ 0xb0
 8002f4a:	460b      	mov	r3, r1
 8002f4c:	4313      	orrs	r3, r2
 8002f4e:	d00b      	beq.n	8002f68 <HAL_RCCEx_PeriphCLKConfig+0x110>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(pPeriphClkInit->Lpuart1ClockSelection));

    /* Configure the LPUART1 clock source */
    __HAL_RCC_LPUART1_CONFIG(pPeriphClkInit->Lpuart1ClockSelection);
 8002f50:	4b92      	ldr	r3, [pc, #584]	@ (800319c <HAL_RCCEx_PeriphCLKConfig+0x344>)
 8002f52:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 8002f56:	f023 0107 	bic.w	r1, r3, #7
 8002f5a:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8002f5e:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8002f60:	4a8e      	ldr	r2, [pc, #568]	@ (800319c <HAL_RCCEx_PeriphCLKConfig+0x344>)
 8002f62:	430b      	orrs	r3, r1
 8002f64:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
  }

  /*-------------------------- I2C1 clock source configuration ---------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 8002f68:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8002f6c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8002f70:	f002 0340 	and.w	r3, r2, #64	@ 0x40
 8002f74:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
 8002f78:	2300      	movs	r3, #0
 8002f7a:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
 8002f7e:	e9d7 122a 	ldrd	r1, r2, [r7, #168]	@ 0xa8
 8002f82:	460b      	mov	r3, r1
 8002f84:	4313      	orrs	r3, r2
 8002f86:	d00b      	beq.n	8002fa0 <HAL_RCCEx_PeriphCLKConfig+0x148>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(pPeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(pPeriphClkInit->I2c1ClockSelection);
 8002f88:	4b84      	ldr	r3, [pc, #528]	@ (800319c <HAL_RCCEx_PeriphCLKConfig+0x344>)
 8002f8a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8002f8e:	f423 6140 	bic.w	r1, r3, #3072	@ 0xc00
 8002f92:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8002f96:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8002f98:	4a80      	ldr	r2, [pc, #512]	@ (800319c <HAL_RCCEx_PeriphCLKConfig+0x344>)
 8002f9a:	430b      	orrs	r3, r1
 8002f9c:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  }

  /*-------------------------- I2C2 clock source configuration ---------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 8002fa0:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8002fa4:	e9d3 2300 	ldrd	r2, r3, [r3]
 8002fa8:	f002 0380 	and.w	r3, r2, #128	@ 0x80
 8002fac:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
 8002fb0:	2300      	movs	r3, #0
 8002fb2:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
 8002fb6:	e9d7 1228 	ldrd	r1, r2, [r7, #160]	@ 0xa0
 8002fba:	460b      	mov	r3, r1
 8002fbc:	4313      	orrs	r3, r2
 8002fbe:	d00b      	beq.n	8002fd8 <HAL_RCCEx_PeriphCLKConfig+0x180>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(pPeriphClkInit->I2c2ClockSelection));

    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(pPeriphClkInit->I2c2ClockSelection);
 8002fc0:	4b76      	ldr	r3, [pc, #472]	@ (800319c <HAL_RCCEx_PeriphCLKConfig+0x344>)
 8002fc2:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8002fc6:	f423 5140 	bic.w	r1, r3, #12288	@ 0x3000
 8002fca:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8002fce:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 8002fd0:	4a72      	ldr	r2, [pc, #456]	@ (800319c <HAL_RCCEx_PeriphCLKConfig+0x344>)
 8002fd2:	430b      	orrs	r3, r1
 8002fd4:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  }

  /*-------------------------- I2C3 clock source configuration ---------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 8002fd8:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8002fdc:	e9d3 2300 	ldrd	r2, r3, [r3]
 8002fe0:	f402 7380 	and.w	r3, r2, #256	@ 0x100
 8002fe4:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
 8002fe8:	2300      	movs	r3, #0
 8002fea:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
 8002fee:	e9d7 1226 	ldrd	r1, r2, [r7, #152]	@ 0x98
 8002ff2:	460b      	mov	r3, r1
 8002ff4:	4313      	orrs	r3, r2
 8002ff6:	d00b      	beq.n	8003010 <HAL_RCCEx_PeriphCLKConfig+0x1b8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(pPeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(pPeriphClkInit->I2c3ClockSelection);
 8002ff8:	4b68      	ldr	r3, [pc, #416]	@ (800319c <HAL_RCCEx_PeriphCLKConfig+0x344>)
 8002ffa:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 8002ffe:	f023 01c0 	bic.w	r1, r3, #192	@ 0xc0
 8003002:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8003006:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 8003008:	4a64      	ldr	r2, [pc, #400]	@ (800319c <HAL_RCCEx_PeriphCLKConfig+0x344>)
 800300a:	430b      	orrs	r3, r1
 800300c:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
  }

  /*-------------------------- I2C4 clock source configuration ---------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 8003010:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8003014:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003018:	f402 0380 	and.w	r3, r2, #4194304	@ 0x400000
 800301c:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
 8003020:	2300      	movs	r3, #0
 8003022:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
 8003026:	e9d7 1224 	ldrd	r1, r2, [r7, #144]	@ 0x90
 800302a:	460b      	mov	r3, r1
 800302c:	4313      	orrs	r3, r2
 800302e:	d00b      	beq.n	8003048 <HAL_RCCEx_PeriphCLKConfig+0x1f0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(pPeriphClkInit->I2c4ClockSelection));

    /* Configure the I2C4 clock source */
    __HAL_RCC_I2C4_CONFIG(pPeriphClkInit->I2c4ClockSelection);
 8003030:	4b5a      	ldr	r3, [pc, #360]	@ (800319c <HAL_RCCEx_PeriphCLKConfig+0x344>)
 8003032:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8003036:	f423 4140 	bic.w	r1, r3, #49152	@ 0xc000
 800303a:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 800303e:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8003040:	4a56      	ldr	r2, [pc, #344]	@ (800319c <HAL_RCCEx_PeriphCLKConfig+0x344>)
 8003042:	430b      	orrs	r3, r1
 8003044:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
    __HAL_RCC_I2C6_CONFIG(pPeriphClkInit->I2c6ClockSelection);
  }
#endif /* I2C6 */

  /*-------------------------- LPTIM1 clock source configuration -------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 8003048:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 800304c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003050:	f402 7300 	and.w	r3, r2, #512	@ 0x200
 8003054:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
 8003058:	2300      	movs	r3, #0
 800305a:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
 800305e:	e9d7 1222 	ldrd	r1, r2, [r7, #136]	@ 0x88
 8003062:	460b      	mov	r3, r1
 8003064:	4313      	orrs	r3, r2
 8003066:	d00b      	beq.n	8003080 <HAL_RCCEx_PeriphCLKConfig+0x228>
  {
    assert_param(IS_RCC_LPTIM1CLK(pPeriphClkInit->Lptim1ClockSelection));
    __HAL_RCC_LPTIM1_CONFIG(pPeriphClkInit->Lptim1ClockSelection);
 8003068:	4b4c      	ldr	r3, [pc, #304]	@ (800319c <HAL_RCCEx_PeriphCLKConfig+0x344>)
 800306a:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 800306e:	f423 6140 	bic.w	r1, r3, #3072	@ 0xc00
 8003072:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8003076:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 8003078:	4a48      	ldr	r2, [pc, #288]	@ (800319c <HAL_RCCEx_PeriphCLKConfig+0x344>)
 800307a:	430b      	orrs	r3, r1
 800307c:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
  }

  /*-------------------------- LPTIM2 clock source configuration -------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == (RCC_PERIPHCLK_LPTIM2))
 8003080:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8003084:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003088:	f402 6380 	and.w	r3, r2, #1024	@ 0x400
 800308c:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
 8003090:	2300      	movs	r3, #0
 8003092:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
 8003096:	e9d7 1220 	ldrd	r1, r2, [r7, #128]	@ 0x80
 800309a:	460b      	mov	r3, r1
 800309c:	4313      	orrs	r3, r2
 800309e:	d00b      	beq.n	80030b8 <HAL_RCCEx_PeriphCLKConfig+0x260>
  {
    assert_param(IS_RCC_LPTIM2CLK(pPeriphClkInit->Lptim2ClockSelection));
    __HAL_RCC_LPTIM2_CONFIG(pPeriphClkInit->Lptim2ClockSelection);
 80030a0:	4b3e      	ldr	r3, [pc, #248]	@ (800319c <HAL_RCCEx_PeriphCLKConfig+0x344>)
 80030a2:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 80030a6:	f423 2140 	bic.w	r1, r3, #786432	@ 0xc0000
 80030aa:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 80030ae:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 80030b0:	4a3a      	ldr	r2, [pc, #232]	@ (800319c <HAL_RCCEx_PeriphCLKConfig+0x344>)
 80030b2:	430b      	orrs	r3, r1
 80030b4:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  }

  /*-------------------------- LPTIM34 clock source configuration -------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM34) == (RCC_PERIPHCLK_LPTIM34))
 80030b8:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 80030bc:	e9d3 2300 	ldrd	r2, r3, [r3]
 80030c0:	f402 6300 	and.w	r3, r2, #2048	@ 0x800
 80030c4:	67bb      	str	r3, [r7, #120]	@ 0x78
 80030c6:	2300      	movs	r3, #0
 80030c8:	67fb      	str	r3, [r7, #124]	@ 0x7c
 80030ca:	e9d7 121e 	ldrd	r1, r2, [r7, #120]	@ 0x78
 80030ce:	460b      	mov	r3, r1
 80030d0:	4313      	orrs	r3, r2
 80030d2:	d00b      	beq.n	80030ec <HAL_RCCEx_PeriphCLKConfig+0x294>
  {
    assert_param(IS_RCC_LPTIM34CLK(pPeriphClkInit->Lptim34ClockSelection));
    __HAL_RCC_LPTIM34_CONFIG(pPeriphClkInit->Lptim34ClockSelection);
 80030d4:	4b31      	ldr	r3, [pc, #196]	@ (800319c <HAL_RCCEx_PeriphCLKConfig+0x344>)
 80030d6:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 80030da:	f423 7140 	bic.w	r1, r3, #768	@ 0x300
 80030de:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 80030e2:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
 80030e4:	4a2d      	ldr	r2, [pc, #180]	@ (800319c <HAL_RCCEx_PeriphCLKConfig+0x344>)
 80030e6:	430b      	orrs	r3, r1
 80030e8:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
  }

  /*-------------------------- SAI1 clock source configuration ---------------------*/
  if ((((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
 80030ec:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 80030f0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80030f4:	f402 5300 	and.w	r3, r2, #8192	@ 0x2000
 80030f8:	673b      	str	r3, [r7, #112]	@ 0x70
 80030fa:	2300      	movs	r3, #0
 80030fc:	677b      	str	r3, [r7, #116]	@ 0x74
 80030fe:	e9d7 121c 	ldrd	r1, r2, [r7, #112]	@ 0x70
 8003102:	460b      	mov	r3, r1
 8003104:	4313      	orrs	r3, r2
 8003106:	d04f      	beq.n	80031a8 <HAL_RCCEx_PeriphCLKConfig+0x350>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLK(pPeriphClkInit->Sai1ClockSelection));

    switch (pPeriphClkInit->Sai1ClockSelection)
 8003108:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 800310c:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8003110:	2b80      	cmp	r3, #128	@ 0x80
 8003112:	d02d      	beq.n	8003170 <HAL_RCCEx_PeriphCLKConfig+0x318>
 8003114:	2b80      	cmp	r3, #128	@ 0x80
 8003116:	d827      	bhi.n	8003168 <HAL_RCCEx_PeriphCLKConfig+0x310>
 8003118:	2b60      	cmp	r3, #96	@ 0x60
 800311a:	d02b      	beq.n	8003174 <HAL_RCCEx_PeriphCLKConfig+0x31c>
 800311c:	2b60      	cmp	r3, #96	@ 0x60
 800311e:	d823      	bhi.n	8003168 <HAL_RCCEx_PeriphCLKConfig+0x310>
 8003120:	2b40      	cmp	r3, #64	@ 0x40
 8003122:	d006      	beq.n	8003132 <HAL_RCCEx_PeriphCLKConfig+0x2da>
 8003124:	2b40      	cmp	r3, #64	@ 0x40
 8003126:	d81f      	bhi.n	8003168 <HAL_RCCEx_PeriphCLKConfig+0x310>
 8003128:	2b00      	cmp	r3, #0
 800312a:	d009      	beq.n	8003140 <HAL_RCCEx_PeriphCLKConfig+0x2e8>
 800312c:	2b20      	cmp	r3, #32
 800312e:	d011      	beq.n	8003154 <HAL_RCCEx_PeriphCLKConfig+0x2fc>
 8003130:	e01a      	b.n	8003168 <HAL_RCCEx_PeriphCLKConfig+0x310>
    {
      case RCC_SAI1CLKSOURCE_PLL1:      /* PLL is used as clock source for SAI1*/
        /* Enable SAI Clock output generated from System PLL  */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVP);
 8003132:	4b1a      	ldr	r3, [pc, #104]	@ (800319c <HAL_RCCEx_PeriphCLKConfig+0x344>)
 8003134:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8003136:	4a19      	ldr	r2, [pc, #100]	@ (800319c <HAL_RCCEx_PeriphCLKConfig+0x344>)
 8003138:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 800313c:	6293      	str	r3, [r2, #40]	@ 0x28
        /* SAI1 clock source config set later after clock selection check */
        break;
 800313e:	e01a      	b.n	8003176 <HAL_RCCEx_PeriphCLKConfig+0x31e>

      case RCC_SAI1CLKSOURCE_PLL2:  /* PLL2 is used as clock source for SAI1*/
        /* PLL2 P input clock, parameters M, N & P configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 8003140:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8003144:	3308      	adds	r3, #8
 8003146:	4618      	mov	r0, r3
 8003148:	f002 f914 	bl	8005374 <RCCEx_PLL2_Config>
 800314c:	4603      	mov	r3, r0
 800314e:	f887 30d3 	strb.w	r3, [r7, #211]	@ 0xd3
        /* SAI1 clock source config set later after clock selection check */
        break;
 8003152:	e010      	b.n	8003176 <HAL_RCCEx_PeriphCLKConfig+0x31e>

      case RCC_SAI1CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI1*/
        /* PLL3 P input clock, parameters M, N & P configuration clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 8003154:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8003158:	332c      	adds	r3, #44	@ 0x2c
 800315a:	4618      	mov	r0, r3
 800315c:	f002 f9a2 	bl	80054a4 <RCCEx_PLL3_Config>
 8003160:	4603      	mov	r3, r0
 8003162:	f887 30d3 	strb.w	r3, [r7, #211]	@ 0xd3
        /* SAI1 clock source config set later after clock selection check */
        break;
 8003166:	e006      	b.n	8003176 <HAL_RCCEx_PeriphCLKConfig+0x31e>
      case RCC_SAI1CLKSOURCE_HSI:      /* HSI is used as source of SAI1 clock*/
        /* SAI1 clock source config set later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8003168:	2301      	movs	r3, #1
 800316a:	f887 30d3 	strb.w	r3, [r7, #211]	@ 0xd3
        break;
 800316e:	e002      	b.n	8003176 <HAL_RCCEx_PeriphCLKConfig+0x31e>
        break;
 8003170:	bf00      	nop
 8003172:	e000      	b.n	8003176 <HAL_RCCEx_PeriphCLKConfig+0x31e>
        break;
 8003174:	bf00      	nop
    }

    if (ret == HAL_OK)
 8003176:	f897 30d3 	ldrb.w	r3, [r7, #211]	@ 0xd3
 800317a:	2b00      	cmp	r3, #0
 800317c:	d110      	bne.n	80031a0 <HAL_RCCEx_PeriphCLKConfig+0x348>
    {
      /* Set the source of SAI1 clock*/
      __HAL_RCC_SAI1_CONFIG(pPeriphClkInit->Sai1ClockSelection);
 800317e:	4b07      	ldr	r3, [pc, #28]	@ (800319c <HAL_RCCEx_PeriphCLKConfig+0x344>)
 8003180:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 8003184:	f023 01e0 	bic.w	r1, r3, #224	@ 0xe0
 8003188:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 800318c:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8003190:	4a02      	ldr	r2, [pc, #8]	@ (800319c <HAL_RCCEx_PeriphCLKConfig+0x344>)
 8003192:	430b      	orrs	r3, r1
 8003194:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
 8003198:	e006      	b.n	80031a8 <HAL_RCCEx_PeriphCLKConfig+0x350>
 800319a:	bf00      	nop
 800319c:	46020c00 	.word	0x46020c00
    }
    else
    {
      /* set overall return value */
      status = ret;
 80031a0:	f897 30d3 	ldrb.w	r3, [r7, #211]	@ 0xd3
 80031a4:	f887 30d2 	strb.w	r3, [r7, #210]	@ 0xd2
    }
  }
#endif /* SAI2 */

  /*-------------------------- ADCDAC clock source configuration ----------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADCDAC) == RCC_PERIPHCLK_ADCDAC)
 80031a8:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 80031ac:	e9d3 2300 	ldrd	r2, r3, [r3]
 80031b0:	f402 4300 	and.w	r3, r2, #32768	@ 0x8000
 80031b4:	66bb      	str	r3, [r7, #104]	@ 0x68
 80031b6:	2300      	movs	r3, #0
 80031b8:	66fb      	str	r3, [r7, #108]	@ 0x6c
 80031ba:	e9d7 121a 	ldrd	r1, r2, [r7, #104]	@ 0x68
 80031be:	460b      	mov	r3, r1
 80031c0:	4313      	orrs	r3, r2
 80031c2:	d046      	beq.n	8003252 <HAL_RCCEx_PeriphCLKConfig+0x3fa>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCDACCLKSOURCE(pPeriphClkInit->AdcDacClockSelection));

    switch (pPeriphClkInit->AdcDacClockSelection)
 80031c4:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 80031c8:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
 80031cc:	f5b3 4fa0 	cmp.w	r3, #20480	@ 0x5000
 80031d0:	d028      	beq.n	8003224 <HAL_RCCEx_PeriphCLKConfig+0x3cc>
 80031d2:	f5b3 4fa0 	cmp.w	r3, #20480	@ 0x5000
 80031d6:	d821      	bhi.n	800321c <HAL_RCCEx_PeriphCLKConfig+0x3c4>
 80031d8:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 80031dc:	d022      	beq.n	8003224 <HAL_RCCEx_PeriphCLKConfig+0x3cc>
 80031de:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 80031e2:	d81b      	bhi.n	800321c <HAL_RCCEx_PeriphCLKConfig+0x3c4>
 80031e4:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 80031e8:	d01c      	beq.n	8003224 <HAL_RCCEx_PeriphCLKConfig+0x3cc>
 80031ea:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 80031ee:	d815      	bhi.n	800321c <HAL_RCCEx_PeriphCLKConfig+0x3c4>
 80031f0:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 80031f4:	d008      	beq.n	8003208 <HAL_RCCEx_PeriphCLKConfig+0x3b0>
 80031f6:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 80031fa:	d80f      	bhi.n	800321c <HAL_RCCEx_PeriphCLKConfig+0x3c4>
 80031fc:	2b00      	cmp	r3, #0
 80031fe:	d011      	beq.n	8003224 <HAL_RCCEx_PeriphCLKConfig+0x3cc>
 8003200:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8003204:	d00e      	beq.n	8003224 <HAL_RCCEx_PeriphCLKConfig+0x3cc>
 8003206:	e009      	b.n	800321c <HAL_RCCEx_PeriphCLKConfig+0x3c4>
    {
      case RCC_ADCDACCLKSOURCE_PLL2:
        /* PLL2 input clock, parameters M, N,P, & R configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 8003208:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 800320c:	3308      	adds	r3, #8
 800320e:	4618      	mov	r0, r3
 8003210:	f002 f8b0 	bl	8005374 <RCCEx_PLL2_Config>
 8003214:	4603      	mov	r3, r0
 8003216:	f887 30d3 	strb.w	r3, [r7, #211]	@ 0xd3
        break;
 800321a:	e004      	b.n	8003226 <HAL_RCCEx_PeriphCLKConfig+0x3ce>
      case RCC_ADCDACCLKSOURCE_HSE:
      case RCC_ADCDACCLKSOURCE_HSI:
      case RCC_ADCDACCLKSOURCE_MSIK:
        break;
      default:
        ret = HAL_ERROR;
 800321c:	2301      	movs	r3, #1
 800321e:	f887 30d3 	strb.w	r3, [r7, #211]	@ 0xd3
        break;
 8003222:	e000      	b.n	8003226 <HAL_RCCEx_PeriphCLKConfig+0x3ce>
        break;
 8003224:	bf00      	nop
    }

    if (ret == HAL_OK)
 8003226:	f897 30d3 	ldrb.w	r3, [r7, #211]	@ 0xd3
 800322a:	2b00      	cmp	r3, #0
 800322c:	d10d      	bne.n	800324a <HAL_RCCEx_PeriphCLKConfig+0x3f2>
    {
      /* Configure the ADC1 interface clock source */
      __HAL_RCC_ADCDAC_CONFIG(pPeriphClkInit->AdcDacClockSelection);
 800322e:	4bb6      	ldr	r3, [pc, #728]	@ (8003508 <HAL_RCCEx_PeriphCLKConfig+0x6b0>)
 8003230:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 8003234:	f423 41e0 	bic.w	r1, r3, #28672	@ 0x7000
 8003238:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 800323c:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
 8003240:	4ab1      	ldr	r2, [pc, #708]	@ (8003508 <HAL_RCCEx_PeriphCLKConfig+0x6b0>)
 8003242:	430b      	orrs	r3, r1
 8003244:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
 8003248:	e003      	b.n	8003252 <HAL_RCCEx_PeriphCLKConfig+0x3fa>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800324a:	f897 30d3 	ldrb.w	r3, [r7, #211]	@ 0xd3
 800324e:	f887 30d2 	strb.w	r3, [r7, #210]	@ 0xd2
    }
  }

  /*-------------------------- MDF1 clock source configuration -------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_MDF1) == RCC_PERIPHCLK_MDF1)
 8003252:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8003256:	e9d3 2300 	ldrd	r2, r3, [r3]
 800325a:	f402 3380 	and.w	r3, r2, #65536	@ 0x10000
 800325e:	663b      	str	r3, [r7, #96]	@ 0x60
 8003260:	2300      	movs	r3, #0
 8003262:	667b      	str	r3, [r7, #100]	@ 0x64
 8003264:	e9d7 1218 	ldrd	r1, r2, [r7, #96]	@ 0x60
 8003268:	460b      	mov	r3, r1
 800326a:	4313      	orrs	r3, r2
 800326c:	d03e      	beq.n	80032ec <HAL_RCCEx_PeriphCLKConfig+0x494>
  {
    /* Check the parameters */
    assert_param(IS_RCC_MDF1CLKSOURCE(pPeriphClkInit->Mdf1ClockSelection));

    switch (pPeriphClkInit->Mdf1ClockSelection)
 800326e:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8003272:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 8003276:	2b04      	cmp	r3, #4
 8003278:	d81d      	bhi.n	80032b6 <HAL_RCCEx_PeriphCLKConfig+0x45e>
 800327a:	a201      	add	r2, pc, #4	@ (adr r2, 8003280 <HAL_RCCEx_PeriphCLKConfig+0x428>)
 800327c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8003280:	080032bf 	.word	0x080032bf
 8003284:	08003295 	.word	0x08003295
 8003288:	080032a3 	.word	0x080032a3
 800328c:	080032bf 	.word	0x080032bf
 8003290:	080032bf 	.word	0x080032bf
    {
      case RCC_MDF1CLKSOURCE_PLL1:
        /* Enable PLL1 Clock output generated from System PLL  */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVP);
 8003294:	4b9c      	ldr	r3, [pc, #624]	@ (8003508 <HAL_RCCEx_PeriphCLKConfig+0x6b0>)
 8003296:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8003298:	4a9b      	ldr	r2, [pc, #620]	@ (8003508 <HAL_RCCEx_PeriphCLKConfig+0x6b0>)
 800329a:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 800329e:	6293      	str	r3, [r2, #40]	@ 0x28
        break;
 80032a0:	e00e      	b.n	80032c0 <HAL_RCCEx_PeriphCLKConfig+0x468>
      case RCC_MDF1CLKSOURCE_PLL3:
        /* PLL3 Q input clock, parameters M, N & Q configuration and clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 80032a2:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 80032a6:	332c      	adds	r3, #44	@ 0x2c
 80032a8:	4618      	mov	r0, r3
 80032aa:	f002 f8fb 	bl	80054a4 <RCCEx_PLL3_Config>
 80032ae:	4603      	mov	r3, r0
 80032b0:	f887 30d3 	strb.w	r3, [r7, #211]	@ 0xd3
        break;
 80032b4:	e004      	b.n	80032c0 <HAL_RCCEx_PeriphCLKConfig+0x468>
      case RCC_MDF1CLKSOURCE_PIN:
        break;
      case RCC_MDF1CLKSOURCE_MSIK:
        break;
      default:
        ret = HAL_ERROR;
 80032b6:	2301      	movs	r3, #1
 80032b8:	f887 30d3 	strb.w	r3, [r7, #211]	@ 0xd3
        break;
 80032bc:	e000      	b.n	80032c0 <HAL_RCCEx_PeriphCLKConfig+0x468>
        break;
 80032be:	bf00      	nop
    }
    if (ret == HAL_OK)
 80032c0:	f897 30d3 	ldrb.w	r3, [r7, #211]	@ 0xd3
 80032c4:	2b00      	cmp	r3, #0
 80032c6:	d10d      	bne.n	80032e4 <HAL_RCCEx_PeriphCLKConfig+0x48c>
    {
      /* Configure the MDF1 interface clock source */
      __HAL_RCC_MDF1_CONFIG(pPeriphClkInit->Mdf1ClockSelection);
 80032c8:	4b8f      	ldr	r3, [pc, #572]	@ (8003508 <HAL_RCCEx_PeriphCLKConfig+0x6b0>)
 80032ca:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 80032ce:	f023 0107 	bic.w	r1, r3, #7
 80032d2:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 80032d6:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 80032da:	4a8b      	ldr	r2, [pc, #556]	@ (8003508 <HAL_RCCEx_PeriphCLKConfig+0x6b0>)
 80032dc:	430b      	orrs	r3, r1
 80032de:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
 80032e2:	e003      	b.n	80032ec <HAL_RCCEx_PeriphCLKConfig+0x494>
    }
    else
    {
      /* set overall return value */
      status = ret;
 80032e4:	f897 30d3 	ldrb.w	r3, [r7, #211]	@ 0xd3
 80032e8:	f887 30d2 	strb.w	r3, [r7, #210]	@ 0xd2
    }
  }

  /*-------------------------- ADF1 clock source configuration -------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADF1) == RCC_PERIPHCLK_ADF1)
 80032ec:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 80032f0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80032f4:	f402 3300 	and.w	r3, r2, #131072	@ 0x20000
 80032f8:	65bb      	str	r3, [r7, #88]	@ 0x58
 80032fa:	2300      	movs	r3, #0
 80032fc:	65fb      	str	r3, [r7, #92]	@ 0x5c
 80032fe:	e9d7 1216 	ldrd	r1, r2, [r7, #88]	@ 0x58
 8003302:	460b      	mov	r3, r1
 8003304:	4313      	orrs	r3, r2
 8003306:	d04a      	beq.n	800339e <HAL_RCCEx_PeriphCLKConfig+0x546>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADF1CLKSOURCE(pPeriphClkInit->Adf1ClockSelection));
    switch (pPeriphClkInit->Adf1ClockSelection)
 8003308:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 800330c:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8003310:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 8003314:	d028      	beq.n	8003368 <HAL_RCCEx_PeriphCLKConfig+0x510>
 8003316:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 800331a:	d821      	bhi.n	8003360 <HAL_RCCEx_PeriphCLKConfig+0x508>
 800331c:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
 8003320:	d024      	beq.n	800336c <HAL_RCCEx_PeriphCLKConfig+0x514>
 8003322:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
 8003326:	d81b      	bhi.n	8003360 <HAL_RCCEx_PeriphCLKConfig+0x508>
 8003328:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 800332c:	d00e      	beq.n	800334c <HAL_RCCEx_PeriphCLKConfig+0x4f4>
 800332e:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8003332:	d815      	bhi.n	8003360 <HAL_RCCEx_PeriphCLKConfig+0x508>
 8003334:	2b00      	cmp	r3, #0
 8003336:	d01b      	beq.n	8003370 <HAL_RCCEx_PeriphCLKConfig+0x518>
 8003338:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 800333c:	d110      	bne.n	8003360 <HAL_RCCEx_PeriphCLKConfig+0x508>
    {
      case RCC_ADF1CLKSOURCE_PLL1:
        /* Enable PLL1 Clock output generated from System PLL  */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVP);
 800333e:	4b72      	ldr	r3, [pc, #456]	@ (8003508 <HAL_RCCEx_PeriphCLKConfig+0x6b0>)
 8003340:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8003342:	4a71      	ldr	r2, [pc, #452]	@ (8003508 <HAL_RCCEx_PeriphCLKConfig+0x6b0>)
 8003344:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8003348:	6293      	str	r3, [r2, #40]	@ 0x28
        break;
 800334a:	e012      	b.n	8003372 <HAL_RCCEx_PeriphCLKConfig+0x51a>
      case RCC_ADF1CLKSOURCE_PLL3:
        /* PLL3 Q input clock, parameters M, N & Q configuration and clock output (PLL3ClockOut) */
        ret = RCCEx_PLL3_Config(&(pPeriphClkInit->PLL3));
 800334c:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8003350:	332c      	adds	r3, #44	@ 0x2c
 8003352:	4618      	mov	r0, r3
 8003354:	f002 f8a6 	bl	80054a4 <RCCEx_PLL3_Config>
 8003358:	4603      	mov	r3, r0
 800335a:	f887 30d3 	strb.w	r3, [r7, #211]	@ 0xd3
        break;
 800335e:	e008      	b.n	8003372 <HAL_RCCEx_PeriphCLKConfig+0x51a>
      case RCC_ADF1CLKSOURCE_PIN:
        break;
      case RCC_ADF1CLKSOURCE_MSIK:
        break;
      default:
        ret = HAL_ERROR;
 8003360:	2301      	movs	r3, #1
 8003362:	f887 30d3 	strb.w	r3, [r7, #211]	@ 0xd3
        break;
 8003366:	e004      	b.n	8003372 <HAL_RCCEx_PeriphCLKConfig+0x51a>
        break;
 8003368:	bf00      	nop
 800336a:	e002      	b.n	8003372 <HAL_RCCEx_PeriphCLKConfig+0x51a>
        break;
 800336c:	bf00      	nop
 800336e:	e000      	b.n	8003372 <HAL_RCCEx_PeriphCLKConfig+0x51a>
        break;
 8003370:	bf00      	nop
    }
    if (ret == HAL_OK)
 8003372:	f897 30d3 	ldrb.w	r3, [r7, #211]	@ 0xd3
 8003376:	2b00      	cmp	r3, #0
 8003378:	d10d      	bne.n	8003396 <HAL_RCCEx_PeriphCLKConfig+0x53e>
    {
      /* Configure the ADF1 interface clock source */
      __HAL_RCC_ADF1_CONFIG(pPeriphClkInit->Adf1ClockSelection);
 800337a:	4b63      	ldr	r3, [pc, #396]	@ (8003508 <HAL_RCCEx_PeriphCLKConfig+0x6b0>)
 800337c:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 8003380:	f423 21e0 	bic.w	r1, r3, #458752	@ 0x70000
 8003384:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8003388:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800338c:	4a5e      	ldr	r2, [pc, #376]	@ (8003508 <HAL_RCCEx_PeriphCLKConfig+0x6b0>)
 800338e:	430b      	orrs	r3, r1
 8003390:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
 8003394:	e003      	b.n	800339e <HAL_RCCEx_PeriphCLKConfig+0x546>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8003396:	f897 30d3 	ldrb.w	r3, [r7, #211]	@ 0xd3
 800339a:	f887 30d2 	strb.w	r3, [r7, #210]	@ 0xd2
    }
  }

  /*-------------------------- RTC clock source configuration ----------------------*/
  if ((pPeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 800339e:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 80033a2:	e9d3 2300 	ldrd	r2, r3, [r3]
 80033a6:	f402 2380 	and.w	r3, r2, #262144	@ 0x40000
 80033aa:	653b      	str	r3, [r7, #80]	@ 0x50
 80033ac:	2300      	movs	r3, #0
 80033ae:	657b      	str	r3, [r7, #84]	@ 0x54
 80033b0:	e9d7 1214 	ldrd	r1, r2, [r7, #80]	@ 0x50
 80033b4:	460b      	mov	r3, r1
 80033b6:	4313      	orrs	r3, r2
 80033b8:	f000 80ba 	beq.w	8003530 <HAL_RCCEx_PeriphCLKConfig+0x6d8>
  {
    FlagStatus       pwrclkchanged = RESET;
 80033bc:	2300      	movs	r3, #0
 80033be:	f887 30d1 	strb.w	r3, [r7, #209]	@ 0xd1
    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(pPeriphClkInit->RTCClockSelection));
    /* Enable Power Clock */
    if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 80033c2:	4b51      	ldr	r3, [pc, #324]	@ (8003508 <HAL_RCCEx_PeriphCLKConfig+0x6b0>)
 80033c4:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 80033c8:	f003 0304 	and.w	r3, r3, #4
 80033cc:	2b00      	cmp	r3, #0
 80033ce:	d113      	bne.n	80033f8 <HAL_RCCEx_PeriphCLKConfig+0x5a0>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 80033d0:	4b4d      	ldr	r3, [pc, #308]	@ (8003508 <HAL_RCCEx_PeriphCLKConfig+0x6b0>)
 80033d2:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 80033d6:	4a4c      	ldr	r2, [pc, #304]	@ (8003508 <HAL_RCCEx_PeriphCLKConfig+0x6b0>)
 80033d8:	f043 0304 	orr.w	r3, r3, #4
 80033dc:	f8c2 3094 	str.w	r3, [r2, #148]	@ 0x94
 80033e0:	4b49      	ldr	r3, [pc, #292]	@ (8003508 <HAL_RCCEx_PeriphCLKConfig+0x6b0>)
 80033e2:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 80033e6:	f003 0304 	and.w	r3, r3, #4
 80033ea:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 80033ee:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
      pwrclkchanged = SET;
 80033f2:	2301      	movs	r3, #1
 80033f4:	f887 30d1 	strb.w	r3, [r7, #209]	@ 0xd1
    }
    /* Enable write access to Backup domain */
    SET_BIT(PWR->DBPR, PWR_DBPR_DBP);
 80033f8:	4b44      	ldr	r3, [pc, #272]	@ (800350c <HAL_RCCEx_PeriphCLKConfig+0x6b4>)
 80033fa:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80033fc:	4a43      	ldr	r2, [pc, #268]	@ (800350c <HAL_RCCEx_PeriphCLKConfig+0x6b4>)
 80033fe:	f043 0301 	orr.w	r3, r3, #1
 8003402:	6293      	str	r3, [r2, #40]	@ 0x28

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 8003404:	f7fd fdba 	bl	8000f7c <HAL_GetTick>
 8003408:	f8c7 00cc 	str.w	r0, [r7, #204]	@ 0xcc

    while (HAL_IS_BIT_CLR(PWR->DBPR, PWR_DBPR_DBP))
 800340c:	e00b      	b.n	8003426 <HAL_RCCEx_PeriphCLKConfig+0x5ce>
    {
      if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800340e:	f7fd fdb5 	bl	8000f7c <HAL_GetTick>
 8003412:	4602      	mov	r2, r0
 8003414:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8003418:	1ad3      	subs	r3, r2, r3
 800341a:	2b02      	cmp	r3, #2
 800341c:	d903      	bls.n	8003426 <HAL_RCCEx_PeriphCLKConfig+0x5ce>
      {
        ret = HAL_TIMEOUT;
 800341e:	2303      	movs	r3, #3
 8003420:	f887 30d3 	strb.w	r3, [r7, #211]	@ 0xd3
        break;
 8003424:	e005      	b.n	8003432 <HAL_RCCEx_PeriphCLKConfig+0x5da>
    while (HAL_IS_BIT_CLR(PWR->DBPR, PWR_DBPR_DBP))
 8003426:	4b39      	ldr	r3, [pc, #228]	@ (800350c <HAL_RCCEx_PeriphCLKConfig+0x6b4>)
 8003428:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800342a:	f003 0301 	and.w	r3, r3, #1
 800342e:	2b00      	cmp	r3, #0
 8003430:	d0ed      	beq.n	800340e <HAL_RCCEx_PeriphCLKConfig+0x5b6>
      }
    }

    if (ret == HAL_OK)
 8003432:	f897 30d3 	ldrb.w	r3, [r7, #211]	@ 0xd3
 8003436:	2b00      	cmp	r3, #0
 8003438:	d16a      	bne.n	8003510 <HAL_RCCEx_PeriphCLKConfig+0x6b8>
    {
      /* Reset the Backup domain only if the RTC Clock source selection is modified from default */
      tmpregister = READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL);
 800343a:	4b33      	ldr	r3, [pc, #204]	@ (8003508 <HAL_RCCEx_PeriphCLKConfig+0x6b0>)
 800343c:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8003440:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 8003444:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4

      if ((tmpregister != RCC_RTCCLKSOURCE_NO_CLK) && (tmpregister != pPeriphClkInit->RTCClockSelection))
 8003448:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 800344c:	2b00      	cmp	r3, #0
 800344e:	d023      	beq.n	8003498 <HAL_RCCEx_PeriphCLKConfig+0x640>
 8003450:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8003454:	f8d3 20b8 	ldr.w	r2, [r3, #184]	@ 0xb8
 8003458:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 800345c:	4293      	cmp	r3, r2
 800345e:	d01b      	beq.n	8003498 <HAL_RCCEx_PeriphCLKConfig+0x640>
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 8003460:	4b29      	ldr	r3, [pc, #164]	@ (8003508 <HAL_RCCEx_PeriphCLKConfig+0x6b0>)
 8003462:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8003466:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 800346a:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        __HAL_RCC_BACKUPRESET_FORCE();
 800346e:	4b26      	ldr	r3, [pc, #152]	@ (8003508 <HAL_RCCEx_PeriphCLKConfig+0x6b0>)
 8003470:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8003474:	4a24      	ldr	r2, [pc, #144]	@ (8003508 <HAL_RCCEx_PeriphCLKConfig+0x6b0>)
 8003476:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 800347a:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
        __HAL_RCC_BACKUPRESET_RELEASE();
 800347e:	4b22      	ldr	r3, [pc, #136]	@ (8003508 <HAL_RCCEx_PeriphCLKConfig+0x6b0>)
 8003480:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8003484:	4a20      	ldr	r2, [pc, #128]	@ (8003508 <HAL_RCCEx_PeriphCLKConfig+0x6b0>)
 8003486:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 800348a:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
        /* Restore the Content of BDCR register */
        RCC->BDCR = tmpregister;
 800348e:	4a1e      	ldr	r2, [pc, #120]	@ (8003508 <HAL_RCCEx_PeriphCLKConfig+0x6b0>)
 8003490:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8003494:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
      }

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSEON))
 8003498:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 800349c:	f003 0301 	and.w	r3, r3, #1
 80034a0:	2b00      	cmp	r3, #0
 80034a2:	d019      	beq.n	80034d8 <HAL_RCCEx_PeriphCLKConfig+0x680>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80034a4:	f7fd fd6a 	bl	8000f7c <HAL_GetTick>
 80034a8:	f8c7 00cc 	str.w	r0, [r7, #204]	@ 0xcc

        /* Wait till LSE is ready */
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 80034ac:	e00d      	b.n	80034ca <HAL_RCCEx_PeriphCLKConfig+0x672>
        {
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80034ae:	f7fd fd65 	bl	8000f7c <HAL_GetTick>
 80034b2:	4602      	mov	r2, r0
 80034b4:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 80034b8:	1ad2      	subs	r2, r2, r3
 80034ba:	f241 3388 	movw	r3, #5000	@ 0x1388
 80034be:	429a      	cmp	r2, r3
 80034c0:	d903      	bls.n	80034ca <HAL_RCCEx_PeriphCLKConfig+0x672>
          {
            ret = HAL_TIMEOUT;
 80034c2:	2303      	movs	r3, #3
 80034c4:	f887 30d3 	strb.w	r3, [r7, #211]	@ 0xd3
            break;
 80034c8:	e006      	b.n	80034d8 <HAL_RCCEx_PeriphCLKConfig+0x680>
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 80034ca:	4b0f      	ldr	r3, [pc, #60]	@ (8003508 <HAL_RCCEx_PeriphCLKConfig+0x6b0>)
 80034cc:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 80034d0:	f003 0302 	and.w	r3, r3, #2
 80034d4:	2b00      	cmp	r3, #0
 80034d6:	d0ea      	beq.n	80034ae <HAL_RCCEx_PeriphCLKConfig+0x656>
          }
        }
      }

      if (ret == HAL_OK)
 80034d8:	f897 30d3 	ldrb.w	r3, [r7, #211]	@ 0xd3
 80034dc:	2b00      	cmp	r3, #0
 80034de:	d10d      	bne.n	80034fc <HAL_RCCEx_PeriphCLKConfig+0x6a4>
      {
        /* Apply new RTC clock source selection */
        __HAL_RCC_RTC_CONFIG(pPeriphClkInit->RTCClockSelection);
 80034e0:	4b09      	ldr	r3, [pc, #36]	@ (8003508 <HAL_RCCEx_PeriphCLKConfig+0x6b0>)
 80034e2:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 80034e6:	f423 7140 	bic.w	r1, r3, #768	@ 0x300
 80034ea:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 80034ee:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
 80034f2:	4a05      	ldr	r2, [pc, #20]	@ (8003508 <HAL_RCCEx_PeriphCLKConfig+0x6b0>)
 80034f4:	430b      	orrs	r3, r1
 80034f6:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
 80034fa:	e00d      	b.n	8003518 <HAL_RCCEx_PeriphCLKConfig+0x6c0>
      }
      else
      {
        /* set overall return value */
        status = ret;
 80034fc:	f897 30d3 	ldrb.w	r3, [r7, #211]	@ 0xd3
 8003500:	f887 30d2 	strb.w	r3, [r7, #210]	@ 0xd2
 8003504:	e008      	b.n	8003518 <HAL_RCCEx_PeriphCLKConfig+0x6c0>
 8003506:	bf00      	nop
 8003508:	46020c00 	.word	0x46020c00
 800350c:	46020800 	.word	0x46020800
      }
    }
    else
    {
      /* set overall return value */
      status = ret;
 8003510:	f897 30d3 	ldrb.w	r3, [r7, #211]	@ 0xd3
 8003514:	f887 30d2 	strb.w	r3, [r7, #210]	@ 0xd2
    }

    /* Restore clock configuration if changed */
    if (pwrclkchanged == SET)
 8003518:	f897 30d1 	ldrb.w	r3, [r7, #209]	@ 0xd1
 800351c:	2b01      	cmp	r3, #1
 800351e:	d107      	bne.n	8003530 <HAL_RCCEx_PeriphCLKConfig+0x6d8>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8003520:	4bb2      	ldr	r3, [pc, #712]	@ (80037ec <HAL_RCCEx_PeriphCLKConfig+0x994>)
 8003522:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8003526:	4ab1      	ldr	r2, [pc, #708]	@ (80037ec <HAL_RCCEx_PeriphCLKConfig+0x994>)
 8003528:	f023 0304 	bic.w	r3, r3, #4
 800352c:	f8c2 3094 	str.w	r3, [r2, #148]	@ 0x94
    }
  }

  /*-------------------------------------- ICLK Configuration -----------------------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ICLK) == RCC_PERIPHCLK_ICLK)
 8003530:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8003534:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003538:	f402 1380 	and.w	r3, r2, #1048576	@ 0x100000
 800353c:	64bb      	str	r3, [r7, #72]	@ 0x48
 800353e:	2300      	movs	r3, #0
 8003540:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8003542:	e9d7 1212 	ldrd	r1, r2, [r7, #72]	@ 0x48
 8003546:	460b      	mov	r3, r1
 8003548:	4313      	orrs	r3, r2
 800354a:	d042      	beq.n	80035d2 <HAL_RCCEx_PeriphCLKConfig+0x77a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ICLKCLKSOURCE(pPeriphClkInit->IclkClockSelection));

    switch (pPeriphClkInit->IclkClockSelection)
 800354c:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8003550:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
 8003554:	f1b3 6f40 	cmp.w	r3, #201326592	@ 0xc000000
 8003558:	d022      	beq.n	80035a0 <HAL_RCCEx_PeriphCLKConfig+0x748>
 800355a:	f1b3 6f40 	cmp.w	r3, #201326592	@ 0xc000000
 800355e:	d81b      	bhi.n	8003598 <HAL_RCCEx_PeriphCLKConfig+0x740>
 8003560:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 8003564:	d011      	beq.n	800358a <HAL_RCCEx_PeriphCLKConfig+0x732>
 8003566:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 800356a:	d815      	bhi.n	8003598 <HAL_RCCEx_PeriphCLKConfig+0x740>
 800356c:	2b00      	cmp	r3, #0
 800356e:	d019      	beq.n	80035a4 <HAL_RCCEx_PeriphCLKConfig+0x74c>
 8003570:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
 8003574:	d110      	bne.n	8003598 <HAL_RCCEx_PeriphCLKConfig+0x740>
    {
      case RCC_ICLK_CLKSOURCE_PLL2:
        /* PLL2 input clock, parameters M, N,P,Q & R configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 8003576:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 800357a:	3308      	adds	r3, #8
 800357c:	4618      	mov	r0, r3
 800357e:	f001 fef9 	bl	8005374 <RCCEx_PLL2_Config>
 8003582:	4603      	mov	r3, r0
 8003584:	f887 30d3 	strb.w	r3, [r7, #211]	@ 0xd3
        break;
 8003588:	e00d      	b.n	80035a6 <HAL_RCCEx_PeriphCLKConfig+0x74e>
      case RCC_ICLK_CLKSOURCE_PLL1:
        /* Enable ICLK Clock output generated from System PLL  */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800358a:	4b98      	ldr	r3, [pc, #608]	@ (80037ec <HAL_RCCEx_PeriphCLKConfig+0x994>)
 800358c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800358e:	4a97      	ldr	r2, [pc, #604]	@ (80037ec <HAL_RCCEx_PeriphCLKConfig+0x994>)
 8003590:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8003594:	6293      	str	r3, [r2, #40]	@ 0x28
        break;
 8003596:	e006      	b.n	80035a6 <HAL_RCCEx_PeriphCLKConfig+0x74e>
      case RCC_ICLK_CLKSOURCE_HSI48:
        break;
      case RCC_ICLK_CLKSOURCE_MSIK:
        break;
      default:
        ret = HAL_ERROR;
 8003598:	2301      	movs	r3, #1
 800359a:	f887 30d3 	strb.w	r3, [r7, #211]	@ 0xd3
        break;
 800359e:	e002      	b.n	80035a6 <HAL_RCCEx_PeriphCLKConfig+0x74e>
        break;
 80035a0:	bf00      	nop
 80035a2:	e000      	b.n	80035a6 <HAL_RCCEx_PeriphCLKConfig+0x74e>
        break;
 80035a4:	bf00      	nop
    }
    if (ret == HAL_OK)
 80035a6:	f897 30d3 	ldrb.w	r3, [r7, #211]	@ 0xd3
 80035aa:	2b00      	cmp	r3, #0
 80035ac:	d10d      	bne.n	80035ca <HAL_RCCEx_PeriphCLKConfig+0x772>
    {
      /* Configure the CLK48 source */
      __HAL_RCC_CLK48_CONFIG(pPeriphClkInit->IclkClockSelection);
 80035ae:	4b8f      	ldr	r3, [pc, #572]	@ (80037ec <HAL_RCCEx_PeriphCLKConfig+0x994>)
 80035b0:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 80035b4:	f023 6140 	bic.w	r1, r3, #201326592	@ 0xc000000
 80035b8:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 80035bc:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
 80035c0:	4a8a      	ldr	r2, [pc, #552]	@ (80037ec <HAL_RCCEx_PeriphCLKConfig+0x994>)
 80035c2:	430b      	orrs	r3, r1
 80035c4:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
 80035c8:	e003      	b.n	80035d2 <HAL_RCCEx_PeriphCLKConfig+0x77a>
    }
    else
    {
      /* set overall return value */
      status = ret;
 80035ca:	f897 30d3 	ldrb.w	r3, [r7, #211]	@ 0xd3
 80035ce:	f887 30d2 	strb.w	r3, [r7, #210]	@ 0xd2
    }
  }

  /*------------------------------ RNG Configuration -------------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == RCC_PERIPHCLK_RNG)
 80035d2:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 80035d6:	e9d3 2300 	ldrd	r2, r3, [r3]
 80035da:	f402 2300 	and.w	r3, r2, #524288	@ 0x80000
 80035de:	643b      	str	r3, [r7, #64]	@ 0x40
 80035e0:	2300      	movs	r3, #0
 80035e2:	647b      	str	r3, [r7, #68]	@ 0x44
 80035e4:	e9d7 1210 	ldrd	r1, r2, [r7, #64]	@ 0x40
 80035e8:	460b      	mov	r3, r1
 80035ea:	4313      	orrs	r3, r2
 80035ec:	d02d      	beq.n	800364a <HAL_RCCEx_PeriphCLKConfig+0x7f2>
  {

    /* Check the parameters */
    assert_param(IS_RCC_RNGCLKSOURCE(pPeriphClkInit->RngClockSelection));

    switch (pPeriphClkInit->RngClockSelection)
 80035ee:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 80035f2:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 80035f6:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 80035fa:	d00b      	beq.n	8003614 <HAL_RCCEx_PeriphCLKConfig+0x7bc>
 80035fc:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8003600:	d804      	bhi.n	800360c <HAL_RCCEx_PeriphCLKConfig+0x7b4>
 8003602:	2b00      	cmp	r3, #0
 8003604:	d008      	beq.n	8003618 <HAL_RCCEx_PeriphCLKConfig+0x7c0>
 8003606:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 800360a:	d007      	beq.n	800361c <HAL_RCCEx_PeriphCLKConfig+0x7c4>
      case RCC_RNGCLKSOURCE_HSI48:
        /* HSI48 oscillator is used as source of RNG clock */
        /* RNG clock source configuration done later after clock selection check */
        break;
      default:
        ret = HAL_ERROR;
 800360c:	2301      	movs	r3, #1
 800360e:	f887 30d3 	strb.w	r3, [r7, #211]	@ 0xd3
        break;
 8003612:	e004      	b.n	800361e <HAL_RCCEx_PeriphCLKConfig+0x7c6>
        break;
 8003614:	bf00      	nop
 8003616:	e002      	b.n	800361e <HAL_RCCEx_PeriphCLKConfig+0x7c6>
        break;
 8003618:	bf00      	nop
 800361a:	e000      	b.n	800361e <HAL_RCCEx_PeriphCLKConfig+0x7c6>
        break;
 800361c:	bf00      	nop
    }
    if (ret == HAL_OK)
 800361e:	f897 30d3 	ldrb.w	r3, [r7, #211]	@ 0xd3
 8003622:	2b00      	cmp	r3, #0
 8003624:	d10d      	bne.n	8003642 <HAL_RCCEx_PeriphCLKConfig+0x7ea>
    {
      /* Set the source of RNG clock*/
      __HAL_RCC_RNG_CONFIG(pPeriphClkInit->RngClockSelection);
 8003626:	4b71      	ldr	r3, [pc, #452]	@ (80037ec <HAL_RCCEx_PeriphCLKConfig+0x994>)
 8003628:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 800362c:	f423 5140 	bic.w	r1, r3, #12288	@ 0x3000
 8003630:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8003634:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 8003638:	4a6c      	ldr	r2, [pc, #432]	@ (80037ec <HAL_RCCEx_PeriphCLKConfig+0x994>)
 800363a:	430b      	orrs	r3, r1
 800363c:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
 8003640:	e003      	b.n	800364a <HAL_RCCEx_PeriphCLKConfig+0x7f2>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8003642:	f897 30d3 	ldrb.w	r3, [r7, #211]	@ 0xd3
 8003646:	f887 30d2 	strb.w	r3, [r7, #210]	@ 0xd2
    }
  }

#if defined(SAES)
  /*-------------------------- SAES clock source configuration ----------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAES) == RCC_PERIPHCLK_SAES)
 800364a:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 800364e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003652:	f402 5380 	and.w	r3, r2, #4096	@ 0x1000
 8003656:	63bb      	str	r3, [r7, #56]	@ 0x38
 8003658:	2300      	movs	r3, #0
 800365a:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800365c:	e9d7 120e 	ldrd	r1, r2, [r7, #56]	@ 0x38
 8003660:	460b      	mov	r3, r1
 8003662:	4313      	orrs	r3, r2
 8003664:	d00c      	beq.n	8003680 <HAL_RCCEx_PeriphCLKConfig+0x828>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAESCLKSOURCE(pPeriphClkInit->SaesClockSelection));

    /* Configure the SAES clock source */
    __HAL_RCC_SAES_CONFIG(pPeriphClkInit->SaesClockSelection);
 8003666:	4b61      	ldr	r3, [pc, #388]	@ (80037ec <HAL_RCCEx_PeriphCLKConfig+0x994>)
 8003668:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 800366c:	f423 6100 	bic.w	r1, r3, #2048	@ 0x800
 8003670:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8003674:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8003678:	4a5c      	ldr	r2, [pc, #368]	@ (80037ec <HAL_RCCEx_PeriphCLKConfig+0x994>)
 800367a:	430b      	orrs	r3, r1
 800367c:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  }
#endif /* SAES */

  /*-------------------------- SDMMC1/2 clock source configuration -------------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC) == (RCC_PERIPHCLK_SDMMC))
 8003680:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8003684:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003688:	f402 1300 	and.w	r3, r2, #2097152	@ 0x200000
 800368c:	633b      	str	r3, [r7, #48]	@ 0x30
 800368e:	2300      	movs	r3, #0
 8003690:	637b      	str	r3, [r7, #52]	@ 0x34
 8003692:	e9d7 120c 	ldrd	r1, r2, [r7, #48]	@ 0x30
 8003696:	460b      	mov	r3, r1
 8003698:	4313      	orrs	r3, r2
 800369a:	d019      	beq.n	80036d0 <HAL_RCCEx_PeriphCLKConfig+0x878>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMCCLKSOURCE(pPeriphClkInit->SdmmcClockSelection));

    if (pPeriphClkInit->SdmmcClockSelection == RCC_SDMMCCLKSOURCE_PLL1)
 800369c:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 80036a0:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
 80036a4:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 80036a8:	d105      	bne.n	80036b6 <HAL_RCCEx_PeriphCLKConfig+0x85e>
    {
      /* Enable PLL1 P CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVP);
 80036aa:	4b50      	ldr	r3, [pc, #320]	@ (80037ec <HAL_RCCEx_PeriphCLKConfig+0x994>)
 80036ac:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80036ae:	4a4f      	ldr	r2, [pc, #316]	@ (80037ec <HAL_RCCEx_PeriphCLKConfig+0x994>)
 80036b0:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 80036b4:	6293      	str	r3, [r2, #40]	@ 0x28
    }

    /* Configure the SDMMC1/2 clock source */
    __HAL_RCC_SDMMC_CONFIG(pPeriphClkInit->SdmmcClockSelection);
 80036b6:	4b4d      	ldr	r3, [pc, #308]	@ (80037ec <HAL_RCCEx_PeriphCLKConfig+0x994>)
 80036b8:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 80036bc:	f423 4180 	bic.w	r1, r3, #16384	@ 0x4000
 80036c0:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 80036c4:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
 80036c8:	4a48      	ldr	r2, [pc, #288]	@ (80037ec <HAL_RCCEx_PeriphCLKConfig+0x994>)
 80036ca:	430b      	orrs	r3, r1
 80036cc:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  }

  /*-------------------------- SPI1 clock source configuration ----------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI1) == RCC_PERIPHCLK_SPI1)
 80036d0:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 80036d4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80036d8:	f402 0300 	and.w	r3, r2, #8388608	@ 0x800000
 80036dc:	62bb      	str	r3, [r7, #40]	@ 0x28
 80036de:	2300      	movs	r3, #0
 80036e0:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80036e2:	e9d7 120a 	ldrd	r1, r2, [r7, #40]	@ 0x28
 80036e6:	460b      	mov	r3, r1
 80036e8:	4313      	orrs	r3, r2
 80036ea:	d00c      	beq.n	8003706 <HAL_RCCEx_PeriphCLKConfig+0x8ae>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI1CLKSOURCE(pPeriphClkInit->Spi1ClockSelection));

    /* Configure the SPI1 clock source */
    __HAL_RCC_SPI1_CONFIG(pPeriphClkInit->Spi1ClockSelection);
 80036ec:	4b3f      	ldr	r3, [pc, #252]	@ (80037ec <HAL_RCCEx_PeriphCLKConfig+0x994>)
 80036ee:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 80036f2:	f423 1240 	bic.w	r2, r3, #3145728	@ 0x300000
 80036f6:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 80036fa:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
 80036fe:	493b      	ldr	r1, [pc, #236]	@ (80037ec <HAL_RCCEx_PeriphCLKConfig+0x994>)
 8003700:	4313      	orrs	r3, r2
 8003702:	f8c1 30e0 	str.w	r3, [r1, #224]	@ 0xe0
  }

  /*-------------------------- SPI2 clock source configuration ----------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI2) == RCC_PERIPHCLK_SPI2)
 8003706:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 800370a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800370e:	f002 7380 	and.w	r3, r2, #16777216	@ 0x1000000
 8003712:	623b      	str	r3, [r7, #32]
 8003714:	2300      	movs	r3, #0
 8003716:	627b      	str	r3, [r7, #36]	@ 0x24
 8003718:	e9d7 1208 	ldrd	r1, r2, [r7, #32]
 800371c:	460b      	mov	r3, r1
 800371e:	4313      	orrs	r3, r2
 8003720:	d00c      	beq.n	800373c <HAL_RCCEx_PeriphCLKConfig+0x8e4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI2CLKSOURCE(pPeriphClkInit->Spi2ClockSelection));

    /* Configure the SPI2 clock source */
    __HAL_RCC_SPI2_CONFIG(pPeriphClkInit->Spi2ClockSelection);
 8003722:	4b32      	ldr	r3, [pc, #200]	@ (80037ec <HAL_RCCEx_PeriphCLKConfig+0x994>)
 8003724:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8003728:	f423 3240 	bic.w	r2, r3, #196608	@ 0x30000
 800372c:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8003730:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
 8003734:	492d      	ldr	r1, [pc, #180]	@ (80037ec <HAL_RCCEx_PeriphCLKConfig+0x994>)
 8003736:	4313      	orrs	r3, r2
 8003738:	f8c1 30e0 	str.w	r3, [r1, #224]	@ 0xe0
  }

  /*-------------------------- SPI3 clock source configuration ----------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI3) == RCC_PERIPHCLK_SPI3)
 800373c:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8003740:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003744:	f002 7300 	and.w	r3, r2, #33554432	@ 0x2000000
 8003748:	61bb      	str	r3, [r7, #24]
 800374a:	2300      	movs	r3, #0
 800374c:	61fb      	str	r3, [r7, #28]
 800374e:	e9d7 1206 	ldrd	r1, r2, [r7, #24]
 8003752:	460b      	mov	r3, r1
 8003754:	4313      	orrs	r3, r2
 8003756:	d00c      	beq.n	8003772 <HAL_RCCEx_PeriphCLKConfig+0x91a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI3CLKSOURCE(pPeriphClkInit->Spi3ClockSelection));

    /* Configure the SPI3 clock source */
    __HAL_RCC_SPI3_CONFIG(pPeriphClkInit->Spi3ClockSelection);
 8003758:	4b24      	ldr	r3, [pc, #144]	@ (80037ec <HAL_RCCEx_PeriphCLKConfig+0x994>)
 800375a:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 800375e:	f023 0218 	bic.w	r2, r3, #24
 8003762:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8003766:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
 800376a:	4920      	ldr	r1, [pc, #128]	@ (80037ec <HAL_RCCEx_PeriphCLKConfig+0x994>)
 800376c:	4313      	orrs	r3, r2
 800376e:	f8c1 30e8 	str.w	r3, [r1, #232]	@ 0xe8
  }

  /*-------------------------- OctoSPIx clock source configuration ----------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_OSPI) == RCC_PERIPHCLK_OSPI)
 8003772:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8003776:	e9d3 2300 	ldrd	r2, r3, [r3]
 800377a:	f002 6380 	and.w	r3, r2, #67108864	@ 0x4000000
 800377e:	613b      	str	r3, [r7, #16]
 8003780:	2300      	movs	r3, #0
 8003782:	617b      	str	r3, [r7, #20]
 8003784:	e9d7 1204 	ldrd	r1, r2, [r7, #16]
 8003788:	460b      	mov	r3, r1
 800378a:	4313      	orrs	r3, r2
 800378c:	d034      	beq.n	80037f8 <HAL_RCCEx_PeriphCLKConfig+0x9a0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_OSPICLKSOURCE(pPeriphClkInit->OspiClockSelection));

    if (pPeriphClkInit->OspiClockSelection == RCC_OSPICLKSOURCE_PLL1)
 800378e:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8003792:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
 8003796:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 800379a:	d105      	bne.n	80037a8 <HAL_RCCEx_PeriphCLKConfig+0x950>
    {
      /* Enable PLL1 Q CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800379c:	4b13      	ldr	r3, [pc, #76]	@ (80037ec <HAL_RCCEx_PeriphCLKConfig+0x994>)
 800379e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80037a0:	4a12      	ldr	r2, [pc, #72]	@ (80037ec <HAL_RCCEx_PeriphCLKConfig+0x994>)
 80037a2:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 80037a6:	6293      	str	r3, [r2, #40]	@ 0x28
    }
    if (pPeriphClkInit->OspiClockSelection == RCC_OSPICLKSOURCE_PLL2)
 80037a8:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 80037ac:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
 80037b0:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
 80037b4:	d108      	bne.n	80037c8 <HAL_RCCEx_PeriphCLKConfig+0x970>
    {
      /* PLL2 input clock, parameters M, N & Q configuration and clock output (PLL2ClockOut) */
      ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 80037b6:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 80037ba:	3308      	adds	r3, #8
 80037bc:	4618      	mov	r0, r3
 80037be:	f001 fdd9 	bl	8005374 <RCCEx_PLL2_Config>
 80037c2:	4603      	mov	r3, r0
 80037c4:	f887 30d3 	strb.w	r3, [r7, #211]	@ 0xd3
    }
    if (ret == HAL_OK)
 80037c8:	f897 30d3 	ldrb.w	r3, [r7, #211]	@ 0xd3
 80037cc:	2b00      	cmp	r3, #0
 80037ce:	d10f      	bne.n	80037f0 <HAL_RCCEx_PeriphCLKConfig+0x998>
    {
      /* Configure the OctoSPI clock source */
      __HAL_RCC_OSPI_CONFIG(pPeriphClkInit->OspiClockSelection);
 80037d0:	4b06      	ldr	r3, [pc, #24]	@ (80037ec <HAL_RCCEx_PeriphCLKConfig+0x994>)
 80037d2:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 80037d6:	f423 1240 	bic.w	r2, r3, #3145728	@ 0x300000
 80037da:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 80037de:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
 80037e2:	4902      	ldr	r1, [pc, #8]	@ (80037ec <HAL_RCCEx_PeriphCLKConfig+0x994>)
 80037e4:	4313      	orrs	r3, r2
 80037e6:	f8c1 30e4 	str.w	r3, [r1, #228]	@ 0xe4
 80037ea:	e005      	b.n	80037f8 <HAL_RCCEx_PeriphCLKConfig+0x9a0>
 80037ec:	46020c00 	.word	0x46020c00
    }
    else
    {
      /* set overall return value */
      status = ret;
 80037f0:	f897 30d3 	ldrb.w	r3, [r7, #211]	@ 0xd3
 80037f4:	f887 30d2 	strb.w	r3, [r7, #210]	@ 0xd2
    }
  }
#endif /* defined(HSPI1) */

  /*-------------------------- FDCAN1 kernel clock source configuration -------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FDCAN1) == (RCC_PERIPHCLK_FDCAN1))
 80037f8:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 80037fc:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003800:	f002 6300 	and.w	r3, r2, #134217728	@ 0x8000000
 8003804:	60bb      	str	r3, [r7, #8]
 8003806:	2300      	movs	r3, #0
 8003808:	60fb      	str	r3, [r7, #12]
 800380a:	e9d7 1202 	ldrd	r1, r2, [r7, #8]
 800380e:	460b      	mov	r3, r1
 8003810:	4313      	orrs	r3, r2
 8003812:	d03a      	beq.n	800388a <HAL_RCCEx_PeriphCLKConfig+0xa32>
  {
    assert_param(IS_RCC_FDCAN1CLK(pPeriphClkInit->Fdcan1ClockSelection));

    switch (pPeriphClkInit->Fdcan1ClockSelection)
 8003814:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8003818:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 800381c:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 8003820:	d00e      	beq.n	8003840 <HAL_RCCEx_PeriphCLKConfig+0x9e8>
 8003822:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 8003826:	d815      	bhi.n	8003854 <HAL_RCCEx_PeriphCLKConfig+0x9fc>
 8003828:	2b00      	cmp	r3, #0
 800382a:	d017      	beq.n	800385c <HAL_RCCEx_PeriphCLKConfig+0xa04>
 800382c:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 8003830:	d110      	bne.n	8003854 <HAL_RCCEx_PeriphCLKConfig+0x9fc>
      case RCC_FDCAN1CLKSOURCE_HSE:      /* HSE is used as source of FDCAN1 kernel clock*/
        /* FDCAN1 kernel clock source config set later after clock selection check */
        break;
      case RCC_FDCAN1CLKSOURCE_PLL1:      /* PLL1 is used as clock source for FDCAN1 kernel clock*/
        /* Enable 48M2 Clock output generated from System PLL  */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8003832:	4b27      	ldr	r3, [pc, #156]	@ (80038d0 <HAL_RCCEx_PeriphCLKConfig+0xa78>)
 8003834:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8003836:	4a26      	ldr	r2, [pc, #152]	@ (80038d0 <HAL_RCCEx_PeriphCLKConfig+0xa78>)
 8003838:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 800383c:	6293      	str	r3, [r2, #40]	@ 0x28
        /* FDCAN1 kernel clock source config set later after clock selection check */
        break;
 800383e:	e00e      	b.n	800385e <HAL_RCCEx_PeriphCLKConfig+0xa06>
      case RCC_FDCAN1CLKSOURCE_PLL2:  /* PLL2 is used as clock source for FDCAN1 kernel clock*/
        /* PLL2 input clock, parameters M, N & P configuration and clock output (PLL2ClockOut) */
        ret = RCCEx_PLL2_Config(&(pPeriphClkInit->PLL2));
 8003840:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8003844:	3308      	adds	r3, #8
 8003846:	4618      	mov	r0, r3
 8003848:	f001 fd94 	bl	8005374 <RCCEx_PLL2_Config>
 800384c:	4603      	mov	r3, r0
 800384e:	f887 30d3 	strb.w	r3, [r7, #211]	@ 0xd3
        /* FDCAN1 kernel clock source config set later after clock selection check */
        break;
 8003852:	e004      	b.n	800385e <HAL_RCCEx_PeriphCLKConfig+0xa06>
      default:
        ret = HAL_ERROR;
 8003854:	2301      	movs	r3, #1
 8003856:	f887 30d3 	strb.w	r3, [r7, #211]	@ 0xd3
        break;
 800385a:	e000      	b.n	800385e <HAL_RCCEx_PeriphCLKConfig+0xa06>
        break;
 800385c:	bf00      	nop
    }
    if (ret == HAL_OK)
 800385e:	f897 30d3 	ldrb.w	r3, [r7, #211]	@ 0xd3
 8003862:	2b00      	cmp	r3, #0
 8003864:	d10d      	bne.n	8003882 <HAL_RCCEx_PeriphCLKConfig+0xa2a>
    {
      /* Set the source of FDCAN1 kernel clock*/
      __HAL_RCC_FDCAN1_CONFIG(pPeriphClkInit->Fdcan1ClockSelection);
 8003866:	4b1a      	ldr	r3, [pc, #104]	@ (80038d0 <HAL_RCCEx_PeriphCLKConfig+0xa78>)
 8003868:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 800386c:	f023 7240 	bic.w	r2, r3, #50331648	@ 0x3000000
 8003870:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8003874:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 8003878:	4915      	ldr	r1, [pc, #84]	@ (80038d0 <HAL_RCCEx_PeriphCLKConfig+0xa78>)
 800387a:	4313      	orrs	r3, r2
 800387c:	f8c1 30e0 	str.w	r3, [r1, #224]	@ 0xe0
 8003880:	e003      	b.n	800388a <HAL_RCCEx_PeriphCLKConfig+0xa32>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8003882:	f897 30d3 	ldrb.w	r3, [r7, #211]	@ 0xd3
 8003886:	f887 30d2 	strb.w	r3, [r7, #210]	@ 0xd2
    }
  }

  /*-------------------------- DAC1 clock source configuration ----------------*/
  if (((pPeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DAC1) == RCC_PERIPHCLK_DAC1)
 800388a:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 800388e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003892:	f002 5380 	and.w	r3, r2, #268435456	@ 0x10000000
 8003896:	603b      	str	r3, [r7, #0]
 8003898:	2300      	movs	r3, #0
 800389a:	607b      	str	r3, [r7, #4]
 800389c:	e9d7 1200 	ldrd	r1, r2, [r7]
 80038a0:	460b      	mov	r3, r1
 80038a2:	4313      	orrs	r3, r2
 80038a4:	d00c      	beq.n	80038c0 <HAL_RCCEx_PeriphCLKConfig+0xa68>

    /* Check the parameters */
    assert_param(IS_RCC_DAC1CLKSOURCE(pPeriphClkInit->Dac1ClockSelection));

    /* Configure the DAC1 clock source */
    __HAL_RCC_DAC1_CONFIG(pPeriphClkInit->Dac1ClockSelection);
 80038a6:	4b0a      	ldr	r3, [pc, #40]	@ (80038d0 <HAL_RCCEx_PeriphCLKConfig+0xa78>)
 80038a8:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 80038ac:	f423 4200 	bic.w	r2, r3, #32768	@ 0x8000
 80038b0:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 80038b4:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
 80038b8:	4905      	ldr	r1, [pc, #20]	@ (80038d0 <HAL_RCCEx_PeriphCLKConfig+0xa78>)
 80038ba:	4313      	orrs	r3, r2
 80038bc:	f8c1 30e8 	str.w	r3, [r1, #232]	@ 0xe8
    }
  }

#endif /* defined(USB_OTG_HS) */

  return status;
 80038c0:	f897 30d2 	ldrb.w	r3, [r7, #210]	@ 0xd2
}
 80038c4:	4618      	mov	r0, r3
 80038c6:	37d8      	adds	r7, #216	@ 0xd8
 80038c8:	46bd      	mov	sp, r7
 80038ca:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 80038ce:	bf00      	nop
 80038d0:	46020c00 	.word	0x46020c00

080038d4 <HAL_RCCEx_GetPLL1ClockFreq>:
  *         right PLL1CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  PLL1_Clocks structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL1ClockFreq(PLL1_ClocksTypeDef *PLL1_Clocks)
{
 80038d4:	b480      	push	{r7}
 80038d6:	b089      	sub	sp, #36	@ 0x24
 80038d8:	af00      	add	r7, sp, #0
 80038da:	6078      	str	r0, [r7, #4]
  uint32_t pll1n;
  uint32_t pll1fracen;
  float_t fracn1;
  float_t pll1vco;

  pll1n = (RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N);
 80038dc:	4ba6      	ldr	r3, [pc, #664]	@ (8003b78 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 80038de:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80038e0:	f3c3 0308 	ubfx	r3, r3, #0, #9
 80038e4:	61bb      	str	r3, [r7, #24]
  pll1source = (RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1SRC);
 80038e6:	4ba4      	ldr	r3, [pc, #656]	@ (8003b78 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 80038e8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80038ea:	f003 0303 	and.w	r3, r3, #3
 80038ee:	617b      	str	r3, [r7, #20]
  pll1m = ((RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1M) >> RCC_PLL1CFGR_PLL1M_Pos) + 1U;
 80038f0:	4ba1      	ldr	r3, [pc, #644]	@ (8003b78 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 80038f2:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80038f4:	0a1b      	lsrs	r3, r3, #8
 80038f6:	f003 030f 	and.w	r3, r3, #15
 80038fa:	3301      	adds	r3, #1
 80038fc:	613b      	str	r3, [r7, #16]
  pll1fracen = ((RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1FRACEN) >> RCC_PLL1CFGR_PLL1FRACEN_Pos);
 80038fe:	4b9e      	ldr	r3, [pc, #632]	@ (8003b78 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 8003900:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8003902:	091b      	lsrs	r3, r3, #4
 8003904:	f003 0301 	and.w	r3, r3, #1
 8003908:	60fb      	str	r3, [r7, #12]
  fracn1 = (float_t)(uint32_t)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_PLL1FRACN) >> \
 800390a:	4b9b      	ldr	r3, [pc, #620]	@ (8003b78 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 800390c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800390e:	08db      	lsrs	r3, r3, #3
 8003910:	f3c3 030c 	ubfx	r3, r3, #0, #13
 8003914:	68fa      	ldr	r2, [r7, #12]
 8003916:	fb02 f303 	mul.w	r3, r2, r3
 800391a:	ee07 3a90 	vmov	s15, r3
 800391e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8003922:	edc7 7a02 	vstr	s15, [r7, #8]
                                             RCC_PLL1FRACR_PLL1FRACN_Pos));

  switch (pll1source)
 8003926:	697b      	ldr	r3, [r7, #20]
 8003928:	2b03      	cmp	r3, #3
 800392a:	d062      	beq.n	80039f2 <HAL_RCCEx_GetPLL1ClockFreq+0x11e>
 800392c:	697b      	ldr	r3, [r7, #20]
 800392e:	2b03      	cmp	r3, #3
 8003930:	f200 8081 	bhi.w	8003a36 <HAL_RCCEx_GetPLL1ClockFreq+0x162>
 8003934:	697b      	ldr	r3, [r7, #20]
 8003936:	2b01      	cmp	r3, #1
 8003938:	d024      	beq.n	8003984 <HAL_RCCEx_GetPLL1ClockFreq+0xb0>
 800393a:	697b      	ldr	r3, [r7, #20]
 800393c:	2b02      	cmp	r3, #2
 800393e:	d17a      	bne.n	8003a36 <HAL_RCCEx_GetPLL1ClockFreq+0x162>
  {

    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
      pll1vco = ((float_t)HSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 8003940:	693b      	ldr	r3, [r7, #16]
 8003942:	ee07 3a90 	vmov	s15, r3
 8003946:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800394a:	eddf 6a8c 	vldr	s13, [pc, #560]	@ 8003b7c <HAL_RCCEx_GetPLL1ClockFreq+0x2a8>
 800394e:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8003952:	4b89      	ldr	r3, [pc, #548]	@ (8003b78 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 8003954:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8003956:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800395a:	ee07 3a90 	vmov	s15, r3
 800395e:	eef8 6a67 	vcvt.f32.u32	s13, s15
                                                         (fracn1 / (float_t)0x2000) + (float_t)1);
 8003962:	ed97 6a02 	vldr	s12, [r7, #8]
 8003966:	eddf 5a86 	vldr	s11, [pc, #536]	@ 8003b80 <HAL_RCCEx_GetPLL1ClockFreq+0x2ac>
 800396a:	eec6 7a25 	vdiv.f32	s15, s12, s11
      pll1vco = ((float_t)HSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 800396e:	ee76 7aa7 	vadd.f32	s15, s13, s15
                                                         (fracn1 / (float_t)0x2000) + (float_t)1);
 8003972:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8003976:	ee77 7aa6 	vadd.f32	s15, s15, s13
      pll1vco = ((float_t)HSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 800397a:	ee67 7a27 	vmul.f32	s15, s14, s15
 800397e:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 8003982:	e08f      	b.n	8003aa4 <HAL_RCCEx_GetPLL1ClockFreq+0x1d0>
    case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
      pll1vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t)pll1m) * \
 8003984:	4b7c      	ldr	r3, [pc, #496]	@ (8003b78 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 8003986:	689b      	ldr	r3, [r3, #8]
 8003988:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 800398c:	2b00      	cmp	r3, #0
 800398e:	d005      	beq.n	800399c <HAL_RCCEx_GetPLL1ClockFreq+0xc8>
 8003990:	4b79      	ldr	r3, [pc, #484]	@ (8003b78 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 8003992:	689b      	ldr	r3, [r3, #8]
 8003994:	0f1b      	lsrs	r3, r3, #28
 8003996:	f003 030f 	and.w	r3, r3, #15
 800399a:	e006      	b.n	80039aa <HAL_RCCEx_GetPLL1ClockFreq+0xd6>
 800399c:	4b76      	ldr	r3, [pc, #472]	@ (8003b78 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 800399e:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 80039a2:	041b      	lsls	r3, r3, #16
 80039a4:	0f1b      	lsrs	r3, r3, #28
 80039a6:	f003 030f 	and.w	r3, r3, #15
 80039aa:	4a76      	ldr	r2, [pc, #472]	@ (8003b84 <HAL_RCCEx_GetPLL1ClockFreq+0x2b0>)
 80039ac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80039b0:	ee07 3a90 	vmov	s15, r3
 80039b4:	eef8 6a67 	vcvt.f32.u32	s13, s15
 80039b8:	693b      	ldr	r3, [r7, #16]
 80039ba:	ee07 3a90 	vmov	s15, r3
 80039be:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80039c2:	ee86 7aa7 	vdiv.f32	s14, s13, s15
                ((float_t)pll1n + (fracn1 / (float_t)0x2000) + (float_t)1);
 80039c6:	69bb      	ldr	r3, [r7, #24]
 80039c8:	ee07 3a90 	vmov	s15, r3
 80039cc:	eef8 6a67 	vcvt.f32.u32	s13, s15
 80039d0:	ed97 6a02 	vldr	s12, [r7, #8]
 80039d4:	eddf 5a6a 	vldr	s11, [pc, #424]	@ 8003b80 <HAL_RCCEx_GetPLL1ClockFreq+0x2ac>
 80039d8:	eec6 7a25 	vdiv.f32	s15, s12, s11
 80039dc:	ee76 7aa7 	vadd.f32	s15, s13, s15
 80039e0:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 80039e4:	ee77 7aa6 	vadd.f32	s15, s15, s13
      pll1vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t)pll1m) * \
 80039e8:	ee67 7a27 	vmul.f32	s15, s14, s15
 80039ec:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 80039f0:	e058      	b.n	8003aa4 <HAL_RCCEx_GetPLL1ClockFreq+0x1d0>
    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      pll1vco = ((float_t)HSE_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 80039f2:	693b      	ldr	r3, [r7, #16]
 80039f4:	ee07 3a90 	vmov	s15, r3
 80039f8:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80039fc:	eddf 6a5f 	vldr	s13, [pc, #380]	@ 8003b7c <HAL_RCCEx_GetPLL1ClockFreq+0x2a8>
 8003a00:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8003a04:	4b5c      	ldr	r3, [pc, #368]	@ (8003b78 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 8003a06:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8003a08:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8003a0c:	ee07 3a90 	vmov	s15, r3
 8003a10:	eef8 6a67 	vcvt.f32.u32	s13, s15
                                                         (fracn1 / (float_t)0x2000) + (float_t)1);
 8003a14:	ed97 6a02 	vldr	s12, [r7, #8]
 8003a18:	eddf 5a59 	vldr	s11, [pc, #356]	@ 8003b80 <HAL_RCCEx_GetPLL1ClockFreq+0x2ac>
 8003a1c:	eec6 7a25 	vdiv.f32	s15, s12, s11
      pll1vco = ((float_t)HSE_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 8003a20:	ee76 7aa7 	vadd.f32	s15, s13, s15
                                                         (fracn1 / (float_t)0x2000) + (float_t)1);
 8003a24:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8003a28:	ee77 7aa6 	vadd.f32	s15, s15, s13
      pll1vco = ((float_t)HSE_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 8003a2c:	ee67 7a27 	vmul.f32	s15, s14, s15
 8003a30:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 8003a34:	e036      	b.n	8003aa4 <HAL_RCCEx_GetPLL1ClockFreq+0x1d0>
    default:
      pll1vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t)pll1m) * \
 8003a36:	4b50      	ldr	r3, [pc, #320]	@ (8003b78 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 8003a38:	689b      	ldr	r3, [r3, #8]
 8003a3a:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 8003a3e:	2b00      	cmp	r3, #0
 8003a40:	d005      	beq.n	8003a4e <HAL_RCCEx_GetPLL1ClockFreq+0x17a>
 8003a42:	4b4d      	ldr	r3, [pc, #308]	@ (8003b78 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 8003a44:	689b      	ldr	r3, [r3, #8]
 8003a46:	0f1b      	lsrs	r3, r3, #28
 8003a48:	f003 030f 	and.w	r3, r3, #15
 8003a4c:	e006      	b.n	8003a5c <HAL_RCCEx_GetPLL1ClockFreq+0x188>
 8003a4e:	4b4a      	ldr	r3, [pc, #296]	@ (8003b78 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 8003a50:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8003a54:	041b      	lsls	r3, r3, #16
 8003a56:	0f1b      	lsrs	r3, r3, #28
 8003a58:	f003 030f 	and.w	r3, r3, #15
 8003a5c:	4a49      	ldr	r2, [pc, #292]	@ (8003b84 <HAL_RCCEx_GetPLL1ClockFreq+0x2b0>)
 8003a5e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8003a62:	ee07 3a90 	vmov	s15, r3
 8003a66:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8003a6a:	693b      	ldr	r3, [r7, #16]
 8003a6c:	ee07 3a90 	vmov	s15, r3
 8003a70:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8003a74:	ee86 7aa7 	vdiv.f32	s14, s13, s15
                ((float_t)pll1n + (fracn1 / (float_t)0x2000) + (float_t)1);
 8003a78:	69bb      	ldr	r3, [r7, #24]
 8003a7a:	ee07 3a90 	vmov	s15, r3
 8003a7e:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8003a82:	ed97 6a02 	vldr	s12, [r7, #8]
 8003a86:	eddf 5a3e 	vldr	s11, [pc, #248]	@ 8003b80 <HAL_RCCEx_GetPLL1ClockFreq+0x2ac>
 8003a8a:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8003a8e:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8003a92:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8003a96:	ee77 7aa6 	vadd.f32	s15, s15, s13
      pll1vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t)pll1m) * \
 8003a9a:	ee67 7a27 	vmul.f32	s15, s14, s15
 8003a9e:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 8003aa2:	bf00      	nop
  }

  if (__HAL_RCC_GET_PLLCLKOUT_CONFIG(RCC_PLL1_DIVP) != 0U)
 8003aa4:	4b34      	ldr	r3, [pc, #208]	@ (8003b78 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 8003aa6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8003aa8:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 8003aac:	2b00      	cmp	r3, #0
 8003aae:	d017      	beq.n	8003ae0 <HAL_RCCEx_GetPLL1ClockFreq+0x20c>
  {
    PLL1_Clocks->PLL1_P_Frequency = (uint32_t)(float_t)(pll1vco / ((float_t)(uint32_t)((RCC->PLL1DIVR & \
 8003ab0:	4b31      	ldr	r3, [pc, #196]	@ (8003b78 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 8003ab2:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8003ab4:	0a5b      	lsrs	r3, r3, #9
 8003ab6:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8003aba:	ee07 3a90 	vmov	s15, r3
 8003abe:	eef8 7a67 	vcvt.f32.u32	s15, s15
                                                                   RCC_PLL1DIVR_PLL1P) >> RCC_PLL1DIVR_PLL1P_Pos) + \
 8003ac2:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8003ac6:	ee37 7a87 	vadd.f32	s14, s15, s14
    PLL1_Clocks->PLL1_P_Frequency = (uint32_t)(float_t)(pll1vco / ((float_t)(uint32_t)((RCC->PLL1DIVR & \
 8003aca:	edd7 6a07 	vldr	s13, [r7, #28]
 8003ace:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8003ad2:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8003ad6:	ee17 2a90 	vmov	r2, s15
 8003ada:	687b      	ldr	r3, [r7, #4]
 8003adc:	601a      	str	r2, [r3, #0]
 8003ade:	e002      	b.n	8003ae6 <HAL_RCCEx_GetPLL1ClockFreq+0x212>
                                                                   (float_t)1));
  }
  else
  {
    PLL1_Clocks->PLL1_P_Frequency = 0U;
 8003ae0:	687b      	ldr	r3, [r7, #4]
 8003ae2:	2200      	movs	r2, #0
 8003ae4:	601a      	str	r2, [r3, #0]
  }

  if (__HAL_RCC_GET_PLLCLKOUT_CONFIG(RCC_PLL1_DIVQ) != 0U)
 8003ae6:	4b24      	ldr	r3, [pc, #144]	@ (8003b78 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 8003ae8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8003aea:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8003aee:	2b00      	cmp	r3, #0
 8003af0:	d017      	beq.n	8003b22 <HAL_RCCEx_GetPLL1ClockFreq+0x24e>
  {
    PLL1_Clocks->PLL1_Q_Frequency = (uint32_t)(float_t)(pll1vco / ((float_t)(uint32_t)((RCC->PLL1DIVR & \
 8003af2:	4b21      	ldr	r3, [pc, #132]	@ (8003b78 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 8003af4:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8003af6:	0c1b      	lsrs	r3, r3, #16
 8003af8:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8003afc:	ee07 3a90 	vmov	s15, r3
 8003b00:	eef8 7a67 	vcvt.f32.u32	s15, s15
                                                                   RCC_PLL1DIVR_PLL1Q) >> RCC_PLL1DIVR_PLL1Q_Pos) + \
 8003b04:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8003b08:	ee37 7a87 	vadd.f32	s14, s15, s14
    PLL1_Clocks->PLL1_Q_Frequency = (uint32_t)(float_t)(pll1vco / ((float_t)(uint32_t)((RCC->PLL1DIVR & \
 8003b0c:	edd7 6a07 	vldr	s13, [r7, #28]
 8003b10:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8003b14:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8003b18:	ee17 2a90 	vmov	r2, s15
 8003b1c:	687b      	ldr	r3, [r7, #4]
 8003b1e:	605a      	str	r2, [r3, #4]
 8003b20:	e002      	b.n	8003b28 <HAL_RCCEx_GetPLL1ClockFreq+0x254>
                                                                   (float_t)1));
  }
  else
  {
    PLL1_Clocks->PLL1_Q_Frequency = 0U;
 8003b22:	687b      	ldr	r3, [r7, #4]
 8003b24:	2200      	movs	r2, #0
 8003b26:	605a      	str	r2, [r3, #4]
  }

  if (__HAL_RCC_GET_PLLCLKOUT_CONFIG(RCC_PLL1_DIVR) != 0U)
 8003b28:	4b13      	ldr	r3, [pc, #76]	@ (8003b78 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 8003b2a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8003b2c:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
 8003b30:	2b00      	cmp	r3, #0
 8003b32:	d017      	beq.n	8003b64 <HAL_RCCEx_GetPLL1ClockFreq+0x290>
  {
    PLL1_Clocks->PLL1_R_Frequency = (uint32_t)(float_t)(pll1vco / ((float_t)(uint32_t)((RCC->PLL1DIVR & \
 8003b34:	4b10      	ldr	r3, [pc, #64]	@ (8003b78 <HAL_RCCEx_GetPLL1ClockFreq+0x2a4>)
 8003b36:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8003b38:	0e1b      	lsrs	r3, r3, #24
 8003b3a:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8003b3e:	ee07 3a90 	vmov	s15, r3
 8003b42:	eef8 7a67 	vcvt.f32.u32	s15, s15
                                                                   RCC_PLL1DIVR_PLL1R) >> RCC_PLL1DIVR_PLL1R_Pos) + \
 8003b46:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8003b4a:	ee37 7a87 	vadd.f32	s14, s15, s14
    PLL1_Clocks->PLL1_R_Frequency = (uint32_t)(float_t)(pll1vco / ((float_t)(uint32_t)((RCC->PLL1DIVR & \
 8003b4e:	edd7 6a07 	vldr	s13, [r7, #28]
 8003b52:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8003b56:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8003b5a:	ee17 2a90 	vmov	r2, s15
 8003b5e:	687b      	ldr	r3, [r7, #4]
 8003b60:	609a      	str	r2, [r3, #8]
  else
  {
    PLL1_Clocks->PLL1_R_Frequency = 0U;
  }

}
 8003b62:	e002      	b.n	8003b6a <HAL_RCCEx_GetPLL1ClockFreq+0x296>
    PLL1_Clocks->PLL1_R_Frequency = 0U;
 8003b64:	687b      	ldr	r3, [r7, #4]
 8003b66:	2200      	movs	r2, #0
 8003b68:	609a      	str	r2, [r3, #8]
}
 8003b6a:	bf00      	nop
 8003b6c:	3724      	adds	r7, #36	@ 0x24
 8003b6e:	46bd      	mov	sp, r7
 8003b70:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003b74:	4770      	bx	lr
 8003b76:	bf00      	nop
 8003b78:	46020c00 	.word	0x46020c00
 8003b7c:	4b742400 	.word	0x4b742400
 8003b80:	46000000 	.word	0x46000000
 8003b84:	080116a4 	.word	0x080116a4

08003b88 <HAL_RCCEx_GetPLL2ClockFreq>:
  *         right PLL2CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  PLL2_Clocks structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL2ClockFreq(PLL2_ClocksTypeDef *PLL2_Clocks)
{
 8003b88:	b480      	push	{r7}
 8003b8a:	b089      	sub	sp, #36	@ 0x24
 8003b8c:	af00      	add	r7, sp, #0
 8003b8e:	6078      	str	r0, [r7, #4]
  float_t fracn2;
  float_t pll2vco;

  /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLL2M) * PLL2N
     PLL2xCLK = PLL2_VCO / PLL2x */
  pll2n = (RCC->PLL2DIVR & RCC_PLL2DIVR_PLL2N);
 8003b90:	4ba6      	ldr	r3, [pc, #664]	@ (8003e2c <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 8003b92:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8003b94:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8003b98:	61bb      	str	r3, [r7, #24]
  pll2source = (RCC->PLL2CFGR & RCC_PLL2CFGR_PLL2SRC);
 8003b9a:	4ba4      	ldr	r3, [pc, #656]	@ (8003e2c <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 8003b9c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8003b9e:	f003 0303 	and.w	r3, r3, #3
 8003ba2:	617b      	str	r3, [r7, #20]
  pll2m = ((RCC->PLL2CFGR & RCC_PLL2CFGR_PLL2M) >> RCC_PLL2CFGR_PLL2M_Pos) + 1U;
 8003ba4:	4ba1      	ldr	r3, [pc, #644]	@ (8003e2c <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 8003ba6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8003ba8:	0a1b      	lsrs	r3, r3, #8
 8003baa:	f003 030f 	and.w	r3, r3, #15
 8003bae:	3301      	adds	r3, #1
 8003bb0:	613b      	str	r3, [r7, #16]
  pll2fracen = ((RCC->PLL2CFGR & RCC_PLL2CFGR_PLL2FRACEN) >> RCC_PLL2CFGR_PLL2FRACEN_Pos);
 8003bb2:	4b9e      	ldr	r3, [pc, #632]	@ (8003e2c <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 8003bb4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8003bb6:	091b      	lsrs	r3, r3, #4
 8003bb8:	f003 0301 	and.w	r3, r3, #1
 8003bbc:	60fb      	str	r3, [r7, #12]
  fracn2 = (float_t)(uint32_t)(pll2fracen * ((RCC->PLL2FRACR & RCC_PLL2FRACR_PLL2FRACN) >> \
 8003bbe:	4b9b      	ldr	r3, [pc, #620]	@ (8003e2c <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 8003bc0:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8003bc2:	08db      	lsrs	r3, r3, #3
 8003bc4:	f3c3 030c 	ubfx	r3, r3, #0, #13
 8003bc8:	68fa      	ldr	r2, [r7, #12]
 8003bca:	fb02 f303 	mul.w	r3, r2, r3
 8003bce:	ee07 3a90 	vmov	s15, r3
 8003bd2:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8003bd6:	edc7 7a02 	vstr	s15, [r7, #8]
                                             RCC_PLL2FRACR_PLL2FRACN_Pos));

  switch (pll2source)
 8003bda:	697b      	ldr	r3, [r7, #20]
 8003bdc:	2b03      	cmp	r3, #3
 8003bde:	d062      	beq.n	8003ca6 <HAL_RCCEx_GetPLL2ClockFreq+0x11e>
 8003be0:	697b      	ldr	r3, [r7, #20]
 8003be2:	2b03      	cmp	r3, #3
 8003be4:	f200 8081 	bhi.w	8003cea <HAL_RCCEx_GetPLL2ClockFreq+0x162>
 8003be8:	697b      	ldr	r3, [r7, #20]
 8003bea:	2b01      	cmp	r3, #1
 8003bec:	d024      	beq.n	8003c38 <HAL_RCCEx_GetPLL2ClockFreq+0xb0>
 8003bee:	697b      	ldr	r3, [r7, #20]
 8003bf0:	2b02      	cmp	r3, #2
 8003bf2:	d17a      	bne.n	8003cea <HAL_RCCEx_GetPLL2ClockFreq+0x162>
  {
    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
      pll2vco = ((float_t)HSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_PLL2N) + \
 8003bf4:	693b      	ldr	r3, [r7, #16]
 8003bf6:	ee07 3a90 	vmov	s15, r3
 8003bfa:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8003bfe:	eddf 6a8c 	vldr	s13, [pc, #560]	@ 8003e30 <HAL_RCCEx_GetPLL2ClockFreq+0x2a8>
 8003c02:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8003c06:	4b89      	ldr	r3, [pc, #548]	@ (8003e2c <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 8003c08:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8003c0a:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8003c0e:	ee07 3a90 	vmov	s15, r3
 8003c12:	eef8 6a67 	vcvt.f32.u32	s13, s15
                                                         (fracn2 / (float_t)0x2000) + (float_t)1);
 8003c16:	ed97 6a02 	vldr	s12, [r7, #8]
 8003c1a:	eddf 5a86 	vldr	s11, [pc, #536]	@ 8003e34 <HAL_RCCEx_GetPLL2ClockFreq+0x2ac>
 8003c1e:	eec6 7a25 	vdiv.f32	s15, s12, s11
      pll2vco = ((float_t)HSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_PLL2N) + \
 8003c22:	ee76 7aa7 	vadd.f32	s15, s13, s15
                                                         (fracn2 / (float_t)0x2000) + (float_t)1);
 8003c26:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8003c2a:	ee77 7aa6 	vadd.f32	s15, s15, s13
      pll2vco = ((float_t)HSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_PLL2N) + \
 8003c2e:	ee67 7a27 	vmul.f32	s15, s14, s15
 8003c32:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 8003c36:	e08f      	b.n	8003d58 <HAL_RCCEx_GetPLL2ClockFreq+0x1d0>

    case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
      pll2vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t)pll2m) * \
 8003c38:	4b7c      	ldr	r3, [pc, #496]	@ (8003e2c <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 8003c3a:	689b      	ldr	r3, [r3, #8]
 8003c3c:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 8003c40:	2b00      	cmp	r3, #0
 8003c42:	d005      	beq.n	8003c50 <HAL_RCCEx_GetPLL2ClockFreq+0xc8>
 8003c44:	4b79      	ldr	r3, [pc, #484]	@ (8003e2c <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 8003c46:	689b      	ldr	r3, [r3, #8]
 8003c48:	0f1b      	lsrs	r3, r3, #28
 8003c4a:	f003 030f 	and.w	r3, r3, #15
 8003c4e:	e006      	b.n	8003c5e <HAL_RCCEx_GetPLL2ClockFreq+0xd6>
 8003c50:	4b76      	ldr	r3, [pc, #472]	@ (8003e2c <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 8003c52:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8003c56:	041b      	lsls	r3, r3, #16
 8003c58:	0f1b      	lsrs	r3, r3, #28
 8003c5a:	f003 030f 	and.w	r3, r3, #15
 8003c5e:	4a76      	ldr	r2, [pc, #472]	@ (8003e38 <HAL_RCCEx_GetPLL2ClockFreq+0x2b0>)
 8003c60:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8003c64:	ee07 3a90 	vmov	s15, r3
 8003c68:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8003c6c:	693b      	ldr	r3, [r7, #16]
 8003c6e:	ee07 3a90 	vmov	s15, r3
 8003c72:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8003c76:	ee86 7aa7 	vdiv.f32	s14, s13, s15
                ((float_t)pll2n + (fracn2 / (float_t)0x2000) + (float_t)1);
 8003c7a:	69bb      	ldr	r3, [r7, #24]
 8003c7c:	ee07 3a90 	vmov	s15, r3
 8003c80:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8003c84:	ed97 6a02 	vldr	s12, [r7, #8]
 8003c88:	eddf 5a6a 	vldr	s11, [pc, #424]	@ 8003e34 <HAL_RCCEx_GetPLL2ClockFreq+0x2ac>
 8003c8c:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8003c90:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8003c94:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8003c98:	ee77 7aa6 	vadd.f32	s15, s15, s13
      pll2vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t)pll2m) * \
 8003c9c:	ee67 7a27 	vmul.f32	s15, s14, s15
 8003ca0:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 8003ca4:	e058      	b.n	8003d58 <HAL_RCCEx_GetPLL2ClockFreq+0x1d0>

    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      pll2vco = ((float_t)HSE_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_PLL2N) + \
 8003ca6:	693b      	ldr	r3, [r7, #16]
 8003ca8:	ee07 3a90 	vmov	s15, r3
 8003cac:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8003cb0:	eddf 6a5f 	vldr	s13, [pc, #380]	@ 8003e30 <HAL_RCCEx_GetPLL2ClockFreq+0x2a8>
 8003cb4:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8003cb8:	4b5c      	ldr	r3, [pc, #368]	@ (8003e2c <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 8003cba:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8003cbc:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8003cc0:	ee07 3a90 	vmov	s15, r3
 8003cc4:	eef8 6a67 	vcvt.f32.u32	s13, s15
                                                         (fracn2 / (float_t)0x2000) + (float_t)1);
 8003cc8:	ed97 6a02 	vldr	s12, [r7, #8]
 8003ccc:	eddf 5a59 	vldr	s11, [pc, #356]	@ 8003e34 <HAL_RCCEx_GetPLL2ClockFreq+0x2ac>
 8003cd0:	eec6 7a25 	vdiv.f32	s15, s12, s11
      pll2vco = ((float_t)HSE_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_PLL2N) + \
 8003cd4:	ee76 7aa7 	vadd.f32	s15, s13, s15
                                                         (fracn2 / (float_t)0x2000) + (float_t)1);
 8003cd8:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8003cdc:	ee77 7aa6 	vadd.f32	s15, s15, s13
      pll2vco = ((float_t)HSE_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_PLL2N) + \
 8003ce0:	ee67 7a27 	vmul.f32	s15, s14, s15
 8003ce4:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 8003ce8:	e036      	b.n	8003d58 <HAL_RCCEx_GetPLL2ClockFreq+0x1d0>

    default:
      pll2vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t) pll2m) \
 8003cea:	4b50      	ldr	r3, [pc, #320]	@ (8003e2c <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 8003cec:	689b      	ldr	r3, [r3, #8]
 8003cee:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 8003cf2:	2b00      	cmp	r3, #0
 8003cf4:	d005      	beq.n	8003d02 <HAL_RCCEx_GetPLL2ClockFreq+0x17a>
 8003cf6:	4b4d      	ldr	r3, [pc, #308]	@ (8003e2c <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 8003cf8:	689b      	ldr	r3, [r3, #8]
 8003cfa:	0f1b      	lsrs	r3, r3, #28
 8003cfc:	f003 030f 	and.w	r3, r3, #15
 8003d00:	e006      	b.n	8003d10 <HAL_RCCEx_GetPLL2ClockFreq+0x188>
 8003d02:	4b4a      	ldr	r3, [pc, #296]	@ (8003e2c <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 8003d04:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8003d08:	041b      	lsls	r3, r3, #16
 8003d0a:	0f1b      	lsrs	r3, r3, #28
 8003d0c:	f003 030f 	and.w	r3, r3, #15
 8003d10:	4a49      	ldr	r2, [pc, #292]	@ (8003e38 <HAL_RCCEx_GetPLL2ClockFreq+0x2b0>)
 8003d12:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8003d16:	ee07 3a90 	vmov	s15, r3
 8003d1a:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8003d1e:	693b      	ldr	r3, [r7, #16]
 8003d20:	ee07 3a90 	vmov	s15, r3
 8003d24:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8003d28:	ee86 7aa7 	vdiv.f32	s14, s13, s15
                * ((float_t)pll2n + (fracn2 / (float_t)0x2000) + (float_t)1);
 8003d2c:	69bb      	ldr	r3, [r7, #24]
 8003d2e:	ee07 3a90 	vmov	s15, r3
 8003d32:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8003d36:	ed97 6a02 	vldr	s12, [r7, #8]
 8003d3a:	eddf 5a3e 	vldr	s11, [pc, #248]	@ 8003e34 <HAL_RCCEx_GetPLL2ClockFreq+0x2ac>
 8003d3e:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8003d42:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8003d46:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8003d4a:	ee77 7aa6 	vadd.f32	s15, s15, s13
      pll2vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t) pll2m) \
 8003d4e:	ee67 7a27 	vmul.f32	s15, s14, s15
 8003d52:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 8003d56:	bf00      	nop
  }
  if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL2_DIVP) != 0U)
 8003d58:	4b34      	ldr	r3, [pc, #208]	@ (8003e2c <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 8003d5a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8003d5c:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 8003d60:	2b00      	cmp	r3, #0
 8003d62:	d017      	beq.n	8003d94 <HAL_RCCEx_GetPLL2ClockFreq+0x20c>
  {
    PLL2_Clocks->PLL2_P_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & \
 8003d64:	4b31      	ldr	r3, [pc, #196]	@ (8003e2c <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 8003d66:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8003d68:	0a5b      	lsrs	r3, r3, #9
 8003d6a:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8003d6e:	ee07 3a90 	vmov	s15, r3
 8003d72:	eef8 7a67 	vcvt.f32.u32	s15, s15
                                                                   RCC_PLL2DIVR_PLL2P) >> RCC_PLL2DIVR_PLL2P_Pos) + \
 8003d76:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8003d7a:	ee37 7a87 	vadd.f32	s14, s15, s14
    PLL2_Clocks->PLL2_P_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & \
 8003d7e:	edd7 6a07 	vldr	s13, [r7, #28]
 8003d82:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8003d86:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8003d8a:	ee17 2a90 	vmov	r2, s15
 8003d8e:	687b      	ldr	r3, [r7, #4]
 8003d90:	601a      	str	r2, [r3, #0]
 8003d92:	e002      	b.n	8003d9a <HAL_RCCEx_GetPLL2ClockFreq+0x212>
                                                                   (float_t)1));
  }
  else
  {
    PLL2_Clocks->PLL2_P_Frequency = 0U;
 8003d94:	687b      	ldr	r3, [r7, #4]
 8003d96:	2200      	movs	r2, #0
 8003d98:	601a      	str	r2, [r3, #0]
  }
  if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL2_DIVQ) != 0U)
 8003d9a:	4b24      	ldr	r3, [pc, #144]	@ (8003e2c <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 8003d9c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8003d9e:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8003da2:	2b00      	cmp	r3, #0
 8003da4:	d017      	beq.n	8003dd6 <HAL_RCCEx_GetPLL2ClockFreq+0x24e>
  {
    PLL2_Clocks->PLL2_Q_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & \
 8003da6:	4b21      	ldr	r3, [pc, #132]	@ (8003e2c <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 8003da8:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8003daa:	0c1b      	lsrs	r3, r3, #16
 8003dac:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8003db0:	ee07 3a90 	vmov	s15, r3
 8003db4:	eef8 7a67 	vcvt.f32.u32	s15, s15
                                                                   RCC_PLL2DIVR_PLL2Q) >> RCC_PLL2DIVR_PLL2Q_Pos) + \
 8003db8:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8003dbc:	ee37 7a87 	vadd.f32	s14, s15, s14
    PLL2_Clocks->PLL2_Q_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & \
 8003dc0:	edd7 6a07 	vldr	s13, [r7, #28]
 8003dc4:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8003dc8:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8003dcc:	ee17 2a90 	vmov	r2, s15
 8003dd0:	687b      	ldr	r3, [r7, #4]
 8003dd2:	605a      	str	r2, [r3, #4]
 8003dd4:	e002      	b.n	8003ddc <HAL_RCCEx_GetPLL2ClockFreq+0x254>
                                                                   (float_t)1));
  }
  else
  {
    PLL2_Clocks->PLL2_Q_Frequency = 0U;
 8003dd6:	687b      	ldr	r3, [r7, #4]
 8003dd8:	2200      	movs	r2, #0
 8003dda:	605a      	str	r2, [r3, #4]
  }
  if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL2_DIVR) != 0U)
 8003ddc:	4b13      	ldr	r3, [pc, #76]	@ (8003e2c <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 8003dde:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8003de0:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
 8003de4:	2b00      	cmp	r3, #0
 8003de6:	d017      	beq.n	8003e18 <HAL_RCCEx_GetPLL2ClockFreq+0x290>
  {
    PLL2_Clocks->PLL2_R_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & \
 8003de8:	4b10      	ldr	r3, [pc, #64]	@ (8003e2c <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>)
 8003dea:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8003dec:	0e1b      	lsrs	r3, r3, #24
 8003dee:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8003df2:	ee07 3a90 	vmov	s15, r3
 8003df6:	eef8 7a67 	vcvt.f32.u32	s15, s15
                                                                   RCC_PLL2DIVR_PLL2R) >> RCC_PLL2DIVR_PLL2R_Pos) + \
 8003dfa:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8003dfe:	ee37 7a87 	vadd.f32	s14, s15, s14
    PLL2_Clocks->PLL2_R_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & \
 8003e02:	edd7 6a07 	vldr	s13, [r7, #28]
 8003e06:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8003e0a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8003e0e:	ee17 2a90 	vmov	r2, s15
 8003e12:	687b      	ldr	r3, [r7, #4]
 8003e14:	609a      	str	r2, [r3, #8]
  }
  else
  {
    PLL2_Clocks->PLL2_R_Frequency = 0U;
  }
}
 8003e16:	e002      	b.n	8003e1e <HAL_RCCEx_GetPLL2ClockFreq+0x296>
    PLL2_Clocks->PLL2_R_Frequency = 0U;
 8003e18:	687b      	ldr	r3, [r7, #4]
 8003e1a:	2200      	movs	r2, #0
 8003e1c:	609a      	str	r2, [r3, #8]
}
 8003e1e:	bf00      	nop
 8003e20:	3724      	adds	r7, #36	@ 0x24
 8003e22:	46bd      	mov	sp, r7
 8003e24:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003e28:	4770      	bx	lr
 8003e2a:	bf00      	nop
 8003e2c:	46020c00 	.word	0x46020c00
 8003e30:	4b742400 	.word	0x4b742400
 8003e34:	46000000 	.word	0x46000000
 8003e38:	080116a4 	.word	0x080116a4

08003e3c <HAL_RCCEx_GetPLL3ClockFreq>:
  *         right PLL3CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  PLL3_Clocks structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL3ClockFreq(PLL3_ClocksTypeDef *PLL3_Clocks)
{
 8003e3c:	b480      	push	{r7}
 8003e3e:	b089      	sub	sp, #36	@ 0x24
 8003e40:	af00      	add	r7, sp, #0
 8003e42:	6078      	str	r0, [r7, #4]

  /* PLL3_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLL3M) * PLL3N
  PLL3xCLK = PLL3_VCO / PLLxR
  */

  pll3n = (RCC->PLL3DIVR & RCC_PLL3DIVR_PLL3N);
 8003e44:	4ba6      	ldr	r3, [pc, #664]	@ (80040e0 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 8003e46:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8003e48:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8003e4c:	61bb      	str	r3, [r7, #24]
  pll3source = (RCC->PLL3CFGR & RCC_PLL3CFGR_PLL3SRC);
 8003e4e:	4ba4      	ldr	r3, [pc, #656]	@ (80040e0 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 8003e50:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8003e52:	f003 0303 	and.w	r3, r3, #3
 8003e56:	617b      	str	r3, [r7, #20]
  pll3m = ((RCC->PLL3CFGR & RCC_PLL3CFGR_PLL3M) >> RCC_PLL3CFGR_PLL3M_Pos) + 1U;
 8003e58:	4ba1      	ldr	r3, [pc, #644]	@ (80040e0 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 8003e5a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8003e5c:	0a1b      	lsrs	r3, r3, #8
 8003e5e:	f003 030f 	and.w	r3, r3, #15
 8003e62:	3301      	adds	r3, #1
 8003e64:	613b      	str	r3, [r7, #16]
  pll3fracen = ((RCC->PLL3CFGR & RCC_PLL3CFGR_PLL3FRACEN) >> RCC_PLL3CFGR_PLL3FRACEN_Pos);
 8003e66:	4b9e      	ldr	r3, [pc, #632]	@ (80040e0 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 8003e68:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8003e6a:	091b      	lsrs	r3, r3, #4
 8003e6c:	f003 0301 	and.w	r3, r3, #1
 8003e70:	60fb      	str	r3, [r7, #12]
  fracn3 = (float_t)(uint32_t)(pll3fracen * ((RCC->PLL3FRACR & RCC_PLL3FRACR_PLL3FRACN) >> \
 8003e72:	4b9b      	ldr	r3, [pc, #620]	@ (80040e0 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 8003e74:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8003e76:	08db      	lsrs	r3, r3, #3
 8003e78:	f3c3 030c 	ubfx	r3, r3, #0, #13
 8003e7c:	68fa      	ldr	r2, [r7, #12]
 8003e7e:	fb02 f303 	mul.w	r3, r2, r3
 8003e82:	ee07 3a90 	vmov	s15, r3
 8003e86:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8003e8a:	edc7 7a02 	vstr	s15, [r7, #8]
                                             RCC_PLL3FRACR_PLL3FRACN_Pos));

  switch (pll3source)
 8003e8e:	697b      	ldr	r3, [r7, #20]
 8003e90:	2b03      	cmp	r3, #3
 8003e92:	d062      	beq.n	8003f5a <HAL_RCCEx_GetPLL3ClockFreq+0x11e>
 8003e94:	697b      	ldr	r3, [r7, #20]
 8003e96:	2b03      	cmp	r3, #3
 8003e98:	f200 8081 	bhi.w	8003f9e <HAL_RCCEx_GetPLL3ClockFreq+0x162>
 8003e9c:	697b      	ldr	r3, [r7, #20]
 8003e9e:	2b01      	cmp	r3, #1
 8003ea0:	d024      	beq.n	8003eec <HAL_RCCEx_GetPLL3ClockFreq+0xb0>
 8003ea2:	697b      	ldr	r3, [r7, #20]
 8003ea4:	2b02      	cmp	r3, #2
 8003ea6:	d17a      	bne.n	8003f9e <HAL_RCCEx_GetPLL3ClockFreq+0x162>
  {
    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
      pll3vco = ((float_t)HSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_PLL3N) + \
 8003ea8:	693b      	ldr	r3, [r7, #16]
 8003eaa:	ee07 3a90 	vmov	s15, r3
 8003eae:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8003eb2:	eddf 6a8c 	vldr	s13, [pc, #560]	@ 80040e4 <HAL_RCCEx_GetPLL3ClockFreq+0x2a8>
 8003eb6:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8003eba:	4b89      	ldr	r3, [pc, #548]	@ (80040e0 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 8003ebc:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8003ebe:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8003ec2:	ee07 3a90 	vmov	s15, r3
 8003ec6:	eef8 6a67 	vcvt.f32.u32	s13, s15
                                                         (fracn3 / (float_t)0x2000) + (float_t)1);
 8003eca:	ed97 6a02 	vldr	s12, [r7, #8]
 8003ece:	eddf 5a86 	vldr	s11, [pc, #536]	@ 80040e8 <HAL_RCCEx_GetPLL3ClockFreq+0x2ac>
 8003ed2:	eec6 7a25 	vdiv.f32	s15, s12, s11
      pll3vco = ((float_t)HSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_PLL3N) + \
 8003ed6:	ee76 7aa7 	vadd.f32	s15, s13, s15
                                                         (fracn3 / (float_t)0x2000) + (float_t)1);
 8003eda:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8003ede:	ee77 7aa6 	vadd.f32	s15, s15, s13
      pll3vco = ((float_t)HSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_PLL3N) + \
 8003ee2:	ee67 7a27 	vmul.f32	s15, s14, s15
 8003ee6:	edc7 7a07 	vstr	s15, [r7, #28]

      break;
 8003eea:	e08f      	b.n	800400c <HAL_RCCEx_GetPLL3ClockFreq+0x1d0>
    case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
      pll3vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t)pll3m) * \
 8003eec:	4b7c      	ldr	r3, [pc, #496]	@ (80040e0 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 8003eee:	689b      	ldr	r3, [r3, #8]
 8003ef0:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 8003ef4:	2b00      	cmp	r3, #0
 8003ef6:	d005      	beq.n	8003f04 <HAL_RCCEx_GetPLL3ClockFreq+0xc8>
 8003ef8:	4b79      	ldr	r3, [pc, #484]	@ (80040e0 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 8003efa:	689b      	ldr	r3, [r3, #8]
 8003efc:	0f1b      	lsrs	r3, r3, #28
 8003efe:	f003 030f 	and.w	r3, r3, #15
 8003f02:	e006      	b.n	8003f12 <HAL_RCCEx_GetPLL3ClockFreq+0xd6>
 8003f04:	4b76      	ldr	r3, [pc, #472]	@ (80040e0 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 8003f06:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8003f0a:	041b      	lsls	r3, r3, #16
 8003f0c:	0f1b      	lsrs	r3, r3, #28
 8003f0e:	f003 030f 	and.w	r3, r3, #15
 8003f12:	4a76      	ldr	r2, [pc, #472]	@ (80040ec <HAL_RCCEx_GetPLL3ClockFreq+0x2b0>)
 8003f14:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8003f18:	ee07 3a90 	vmov	s15, r3
 8003f1c:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8003f20:	693b      	ldr	r3, [r7, #16]
 8003f22:	ee07 3a90 	vmov	s15, r3
 8003f26:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8003f2a:	ee86 7aa7 	vdiv.f32	s14, s13, s15
                ((float_t)pll3n + (fracn3 / (float_t)0x2000) + (float_t)1);
 8003f2e:	69bb      	ldr	r3, [r7, #24]
 8003f30:	ee07 3a90 	vmov	s15, r3
 8003f34:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8003f38:	ed97 6a02 	vldr	s12, [r7, #8]
 8003f3c:	eddf 5a6a 	vldr	s11, [pc, #424]	@ 80040e8 <HAL_RCCEx_GetPLL3ClockFreq+0x2ac>
 8003f40:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8003f44:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8003f48:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8003f4c:	ee77 7aa6 	vadd.f32	s15, s15, s13
      pll3vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t)pll3m) * \
 8003f50:	ee67 7a27 	vmul.f32	s15, s14, s15
 8003f54:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 8003f58:	e058      	b.n	800400c <HAL_RCCEx_GetPLL3ClockFreq+0x1d0>

    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      pll3vco = ((float_t)HSE_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_PLL3N) + \
 8003f5a:	693b      	ldr	r3, [r7, #16]
 8003f5c:	ee07 3a90 	vmov	s15, r3
 8003f60:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8003f64:	eddf 6a5f 	vldr	s13, [pc, #380]	@ 80040e4 <HAL_RCCEx_GetPLL3ClockFreq+0x2a8>
 8003f68:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8003f6c:	4b5c      	ldr	r3, [pc, #368]	@ (80040e0 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 8003f6e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8003f70:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8003f74:	ee07 3a90 	vmov	s15, r3
 8003f78:	eef8 6a67 	vcvt.f32.u32	s13, s15
                                                         (fracn3 / (float_t)0x2000) + (float_t)1);
 8003f7c:	ed97 6a02 	vldr	s12, [r7, #8]
 8003f80:	eddf 5a59 	vldr	s11, [pc, #356]	@ 80040e8 <HAL_RCCEx_GetPLL3ClockFreq+0x2ac>
 8003f84:	eec6 7a25 	vdiv.f32	s15, s12, s11
      pll3vco = ((float_t)HSE_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_PLL3N) + \
 8003f88:	ee76 7aa7 	vadd.f32	s15, s13, s15
                                                         (fracn3 / (float_t)0x2000) + (float_t)1);
 8003f8c:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8003f90:	ee77 7aa6 	vadd.f32	s15, s15, s13
      pll3vco = ((float_t)HSE_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_PLL3N) + \
 8003f94:	ee67 7a27 	vmul.f32	s15, s14, s15
 8003f98:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 8003f9c:	e036      	b.n	800400c <HAL_RCCEx_GetPLL3ClockFreq+0x1d0>

    default:
      pll3vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t)pll3m) * \
 8003f9e:	4b50      	ldr	r3, [pc, #320]	@ (80040e0 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 8003fa0:	689b      	ldr	r3, [r3, #8]
 8003fa2:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 8003fa6:	2b00      	cmp	r3, #0
 8003fa8:	d005      	beq.n	8003fb6 <HAL_RCCEx_GetPLL3ClockFreq+0x17a>
 8003faa:	4b4d      	ldr	r3, [pc, #308]	@ (80040e0 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 8003fac:	689b      	ldr	r3, [r3, #8]
 8003fae:	0f1b      	lsrs	r3, r3, #28
 8003fb0:	f003 030f 	and.w	r3, r3, #15
 8003fb4:	e006      	b.n	8003fc4 <HAL_RCCEx_GetPLL3ClockFreq+0x188>
 8003fb6:	4b4a      	ldr	r3, [pc, #296]	@ (80040e0 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 8003fb8:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8003fbc:	041b      	lsls	r3, r3, #16
 8003fbe:	0f1b      	lsrs	r3, r3, #28
 8003fc0:	f003 030f 	and.w	r3, r3, #15
 8003fc4:	4a49      	ldr	r2, [pc, #292]	@ (80040ec <HAL_RCCEx_GetPLL3ClockFreq+0x2b0>)
 8003fc6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8003fca:	ee07 3a90 	vmov	s15, r3
 8003fce:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8003fd2:	693b      	ldr	r3, [r7, #16]
 8003fd4:	ee07 3a90 	vmov	s15, r3
 8003fd8:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8003fdc:	ee86 7aa7 	vdiv.f32	s14, s13, s15
                ((float_t)pll3n + (fracn3 / (float_t)0x2000) + (float_t)1);
 8003fe0:	69bb      	ldr	r3, [r7, #24]
 8003fe2:	ee07 3a90 	vmov	s15, r3
 8003fe6:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8003fea:	ed97 6a02 	vldr	s12, [r7, #8]
 8003fee:	eddf 5a3e 	vldr	s11, [pc, #248]	@ 80040e8 <HAL_RCCEx_GetPLL3ClockFreq+0x2ac>
 8003ff2:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8003ff6:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8003ffa:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8003ffe:	ee77 7aa6 	vadd.f32	s15, s15, s13
      pll3vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t)pll3m) * \
 8004002:	ee67 7a27 	vmul.f32	s15, s14, s15
 8004006:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 800400a:	bf00      	nop
  }

  if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL3_DIVP) != 0U)
 800400c:	4b34      	ldr	r3, [pc, #208]	@ (80040e0 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 800400e:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8004010:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 8004014:	2b00      	cmp	r3, #0
 8004016:	d017      	beq.n	8004048 <HAL_RCCEx_GetPLL3ClockFreq+0x20c>
  {
    PLL3_Clocks->PLL3_P_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & \
 8004018:	4b31      	ldr	r3, [pc, #196]	@ (80040e0 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 800401a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800401c:	0a5b      	lsrs	r3, r3, #9
 800401e:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8004022:	ee07 3a90 	vmov	s15, r3
 8004026:	eef8 7a67 	vcvt.f32.u32	s15, s15
                                                                   RCC_PLL3DIVR_PLL3P) >> RCC_PLL3DIVR_PLL3P_Pos) + \
 800402a:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 800402e:	ee37 7a87 	vadd.f32	s14, s15, s14
    PLL3_Clocks->PLL3_P_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & \
 8004032:	edd7 6a07 	vldr	s13, [r7, #28]
 8004036:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800403a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 800403e:	ee17 2a90 	vmov	r2, s15
 8004042:	687b      	ldr	r3, [r7, #4]
 8004044:	601a      	str	r2, [r3, #0]
 8004046:	e002      	b.n	800404e <HAL_RCCEx_GetPLL3ClockFreq+0x212>
                                                                   (float_t)1));
  }
  else
  {
    PLL3_Clocks->PLL3_P_Frequency = 0U;
 8004048:	687b      	ldr	r3, [r7, #4]
 800404a:	2200      	movs	r2, #0
 800404c:	601a      	str	r2, [r3, #0]
  }

  if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL3_DIVQ) != 0U)
 800404e:	4b24      	ldr	r3, [pc, #144]	@ (80040e0 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 8004050:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8004052:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8004056:	2b00      	cmp	r3, #0
 8004058:	d017      	beq.n	800408a <HAL_RCCEx_GetPLL3ClockFreq+0x24e>
  {
    PLL3_Clocks->PLL3_Q_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & \
 800405a:	4b21      	ldr	r3, [pc, #132]	@ (80040e0 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 800405c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800405e:	0c1b      	lsrs	r3, r3, #16
 8004060:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8004064:	ee07 3a90 	vmov	s15, r3
 8004068:	eef8 7a67 	vcvt.f32.u32	s15, s15
                                                                   RCC_PLL3DIVR_PLL3Q) >> RCC_PLL3DIVR_PLL3Q_Pos) + \
 800406c:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8004070:	ee37 7a87 	vadd.f32	s14, s15, s14
    PLL3_Clocks->PLL3_Q_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & \
 8004074:	edd7 6a07 	vldr	s13, [r7, #28]
 8004078:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800407c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8004080:	ee17 2a90 	vmov	r2, s15
 8004084:	687b      	ldr	r3, [r7, #4]
 8004086:	605a      	str	r2, [r3, #4]
 8004088:	e002      	b.n	8004090 <HAL_RCCEx_GetPLL3ClockFreq+0x254>
                                                                   (float_t)1));
  }
  else
  {
    PLL3_Clocks->PLL3_Q_Frequency = 0U;
 800408a:	687b      	ldr	r3, [r7, #4]
 800408c:	2200      	movs	r2, #0
 800408e:	605a      	str	r2, [r3, #4]
  }

  if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL3_DIVR) != 0U)
 8004090:	4b13      	ldr	r3, [pc, #76]	@ (80040e0 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 8004092:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8004094:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
 8004098:	2b00      	cmp	r3, #0
 800409a:	d017      	beq.n	80040cc <HAL_RCCEx_GetPLL3ClockFreq+0x290>
  {
    PLL3_Clocks->PLL3_R_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & \
 800409c:	4b10      	ldr	r3, [pc, #64]	@ (80040e0 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>)
 800409e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80040a0:	0e1b      	lsrs	r3, r3, #24
 80040a2:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 80040a6:	ee07 3a90 	vmov	s15, r3
 80040aa:	eef8 7a67 	vcvt.f32.u32	s15, s15
                                                                   RCC_PLL3DIVR_PLL3R) >> RCC_PLL3DIVR_PLL3R_Pos) + \
 80040ae:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 80040b2:	ee37 7a87 	vadd.f32	s14, s15, s14
    PLL3_Clocks->PLL3_R_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & \
 80040b6:	edd7 6a07 	vldr	s13, [r7, #28]
 80040ba:	eec6 7a87 	vdiv.f32	s15, s13, s14
 80040be:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 80040c2:	ee17 2a90 	vmov	r2, s15
 80040c6:	687b      	ldr	r3, [r7, #4]
 80040c8:	609a      	str	r2, [r3, #8]
  else
  {
    PLL3_Clocks->PLL3_R_Frequency = 0U;
  }

}
 80040ca:	e002      	b.n	80040d2 <HAL_RCCEx_GetPLL3ClockFreq+0x296>
    PLL3_Clocks->PLL3_R_Frequency = 0U;
 80040cc:	687b      	ldr	r3, [r7, #4]
 80040ce:	2200      	movs	r2, #0
 80040d0:	609a      	str	r2, [r3, #8]
}
 80040d2:	bf00      	nop
 80040d4:	3724      	adds	r7, #36	@ 0x24
 80040d6:	46bd      	mov	sp, r7
 80040d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80040dc:	4770      	bx	lr
 80040de:	bf00      	nop
 80040e0:	46020c00 	.word	0x46020c00
 80040e4:	4b742400 	.word	0x4b742400
 80040e8:	46000000 	.word	0x46000000
 80040ec:	080116a4 	.word	0x080116a4

080040f0 <HAL_RCCEx_GetPeriphCLKFreq>:
  * @retval Frequency in Hz
  *
  *        (*) value not defined in all devices.
  */
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint64_t PeriphClk)
{
 80040f0:	b580      	push	{r7, lr}
 80040f2:	b08e      	sub	sp, #56	@ 0x38
 80040f4:	af00      	add	r7, sp, #0
 80040f6:	e9c7 0100 	strd	r0, r1, [r7]
  uint32_t srcclk;

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClk));

  if (PeriphClk == RCC_PERIPHCLK_RTC)
 80040fa:	e9d7 2300 	ldrd	r2, r3, [r7]
 80040fe:	f5a2 2180 	sub.w	r1, r2, #262144	@ 0x40000
 8004102:	430b      	orrs	r3, r1
 8004104:	d145      	bne.n	8004192 <HAL_RCCEx_GetPeriphCLKFreq+0xa2>
  {
    /* Get the current RTC source */
    srcclk = __HAL_RCC_GET_RTC_SOURCE();
 8004106:	4b9b      	ldr	r3, [pc, #620]	@ (8004374 <HAL_RCCEx_GetPeriphCLKFreq+0x284>)
 8004108:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 800410c:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 8004110:	633b      	str	r3, [r7, #48]	@ 0x30

    /* Check if LSE is ready and if RTC clock selection is LSE */
    if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_RTCCLKSOURCE_LSE))
 8004112:	4b98      	ldr	r3, [pc, #608]	@ (8004374 <HAL_RCCEx_GetPeriphCLKFreq+0x284>)
 8004114:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8004118:	f003 0302 	and.w	r3, r3, #2
 800411c:	2b02      	cmp	r3, #2
 800411e:	d108      	bne.n	8004132 <HAL_RCCEx_GetPeriphCLKFreq+0x42>
 8004120:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004122:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8004126:	d104      	bne.n	8004132 <HAL_RCCEx_GetPeriphCLKFreq+0x42>
    {
      frequency = LSE_VALUE;
 8004128:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 800412c:	637b      	str	r3, [r7, #52]	@ 0x34
 800412e:	f001 b912 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    /* Check if LSI is ready and if RTC clock selection is LSI */
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIRDY)) && (srcclk == RCC_RTCCLKSOURCE_LSI))
 8004132:	4b90      	ldr	r3, [pc, #576]	@ (8004374 <HAL_RCCEx_GetPeriphCLKFreq+0x284>)
 8004134:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8004138:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 800413c:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 8004140:	d114      	bne.n	800416c <HAL_RCCEx_GetPeriphCLKFreq+0x7c>
 8004142:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004144:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8004148:	d110      	bne.n	800416c <HAL_RCCEx_GetPeriphCLKFreq+0x7c>
    {
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 800414a:	4b8a      	ldr	r3, [pc, #552]	@ (8004374 <HAL_RCCEx_GetPeriphCLKFreq+0x284>)
 800414c:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8004150:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 8004154:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 8004158:	d103      	bne.n	8004162 <HAL_RCCEx_GetPeriphCLKFreq+0x72>
      {
        frequency = LSI_VALUE / 128U;
 800415a:	23fa      	movs	r3, #250	@ 0xfa
 800415c:	637b      	str	r3, [r7, #52]	@ 0x34
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 800415e:	f001 b8fa 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
      }
      else
      {
        frequency = LSI_VALUE;
 8004162:	f44f 43fa 	mov.w	r3, #32000	@ 0x7d00
 8004166:	637b      	str	r3, [r7, #52]	@ 0x34
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 8004168:	f001 b8f5 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
      }
    }
    /* Check if HSE is ready  and if RTC clock selection is HSI_DIV32*/
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (srcclk == RCC_RTCCLKSOURCE_HSE_DIV32))
 800416c:	4b81      	ldr	r3, [pc, #516]	@ (8004374 <HAL_RCCEx_GetPeriphCLKFreq+0x284>)
 800416e:	681b      	ldr	r3, [r3, #0]
 8004170:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8004174:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8004178:	d107      	bne.n	800418a <HAL_RCCEx_GetPeriphCLKFreq+0x9a>
 800417a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800417c:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 8004180:	d103      	bne.n	800418a <HAL_RCCEx_GetPeriphCLKFreq+0x9a>
    {
      frequency = HSE_VALUE / 32U;
 8004182:	4b7d      	ldr	r3, [pc, #500]	@ (8004378 <HAL_RCCEx_GetPeriphCLKFreq+0x288>)
 8004184:	637b      	str	r3, [r7, #52]	@ 0x34
 8004186:	f001 b8e6 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    /* Clock not enabled for RTC*/
    else
    {
      frequency = 0U;
 800418a:	2300      	movs	r3, #0
 800418c:	637b      	str	r3, [r7, #52]	@ 0x34
 800418e:	f001 b8e2 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_SAI1)
 8004192:	e9d7 2300 	ldrd	r2, r3, [r7]
 8004196:	f5a2 5100 	sub.w	r1, r2, #8192	@ 0x2000
 800419a:	430b      	orrs	r3, r1
 800419c:	d151      	bne.n	8004242 <HAL_RCCEx_GetPeriphCLKFreq+0x152>
  {
    srcclk = __HAL_RCC_GET_SAI1_SOURCE();
 800419e:	4b75      	ldr	r3, [pc, #468]	@ (8004374 <HAL_RCCEx_GetPeriphCLKFreq+0x284>)
 80041a0:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 80041a4:	f003 03e0 	and.w	r3, r3, #224	@ 0xe0
 80041a8:	633b      	str	r3, [r7, #48]	@ 0x30

    switch (srcclk)
 80041aa:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80041ac:	2b80      	cmp	r3, #128	@ 0x80
 80041ae:	d035      	beq.n	800421c <HAL_RCCEx_GetPeriphCLKFreq+0x12c>
 80041b0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80041b2:	2b80      	cmp	r3, #128	@ 0x80
 80041b4:	d841      	bhi.n	800423a <HAL_RCCEx_GetPeriphCLKFreq+0x14a>
 80041b6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80041b8:	2b60      	cmp	r3, #96	@ 0x60
 80041ba:	d02a      	beq.n	8004212 <HAL_RCCEx_GetPeriphCLKFreq+0x122>
 80041bc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80041be:	2b60      	cmp	r3, #96	@ 0x60
 80041c0:	d83b      	bhi.n	800423a <HAL_RCCEx_GetPeriphCLKFreq+0x14a>
 80041c2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80041c4:	2b40      	cmp	r3, #64	@ 0x40
 80041c6:	d009      	beq.n	80041dc <HAL_RCCEx_GetPeriphCLKFreq+0xec>
 80041c8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80041ca:	2b40      	cmp	r3, #64	@ 0x40
 80041cc:	d835      	bhi.n	800423a <HAL_RCCEx_GetPeriphCLKFreq+0x14a>
 80041ce:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80041d0:	2b00      	cmp	r3, #0
 80041d2:	d00c      	beq.n	80041ee <HAL_RCCEx_GetPeriphCLKFreq+0xfe>
 80041d4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80041d6:	2b20      	cmp	r3, #32
 80041d8:	d012      	beq.n	8004200 <HAL_RCCEx_GetPeriphCLKFreq+0x110>
 80041da:	e02e      	b.n	800423a <HAL_RCCEx_GetPeriphCLKFreq+0x14a>
    {
      case RCC_SAI1CLKSOURCE_PLL1: /* PLL1P is the clock source for SAI1 */

        HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 80041dc:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 80041e0:	4618      	mov	r0, r3
 80041e2:	f7ff fb77 	bl	80038d4 <HAL_RCCEx_GetPLL1ClockFreq>
        frequency = pll1_clocks.PLL1_P_Frequency;
 80041e6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80041e8:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 80041ea:	f001 b8b4 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>

      case RCC_SAI1CLKSOURCE_PLL2: /* PLL2P is the clock source for SAI1 */

        HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 80041ee:	f107 0318 	add.w	r3, r7, #24
 80041f2:	4618      	mov	r0, r3
 80041f4:	f7ff fcc8 	bl	8003b88 <HAL_RCCEx_GetPLL2ClockFreq>
        frequency = pll2_clocks.PLL2_P_Frequency;
 80041f8:	69bb      	ldr	r3, [r7, #24]
 80041fa:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 80041fc:	f001 b8ab 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>

      case RCC_SAI1CLKSOURCE_PLL3: /* PLLI3P is the clock source for SAI1 */

        HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 8004200:	f107 030c 	add.w	r3, r7, #12
 8004204:	4618      	mov	r0, r3
 8004206:	f7ff fe19 	bl	8003e3c <HAL_RCCEx_GetPLL3ClockFreq>
        frequency = pll3_clocks.PLL3_P_Frequency;
 800420a:	68fb      	ldr	r3, [r7, #12]
 800420c:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 800420e:	f001 b8a2 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>

      case RCC_SAI1CLKSOURCE_PIN:

        frequency = EXTERNAL_SAI1_CLOCK_VALUE;
 8004212:	f64b 3380 	movw	r3, #48000	@ 0xbb80
 8004216:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8004218:	f001 b89d 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>

      case RCC_SAI1CLKSOURCE_HSI: /* HSI is the clock source for SAI1 */

        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 800421c:	4b55      	ldr	r3, [pc, #340]	@ (8004374 <HAL_RCCEx_GetPeriphCLKFreq+0x284>)
 800421e:	681b      	ldr	r3, [r3, #0]
 8004220:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8004224:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8004228:	d103      	bne.n	8004232 <HAL_RCCEx_GetPeriphCLKFreq+0x142>
        {
          frequency = HSI_VALUE;
 800422a:	4b54      	ldr	r3, [pc, #336]	@ (800437c <HAL_RCCEx_GetPeriphCLKFreq+0x28c>)
 800422c:	637b      	str	r3, [r7, #52]	@ 0x34
        }
        else
        {
          frequency = 0U;
        }
        break;
 800422e:	f001 b892 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
          frequency = 0U;
 8004232:	2300      	movs	r3, #0
 8004234:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8004236:	f001 b88e 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>

      default :
      {
        frequency = 0U;
 800423a:	2300      	movs	r3, #0
 800423c:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 800423e:	f001 b88a 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
        break;
    }
  }
#endif /* SAI2 */
#if defined(SAES)
  else if (PeriphClk == RCC_PERIPHCLK_SAES)
 8004242:	e9d7 2300 	ldrd	r2, r3, [r7]
 8004246:	f5a2 5180 	sub.w	r1, r2, #4096	@ 0x1000
 800424a:	430b      	orrs	r3, r1
 800424c:	d126      	bne.n	800429c <HAL_RCCEx_GetPeriphCLKFreq+0x1ac>
  {
    /* Get the current SAES source */
    srcclk = __HAL_RCC_GET_SAES_SOURCE();
 800424e:	4b49      	ldr	r3, [pc, #292]	@ (8004374 <HAL_RCCEx_GetPeriphCLKFreq+0x284>)
 8004250:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 8004254:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 8004258:	633b      	str	r3, [r7, #48]	@ 0x30

    if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY) && (srcclk == RCC_SAESCLKSOURCE_SHSI))
 800425a:	4b46      	ldr	r3, [pc, #280]	@ (8004374 <HAL_RCCEx_GetPeriphCLKFreq+0x284>)
 800425c:	681b      	ldr	r3, [r3, #0]
 800425e:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8004262:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8004266:	d106      	bne.n	8004276 <HAL_RCCEx_GetPeriphCLKFreq+0x186>
 8004268:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800426a:	2b00      	cmp	r3, #0
 800426c:	d103      	bne.n	8004276 <HAL_RCCEx_GetPeriphCLKFreq+0x186>
    {
      frequency = HSI_VALUE;
 800426e:	4b43      	ldr	r3, [pc, #268]	@ (800437c <HAL_RCCEx_GetPeriphCLKFreq+0x28c>)
 8004270:	637b      	str	r3, [r7, #52]	@ 0x34
 8004272:	f001 b870 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY) && (srcclk == RCC_SAESCLKSOURCE_SHSI_DIV2))
 8004276:	4b3f      	ldr	r3, [pc, #252]	@ (8004374 <HAL_RCCEx_GetPeriphCLKFreq+0x284>)
 8004278:	681b      	ldr	r3, [r3, #0]
 800427a:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 800427e:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8004282:	d107      	bne.n	8004294 <HAL_RCCEx_GetPeriphCLKFreq+0x1a4>
 8004284:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004286:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 800428a:	d103      	bne.n	8004294 <HAL_RCCEx_GetPeriphCLKFreq+0x1a4>
    {
      frequency = HSI_VALUE >> 1U;
 800428c:	4b3c      	ldr	r3, [pc, #240]	@ (8004380 <HAL_RCCEx_GetPeriphCLKFreq+0x290>)
 800428e:	637b      	str	r3, [r7, #52]	@ 0x34
 8004290:	f001 b861 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    /* Clock not enabled for SAES */
    else
    {
      frequency = 0U;
 8004294:	2300      	movs	r3, #0
 8004296:	637b      	str	r3, [r7, #52]	@ 0x34
 8004298:	f001 b85d 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
  }
#endif /* SAES */
  else if (PeriphClk == RCC_PERIPHCLK_ICLK)
 800429c:	e9d7 2300 	ldrd	r2, r3, [r7]
 80042a0:	f5a2 1180 	sub.w	r1, r2, #1048576	@ 0x100000
 80042a4:	430b      	orrs	r3, r1
 80042a6:	d171      	bne.n	800438c <HAL_RCCEx_GetPeriphCLKFreq+0x29c>
  {
    srcclk = __HAL_RCC_GET_ICLK_SOURCE();
 80042a8:	4b32      	ldr	r3, [pc, #200]	@ (8004374 <HAL_RCCEx_GetPeriphCLKFreq+0x284>)
 80042aa:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 80042ae:	f003 6340 	and.w	r3, r3, #201326592	@ 0xc000000
 80042b2:	633b      	str	r3, [r7, #48]	@ 0x30

    switch (srcclk)
 80042b4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80042b6:	f1b3 6f40 	cmp.w	r3, #201326592	@ 0xc000000
 80042ba:	d034      	beq.n	8004326 <HAL_RCCEx_GetPeriphCLKFreq+0x236>
 80042bc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80042be:	f1b3 6f40 	cmp.w	r3, #201326592	@ 0xc000000
 80042c2:	d853      	bhi.n	800436c <HAL_RCCEx_GetPeriphCLKFreq+0x27c>
 80042c4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80042c6:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 80042ca:	d00b      	beq.n	80042e4 <HAL_RCCEx_GetPeriphCLKFreq+0x1f4>
 80042cc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80042ce:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 80042d2:	d84b      	bhi.n	800436c <HAL_RCCEx_GetPeriphCLKFreq+0x27c>
 80042d4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80042d6:	2b00      	cmp	r3, #0
 80042d8:	d016      	beq.n	8004308 <HAL_RCCEx_GetPeriphCLKFreq+0x218>
 80042da:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80042dc:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
 80042e0:	d009      	beq.n	80042f6 <HAL_RCCEx_GetPeriphCLKFreq+0x206>
 80042e2:	e043      	b.n	800436c <HAL_RCCEx_GetPeriphCLKFreq+0x27c>
    {
      case RCC_ICLK_CLKSOURCE_PLL1: /* PLL1Q  */

        HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 80042e4:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 80042e8:	4618      	mov	r0, r3
 80042ea:	f7ff faf3 	bl	80038d4 <HAL_RCCEx_GetPLL1ClockFreq>
        frequency = pll1_clocks.PLL1_Q_Frequency;
 80042ee:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80042f0:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 80042f2:	f001 b830 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>

      case RCC_ICLK_CLKSOURCE_PLL2: /* PLL2Q */

        HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 80042f6:	f107 0318 	add.w	r3, r7, #24
 80042fa:	4618      	mov	r0, r3
 80042fc:	f7ff fc44 	bl	8003b88 <HAL_RCCEx_GetPLL2ClockFreq>
        frequency = pll2_clocks.PLL2_Q_Frequency;
 8004300:	69fb      	ldr	r3, [r7, #28]
 8004302:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8004304:	f001 b827 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>

      case RCC_ICLK_CLKSOURCE_HSI48: /* HSI48 */

        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSI48RDY))
 8004308:	4b1a      	ldr	r3, [pc, #104]	@ (8004374 <HAL_RCCEx_GetPeriphCLKFreq+0x284>)
 800430a:	681b      	ldr	r3, [r3, #0]
 800430c:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 8004310:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8004314:	d103      	bne.n	800431e <HAL_RCCEx_GetPeriphCLKFreq+0x22e>
        {
          frequency = HSI48_VALUE;
 8004316:	4b1b      	ldr	r3, [pc, #108]	@ (8004384 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 8004318:	637b      	str	r3, [r7, #52]	@ 0x34
        }
        else
        {
          frequency = 0U;
        }
        break;
 800431a:	f001 b81c 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
          frequency = 0U;
 800431e:	2300      	movs	r3, #0
 8004320:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8004322:	f001 b818 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>

      case RCC_ICLK_CLKSOURCE_MSIK: /* MSIK frequency range in HZ */

        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 8004326:	4b13      	ldr	r3, [pc, #76]	@ (8004374 <HAL_RCCEx_GetPeriphCLKFreq+0x284>)
 8004328:	681b      	ldr	r3, [r3, #0]
 800432a:	f003 0320 	and.w	r3, r3, #32
 800432e:	2b20      	cmp	r3, #32
 8004330:	d118      	bne.n	8004364 <HAL_RCCEx_GetPeriphCLKFreq+0x274>
        {
          frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 8004332:	4b10      	ldr	r3, [pc, #64]	@ (8004374 <HAL_RCCEx_GetPeriphCLKFreq+0x284>)
 8004334:	689b      	ldr	r3, [r3, #8]
 8004336:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 800433a:	2b00      	cmp	r3, #0
 800433c:	d005      	beq.n	800434a <HAL_RCCEx_GetPeriphCLKFreq+0x25a>
 800433e:	4b0d      	ldr	r3, [pc, #52]	@ (8004374 <HAL_RCCEx_GetPeriphCLKFreq+0x284>)
 8004340:	689b      	ldr	r3, [r3, #8]
 8004342:	0e1b      	lsrs	r3, r3, #24
 8004344:	f003 030f 	and.w	r3, r3, #15
 8004348:	e006      	b.n	8004358 <HAL_RCCEx_GetPeriphCLKFreq+0x268>
 800434a:	4b0a      	ldr	r3, [pc, #40]	@ (8004374 <HAL_RCCEx_GetPeriphCLKFreq+0x284>)
 800434c:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8004350:	041b      	lsls	r3, r3, #16
 8004352:	0e1b      	lsrs	r3, r3, #24
 8004354:	f003 030f 	and.w	r3, r3, #15
 8004358:	4a0b      	ldr	r2, [pc, #44]	@ (8004388 <HAL_RCCEx_GetPeriphCLKFreq+0x298>)
 800435a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800435e:	637b      	str	r3, [r7, #52]	@ 0x34
        }
        else
        {
          frequency = 0U;
        }
        break;
 8004360:	f000 bff9 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
          frequency = 0U;
 8004364:	2300      	movs	r3, #0
 8004366:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8004368:	f000 bff5 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>

      default :

        frequency = 0U;
 800436c:	2300      	movs	r3, #0
 800436e:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8004370:	f000 bff1 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
 8004374:	46020c00 	.word	0x46020c00
 8004378:	0007a120 	.word	0x0007a120
 800437c:	00f42400 	.word	0x00f42400
 8004380:	007a1200 	.word	0x007a1200
 8004384:	02dc6c00 	.word	0x02dc6c00
 8004388:	080116a4 	.word	0x080116a4
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_SDMMC)
 800438c:	e9d7 2300 	ldrd	r2, r3, [r7]
 8004390:	f5a2 1100 	sub.w	r1, r2, #2097152	@ 0x200000
 8004394:	430b      	orrs	r3, r1
 8004396:	d17f      	bne.n	8004498 <HAL_RCCEx_GetPeriphCLKFreq+0x3a8>
  {
    srcclk = __HAL_RCC_GET_SDMMC_SOURCE();
 8004398:	4ba8      	ldr	r3, [pc, #672]	@ (800463c <HAL_RCCEx_GetPeriphCLKFreq+0x54c>)
 800439a:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 800439e:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 80043a2:	633b      	str	r3, [r7, #48]	@ 0x30
    if (srcclk == RCC_SDMMCCLKSOURCE_CLK48)
 80043a4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80043a6:	2b00      	cmp	r3, #0
 80043a8:	d165      	bne.n	8004476 <HAL_RCCEx_GetPeriphCLKFreq+0x386>
    {
      srcclk = __HAL_RCC_GET_ICLK_SOURCE();
 80043aa:	4ba4      	ldr	r3, [pc, #656]	@ (800463c <HAL_RCCEx_GetPeriphCLKFreq+0x54c>)
 80043ac:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 80043b0:	f003 6340 	and.w	r3, r3, #201326592	@ 0xc000000
 80043b4:	633b      	str	r3, [r7, #48]	@ 0x30

      switch (srcclk)
 80043b6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80043b8:	f1b3 6f40 	cmp.w	r3, #201326592	@ 0xc000000
 80043bc:	d034      	beq.n	8004428 <HAL_RCCEx_GetPeriphCLKFreq+0x338>
 80043be:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80043c0:	f1b3 6f40 	cmp.w	r3, #201326592	@ 0xc000000
 80043c4:	d853      	bhi.n	800446e <HAL_RCCEx_GetPeriphCLKFreq+0x37e>
 80043c6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80043c8:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 80043cc:	d00b      	beq.n	80043e6 <HAL_RCCEx_GetPeriphCLKFreq+0x2f6>
 80043ce:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80043d0:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 80043d4:	d84b      	bhi.n	800446e <HAL_RCCEx_GetPeriphCLKFreq+0x37e>
 80043d6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80043d8:	2b00      	cmp	r3, #0
 80043da:	d016      	beq.n	800440a <HAL_RCCEx_GetPeriphCLKFreq+0x31a>
 80043dc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80043de:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
 80043e2:	d009      	beq.n	80043f8 <HAL_RCCEx_GetPeriphCLKFreq+0x308>
 80043e4:	e043      	b.n	800446e <HAL_RCCEx_GetPeriphCLKFreq+0x37e>
      {
        case RCC_ICLK_CLKSOURCE_PLL1: /* PLL1Q  */
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 80043e6:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 80043ea:	4618      	mov	r0, r3
 80043ec:	f7ff fa72 	bl	80038d4 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
 80043f0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80043f2:	637b      	str	r3, [r7, #52]	@ 0x34
          break;
 80043f4:	f000 bfaf 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
        }
        case RCC_ICLK_CLKSOURCE_PLL2: /* PLL2Q */
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 80043f8:	f107 0318 	add.w	r3, r7, #24
 80043fc:	4618      	mov	r0, r3
 80043fe:	f7ff fbc3 	bl	8003b88 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
 8004402:	69fb      	ldr	r3, [r7, #28]
 8004404:	637b      	str	r3, [r7, #52]	@ 0x34
          break;
 8004406:	f000 bfa6 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
        }
        case RCC_ICLK_CLKSOURCE_HSI48: /* HSI48 */
        {
          if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSI48RDY))
 800440a:	4b8c      	ldr	r3, [pc, #560]	@ (800463c <HAL_RCCEx_GetPeriphCLKFreq+0x54c>)
 800440c:	681b      	ldr	r3, [r3, #0]
 800440e:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 8004412:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8004416:	d103      	bne.n	8004420 <HAL_RCCEx_GetPeriphCLKFreq+0x330>
          {
            frequency = HSI48_VALUE;
 8004418:	4b89      	ldr	r3, [pc, #548]	@ (8004640 <HAL_RCCEx_GetPeriphCLKFreq+0x550>)
 800441a:	637b      	str	r3, [r7, #52]	@ 0x34
          }
          else
          {
            frequency = 0U;
          }
          break;
 800441c:	f000 bf9b 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
            frequency = 0U;
 8004420:	2300      	movs	r3, #0
 8004422:	637b      	str	r3, [r7, #52]	@ 0x34
          break;
 8004424:	f000 bf97 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
        }
        case RCC_ICLK_CLKSOURCE_MSIK: /* MSIK frequency range in HZ */
        {
          if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 8004428:	4b84      	ldr	r3, [pc, #528]	@ (800463c <HAL_RCCEx_GetPeriphCLKFreq+0x54c>)
 800442a:	681b      	ldr	r3, [r3, #0]
 800442c:	f003 0320 	and.w	r3, r3, #32
 8004430:	2b20      	cmp	r3, #32
 8004432:	d118      	bne.n	8004466 <HAL_RCCEx_GetPeriphCLKFreq+0x376>
          {
            frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 8004434:	4b81      	ldr	r3, [pc, #516]	@ (800463c <HAL_RCCEx_GetPeriphCLKFreq+0x54c>)
 8004436:	689b      	ldr	r3, [r3, #8]
 8004438:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 800443c:	2b00      	cmp	r3, #0
 800443e:	d005      	beq.n	800444c <HAL_RCCEx_GetPeriphCLKFreq+0x35c>
 8004440:	4b7e      	ldr	r3, [pc, #504]	@ (800463c <HAL_RCCEx_GetPeriphCLKFreq+0x54c>)
 8004442:	689b      	ldr	r3, [r3, #8]
 8004444:	0e1b      	lsrs	r3, r3, #24
 8004446:	f003 030f 	and.w	r3, r3, #15
 800444a:	e006      	b.n	800445a <HAL_RCCEx_GetPeriphCLKFreq+0x36a>
 800444c:	4b7b      	ldr	r3, [pc, #492]	@ (800463c <HAL_RCCEx_GetPeriphCLKFreq+0x54c>)
 800444e:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8004452:	041b      	lsls	r3, r3, #16
 8004454:	0e1b      	lsrs	r3, r3, #24
 8004456:	f003 030f 	and.w	r3, r3, #15
 800445a:	4a7a      	ldr	r2, [pc, #488]	@ (8004644 <HAL_RCCEx_GetPeriphCLKFreq+0x554>)
 800445c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8004460:	637b      	str	r3, [r7, #52]	@ 0x34
          }
          else
          {
            frequency = 0U;
          }
          break;
 8004462:	f000 bf78 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
            frequency = 0U;
 8004466:	2300      	movs	r3, #0
 8004468:	637b      	str	r3, [r7, #52]	@ 0x34
          break;
 800446a:	f000 bf74 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
        }
        default :
        {
          frequency = 0U;
 800446e:	2300      	movs	r3, #0
 8004470:	637b      	str	r3, [r7, #52]	@ 0x34
          break;
 8004472:	f000 bf70 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
        }
      }
    }
    else if (srcclk == RCC_SDMMCCLKSOURCE_PLL1)
 8004476:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004478:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 800447c:	d108      	bne.n	8004490 <HAL_RCCEx_GetPeriphCLKFreq+0x3a0>
    {
      HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 800447e:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 8004482:	4618      	mov	r0, r3
 8004484:	f7ff fa26 	bl	80038d4 <HAL_RCCEx_GetPLL1ClockFreq>
      frequency = pll1_clocks.PLL1_P_Frequency;
 8004488:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800448a:	637b      	str	r3, [r7, #52]	@ 0x34
 800448c:	f000 bf63 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    else
    {
      frequency = 0U;
 8004490:	2300      	movs	r3, #0
 8004492:	637b      	str	r3, [r7, #52]	@ 0x34
 8004494:	f000 bf5f 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_USART1)
 8004498:	e9d7 2300 	ldrd	r2, r3, [r7]
 800449c:	1e51      	subs	r1, r2, #1
 800449e:	430b      	orrs	r3, r1
 80044a0:	d136      	bne.n	8004510 <HAL_RCCEx_GetPeriphCLKFreq+0x420>
  {
    /* Get the current USART1 source */
    srcclk = __HAL_RCC_GET_USART1_SOURCE();
 80044a2:	4b66      	ldr	r3, [pc, #408]	@ (800463c <HAL_RCCEx_GetPeriphCLKFreq+0x54c>)
 80044a4:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 80044a8:	f003 0303 	and.w	r3, r3, #3
 80044ac:	633b      	str	r3, [r7, #48]	@ 0x30

    if (srcclk == RCC_USART1CLKSOURCE_PCLK2)
 80044ae:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80044b0:	2b00      	cmp	r3, #0
 80044b2:	d104      	bne.n	80044be <HAL_RCCEx_GetPeriphCLKFreq+0x3ce>
    {
      frequency = HAL_RCC_GetPCLK2Freq();
 80044b4:	f7fe fc22 	bl	8002cfc <HAL_RCC_GetPCLK2Freq>
 80044b8:	6378      	str	r0, [r7, #52]	@ 0x34
 80044ba:	f000 bf4c 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    else if (srcclk == RCC_USART1CLKSOURCE_SYSCLK)
 80044be:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80044c0:	2b01      	cmp	r3, #1
 80044c2:	d104      	bne.n	80044ce <HAL_RCCEx_GetPeriphCLKFreq+0x3de>
    {
      frequency = HAL_RCC_GetSysClockFreq();
 80044c4:	f7fe faea 	bl	8002a9c <HAL_RCC_GetSysClockFreq>
 80044c8:	6378      	str	r0, [r7, #52]	@ 0x34
 80044ca:	f000 bf44 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_USART1CLKSOURCE_HSI))
 80044ce:	4b5b      	ldr	r3, [pc, #364]	@ (800463c <HAL_RCCEx_GetPeriphCLKFreq+0x54c>)
 80044d0:	681b      	ldr	r3, [r3, #0]
 80044d2:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 80044d6:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 80044da:	d106      	bne.n	80044ea <HAL_RCCEx_GetPeriphCLKFreq+0x3fa>
 80044dc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80044de:	2b02      	cmp	r3, #2
 80044e0:	d103      	bne.n	80044ea <HAL_RCCEx_GetPeriphCLKFreq+0x3fa>
    {
      frequency = HSI_VALUE;
 80044e2:	4b59      	ldr	r3, [pc, #356]	@ (8004648 <HAL_RCCEx_GetPeriphCLKFreq+0x558>)
 80044e4:	637b      	str	r3, [r7, #52]	@ 0x34
 80044e6:	f000 bf36 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_USART1CLKSOURCE_LSE))
 80044ea:	4b54      	ldr	r3, [pc, #336]	@ (800463c <HAL_RCCEx_GetPeriphCLKFreq+0x54c>)
 80044ec:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 80044f0:	f003 0302 	and.w	r3, r3, #2
 80044f4:	2b02      	cmp	r3, #2
 80044f6:	d107      	bne.n	8004508 <HAL_RCCEx_GetPeriphCLKFreq+0x418>
 80044f8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80044fa:	2b03      	cmp	r3, #3
 80044fc:	d104      	bne.n	8004508 <HAL_RCCEx_GetPeriphCLKFreq+0x418>
    {
      frequency = LSE_VALUE;
 80044fe:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 8004502:	637b      	str	r3, [r7, #52]	@ 0x34
 8004504:	f000 bf27 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    /* Clock not enabled for USART1 */
    else
    {
      frequency = 0U;
 8004508:	2300      	movs	r3, #0
 800450a:	637b      	str	r3, [r7, #52]	@ 0x34
 800450c:	f000 bf23 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    {
      frequency = 0U;
    }
  }
#endif /* USART2 */
  else if (PeriphClk == RCC_PERIPHCLK_USART3)
 8004510:	e9d7 2300 	ldrd	r2, r3, [r7]
 8004514:	1f11      	subs	r1, r2, #4
 8004516:	430b      	orrs	r3, r1
 8004518:	d136      	bne.n	8004588 <HAL_RCCEx_GetPeriphCLKFreq+0x498>
  {
    /* Get the current USART3 source */
    srcclk = __HAL_RCC_GET_USART3_SOURCE();
 800451a:	4b48      	ldr	r3, [pc, #288]	@ (800463c <HAL_RCCEx_GetPeriphCLKFreq+0x54c>)
 800451c:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8004520:	f003 0330 	and.w	r3, r3, #48	@ 0x30
 8004524:	633b      	str	r3, [r7, #48]	@ 0x30

    if (srcclk == RCC_USART3CLKSOURCE_PCLK1)
 8004526:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004528:	2b00      	cmp	r3, #0
 800452a:	d104      	bne.n	8004536 <HAL_RCCEx_GetPeriphCLKFreq+0x446>
    {
      frequency = HAL_RCC_GetPCLK1Freq();
 800452c:	f7fe fbd2 	bl	8002cd4 <HAL_RCC_GetPCLK1Freq>
 8004530:	6378      	str	r0, [r7, #52]	@ 0x34
 8004532:	f000 bf10 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    else if (srcclk == RCC_USART3CLKSOURCE_SYSCLK)
 8004536:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004538:	2b10      	cmp	r3, #16
 800453a:	d104      	bne.n	8004546 <HAL_RCCEx_GetPeriphCLKFreq+0x456>
    {
      frequency = HAL_RCC_GetSysClockFreq();
 800453c:	f7fe faae 	bl	8002a9c <HAL_RCC_GetSysClockFreq>
 8004540:	6378      	str	r0, [r7, #52]	@ 0x34
 8004542:	f000 bf08 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_USART3CLKSOURCE_HSI))
 8004546:	4b3d      	ldr	r3, [pc, #244]	@ (800463c <HAL_RCCEx_GetPeriphCLKFreq+0x54c>)
 8004548:	681b      	ldr	r3, [r3, #0]
 800454a:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 800454e:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8004552:	d106      	bne.n	8004562 <HAL_RCCEx_GetPeriphCLKFreq+0x472>
 8004554:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004556:	2b20      	cmp	r3, #32
 8004558:	d103      	bne.n	8004562 <HAL_RCCEx_GetPeriphCLKFreq+0x472>
    {
      frequency = HSI_VALUE;
 800455a:	4b3b      	ldr	r3, [pc, #236]	@ (8004648 <HAL_RCCEx_GetPeriphCLKFreq+0x558>)
 800455c:	637b      	str	r3, [r7, #52]	@ 0x34
 800455e:	f000 befa 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_USART3CLKSOURCE_LSE))
 8004562:	4b36      	ldr	r3, [pc, #216]	@ (800463c <HAL_RCCEx_GetPeriphCLKFreq+0x54c>)
 8004564:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8004568:	f003 0302 	and.w	r3, r3, #2
 800456c:	2b02      	cmp	r3, #2
 800456e:	d107      	bne.n	8004580 <HAL_RCCEx_GetPeriphCLKFreq+0x490>
 8004570:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004572:	2b30      	cmp	r3, #48	@ 0x30
 8004574:	d104      	bne.n	8004580 <HAL_RCCEx_GetPeriphCLKFreq+0x490>
    {
      frequency = LSE_VALUE;
 8004576:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 800457a:	637b      	str	r3, [r7, #52]	@ 0x34
 800457c:	f000 beeb 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    /* Clock not enabled for USART3 */
    else
    {
      frequency = 0U;
 8004580:	2300      	movs	r3, #0
 8004582:	637b      	str	r3, [r7, #52]	@ 0x34
 8004584:	f000 bee7 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_UART4)
 8004588:	e9d7 2300 	ldrd	r2, r3, [r7]
 800458c:	f1a2 0108 	sub.w	r1, r2, #8
 8004590:	430b      	orrs	r3, r1
 8004592:	d136      	bne.n	8004602 <HAL_RCCEx_GetPeriphCLKFreq+0x512>
  {
    /* Get the current UART4 source */
    srcclk = __HAL_RCC_GET_UART4_SOURCE();
 8004594:	4b29      	ldr	r3, [pc, #164]	@ (800463c <HAL_RCCEx_GetPeriphCLKFreq+0x54c>)
 8004596:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 800459a:	f003 03c0 	and.w	r3, r3, #192	@ 0xc0
 800459e:	633b      	str	r3, [r7, #48]	@ 0x30

    if (srcclk == RCC_UART4CLKSOURCE_PCLK1)
 80045a0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80045a2:	2b00      	cmp	r3, #0
 80045a4:	d104      	bne.n	80045b0 <HAL_RCCEx_GetPeriphCLKFreq+0x4c0>
    {
      frequency = HAL_RCC_GetPCLK1Freq();
 80045a6:	f7fe fb95 	bl	8002cd4 <HAL_RCC_GetPCLK1Freq>
 80045aa:	6378      	str	r0, [r7, #52]	@ 0x34
 80045ac:	f000 bed3 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    else if (srcclk == RCC_UART4CLKSOURCE_SYSCLK)
 80045b0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80045b2:	2b40      	cmp	r3, #64	@ 0x40
 80045b4:	d104      	bne.n	80045c0 <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
    {
      frequency = HAL_RCC_GetSysClockFreq();
 80045b6:	f7fe fa71 	bl	8002a9c <HAL_RCC_GetSysClockFreq>
 80045ba:	6378      	str	r0, [r7, #52]	@ 0x34
 80045bc:	f000 becb 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_UART4CLKSOURCE_HSI))
 80045c0:	4b1e      	ldr	r3, [pc, #120]	@ (800463c <HAL_RCCEx_GetPeriphCLKFreq+0x54c>)
 80045c2:	681b      	ldr	r3, [r3, #0]
 80045c4:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 80045c8:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 80045cc:	d106      	bne.n	80045dc <HAL_RCCEx_GetPeriphCLKFreq+0x4ec>
 80045ce:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80045d0:	2b80      	cmp	r3, #128	@ 0x80
 80045d2:	d103      	bne.n	80045dc <HAL_RCCEx_GetPeriphCLKFreq+0x4ec>
    {
      frequency = HSI_VALUE;
 80045d4:	4b1c      	ldr	r3, [pc, #112]	@ (8004648 <HAL_RCCEx_GetPeriphCLKFreq+0x558>)
 80045d6:	637b      	str	r3, [r7, #52]	@ 0x34
 80045d8:	f000 bebd 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_UART4CLKSOURCE_LSE))
 80045dc:	4b17      	ldr	r3, [pc, #92]	@ (800463c <HAL_RCCEx_GetPeriphCLKFreq+0x54c>)
 80045de:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 80045e2:	f003 0302 	and.w	r3, r3, #2
 80045e6:	2b02      	cmp	r3, #2
 80045e8:	d107      	bne.n	80045fa <HAL_RCCEx_GetPeriphCLKFreq+0x50a>
 80045ea:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80045ec:	2bc0      	cmp	r3, #192	@ 0xc0
 80045ee:	d104      	bne.n	80045fa <HAL_RCCEx_GetPeriphCLKFreq+0x50a>
    {
      frequency = LSE_VALUE;
 80045f0:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 80045f4:	637b      	str	r3, [r7, #52]	@ 0x34
 80045f6:	f000 beae 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    /* Clock not enabled for UART4 */
    else
    {
      frequency = 0U;
 80045fa:	2300      	movs	r3, #0
 80045fc:	637b      	str	r3, [r7, #52]	@ 0x34
 80045fe:	f000 beaa 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_UART5)
 8004602:	e9d7 2300 	ldrd	r2, r3, [r7]
 8004606:	f1a2 0110 	sub.w	r1, r2, #16
 800460a:	430b      	orrs	r3, r1
 800460c:	d141      	bne.n	8004692 <HAL_RCCEx_GetPeriphCLKFreq+0x5a2>
  {
    /* Get the current UART5 source */
    srcclk = __HAL_RCC_GET_UART5_SOURCE();
 800460e:	4b0b      	ldr	r3, [pc, #44]	@ (800463c <HAL_RCCEx_GetPeriphCLKFreq+0x54c>)
 8004610:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8004614:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 8004618:	633b      	str	r3, [r7, #48]	@ 0x30

    if (srcclk == RCC_UART5CLKSOURCE_PCLK1)
 800461a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800461c:	2b00      	cmp	r3, #0
 800461e:	d104      	bne.n	800462a <HAL_RCCEx_GetPeriphCLKFreq+0x53a>
    {
      frequency = HAL_RCC_GetPCLK1Freq();
 8004620:	f7fe fb58 	bl	8002cd4 <HAL_RCC_GetPCLK1Freq>
 8004624:	6378      	str	r0, [r7, #52]	@ 0x34
 8004626:	f000 be96 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    else if (srcclk == RCC_UART5CLKSOURCE_SYSCLK)
 800462a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800462c:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8004630:	d10c      	bne.n	800464c <HAL_RCCEx_GetPeriphCLKFreq+0x55c>
    {
      frequency = HAL_RCC_GetSysClockFreq();
 8004632:	f7fe fa33 	bl	8002a9c <HAL_RCC_GetSysClockFreq>
 8004636:	6378      	str	r0, [r7, #52]	@ 0x34
 8004638:	f000 be8d 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
 800463c:	46020c00 	.word	0x46020c00
 8004640:	02dc6c00 	.word	0x02dc6c00
 8004644:	080116a4 	.word	0x080116a4
 8004648:	00f42400 	.word	0x00f42400
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_UART5CLKSOURCE_HSI))
 800464c:	4baa      	ldr	r3, [pc, #680]	@ (80048f8 <HAL_RCCEx_GetPeriphCLKFreq+0x808>)
 800464e:	681b      	ldr	r3, [r3, #0]
 8004650:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8004654:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8004658:	d107      	bne.n	800466a <HAL_RCCEx_GetPeriphCLKFreq+0x57a>
 800465a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800465c:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8004660:	d103      	bne.n	800466a <HAL_RCCEx_GetPeriphCLKFreq+0x57a>
    {
      frequency = HSI_VALUE;
 8004662:	4ba6      	ldr	r3, [pc, #664]	@ (80048fc <HAL_RCCEx_GetPeriphCLKFreq+0x80c>)
 8004664:	637b      	str	r3, [r7, #52]	@ 0x34
 8004666:	f000 be76 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_UART5CLKSOURCE_LSE))
 800466a:	4ba3      	ldr	r3, [pc, #652]	@ (80048f8 <HAL_RCCEx_GetPeriphCLKFreq+0x808>)
 800466c:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8004670:	f003 0302 	and.w	r3, r3, #2
 8004674:	2b02      	cmp	r3, #2
 8004676:	d108      	bne.n	800468a <HAL_RCCEx_GetPeriphCLKFreq+0x59a>
 8004678:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800467a:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 800467e:	d104      	bne.n	800468a <HAL_RCCEx_GetPeriphCLKFreq+0x59a>
    {
      frequency = LSE_VALUE;
 8004680:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 8004684:	637b      	str	r3, [r7, #52]	@ 0x34
 8004686:	f000 be66 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    /* Clock not enabled for UART5 */
    else
    {
      frequency = 0U;
 800468a:	2300      	movs	r3, #0
 800468c:	637b      	str	r3, [r7, #52]	@ 0x34
 800468e:	f000 be62 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    {
      frequency = 0U;
    }
  }
#endif /* USART6 */
  else if (PeriphClk == RCC_PERIPHCLK_LPUART1)
 8004692:	e9d7 2300 	ldrd	r2, r3, [r7]
 8004696:	f1a2 0120 	sub.w	r1, r2, #32
 800469a:	430b      	orrs	r3, r1
 800469c:	d158      	bne.n	8004750 <HAL_RCCEx_GetPeriphCLKFreq+0x660>
  {
    /* Get the current LPUART1 source */
    srcclk = __HAL_RCC_GET_LPUART1_SOURCE();
 800469e:	4b96      	ldr	r3, [pc, #600]	@ (80048f8 <HAL_RCCEx_GetPeriphCLKFreq+0x808>)
 80046a0:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 80046a4:	f003 0307 	and.w	r3, r3, #7
 80046a8:	633b      	str	r3, [r7, #48]	@ 0x30

    if (srcclk == RCC_LPUART1CLKSOURCE_PCLK3)
 80046aa:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80046ac:	2b00      	cmp	r3, #0
 80046ae:	d104      	bne.n	80046ba <HAL_RCCEx_GetPeriphCLKFreq+0x5ca>
    {
      frequency = HAL_RCC_GetPCLK3Freq();
 80046b0:	f7fe fb38 	bl	8002d24 <HAL_RCC_GetPCLK3Freq>
 80046b4:	6378      	str	r0, [r7, #52]	@ 0x34
 80046b6:	f000 be4e 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    else if (srcclk == RCC_LPUART1CLKSOURCE_SYSCLK)
 80046ba:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80046bc:	2b01      	cmp	r3, #1
 80046be:	d104      	bne.n	80046ca <HAL_RCCEx_GetPeriphCLKFreq+0x5da>
    {
      frequency = HAL_RCC_GetSysClockFreq();
 80046c0:	f7fe f9ec 	bl	8002a9c <HAL_RCC_GetSysClockFreq>
 80046c4:	6378      	str	r0, [r7, #52]	@ 0x34
 80046c6:	f000 be46 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_LPUART1CLKSOURCE_HSI))
 80046ca:	4b8b      	ldr	r3, [pc, #556]	@ (80048f8 <HAL_RCCEx_GetPeriphCLKFreq+0x808>)
 80046cc:	681b      	ldr	r3, [r3, #0]
 80046ce:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 80046d2:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 80046d6:	d106      	bne.n	80046e6 <HAL_RCCEx_GetPeriphCLKFreq+0x5f6>
 80046d8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80046da:	2b02      	cmp	r3, #2
 80046dc:	d103      	bne.n	80046e6 <HAL_RCCEx_GetPeriphCLKFreq+0x5f6>
    {
      frequency = HSI_VALUE;
 80046de:	4b87      	ldr	r3, [pc, #540]	@ (80048fc <HAL_RCCEx_GetPeriphCLKFreq+0x80c>)
 80046e0:	637b      	str	r3, [r7, #52]	@ 0x34
 80046e2:	f000 be38 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_LPUART1CLKSOURCE_LSE))
 80046e6:	4b84      	ldr	r3, [pc, #528]	@ (80048f8 <HAL_RCCEx_GetPeriphCLKFreq+0x808>)
 80046e8:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 80046ec:	f003 0302 	and.w	r3, r3, #2
 80046f0:	2b02      	cmp	r3, #2
 80046f2:	d107      	bne.n	8004704 <HAL_RCCEx_GetPeriphCLKFreq+0x614>
 80046f4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80046f6:	2b03      	cmp	r3, #3
 80046f8:	d104      	bne.n	8004704 <HAL_RCCEx_GetPeriphCLKFreq+0x614>
    {
      frequency = LSE_VALUE;
 80046fa:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 80046fe:	637b      	str	r3, [r7, #52]	@ 0x34
 8004700:	f000 be29 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY)) && (srcclk == RCC_LPUART1CLKSOURCE_MSIK))
 8004704:	4b7c      	ldr	r3, [pc, #496]	@ (80048f8 <HAL_RCCEx_GetPeriphCLKFreq+0x808>)
 8004706:	681b      	ldr	r3, [r3, #0]
 8004708:	f003 0320 	and.w	r3, r3, #32
 800470c:	2b20      	cmp	r3, #32
 800470e:	d11b      	bne.n	8004748 <HAL_RCCEx_GetPeriphCLKFreq+0x658>
 8004710:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004712:	2b04      	cmp	r3, #4
 8004714:	d118      	bne.n	8004748 <HAL_RCCEx_GetPeriphCLKFreq+0x658>
    {
      frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 8004716:	4b78      	ldr	r3, [pc, #480]	@ (80048f8 <HAL_RCCEx_GetPeriphCLKFreq+0x808>)
 8004718:	689b      	ldr	r3, [r3, #8]
 800471a:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 800471e:	2b00      	cmp	r3, #0
 8004720:	d005      	beq.n	800472e <HAL_RCCEx_GetPeriphCLKFreq+0x63e>
 8004722:	4b75      	ldr	r3, [pc, #468]	@ (80048f8 <HAL_RCCEx_GetPeriphCLKFreq+0x808>)
 8004724:	689b      	ldr	r3, [r3, #8]
 8004726:	0e1b      	lsrs	r3, r3, #24
 8004728:	f003 030f 	and.w	r3, r3, #15
 800472c:	e006      	b.n	800473c <HAL_RCCEx_GetPeriphCLKFreq+0x64c>
 800472e:	4b72      	ldr	r3, [pc, #456]	@ (80048f8 <HAL_RCCEx_GetPeriphCLKFreq+0x808>)
 8004730:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8004734:	041b      	lsls	r3, r3, #16
 8004736:	0e1b      	lsrs	r3, r3, #24
 8004738:	f003 030f 	and.w	r3, r3, #15
 800473c:	4a70      	ldr	r2, [pc, #448]	@ (8004900 <HAL_RCCEx_GetPeriphCLKFreq+0x810>)
 800473e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8004742:	637b      	str	r3, [r7, #52]	@ 0x34
 8004744:	f000 be07 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    /* Clock not enabled for LPUART1 */
    else
    {
      frequency = 0U;
 8004748:	2300      	movs	r3, #0
 800474a:	637b      	str	r3, [r7, #52]	@ 0x34
 800474c:	f000 be03 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_ADCDAC)
 8004750:	e9d7 2300 	ldrd	r2, r3, [r7]
 8004754:	f5a2 4100 	sub.w	r1, r2, #32768	@ 0x8000
 8004758:	430b      	orrs	r3, r1
 800475a:	d16c      	bne.n	8004836 <HAL_RCCEx_GetPeriphCLKFreq+0x746>
  {
    srcclk = __HAL_RCC_GET_ADCDAC_SOURCE();
 800475c:	4b66      	ldr	r3, [pc, #408]	@ (80048f8 <HAL_RCCEx_GetPeriphCLKFreq+0x808>)
 800475e:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 8004762:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
 8004766:	633b      	str	r3, [r7, #48]	@ 0x30

    if (srcclk == RCC_ADCDACCLKSOURCE_SYSCLK)
 8004768:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800476a:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 800476e:	d104      	bne.n	800477a <HAL_RCCEx_GetPeriphCLKFreq+0x68a>
    {
      frequency = HAL_RCC_GetSysClockFreq();
 8004770:	f7fe f994 	bl	8002a9c <HAL_RCC_GetSysClockFreq>
 8004774:	6378      	str	r0, [r7, #52]	@ 0x34
 8004776:	f000 bdee 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    else if (srcclk == RCC_ADCDACCLKSOURCE_PLL2)
 800477a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800477c:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8004780:	d108      	bne.n	8004794 <HAL_RCCEx_GetPeriphCLKFreq+0x6a4>
    {
      HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8004782:	f107 0318 	add.w	r3, r7, #24
 8004786:	4618      	mov	r0, r3
 8004788:	f7ff f9fe 	bl	8003b88 <HAL_RCCEx_GetPLL2ClockFreq>
      frequency = pll2_clocks.PLL2_R_Frequency;
 800478c:	6a3b      	ldr	r3, [r7, #32]
 800478e:	637b      	str	r3, [r7, #52]	@ 0x34
 8004790:	f000 bde1 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    else if (srcclk == RCC_ADCDACCLKSOURCE_HCLK)
 8004794:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004796:	2b00      	cmp	r3, #0
 8004798:	d104      	bne.n	80047a4 <HAL_RCCEx_GetPeriphCLKFreq+0x6b4>
    {
      frequency = HAL_RCC_GetHCLKFreq();
 800479a:	f7fe fa81 	bl	8002ca0 <HAL_RCC_GetHCLKFreq>
 800479e:	6378      	str	r0, [r7, #52]	@ 0x34
 80047a0:	f000 bdd9 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    else if (srcclk == RCC_ADCDACCLKSOURCE_MSIK)
 80047a4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80047a6:	f5b3 4fa0 	cmp.w	r3, #20480	@ 0x5000
 80047aa:	d122      	bne.n	80047f2 <HAL_RCCEx_GetPeriphCLKFreq+0x702>
    {
      if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 80047ac:	4b52      	ldr	r3, [pc, #328]	@ (80048f8 <HAL_RCCEx_GetPeriphCLKFreq+0x808>)
 80047ae:	681b      	ldr	r3, [r3, #0]
 80047b0:	f003 0320 	and.w	r3, r3, #32
 80047b4:	2b20      	cmp	r3, #32
 80047b6:	d118      	bne.n	80047ea <HAL_RCCEx_GetPeriphCLKFreq+0x6fa>
      {
        frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 80047b8:	4b4f      	ldr	r3, [pc, #316]	@ (80048f8 <HAL_RCCEx_GetPeriphCLKFreq+0x808>)
 80047ba:	689b      	ldr	r3, [r3, #8]
 80047bc:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 80047c0:	2b00      	cmp	r3, #0
 80047c2:	d005      	beq.n	80047d0 <HAL_RCCEx_GetPeriphCLKFreq+0x6e0>
 80047c4:	4b4c      	ldr	r3, [pc, #304]	@ (80048f8 <HAL_RCCEx_GetPeriphCLKFreq+0x808>)
 80047c6:	689b      	ldr	r3, [r3, #8]
 80047c8:	0e1b      	lsrs	r3, r3, #24
 80047ca:	f003 030f 	and.w	r3, r3, #15
 80047ce:	e006      	b.n	80047de <HAL_RCCEx_GetPeriphCLKFreq+0x6ee>
 80047d0:	4b49      	ldr	r3, [pc, #292]	@ (80048f8 <HAL_RCCEx_GetPeriphCLKFreq+0x808>)
 80047d2:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 80047d6:	041b      	lsls	r3, r3, #16
 80047d8:	0e1b      	lsrs	r3, r3, #24
 80047da:	f003 030f 	and.w	r3, r3, #15
 80047de:	4a48      	ldr	r2, [pc, #288]	@ (8004900 <HAL_RCCEx_GetPeriphCLKFreq+0x810>)
 80047e0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80047e4:	637b      	str	r3, [r7, #52]	@ 0x34
 80047e6:	f000 bdb6 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
      }
      else
      {
        frequency = 0U;
 80047ea:	2300      	movs	r3, #0
 80047ec:	637b      	str	r3, [r7, #52]	@ 0x34
 80047ee:	f000 bdb2 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
      }
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (srcclk == RCC_ADCDACCLKSOURCE_HSE))
 80047f2:	4b41      	ldr	r3, [pc, #260]	@ (80048f8 <HAL_RCCEx_GetPeriphCLKFreq+0x808>)
 80047f4:	681b      	ldr	r3, [r3, #0]
 80047f6:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 80047fa:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 80047fe:	d107      	bne.n	8004810 <HAL_RCCEx_GetPeriphCLKFreq+0x720>
 8004800:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004802:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 8004806:	d103      	bne.n	8004810 <HAL_RCCEx_GetPeriphCLKFreq+0x720>
    {
      frequency = HSE_VALUE;
 8004808:	4b3c      	ldr	r3, [pc, #240]	@ (80048fc <HAL_RCCEx_GetPeriphCLKFreq+0x80c>)
 800480a:	637b      	str	r3, [r7, #52]	@ 0x34
 800480c:	f000 bda3 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_ADCDACCLKSOURCE_HSI))
 8004810:	4b39      	ldr	r3, [pc, #228]	@ (80048f8 <HAL_RCCEx_GetPeriphCLKFreq+0x808>)
 8004812:	681b      	ldr	r3, [r3, #0]
 8004814:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8004818:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 800481c:	d107      	bne.n	800482e <HAL_RCCEx_GetPeriphCLKFreq+0x73e>
 800481e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004820:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 8004824:	d103      	bne.n	800482e <HAL_RCCEx_GetPeriphCLKFreq+0x73e>
    {
      frequency = HSI_VALUE;
 8004826:	4b35      	ldr	r3, [pc, #212]	@ (80048fc <HAL_RCCEx_GetPeriphCLKFreq+0x80c>)
 8004828:	637b      	str	r3, [r7, #52]	@ 0x34
 800482a:	f000 bd94 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    /* Clock not enabled for ADC */
    else
    {
      frequency = 0U;
 800482e:	2300      	movs	r3, #0
 8004830:	637b      	str	r3, [r7, #52]	@ 0x34
 8004832:	f000 bd90 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_MDF1)
 8004836:	e9d7 2300 	ldrd	r2, r3, [r7]
 800483a:	f5a2 3180 	sub.w	r1, r2, #65536	@ 0x10000
 800483e:	430b      	orrs	r3, r1
 8004840:	d160      	bne.n	8004904 <HAL_RCCEx_GetPeriphCLKFreq+0x814>
  {
    /* Get the current MDF1 source */
    srcclk = __HAL_RCC_GET_MDF1_SOURCE();
 8004842:	4b2d      	ldr	r3, [pc, #180]	@ (80048f8 <HAL_RCCEx_GetPeriphCLKFreq+0x808>)
 8004844:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 8004848:	f003 0307 	and.w	r3, r3, #7
 800484c:	633b      	str	r3, [r7, #48]	@ 0x30

    switch (srcclk)
 800484e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004850:	2b04      	cmp	r3, #4
 8004852:	d84c      	bhi.n	80048ee <HAL_RCCEx_GetPeriphCLKFreq+0x7fe>
 8004854:	a201      	add	r2, pc, #4	@ (adr r2, 800485c <HAL_RCCEx_GetPeriphCLKFreq+0x76c>)
 8004856:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800485a:	bf00      	nop
 800485c:	08004895 	.word	0x08004895
 8004860:	08004871 	.word	0x08004871
 8004864:	08004883 	.word	0x08004883
 8004868:	0800489f 	.word	0x0800489f
 800486c:	080048a9 	.word	0x080048a9
    {
      case RCC_MDF1CLKSOURCE_PLL1:

        HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 8004870:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 8004874:	4618      	mov	r0, r3
 8004876:	f7ff f82d 	bl	80038d4 <HAL_RCCEx_GetPLL1ClockFreq>
        frequency = pll1_clocks.PLL1_P_Frequency;
 800487a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800487c:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 800487e:	f000 bd6a 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>

      case RCC_MDF1CLKSOURCE_PLL3:

        HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 8004882:	f107 030c 	add.w	r3, r7, #12
 8004886:	4618      	mov	r0, r3
 8004888:	f7ff fad8 	bl	8003e3c <HAL_RCCEx_GetPLL3ClockFreq>
        frequency = pll3_clocks.PLL3_Q_Frequency;
 800488c:	693b      	ldr	r3, [r7, #16]
 800488e:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8004890:	f000 bd61 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>

      case RCC_MDF1CLKSOURCE_HCLK:

        frequency = HAL_RCC_GetHCLKFreq();
 8004894:	f7fe fa04 	bl	8002ca0 <HAL_RCC_GetHCLKFreq>
 8004898:	6378      	str	r0, [r7, #52]	@ 0x34
        break;
 800489a:	f000 bd5c 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>

      case RCC_MDF1CLKSOURCE_PIN:

        frequency = EXTERNAL_SAI1_CLOCK_VALUE;
 800489e:	f64b 3380 	movw	r3, #48000	@ 0xbb80
 80048a2:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 80048a4:	f000 bd57 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>

      case RCC_MDF1CLKSOURCE_MSIK:

        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 80048a8:	4b13      	ldr	r3, [pc, #76]	@ (80048f8 <HAL_RCCEx_GetPeriphCLKFreq+0x808>)
 80048aa:	681b      	ldr	r3, [r3, #0]
 80048ac:	f003 0320 	and.w	r3, r3, #32
 80048b0:	2b20      	cmp	r3, #32
 80048b2:	d118      	bne.n	80048e6 <HAL_RCCEx_GetPeriphCLKFreq+0x7f6>
        {
          frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 80048b4:	4b10      	ldr	r3, [pc, #64]	@ (80048f8 <HAL_RCCEx_GetPeriphCLKFreq+0x808>)
 80048b6:	689b      	ldr	r3, [r3, #8]
 80048b8:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 80048bc:	2b00      	cmp	r3, #0
 80048be:	d005      	beq.n	80048cc <HAL_RCCEx_GetPeriphCLKFreq+0x7dc>
 80048c0:	4b0d      	ldr	r3, [pc, #52]	@ (80048f8 <HAL_RCCEx_GetPeriphCLKFreq+0x808>)
 80048c2:	689b      	ldr	r3, [r3, #8]
 80048c4:	0e1b      	lsrs	r3, r3, #24
 80048c6:	f003 030f 	and.w	r3, r3, #15
 80048ca:	e006      	b.n	80048da <HAL_RCCEx_GetPeriphCLKFreq+0x7ea>
 80048cc:	4b0a      	ldr	r3, [pc, #40]	@ (80048f8 <HAL_RCCEx_GetPeriphCLKFreq+0x808>)
 80048ce:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 80048d2:	041b      	lsls	r3, r3, #16
 80048d4:	0e1b      	lsrs	r3, r3, #24
 80048d6:	f003 030f 	and.w	r3, r3, #15
 80048da:	4a09      	ldr	r2, [pc, #36]	@ (8004900 <HAL_RCCEx_GetPeriphCLKFreq+0x810>)
 80048dc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80048e0:	637b      	str	r3, [r7, #52]	@ 0x34
        }
        else
        {
          frequency = 0U;
        }
        break;
 80048e2:	f000 bd38 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
          frequency = 0U;
 80048e6:	2300      	movs	r3, #0
 80048e8:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 80048ea:	f000 bd34 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>

      default:

        frequency = 0U;
 80048ee:	2300      	movs	r3, #0
 80048f0:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 80048f2:	f000 bd30 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
 80048f6:	bf00      	nop
 80048f8:	46020c00 	.word	0x46020c00
 80048fc:	00f42400 	.word	0x00f42400
 8004900:	080116a4 	.word	0x080116a4
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_ADF1)
 8004904:	e9d7 2300 	ldrd	r2, r3, [r7]
 8004908:	f5a2 3100 	sub.w	r1, r2, #131072	@ 0x20000
 800490c:	430b      	orrs	r3, r1
 800490e:	d167      	bne.n	80049e0 <HAL_RCCEx_GetPeriphCLKFreq+0x8f0>
  {
    /* Get the current ADF1 source */
    srcclk = __HAL_RCC_GET_ADF1_SOURCE();
 8004910:	4ba0      	ldr	r3, [pc, #640]	@ (8004b94 <HAL_RCCEx_GetPeriphCLKFreq+0xaa4>)
 8004912:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 8004916:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
 800491a:	633b      	str	r3, [r7, #48]	@ 0x30

    switch (srcclk)
 800491c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800491e:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 8004922:	d036      	beq.n	8004992 <HAL_RCCEx_GetPeriphCLKFreq+0x8a2>
 8004924:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004926:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 800492a:	d855      	bhi.n	80049d8 <HAL_RCCEx_GetPeriphCLKFreq+0x8e8>
 800492c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800492e:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
 8004932:	d029      	beq.n	8004988 <HAL_RCCEx_GetPeriphCLKFreq+0x898>
 8004934:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004936:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
 800493a:	d84d      	bhi.n	80049d8 <HAL_RCCEx_GetPeriphCLKFreq+0x8e8>
 800493c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800493e:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8004942:	d013      	beq.n	800496c <HAL_RCCEx_GetPeriphCLKFreq+0x87c>
 8004944:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004946:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 800494a:	d845      	bhi.n	80049d8 <HAL_RCCEx_GetPeriphCLKFreq+0x8e8>
 800494c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800494e:	2b00      	cmp	r3, #0
 8004950:	d015      	beq.n	800497e <HAL_RCCEx_GetPeriphCLKFreq+0x88e>
 8004952:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004954:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8004958:	d13e      	bne.n	80049d8 <HAL_RCCEx_GetPeriphCLKFreq+0x8e8>
    {
      case RCC_ADF1CLKSOURCE_PLL1:

        HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 800495a:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 800495e:	4618      	mov	r0, r3
 8004960:	f7fe ffb8 	bl	80038d4 <HAL_RCCEx_GetPLL1ClockFreq>
        frequency = pll1_clocks.PLL1_P_Frequency;
 8004964:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8004966:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8004968:	f000 bcf5 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>

      case RCC_ADF1CLKSOURCE_PLL3:

        HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 800496c:	f107 030c 	add.w	r3, r7, #12
 8004970:	4618      	mov	r0, r3
 8004972:	f7ff fa63 	bl	8003e3c <HAL_RCCEx_GetPLL3ClockFreq>
        frequency = pll3_clocks.PLL3_Q_Frequency;
 8004976:	693b      	ldr	r3, [r7, #16]
 8004978:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 800497a:	f000 bcec 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>

      case RCC_ADF1CLKSOURCE_HCLK:

        frequency = HAL_RCC_GetHCLKFreq();
 800497e:	f7fe f98f 	bl	8002ca0 <HAL_RCC_GetHCLKFreq>
 8004982:	6378      	str	r0, [r7, #52]	@ 0x34
        break;
 8004984:	f000 bce7 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>

      case RCC_ADF1CLKSOURCE_PIN:

        frequency = EXTERNAL_SAI1_CLOCK_VALUE;
 8004988:	f64b 3380 	movw	r3, #48000	@ 0xbb80
 800498c:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 800498e:	f000 bce2 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>

      case RCC_ADF1CLKSOURCE_MSIK:

        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 8004992:	4b80      	ldr	r3, [pc, #512]	@ (8004b94 <HAL_RCCEx_GetPeriphCLKFreq+0xaa4>)
 8004994:	681b      	ldr	r3, [r3, #0]
 8004996:	f003 0320 	and.w	r3, r3, #32
 800499a:	2b20      	cmp	r3, #32
 800499c:	d118      	bne.n	80049d0 <HAL_RCCEx_GetPeriphCLKFreq+0x8e0>
        {
          frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 800499e:	4b7d      	ldr	r3, [pc, #500]	@ (8004b94 <HAL_RCCEx_GetPeriphCLKFreq+0xaa4>)
 80049a0:	689b      	ldr	r3, [r3, #8]
 80049a2:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 80049a6:	2b00      	cmp	r3, #0
 80049a8:	d005      	beq.n	80049b6 <HAL_RCCEx_GetPeriphCLKFreq+0x8c6>
 80049aa:	4b7a      	ldr	r3, [pc, #488]	@ (8004b94 <HAL_RCCEx_GetPeriphCLKFreq+0xaa4>)
 80049ac:	689b      	ldr	r3, [r3, #8]
 80049ae:	0e1b      	lsrs	r3, r3, #24
 80049b0:	f003 030f 	and.w	r3, r3, #15
 80049b4:	e006      	b.n	80049c4 <HAL_RCCEx_GetPeriphCLKFreq+0x8d4>
 80049b6:	4b77      	ldr	r3, [pc, #476]	@ (8004b94 <HAL_RCCEx_GetPeriphCLKFreq+0xaa4>)
 80049b8:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 80049bc:	041b      	lsls	r3, r3, #16
 80049be:	0e1b      	lsrs	r3, r3, #24
 80049c0:	f003 030f 	and.w	r3, r3, #15
 80049c4:	4a74      	ldr	r2, [pc, #464]	@ (8004b98 <HAL_RCCEx_GetPeriphCLKFreq+0xaa8>)
 80049c6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80049ca:	637b      	str	r3, [r7, #52]	@ 0x34
        }
        else
        {
          frequency = 0U;
        }
        break;
 80049cc:	f000 bcc3 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
          frequency = 0U;
 80049d0:	2300      	movs	r3, #0
 80049d2:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 80049d4:	f000 bcbf 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>

      default:

        frequency = 0U;
 80049d8:	2300      	movs	r3, #0
 80049da:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 80049dc:	f000 bcbb 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_I2C1)
 80049e0:	e9d7 2300 	ldrd	r2, r3, [r7]
 80049e4:	f1a2 0140 	sub.w	r1, r2, #64	@ 0x40
 80049e8:	430b      	orrs	r3, r1
 80049ea:	d14c      	bne.n	8004a86 <HAL_RCCEx_GetPeriphCLKFreq+0x996>
  {
    /* Get the current I2C1 source */
    srcclk = __HAL_RCC_GET_I2C1_SOURCE();
 80049ec:	4b69      	ldr	r3, [pc, #420]	@ (8004b94 <HAL_RCCEx_GetPeriphCLKFreq+0xaa4>)
 80049ee:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 80049f2:	f403 6340 	and.w	r3, r3, #3072	@ 0xc00
 80049f6:	633b      	str	r3, [r7, #48]	@ 0x30

    if (srcclk == RCC_I2C1CLKSOURCE_PCLK1)
 80049f8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80049fa:	2b00      	cmp	r3, #0
 80049fc:	d104      	bne.n	8004a08 <HAL_RCCEx_GetPeriphCLKFreq+0x918>
    {
      frequency = HAL_RCC_GetPCLK1Freq();
 80049fe:	f7fe f969 	bl	8002cd4 <HAL_RCC_GetPCLK1Freq>
 8004a02:	6378      	str	r0, [r7, #52]	@ 0x34
 8004a04:	f000 bca7 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    else if (srcclk == RCC_I2C1CLKSOURCE_SYSCLK)
 8004a08:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004a0a:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8004a0e:	d104      	bne.n	8004a1a <HAL_RCCEx_GetPeriphCLKFreq+0x92a>
    {
      frequency = HAL_RCC_GetSysClockFreq();
 8004a10:	f7fe f844 	bl	8002a9c <HAL_RCC_GetSysClockFreq>
 8004a14:	6378      	str	r0, [r7, #52]	@ 0x34
 8004a16:	f000 bc9e 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_I2C1CLKSOURCE_HSI))
 8004a1a:	4b5e      	ldr	r3, [pc, #376]	@ (8004b94 <HAL_RCCEx_GetPeriphCLKFreq+0xaa4>)
 8004a1c:	681b      	ldr	r3, [r3, #0]
 8004a1e:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8004a22:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8004a26:	d107      	bne.n	8004a38 <HAL_RCCEx_GetPeriphCLKFreq+0x948>
 8004a28:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004a2a:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 8004a2e:	d103      	bne.n	8004a38 <HAL_RCCEx_GetPeriphCLKFreq+0x948>
    {
      frequency = HSI_VALUE;
 8004a30:	4b5a      	ldr	r3, [pc, #360]	@ (8004b9c <HAL_RCCEx_GetPeriphCLKFreq+0xaac>)
 8004a32:	637b      	str	r3, [r7, #52]	@ 0x34
 8004a34:	f000 bc8f 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY)) && (srcclk == RCC_I2C1CLKSOURCE_MSIK))
 8004a38:	4b56      	ldr	r3, [pc, #344]	@ (8004b94 <HAL_RCCEx_GetPeriphCLKFreq+0xaa4>)
 8004a3a:	681b      	ldr	r3, [r3, #0]
 8004a3c:	f003 0320 	and.w	r3, r3, #32
 8004a40:	2b20      	cmp	r3, #32
 8004a42:	d11c      	bne.n	8004a7e <HAL_RCCEx_GetPeriphCLKFreq+0x98e>
 8004a44:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004a46:	f5b3 6f40 	cmp.w	r3, #3072	@ 0xc00
 8004a4a:	d118      	bne.n	8004a7e <HAL_RCCEx_GetPeriphCLKFreq+0x98e>
    {
      frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 8004a4c:	4b51      	ldr	r3, [pc, #324]	@ (8004b94 <HAL_RCCEx_GetPeriphCLKFreq+0xaa4>)
 8004a4e:	689b      	ldr	r3, [r3, #8]
 8004a50:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 8004a54:	2b00      	cmp	r3, #0
 8004a56:	d005      	beq.n	8004a64 <HAL_RCCEx_GetPeriphCLKFreq+0x974>
 8004a58:	4b4e      	ldr	r3, [pc, #312]	@ (8004b94 <HAL_RCCEx_GetPeriphCLKFreq+0xaa4>)
 8004a5a:	689b      	ldr	r3, [r3, #8]
 8004a5c:	0e1b      	lsrs	r3, r3, #24
 8004a5e:	f003 030f 	and.w	r3, r3, #15
 8004a62:	e006      	b.n	8004a72 <HAL_RCCEx_GetPeriphCLKFreq+0x982>
 8004a64:	4b4b      	ldr	r3, [pc, #300]	@ (8004b94 <HAL_RCCEx_GetPeriphCLKFreq+0xaa4>)
 8004a66:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8004a6a:	041b      	lsls	r3, r3, #16
 8004a6c:	0e1b      	lsrs	r3, r3, #24
 8004a6e:	f003 030f 	and.w	r3, r3, #15
 8004a72:	4a49      	ldr	r2, [pc, #292]	@ (8004b98 <HAL_RCCEx_GetPeriphCLKFreq+0xaa8>)
 8004a74:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8004a78:	637b      	str	r3, [r7, #52]	@ 0x34
 8004a7a:	f000 bc6c 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    /* Clock not enabled for I2C1 */
    else
    {
      frequency = 0U;
 8004a7e:	2300      	movs	r3, #0
 8004a80:	637b      	str	r3, [r7, #52]	@ 0x34
 8004a82:	f000 bc68 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_I2C2)
 8004a86:	e9d7 2300 	ldrd	r2, r3, [r7]
 8004a8a:	f1a2 0180 	sub.w	r1, r2, #128	@ 0x80
 8004a8e:	430b      	orrs	r3, r1
 8004a90:	d14c      	bne.n	8004b2c <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>
  {
    /* Get the current I2C2 source */
    srcclk = __HAL_RCC_GET_I2C2_SOURCE();
 8004a92:	4b40      	ldr	r3, [pc, #256]	@ (8004b94 <HAL_RCCEx_GetPeriphCLKFreq+0xaa4>)
 8004a94:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8004a98:	f403 5340 	and.w	r3, r3, #12288	@ 0x3000
 8004a9c:	633b      	str	r3, [r7, #48]	@ 0x30

    if (srcclk == RCC_I2C2CLKSOURCE_PCLK1)
 8004a9e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004aa0:	2b00      	cmp	r3, #0
 8004aa2:	d104      	bne.n	8004aae <HAL_RCCEx_GetPeriphCLKFreq+0x9be>
    {
      frequency = HAL_RCC_GetPCLK1Freq();
 8004aa4:	f7fe f916 	bl	8002cd4 <HAL_RCC_GetPCLK1Freq>
 8004aa8:	6378      	str	r0, [r7, #52]	@ 0x34
 8004aaa:	f000 bc54 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    else if (srcclk == RCC_I2C2CLKSOURCE_SYSCLK)
 8004aae:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004ab0:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8004ab4:	d104      	bne.n	8004ac0 <HAL_RCCEx_GetPeriphCLKFreq+0x9d0>
    {
      frequency = HAL_RCC_GetSysClockFreq();
 8004ab6:	f7fd fff1 	bl	8002a9c <HAL_RCC_GetSysClockFreq>
 8004aba:	6378      	str	r0, [r7, #52]	@ 0x34
 8004abc:	f000 bc4b 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_I2C2CLKSOURCE_HSI))
 8004ac0:	4b34      	ldr	r3, [pc, #208]	@ (8004b94 <HAL_RCCEx_GetPeriphCLKFreq+0xaa4>)
 8004ac2:	681b      	ldr	r3, [r3, #0]
 8004ac4:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8004ac8:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8004acc:	d107      	bne.n	8004ade <HAL_RCCEx_GetPeriphCLKFreq+0x9ee>
 8004ace:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004ad0:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8004ad4:	d103      	bne.n	8004ade <HAL_RCCEx_GetPeriphCLKFreq+0x9ee>
    {
      frequency = HSI_VALUE;
 8004ad6:	4b31      	ldr	r3, [pc, #196]	@ (8004b9c <HAL_RCCEx_GetPeriphCLKFreq+0xaac>)
 8004ad8:	637b      	str	r3, [r7, #52]	@ 0x34
 8004ada:	f000 bc3c 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY)) && (srcclk == RCC_I2C2CLKSOURCE_MSIK))
 8004ade:	4b2d      	ldr	r3, [pc, #180]	@ (8004b94 <HAL_RCCEx_GetPeriphCLKFreq+0xaa4>)
 8004ae0:	681b      	ldr	r3, [r3, #0]
 8004ae2:	f003 0320 	and.w	r3, r3, #32
 8004ae6:	2b20      	cmp	r3, #32
 8004ae8:	d11c      	bne.n	8004b24 <HAL_RCCEx_GetPeriphCLKFreq+0xa34>
 8004aea:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004aec:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 8004af0:	d118      	bne.n	8004b24 <HAL_RCCEx_GetPeriphCLKFreq+0xa34>
    {
      frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 8004af2:	4b28      	ldr	r3, [pc, #160]	@ (8004b94 <HAL_RCCEx_GetPeriphCLKFreq+0xaa4>)
 8004af4:	689b      	ldr	r3, [r3, #8]
 8004af6:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 8004afa:	2b00      	cmp	r3, #0
 8004afc:	d005      	beq.n	8004b0a <HAL_RCCEx_GetPeriphCLKFreq+0xa1a>
 8004afe:	4b25      	ldr	r3, [pc, #148]	@ (8004b94 <HAL_RCCEx_GetPeriphCLKFreq+0xaa4>)
 8004b00:	689b      	ldr	r3, [r3, #8]
 8004b02:	0e1b      	lsrs	r3, r3, #24
 8004b04:	f003 030f 	and.w	r3, r3, #15
 8004b08:	e006      	b.n	8004b18 <HAL_RCCEx_GetPeriphCLKFreq+0xa28>
 8004b0a:	4b22      	ldr	r3, [pc, #136]	@ (8004b94 <HAL_RCCEx_GetPeriphCLKFreq+0xaa4>)
 8004b0c:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8004b10:	041b      	lsls	r3, r3, #16
 8004b12:	0e1b      	lsrs	r3, r3, #24
 8004b14:	f003 030f 	and.w	r3, r3, #15
 8004b18:	4a1f      	ldr	r2, [pc, #124]	@ (8004b98 <HAL_RCCEx_GetPeriphCLKFreq+0xaa8>)
 8004b1a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8004b1e:	637b      	str	r3, [r7, #52]	@ 0x34
 8004b20:	f000 bc19 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    /* Clock not enabled for I2C2 */
    else
    {
      frequency = 0U;
 8004b24:	2300      	movs	r3, #0
 8004b26:	637b      	str	r3, [r7, #52]	@ 0x34
 8004b28:	f000 bc15 	b.w	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_I2C3)
 8004b2c:	e9d7 2300 	ldrd	r2, r3, [r7]
 8004b30:	f5a2 7180 	sub.w	r1, r2, #256	@ 0x100
 8004b34:	430b      	orrs	r3, r1
 8004b36:	d157      	bne.n	8004be8 <HAL_RCCEx_GetPeriphCLKFreq+0xaf8>
  {
    /* Get the current I2C3 source */
    srcclk = __HAL_RCC_GET_I2C3_SOURCE();
 8004b38:	4b16      	ldr	r3, [pc, #88]	@ (8004b94 <HAL_RCCEx_GetPeriphCLKFreq+0xaa4>)
 8004b3a:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 8004b3e:	f003 03c0 	and.w	r3, r3, #192	@ 0xc0
 8004b42:	633b      	str	r3, [r7, #48]	@ 0x30

    switch (srcclk)
 8004b44:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004b46:	2bc0      	cmp	r3, #192	@ 0xc0
 8004b48:	d02a      	beq.n	8004ba0 <HAL_RCCEx_GetPeriphCLKFreq+0xab0>
 8004b4a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004b4c:	2bc0      	cmp	r3, #192	@ 0xc0
 8004b4e:	d848      	bhi.n	8004be2 <HAL_RCCEx_GetPeriphCLKFreq+0xaf2>
 8004b50:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004b52:	2b80      	cmp	r3, #128	@ 0x80
 8004b54:	d00d      	beq.n	8004b72 <HAL_RCCEx_GetPeriphCLKFreq+0xa82>
 8004b56:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004b58:	2b80      	cmp	r3, #128	@ 0x80
 8004b5a:	d842      	bhi.n	8004be2 <HAL_RCCEx_GetPeriphCLKFreq+0xaf2>
 8004b5c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004b5e:	2b00      	cmp	r3, #0
 8004b60:	d003      	beq.n	8004b6a <HAL_RCCEx_GetPeriphCLKFreq+0xa7a>
 8004b62:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004b64:	2b40      	cmp	r3, #64	@ 0x40
 8004b66:	d011      	beq.n	8004b8c <HAL_RCCEx_GetPeriphCLKFreq+0xa9c>
 8004b68:	e03b      	b.n	8004be2 <HAL_RCCEx_GetPeriphCLKFreq+0xaf2>
    {
      case RCC_I2C3CLKSOURCE_PCLK3:
      {
        frequency = HAL_RCC_GetPCLK3Freq();
 8004b6a:	f7fe f8db 	bl	8002d24 <HAL_RCC_GetPCLK3Freq>
 8004b6e:	6378      	str	r0, [r7, #52]	@ 0x34
        break;
 8004b70:	e3f1      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
      }
      case RCC_I2C3CLKSOURCE_HSI:
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 8004b72:	4b08      	ldr	r3, [pc, #32]	@ (8004b94 <HAL_RCCEx_GetPeriphCLKFreq+0xaa4>)
 8004b74:	681b      	ldr	r3, [r3, #0]
 8004b76:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8004b7a:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8004b7e:	d102      	bne.n	8004b86 <HAL_RCCEx_GetPeriphCLKFreq+0xa96>
        {
          frequency = HSI_VALUE;
 8004b80:	4b06      	ldr	r3, [pc, #24]	@ (8004b9c <HAL_RCCEx_GetPeriphCLKFreq+0xaac>)
 8004b82:	637b      	str	r3, [r7, #52]	@ 0x34
        }
        else
        {
          frequency = 0U;
        }
        break;
 8004b84:	e3e7      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
          frequency = 0U;
 8004b86:	2300      	movs	r3, #0
 8004b88:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8004b8a:	e3e4      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
      }
      case RCC_I2C3CLKSOURCE_SYSCLK:
      {
        frequency = HAL_RCC_GetSysClockFreq();
 8004b8c:	f7fd ff86 	bl	8002a9c <HAL_RCC_GetSysClockFreq>
 8004b90:	6378      	str	r0, [r7, #52]	@ 0x34
        break;
 8004b92:	e3e0      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
 8004b94:	46020c00 	.word	0x46020c00
 8004b98:	080116a4 	.word	0x080116a4
 8004b9c:	00f42400 	.word	0x00f42400
      }
      case RCC_I2C3CLKSOURCE_MSIK:
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 8004ba0:	4ba3      	ldr	r3, [pc, #652]	@ (8004e30 <HAL_RCCEx_GetPeriphCLKFreq+0xd40>)
 8004ba2:	681b      	ldr	r3, [r3, #0]
 8004ba4:	f003 0320 	and.w	r3, r3, #32
 8004ba8:	2b20      	cmp	r3, #32
 8004baa:	d117      	bne.n	8004bdc <HAL_RCCEx_GetPeriphCLKFreq+0xaec>
        {
          frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 8004bac:	4ba0      	ldr	r3, [pc, #640]	@ (8004e30 <HAL_RCCEx_GetPeriphCLKFreq+0xd40>)
 8004bae:	689b      	ldr	r3, [r3, #8]
 8004bb0:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 8004bb4:	2b00      	cmp	r3, #0
 8004bb6:	d005      	beq.n	8004bc4 <HAL_RCCEx_GetPeriphCLKFreq+0xad4>
 8004bb8:	4b9d      	ldr	r3, [pc, #628]	@ (8004e30 <HAL_RCCEx_GetPeriphCLKFreq+0xd40>)
 8004bba:	689b      	ldr	r3, [r3, #8]
 8004bbc:	0e1b      	lsrs	r3, r3, #24
 8004bbe:	f003 030f 	and.w	r3, r3, #15
 8004bc2:	e006      	b.n	8004bd2 <HAL_RCCEx_GetPeriphCLKFreq+0xae2>
 8004bc4:	4b9a      	ldr	r3, [pc, #616]	@ (8004e30 <HAL_RCCEx_GetPeriphCLKFreq+0xd40>)
 8004bc6:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8004bca:	041b      	lsls	r3, r3, #16
 8004bcc:	0e1b      	lsrs	r3, r3, #24
 8004bce:	f003 030f 	and.w	r3, r3, #15
 8004bd2:	4a98      	ldr	r2, [pc, #608]	@ (8004e34 <HAL_RCCEx_GetPeriphCLKFreq+0xd44>)
 8004bd4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8004bd8:	637b      	str	r3, [r7, #52]	@ 0x34
        }
        else
        {
          frequency = 0U;
        }
        break;
 8004bda:	e3bc      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
          frequency = 0U;
 8004bdc:	2300      	movs	r3, #0
 8004bde:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8004be0:	e3b9      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
      }
      default:
      {
        frequency = 0U;
 8004be2:	2300      	movs	r3, #0
 8004be4:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8004be6:	e3b6      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
      }
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_I2C4)
 8004be8:	e9d7 2300 	ldrd	r2, r3, [r7]
 8004bec:	f5a2 0180 	sub.w	r1, r2, #4194304	@ 0x400000
 8004bf0:	430b      	orrs	r3, r1
 8004bf2:	d147      	bne.n	8004c84 <HAL_RCCEx_GetPeriphCLKFreq+0xb94>
  {
    /* Get the current I2C4 source */
    srcclk = __HAL_RCC_GET_I2C4_SOURCE();
 8004bf4:	4b8e      	ldr	r3, [pc, #568]	@ (8004e30 <HAL_RCCEx_GetPeriphCLKFreq+0xd40>)
 8004bf6:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8004bfa:	f403 4340 	and.w	r3, r3, #49152	@ 0xc000
 8004bfe:	633b      	str	r3, [r7, #48]	@ 0x30

    if (srcclk == RCC_I2C4CLKSOURCE_PCLK1)
 8004c00:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004c02:	2b00      	cmp	r3, #0
 8004c04:	d103      	bne.n	8004c0e <HAL_RCCEx_GetPeriphCLKFreq+0xb1e>
    {
      frequency = HAL_RCC_GetPCLK1Freq();
 8004c06:	f7fe f865 	bl	8002cd4 <HAL_RCC_GetPCLK1Freq>
 8004c0a:	6378      	str	r0, [r7, #52]	@ 0x34
 8004c0c:	e3a3      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    else if (srcclk == RCC_I2C4CLKSOURCE_SYSCLK)
 8004c0e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004c10:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 8004c14:	d103      	bne.n	8004c1e <HAL_RCCEx_GetPeriphCLKFreq+0xb2e>
    {
      frequency = HAL_RCC_GetSysClockFreq();
 8004c16:	f7fd ff41 	bl	8002a9c <HAL_RCC_GetSysClockFreq>
 8004c1a:	6378      	str	r0, [r7, #52]	@ 0x34
 8004c1c:	e39b      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_I2C4CLKSOURCE_HSI))
 8004c1e:	4b84      	ldr	r3, [pc, #528]	@ (8004e30 <HAL_RCCEx_GetPeriphCLKFreq+0xd40>)
 8004c20:	681b      	ldr	r3, [r3, #0]
 8004c22:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8004c26:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8004c2a:	d106      	bne.n	8004c3a <HAL_RCCEx_GetPeriphCLKFreq+0xb4a>
 8004c2c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004c2e:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 8004c32:	d102      	bne.n	8004c3a <HAL_RCCEx_GetPeriphCLKFreq+0xb4a>
    {
      frequency = HSI_VALUE;
 8004c34:	4b80      	ldr	r3, [pc, #512]	@ (8004e38 <HAL_RCCEx_GetPeriphCLKFreq+0xd48>)
 8004c36:	637b      	str	r3, [r7, #52]	@ 0x34
 8004c38:	e38d      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY)) && (srcclk == RCC_I2C4CLKSOURCE_MSIK))
 8004c3a:	4b7d      	ldr	r3, [pc, #500]	@ (8004e30 <HAL_RCCEx_GetPeriphCLKFreq+0xd40>)
 8004c3c:	681b      	ldr	r3, [r3, #0]
 8004c3e:	f003 0320 	and.w	r3, r3, #32
 8004c42:	2b20      	cmp	r3, #32
 8004c44:	d11b      	bne.n	8004c7e <HAL_RCCEx_GetPeriphCLKFreq+0xb8e>
 8004c46:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004c48:	f5b3 4f40 	cmp.w	r3, #49152	@ 0xc000
 8004c4c:	d117      	bne.n	8004c7e <HAL_RCCEx_GetPeriphCLKFreq+0xb8e>
    {
      frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 8004c4e:	4b78      	ldr	r3, [pc, #480]	@ (8004e30 <HAL_RCCEx_GetPeriphCLKFreq+0xd40>)
 8004c50:	689b      	ldr	r3, [r3, #8]
 8004c52:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 8004c56:	2b00      	cmp	r3, #0
 8004c58:	d005      	beq.n	8004c66 <HAL_RCCEx_GetPeriphCLKFreq+0xb76>
 8004c5a:	4b75      	ldr	r3, [pc, #468]	@ (8004e30 <HAL_RCCEx_GetPeriphCLKFreq+0xd40>)
 8004c5c:	689b      	ldr	r3, [r3, #8]
 8004c5e:	0e1b      	lsrs	r3, r3, #24
 8004c60:	f003 030f 	and.w	r3, r3, #15
 8004c64:	e006      	b.n	8004c74 <HAL_RCCEx_GetPeriphCLKFreq+0xb84>
 8004c66:	4b72      	ldr	r3, [pc, #456]	@ (8004e30 <HAL_RCCEx_GetPeriphCLKFreq+0xd40>)
 8004c68:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8004c6c:	041b      	lsls	r3, r3, #16
 8004c6e:	0e1b      	lsrs	r3, r3, #24
 8004c70:	f003 030f 	and.w	r3, r3, #15
 8004c74:	4a6f      	ldr	r2, [pc, #444]	@ (8004e34 <HAL_RCCEx_GetPeriphCLKFreq+0xd44>)
 8004c76:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8004c7a:	637b      	str	r3, [r7, #52]	@ 0x34
 8004c7c:	e36b      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    /* Clock not enabled for I2C4 */
    else
    {
      frequency = 0U;
 8004c7e:	2300      	movs	r3, #0
 8004c80:	637b      	str	r3, [r7, #52]	@ 0x34
 8004c82:	e368      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    {
      frequency = 0U;
    }
  }
#endif /* I2C6 */
  else if (PeriphClk == RCC_PERIPHCLK_LPTIM34)
 8004c84:	e9d7 2300 	ldrd	r2, r3, [r7]
 8004c88:	f5a2 6100 	sub.w	r1, r2, #2048	@ 0x800
 8004c8c:	430b      	orrs	r3, r1
 8004c8e:	d164      	bne.n	8004d5a <HAL_RCCEx_GetPeriphCLKFreq+0xc6a>
  {
    /* Get the current LPTIM34 source */
    srcclk = __HAL_RCC_GET_LPTIM34_SOURCE();
 8004c90:	4b67      	ldr	r3, [pc, #412]	@ (8004e30 <HAL_RCCEx_GetPeriphCLKFreq+0xd40>)
 8004c92:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 8004c96:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 8004c9a:	633b      	str	r3, [r7, #48]	@ 0x30

    if (srcclk == RCC_LPTIM34CLKSOURCE_MSIK)
 8004c9c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004c9e:	2b00      	cmp	r3, #0
 8004ca0:	d120      	bne.n	8004ce4 <HAL_RCCEx_GetPeriphCLKFreq+0xbf4>
    {
      if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 8004ca2:	4b63      	ldr	r3, [pc, #396]	@ (8004e30 <HAL_RCCEx_GetPeriphCLKFreq+0xd40>)
 8004ca4:	681b      	ldr	r3, [r3, #0]
 8004ca6:	f003 0320 	and.w	r3, r3, #32
 8004caa:	2b20      	cmp	r3, #32
 8004cac:	d117      	bne.n	8004cde <HAL_RCCEx_GetPeriphCLKFreq+0xbee>
      {
        frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 8004cae:	4b60      	ldr	r3, [pc, #384]	@ (8004e30 <HAL_RCCEx_GetPeriphCLKFreq+0xd40>)
 8004cb0:	689b      	ldr	r3, [r3, #8]
 8004cb2:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 8004cb6:	2b00      	cmp	r3, #0
 8004cb8:	d005      	beq.n	8004cc6 <HAL_RCCEx_GetPeriphCLKFreq+0xbd6>
 8004cba:	4b5d      	ldr	r3, [pc, #372]	@ (8004e30 <HAL_RCCEx_GetPeriphCLKFreq+0xd40>)
 8004cbc:	689b      	ldr	r3, [r3, #8]
 8004cbe:	0e1b      	lsrs	r3, r3, #24
 8004cc0:	f003 030f 	and.w	r3, r3, #15
 8004cc4:	e006      	b.n	8004cd4 <HAL_RCCEx_GetPeriphCLKFreq+0xbe4>
 8004cc6:	4b5a      	ldr	r3, [pc, #360]	@ (8004e30 <HAL_RCCEx_GetPeriphCLKFreq+0xd40>)
 8004cc8:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8004ccc:	041b      	lsls	r3, r3, #16
 8004cce:	0e1b      	lsrs	r3, r3, #24
 8004cd0:	f003 030f 	and.w	r3, r3, #15
 8004cd4:	4a57      	ldr	r2, [pc, #348]	@ (8004e34 <HAL_RCCEx_GetPeriphCLKFreq+0xd44>)
 8004cd6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8004cda:	637b      	str	r3, [r7, #52]	@ 0x34
 8004cdc:	e33b      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
      }
      else
      {
        frequency = 0U;
 8004cde:	2300      	movs	r3, #0
 8004ce0:	637b      	str	r3, [r7, #52]	@ 0x34
 8004ce2:	e338      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
      }
    }
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIRDY)) && (srcclk == RCC_LPTIM34CLKSOURCE_LSI))
 8004ce4:	4b52      	ldr	r3, [pc, #328]	@ (8004e30 <HAL_RCCEx_GetPeriphCLKFreq+0xd40>)
 8004ce6:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8004cea:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8004cee:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 8004cf2:	d112      	bne.n	8004d1a <HAL_RCCEx_GetPeriphCLKFreq+0xc2a>
 8004cf4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004cf6:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8004cfa:	d10e      	bne.n	8004d1a <HAL_RCCEx_GetPeriphCLKFreq+0xc2a>
    {
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 8004cfc:	4b4c      	ldr	r3, [pc, #304]	@ (8004e30 <HAL_RCCEx_GetPeriphCLKFreq+0xd40>)
 8004cfe:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8004d02:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 8004d06:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 8004d0a:	d102      	bne.n	8004d12 <HAL_RCCEx_GetPeriphCLKFreq+0xc22>
      {
        frequency = LSI_VALUE / 128U;
 8004d0c:	23fa      	movs	r3, #250	@ 0xfa
 8004d0e:	637b      	str	r3, [r7, #52]	@ 0x34
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 8004d10:	e321      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
      }
      else
      {
        frequency = LSI_VALUE;
 8004d12:	f44f 43fa 	mov.w	r3, #32000	@ 0x7d00
 8004d16:	637b      	str	r3, [r7, #52]	@ 0x34
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 8004d18:	e31d      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
      }
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_LPTIM34CLKSOURCE_HSI))
 8004d1a:	4b45      	ldr	r3, [pc, #276]	@ (8004e30 <HAL_RCCEx_GetPeriphCLKFreq+0xd40>)
 8004d1c:	681b      	ldr	r3, [r3, #0]
 8004d1e:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8004d22:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8004d26:	d106      	bne.n	8004d36 <HAL_RCCEx_GetPeriphCLKFreq+0xc46>
 8004d28:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004d2a:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8004d2e:	d102      	bne.n	8004d36 <HAL_RCCEx_GetPeriphCLKFreq+0xc46>
    {
      frequency = HSI_VALUE;
 8004d30:	4b41      	ldr	r3, [pc, #260]	@ (8004e38 <HAL_RCCEx_GetPeriphCLKFreq+0xd48>)
 8004d32:	637b      	str	r3, [r7, #52]	@ 0x34
 8004d34:	e30f      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_LPTIM34CLKSOURCE_LSE))
 8004d36:	4b3e      	ldr	r3, [pc, #248]	@ (8004e30 <HAL_RCCEx_GetPeriphCLKFreq+0xd40>)
 8004d38:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8004d3c:	f003 0302 	and.w	r3, r3, #2
 8004d40:	2b02      	cmp	r3, #2
 8004d42:	d107      	bne.n	8004d54 <HAL_RCCEx_GetPeriphCLKFreq+0xc64>
 8004d44:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004d46:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 8004d4a:	d103      	bne.n	8004d54 <HAL_RCCEx_GetPeriphCLKFreq+0xc64>
    {
      frequency = LSE_VALUE;
 8004d4c:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 8004d50:	637b      	str	r3, [r7, #52]	@ 0x34
 8004d52:	e300      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    /* Clock not enabled for LPTIM34 */
    else
    {
      frequency = 0U;
 8004d54:	2300      	movs	r3, #0
 8004d56:	637b      	str	r3, [r7, #52]	@ 0x34
 8004d58:	e2fd      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_LPTIM1)
 8004d5a:	e9d7 2300 	ldrd	r2, r3, [r7]
 8004d5e:	f5a2 7100 	sub.w	r1, r2, #512	@ 0x200
 8004d62:	430b      	orrs	r3, r1
 8004d64:	d16a      	bne.n	8004e3c <HAL_RCCEx_GetPeriphCLKFreq+0xd4c>
  {
    /* Get the current LPTIM1 source */
    srcclk = __HAL_RCC_GET_LPTIM1_SOURCE();
 8004d66:	4b32      	ldr	r3, [pc, #200]	@ (8004e30 <HAL_RCCEx_GetPeriphCLKFreq+0xd40>)
 8004d68:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 8004d6c:	f403 6340 	and.w	r3, r3, #3072	@ 0xc00
 8004d70:	633b      	str	r3, [r7, #48]	@ 0x30

    if (srcclk == RCC_LPTIM1CLKSOURCE_MSIK)
 8004d72:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004d74:	2b00      	cmp	r3, #0
 8004d76:	d120      	bne.n	8004dba <HAL_RCCEx_GetPeriphCLKFreq+0xcca>
    {
      if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 8004d78:	4b2d      	ldr	r3, [pc, #180]	@ (8004e30 <HAL_RCCEx_GetPeriphCLKFreq+0xd40>)
 8004d7a:	681b      	ldr	r3, [r3, #0]
 8004d7c:	f003 0320 	and.w	r3, r3, #32
 8004d80:	2b20      	cmp	r3, #32
 8004d82:	d117      	bne.n	8004db4 <HAL_RCCEx_GetPeriphCLKFreq+0xcc4>
      {
        frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 8004d84:	4b2a      	ldr	r3, [pc, #168]	@ (8004e30 <HAL_RCCEx_GetPeriphCLKFreq+0xd40>)
 8004d86:	689b      	ldr	r3, [r3, #8]
 8004d88:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 8004d8c:	2b00      	cmp	r3, #0
 8004d8e:	d005      	beq.n	8004d9c <HAL_RCCEx_GetPeriphCLKFreq+0xcac>
 8004d90:	4b27      	ldr	r3, [pc, #156]	@ (8004e30 <HAL_RCCEx_GetPeriphCLKFreq+0xd40>)
 8004d92:	689b      	ldr	r3, [r3, #8]
 8004d94:	0e1b      	lsrs	r3, r3, #24
 8004d96:	f003 030f 	and.w	r3, r3, #15
 8004d9a:	e006      	b.n	8004daa <HAL_RCCEx_GetPeriphCLKFreq+0xcba>
 8004d9c:	4b24      	ldr	r3, [pc, #144]	@ (8004e30 <HAL_RCCEx_GetPeriphCLKFreq+0xd40>)
 8004d9e:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8004da2:	041b      	lsls	r3, r3, #16
 8004da4:	0e1b      	lsrs	r3, r3, #24
 8004da6:	f003 030f 	and.w	r3, r3, #15
 8004daa:	4a22      	ldr	r2, [pc, #136]	@ (8004e34 <HAL_RCCEx_GetPeriphCLKFreq+0xd44>)
 8004dac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8004db0:	637b      	str	r3, [r7, #52]	@ 0x34
 8004db2:	e2d0      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
      }
      else
      {
        frequency = 0U;
 8004db4:	2300      	movs	r3, #0
 8004db6:	637b      	str	r3, [r7, #52]	@ 0x34
 8004db8:	e2cd      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
      }
    }
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIRDY)) && (srcclk == RCC_LPTIM1CLKSOURCE_LSI))
 8004dba:	4b1d      	ldr	r3, [pc, #116]	@ (8004e30 <HAL_RCCEx_GetPeriphCLKFreq+0xd40>)
 8004dbc:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8004dc0:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8004dc4:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 8004dc8:	d112      	bne.n	8004df0 <HAL_RCCEx_GetPeriphCLKFreq+0xd00>
 8004dca:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004dcc:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8004dd0:	d10e      	bne.n	8004df0 <HAL_RCCEx_GetPeriphCLKFreq+0xd00>
    {
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 8004dd2:	4b17      	ldr	r3, [pc, #92]	@ (8004e30 <HAL_RCCEx_GetPeriphCLKFreq+0xd40>)
 8004dd4:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8004dd8:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 8004ddc:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 8004de0:	d102      	bne.n	8004de8 <HAL_RCCEx_GetPeriphCLKFreq+0xcf8>
      {
        frequency = LSI_VALUE / 128U;
 8004de2:	23fa      	movs	r3, #250	@ 0xfa
 8004de4:	637b      	str	r3, [r7, #52]	@ 0x34
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 8004de6:	e2b6      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
      }
      else
      {
        frequency = LSI_VALUE;
 8004de8:	f44f 43fa 	mov.w	r3, #32000	@ 0x7d00
 8004dec:	637b      	str	r3, [r7, #52]	@ 0x34
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 8004dee:	e2b2      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
      }
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_LPTIM1CLKSOURCE_HSI))
 8004df0:	4b0f      	ldr	r3, [pc, #60]	@ (8004e30 <HAL_RCCEx_GetPeriphCLKFreq+0xd40>)
 8004df2:	681b      	ldr	r3, [r3, #0]
 8004df4:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8004df8:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8004dfc:	d106      	bne.n	8004e0c <HAL_RCCEx_GetPeriphCLKFreq+0xd1c>
 8004dfe:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004e00:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 8004e04:	d102      	bne.n	8004e0c <HAL_RCCEx_GetPeriphCLKFreq+0xd1c>
    {
      frequency = HSI_VALUE;
 8004e06:	4b0c      	ldr	r3, [pc, #48]	@ (8004e38 <HAL_RCCEx_GetPeriphCLKFreq+0xd48>)
 8004e08:	637b      	str	r3, [r7, #52]	@ 0x34
 8004e0a:	e2a4      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_LPTIM1CLKSOURCE_LSE))
 8004e0c:	4b08      	ldr	r3, [pc, #32]	@ (8004e30 <HAL_RCCEx_GetPeriphCLKFreq+0xd40>)
 8004e0e:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8004e12:	f003 0302 	and.w	r3, r3, #2
 8004e16:	2b02      	cmp	r3, #2
 8004e18:	d107      	bne.n	8004e2a <HAL_RCCEx_GetPeriphCLKFreq+0xd3a>
 8004e1a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004e1c:	f5b3 6f40 	cmp.w	r3, #3072	@ 0xc00
 8004e20:	d103      	bne.n	8004e2a <HAL_RCCEx_GetPeriphCLKFreq+0xd3a>
    {
      frequency = LSE_VALUE;
 8004e22:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 8004e26:	637b      	str	r3, [r7, #52]	@ 0x34
 8004e28:	e295      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    /* Clock not enabled for LPTIM1 */
    else
    {
      frequency = 0U;
 8004e2a:	2300      	movs	r3, #0
 8004e2c:	637b      	str	r3, [r7, #52]	@ 0x34
 8004e2e:	e292      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
 8004e30:	46020c00 	.word	0x46020c00
 8004e34:	080116a4 	.word	0x080116a4
 8004e38:	00f42400 	.word	0x00f42400
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_LPTIM2)
 8004e3c:	e9d7 2300 	ldrd	r2, r3, [r7]
 8004e40:	f5a2 6180 	sub.w	r1, r2, #1024	@ 0x400
 8004e44:	430b      	orrs	r3, r1
 8004e46:	d147      	bne.n	8004ed8 <HAL_RCCEx_GetPeriphCLKFreq+0xde8>
  {
    /* Get the current LPTIM2 source */
    srcclk = __HAL_RCC_GET_LPTIM2_SOURCE();
 8004e48:	4b9a      	ldr	r3, [pc, #616]	@ (80050b4 <HAL_RCCEx_GetPeriphCLKFreq+0xfc4>)
 8004e4a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8004e4e:	f403 2340 	and.w	r3, r3, #786432	@ 0xc0000
 8004e52:	633b      	str	r3, [r7, #48]	@ 0x30

    if (srcclk == RCC_LPTIM2CLKSOURCE_PCLK1)
 8004e54:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004e56:	2b00      	cmp	r3, #0
 8004e58:	d103      	bne.n	8004e62 <HAL_RCCEx_GetPeriphCLKFreq+0xd72>
    {
      frequency = HAL_RCC_GetPCLK1Freq();
 8004e5a:	f7fd ff3b 	bl	8002cd4 <HAL_RCC_GetPCLK1Freq>
 8004e5e:	6378      	str	r0, [r7, #52]	@ 0x34
 8004e60:	e279      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIRDY)) && (srcclk == RCC_LPTIM2CLKSOURCE_LSI))
 8004e62:	4b94      	ldr	r3, [pc, #592]	@ (80050b4 <HAL_RCCEx_GetPeriphCLKFreq+0xfc4>)
 8004e64:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8004e68:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8004e6c:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 8004e70:	d112      	bne.n	8004e98 <HAL_RCCEx_GetPeriphCLKFreq+0xda8>
 8004e72:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004e74:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 8004e78:	d10e      	bne.n	8004e98 <HAL_RCCEx_GetPeriphCLKFreq+0xda8>
    {
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 8004e7a:	4b8e      	ldr	r3, [pc, #568]	@ (80050b4 <HAL_RCCEx_GetPeriphCLKFreq+0xfc4>)
 8004e7c:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8004e80:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 8004e84:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 8004e88:	d102      	bne.n	8004e90 <HAL_RCCEx_GetPeriphCLKFreq+0xda0>
      {
        frequency = LSI_VALUE / 128U;
 8004e8a:	23fa      	movs	r3, #250	@ 0xfa
 8004e8c:	637b      	str	r3, [r7, #52]	@ 0x34
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 8004e8e:	e262      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
      }
      else
      {
        frequency = LSI_VALUE;
 8004e90:	f44f 43fa 	mov.w	r3, #32000	@ 0x7d00
 8004e94:	637b      	str	r3, [r7, #52]	@ 0x34
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 8004e96:	e25e      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
      }
    }
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_LPTIM2CLKSOURCE_HSI))
 8004e98:	4b86      	ldr	r3, [pc, #536]	@ (80050b4 <HAL_RCCEx_GetPeriphCLKFreq+0xfc4>)
 8004e9a:	681b      	ldr	r3, [r3, #0]
 8004e9c:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8004ea0:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8004ea4:	d106      	bne.n	8004eb4 <HAL_RCCEx_GetPeriphCLKFreq+0xdc4>
 8004ea6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004ea8:	f5b3 2f00 	cmp.w	r3, #524288	@ 0x80000
 8004eac:	d102      	bne.n	8004eb4 <HAL_RCCEx_GetPeriphCLKFreq+0xdc4>
    {
      frequency = HSI_VALUE;
 8004eae:	4b82      	ldr	r3, [pc, #520]	@ (80050b8 <HAL_RCCEx_GetPeriphCLKFreq+0xfc8>)
 8004eb0:	637b      	str	r3, [r7, #52]	@ 0x34
 8004eb2:	e250      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_LPTIM2CLKSOURCE_LSE))
 8004eb4:	4b7f      	ldr	r3, [pc, #508]	@ (80050b4 <HAL_RCCEx_GetPeriphCLKFreq+0xfc4>)
 8004eb6:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8004eba:	f003 0302 	and.w	r3, r3, #2
 8004ebe:	2b02      	cmp	r3, #2
 8004ec0:	d107      	bne.n	8004ed2 <HAL_RCCEx_GetPeriphCLKFreq+0xde2>
 8004ec2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004ec4:	f5b3 2f40 	cmp.w	r3, #786432	@ 0xc0000
 8004ec8:	d103      	bne.n	8004ed2 <HAL_RCCEx_GetPeriphCLKFreq+0xde2>
    {
      frequency = LSE_VALUE;
 8004eca:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 8004ece:	637b      	str	r3, [r7, #52]	@ 0x34
 8004ed0:	e241      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    /* Clock not enabled for LPTIM2 */
    else
    {
      frequency = 0U;
 8004ed2:	2300      	movs	r3, #0
 8004ed4:	637b      	str	r3, [r7, #52]	@ 0x34
 8004ed6:	e23e      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_FDCAN1)
 8004ed8:	e9d7 2300 	ldrd	r2, r3, [r7]
 8004edc:	f102 4178 	add.w	r1, r2, #4160749568	@ 0xf8000000
 8004ee0:	430b      	orrs	r3, r1
 8004ee2:	d12d      	bne.n	8004f40 <HAL_RCCEx_GetPeriphCLKFreq+0xe50>
  {
    /* Get the current FDCAN1 kernel source */
    srcclk = __HAL_RCC_GET_FDCAN1_SOURCE();
 8004ee4:	4b73      	ldr	r3, [pc, #460]	@ (80050b4 <HAL_RCCEx_GetPeriphCLKFreq+0xfc4>)
 8004ee6:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8004eea:	f003 7340 	and.w	r3, r3, #50331648	@ 0x3000000
 8004eee:	633b      	str	r3, [r7, #48]	@ 0x30

    if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (srcclk == RCC_FDCAN1CLKSOURCE_HSE))
 8004ef0:	4b70      	ldr	r3, [pc, #448]	@ (80050b4 <HAL_RCCEx_GetPeriphCLKFreq+0xfc4>)
 8004ef2:	681b      	ldr	r3, [r3, #0]
 8004ef4:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8004ef8:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8004efc:	d105      	bne.n	8004f0a <HAL_RCCEx_GetPeriphCLKFreq+0xe1a>
 8004efe:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004f00:	2b00      	cmp	r3, #0
 8004f02:	d102      	bne.n	8004f0a <HAL_RCCEx_GetPeriphCLKFreq+0xe1a>
    {
      frequency = HSE_VALUE;
 8004f04:	4b6c      	ldr	r3, [pc, #432]	@ (80050b8 <HAL_RCCEx_GetPeriphCLKFreq+0xfc8>)
 8004f06:	637b      	str	r3, [r7, #52]	@ 0x34
 8004f08:	e225      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    else if (srcclk == RCC_FDCAN1CLKSOURCE_PLL1) /* PLL1 ? */
 8004f0a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004f0c:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 8004f10:	d107      	bne.n	8004f22 <HAL_RCCEx_GetPeriphCLKFreq+0xe32>
    {
      HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 8004f12:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 8004f16:	4618      	mov	r0, r3
 8004f18:	f7fe fcdc 	bl	80038d4 <HAL_RCCEx_GetPLL1ClockFreq>
      frequency = pll1_clocks.PLL1_Q_Frequency;
 8004f1c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8004f1e:	637b      	str	r3, [r7, #52]	@ 0x34
 8004f20:	e219      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    else if (srcclk == RCC_FDCAN1CLKSOURCE_PLL2) /* PLL2 ? */
 8004f22:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004f24:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 8004f28:	d107      	bne.n	8004f3a <HAL_RCCEx_GetPeriphCLKFreq+0xe4a>
    {
      HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8004f2a:	f107 0318 	add.w	r3, r7, #24
 8004f2e:	4618      	mov	r0, r3
 8004f30:	f7fe fe2a 	bl	8003b88 <HAL_RCCEx_GetPLL2ClockFreq>
      frequency = pll2_clocks.PLL2_P_Frequency;
 8004f34:	69bb      	ldr	r3, [r7, #24]
 8004f36:	637b      	str	r3, [r7, #52]	@ 0x34
 8004f38:	e20d      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    /* Clock not enabled for FDCAN1 */
    else
    {
      frequency = 0U;
 8004f3a:	2300      	movs	r3, #0
 8004f3c:	637b      	str	r3, [r7, #52]	@ 0x34
 8004f3e:	e20a      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_SPI1)
 8004f40:	e9d7 2300 	ldrd	r2, r3, [r7]
 8004f44:	f5a2 0100 	sub.w	r1, r2, #8388608	@ 0x800000
 8004f48:	430b      	orrs	r3, r1
 8004f4a:	d156      	bne.n	8004ffa <HAL_RCCEx_GetPeriphCLKFreq+0xf0a>
  {
    /* Get the current SPI1 kernel source */
    srcclk = __HAL_RCC_GET_SPI1_SOURCE();
 8004f4c:	4b59      	ldr	r3, [pc, #356]	@ (80050b4 <HAL_RCCEx_GetPeriphCLKFreq+0xfc4>)
 8004f4e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8004f52:	f403 1340 	and.w	r3, r3, #3145728	@ 0x300000
 8004f56:	633b      	str	r3, [r7, #48]	@ 0x30
    switch (srcclk)
 8004f58:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004f5a:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
 8004f5e:	d028      	beq.n	8004fb2 <HAL_RCCEx_GetPeriphCLKFreq+0xec2>
 8004f60:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004f62:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
 8004f66:	d845      	bhi.n	8004ff4 <HAL_RCCEx_GetPeriphCLKFreq+0xf04>
 8004f68:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004f6a:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 8004f6e:	d013      	beq.n	8004f98 <HAL_RCCEx_GetPeriphCLKFreq+0xea8>
 8004f70:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004f72:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 8004f76:	d83d      	bhi.n	8004ff4 <HAL_RCCEx_GetPeriphCLKFreq+0xf04>
 8004f78:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004f7a:	2b00      	cmp	r3, #0
 8004f7c:	d004      	beq.n	8004f88 <HAL_RCCEx_GetPeriphCLKFreq+0xe98>
 8004f7e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004f80:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 8004f84:	d004      	beq.n	8004f90 <HAL_RCCEx_GetPeriphCLKFreq+0xea0>
 8004f86:	e035      	b.n	8004ff4 <HAL_RCCEx_GetPeriphCLKFreq+0xf04>
    {
      case RCC_SPI1CLKSOURCE_PCLK2:

        frequency = HAL_RCC_GetPCLK2Freq();
 8004f88:	f7fd feb8 	bl	8002cfc <HAL_RCC_GetPCLK2Freq>
 8004f8c:	6378      	str	r0, [r7, #52]	@ 0x34
        break;
 8004f8e:	e1e2      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>

      case RCC_SPI1CLKSOURCE_SYSCLK:

        frequency = HAL_RCC_GetSysClockFreq();
 8004f90:	f7fd fd84 	bl	8002a9c <HAL_RCC_GetSysClockFreq>
 8004f94:	6378      	str	r0, [r7, #52]	@ 0x34
        break;
 8004f96:	e1de      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>

      case RCC_SPI1CLKSOURCE_HSI:

        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 8004f98:	4b46      	ldr	r3, [pc, #280]	@ (80050b4 <HAL_RCCEx_GetPeriphCLKFreq+0xfc4>)
 8004f9a:	681b      	ldr	r3, [r3, #0]
 8004f9c:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8004fa0:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8004fa4:	d102      	bne.n	8004fac <HAL_RCCEx_GetPeriphCLKFreq+0xebc>
        {
          frequency = HSI_VALUE;
 8004fa6:	4b44      	ldr	r3, [pc, #272]	@ (80050b8 <HAL_RCCEx_GetPeriphCLKFreq+0xfc8>)
 8004fa8:	637b      	str	r3, [r7, #52]	@ 0x34
        }
        else
        {
          frequency = 0U;
        }
        break;
 8004faa:	e1d4      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
          frequency = 0U;
 8004fac:	2300      	movs	r3, #0
 8004fae:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8004fb0:	e1d1      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>

      case RCC_SPI1CLKSOURCE_MSIK:

        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 8004fb2:	4b40      	ldr	r3, [pc, #256]	@ (80050b4 <HAL_RCCEx_GetPeriphCLKFreq+0xfc4>)
 8004fb4:	681b      	ldr	r3, [r3, #0]
 8004fb6:	f003 0320 	and.w	r3, r3, #32
 8004fba:	2b20      	cmp	r3, #32
 8004fbc:	d117      	bne.n	8004fee <HAL_RCCEx_GetPeriphCLKFreq+0xefe>
        {
          frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 8004fbe:	4b3d      	ldr	r3, [pc, #244]	@ (80050b4 <HAL_RCCEx_GetPeriphCLKFreq+0xfc4>)
 8004fc0:	689b      	ldr	r3, [r3, #8]
 8004fc2:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 8004fc6:	2b00      	cmp	r3, #0
 8004fc8:	d005      	beq.n	8004fd6 <HAL_RCCEx_GetPeriphCLKFreq+0xee6>
 8004fca:	4b3a      	ldr	r3, [pc, #232]	@ (80050b4 <HAL_RCCEx_GetPeriphCLKFreq+0xfc4>)
 8004fcc:	689b      	ldr	r3, [r3, #8]
 8004fce:	0e1b      	lsrs	r3, r3, #24
 8004fd0:	f003 030f 	and.w	r3, r3, #15
 8004fd4:	e006      	b.n	8004fe4 <HAL_RCCEx_GetPeriphCLKFreq+0xef4>
 8004fd6:	4b37      	ldr	r3, [pc, #220]	@ (80050b4 <HAL_RCCEx_GetPeriphCLKFreq+0xfc4>)
 8004fd8:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8004fdc:	041b      	lsls	r3, r3, #16
 8004fde:	0e1b      	lsrs	r3, r3, #24
 8004fe0:	f003 030f 	and.w	r3, r3, #15
 8004fe4:	4a35      	ldr	r2, [pc, #212]	@ (80050bc <HAL_RCCEx_GetPeriphCLKFreq+0xfcc>)
 8004fe6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8004fea:	637b      	str	r3, [r7, #52]	@ 0x34
        }
        else
        {
          frequency = 0U;
        }
        break;
 8004fec:	e1b3      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
          frequency = 0U;
 8004fee:	2300      	movs	r3, #0
 8004ff0:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8004ff2:	e1b0      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>

      default:

        frequency = 0U;
 8004ff4:	2300      	movs	r3, #0
 8004ff6:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8004ff8:	e1ad      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_SPI2)
 8004ffa:	e9d7 2300 	ldrd	r2, r3, [r7]
 8004ffe:	f102 417f 	add.w	r1, r2, #4278190080	@ 0xff000000
 8005002:	430b      	orrs	r3, r1
 8005004:	d15c      	bne.n	80050c0 <HAL_RCCEx_GetPeriphCLKFreq+0xfd0>
  {
    /* Get the current SPI2 kernel source */
    srcclk = __HAL_RCC_GET_SPI2_SOURCE();
 8005006:	4b2b      	ldr	r3, [pc, #172]	@ (80050b4 <HAL_RCCEx_GetPeriphCLKFreq+0xfc4>)
 8005008:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 800500c:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
 8005010:	633b      	str	r3, [r7, #48]	@ 0x30
    switch (srcclk)
 8005012:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8005014:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
 8005018:	d028      	beq.n	800506c <HAL_RCCEx_GetPeriphCLKFreq+0xf7c>
 800501a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800501c:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
 8005020:	d845      	bhi.n	80050ae <HAL_RCCEx_GetPeriphCLKFreq+0xfbe>
 8005022:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8005024:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8005028:	d013      	beq.n	8005052 <HAL_RCCEx_GetPeriphCLKFreq+0xf62>
 800502a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800502c:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8005030:	d83d      	bhi.n	80050ae <HAL_RCCEx_GetPeriphCLKFreq+0xfbe>
 8005032:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8005034:	2b00      	cmp	r3, #0
 8005036:	d004      	beq.n	8005042 <HAL_RCCEx_GetPeriphCLKFreq+0xf52>
 8005038:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800503a:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 800503e:	d004      	beq.n	800504a <HAL_RCCEx_GetPeriphCLKFreq+0xf5a>
 8005040:	e035      	b.n	80050ae <HAL_RCCEx_GetPeriphCLKFreq+0xfbe>
    {
      case RCC_SPI2CLKSOURCE_PCLK1:

        frequency = HAL_RCC_GetPCLK1Freq();
 8005042:	f7fd fe47 	bl	8002cd4 <HAL_RCC_GetPCLK1Freq>
 8005046:	6378      	str	r0, [r7, #52]	@ 0x34
        break;
 8005048:	e185      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>

      case RCC_SPI2CLKSOURCE_SYSCLK:

        frequency = HAL_RCC_GetSysClockFreq();
 800504a:	f7fd fd27 	bl	8002a9c <HAL_RCC_GetSysClockFreq>
 800504e:	6378      	str	r0, [r7, #52]	@ 0x34
        break;
 8005050:	e181      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>

      case RCC_SPI2CLKSOURCE_HSI:

        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 8005052:	4b18      	ldr	r3, [pc, #96]	@ (80050b4 <HAL_RCCEx_GetPeriphCLKFreq+0xfc4>)
 8005054:	681b      	ldr	r3, [r3, #0]
 8005056:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 800505a:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 800505e:	d102      	bne.n	8005066 <HAL_RCCEx_GetPeriphCLKFreq+0xf76>
        {
          frequency = HSI_VALUE;
 8005060:	4b15      	ldr	r3, [pc, #84]	@ (80050b8 <HAL_RCCEx_GetPeriphCLKFreq+0xfc8>)
 8005062:	637b      	str	r3, [r7, #52]	@ 0x34
        }
        else
        {
          frequency = 0U;
        }
        break;
 8005064:	e177      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
          frequency = 0U;
 8005066:	2300      	movs	r3, #0
 8005068:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 800506a:	e174      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>

      case RCC_SPI2CLKSOURCE_MSIK:

        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 800506c:	4b11      	ldr	r3, [pc, #68]	@ (80050b4 <HAL_RCCEx_GetPeriphCLKFreq+0xfc4>)
 800506e:	681b      	ldr	r3, [r3, #0]
 8005070:	f003 0320 	and.w	r3, r3, #32
 8005074:	2b20      	cmp	r3, #32
 8005076:	d117      	bne.n	80050a8 <HAL_RCCEx_GetPeriphCLKFreq+0xfb8>
        {
          frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 8005078:	4b0e      	ldr	r3, [pc, #56]	@ (80050b4 <HAL_RCCEx_GetPeriphCLKFreq+0xfc4>)
 800507a:	689b      	ldr	r3, [r3, #8]
 800507c:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 8005080:	2b00      	cmp	r3, #0
 8005082:	d005      	beq.n	8005090 <HAL_RCCEx_GetPeriphCLKFreq+0xfa0>
 8005084:	4b0b      	ldr	r3, [pc, #44]	@ (80050b4 <HAL_RCCEx_GetPeriphCLKFreq+0xfc4>)
 8005086:	689b      	ldr	r3, [r3, #8]
 8005088:	0e1b      	lsrs	r3, r3, #24
 800508a:	f003 030f 	and.w	r3, r3, #15
 800508e:	e006      	b.n	800509e <HAL_RCCEx_GetPeriphCLKFreq+0xfae>
 8005090:	4b08      	ldr	r3, [pc, #32]	@ (80050b4 <HAL_RCCEx_GetPeriphCLKFreq+0xfc4>)
 8005092:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8005096:	041b      	lsls	r3, r3, #16
 8005098:	0e1b      	lsrs	r3, r3, #24
 800509a:	f003 030f 	and.w	r3, r3, #15
 800509e:	4a07      	ldr	r2, [pc, #28]	@ (80050bc <HAL_RCCEx_GetPeriphCLKFreq+0xfcc>)
 80050a0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80050a4:	637b      	str	r3, [r7, #52]	@ 0x34
        }
        else
        {
          frequency = 0U;
        }
        break;
 80050a6:	e156      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
          frequency = 0U;
 80050a8:	2300      	movs	r3, #0
 80050aa:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 80050ac:	e153      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>

      default:

        frequency = 0U;
 80050ae:	2300      	movs	r3, #0
 80050b0:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 80050b2:	e150      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
 80050b4:	46020c00 	.word	0x46020c00
 80050b8:	00f42400 	.word	0x00f42400
 80050bc:	080116a4 	.word	0x080116a4
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_SPI3)
 80050c0:	e9d7 2300 	ldrd	r2, r3, [r7]
 80050c4:	f102 417e 	add.w	r1, r2, #4261412864	@ 0xfe000000
 80050c8:	430b      	orrs	r3, r1
 80050ca:	d176      	bne.n	80051ba <HAL_RCCEx_GetPeriphCLKFreq+0x10ca>
  {
    /* Get the current SPI3 kernel source */
    srcclk = __HAL_RCC_GET_SPI3_SOURCE();
 80050cc:	4ba4      	ldr	r3, [pc, #656]	@ (8005360 <HAL_RCCEx_GetPeriphCLKFreq+0x1270>)
 80050ce:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 80050d2:	f003 0318 	and.w	r3, r3, #24
 80050d6:	633b      	str	r3, [r7, #48]	@ 0x30
    switch (srcclk)
 80050d8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80050da:	2b18      	cmp	r3, #24
 80050dc:	d86a      	bhi.n	80051b4 <HAL_RCCEx_GetPeriphCLKFreq+0x10c4>
 80050de:	a201      	add	r2, pc, #4	@ (adr r2, 80050e4 <HAL_RCCEx_GetPeriphCLKFreq+0xff4>)
 80050e0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80050e4:	08005149 	.word	0x08005149
 80050e8:	080051b5 	.word	0x080051b5
 80050ec:	080051b5 	.word	0x080051b5
 80050f0:	080051b5 	.word	0x080051b5
 80050f4:	080051b5 	.word	0x080051b5
 80050f8:	080051b5 	.word	0x080051b5
 80050fc:	080051b5 	.word	0x080051b5
 8005100:	080051b5 	.word	0x080051b5
 8005104:	08005151 	.word	0x08005151
 8005108:	080051b5 	.word	0x080051b5
 800510c:	080051b5 	.word	0x080051b5
 8005110:	080051b5 	.word	0x080051b5
 8005114:	080051b5 	.word	0x080051b5
 8005118:	080051b5 	.word	0x080051b5
 800511c:	080051b5 	.word	0x080051b5
 8005120:	080051b5 	.word	0x080051b5
 8005124:	08005159 	.word	0x08005159
 8005128:	080051b5 	.word	0x080051b5
 800512c:	080051b5 	.word	0x080051b5
 8005130:	080051b5 	.word	0x080051b5
 8005134:	080051b5 	.word	0x080051b5
 8005138:	080051b5 	.word	0x080051b5
 800513c:	080051b5 	.word	0x080051b5
 8005140:	080051b5 	.word	0x080051b5
 8005144:	08005173 	.word	0x08005173
    {
      case RCC_SPI3CLKSOURCE_PCLK3:

        frequency = HAL_RCC_GetPCLK3Freq();
 8005148:	f7fd fdec 	bl	8002d24 <HAL_RCC_GetPCLK3Freq>
 800514c:	6378      	str	r0, [r7, #52]	@ 0x34
        break;
 800514e:	e102      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>

      case RCC_SPI3CLKSOURCE_SYSCLK:

        frequency = HAL_RCC_GetSysClockFreq();
 8005150:	f7fd fca4 	bl	8002a9c <HAL_RCC_GetSysClockFreq>
 8005154:	6378      	str	r0, [r7, #52]	@ 0x34
        break;
 8005156:	e0fe      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>

      case RCC_SPI3CLKSOURCE_HSI:

        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 8005158:	4b81      	ldr	r3, [pc, #516]	@ (8005360 <HAL_RCCEx_GetPeriphCLKFreq+0x1270>)
 800515a:	681b      	ldr	r3, [r3, #0]
 800515c:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8005160:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8005164:	d102      	bne.n	800516c <HAL_RCCEx_GetPeriphCLKFreq+0x107c>
        {
          frequency = HSI_VALUE;
 8005166:	4b7f      	ldr	r3, [pc, #508]	@ (8005364 <HAL_RCCEx_GetPeriphCLKFreq+0x1274>)
 8005168:	637b      	str	r3, [r7, #52]	@ 0x34
        }
        else
        {
          frequency = 0U;
        }
        break;
 800516a:	e0f4      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
          frequency = 0U;
 800516c:	2300      	movs	r3, #0
 800516e:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8005170:	e0f1      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>

      case RCC_SPI3CLKSOURCE_MSIK:

        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 8005172:	4b7b      	ldr	r3, [pc, #492]	@ (8005360 <HAL_RCCEx_GetPeriphCLKFreq+0x1270>)
 8005174:	681b      	ldr	r3, [r3, #0]
 8005176:	f003 0320 	and.w	r3, r3, #32
 800517a:	2b20      	cmp	r3, #32
 800517c:	d117      	bne.n	80051ae <HAL_RCCEx_GetPeriphCLKFreq+0x10be>
        {
          frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 800517e:	4b78      	ldr	r3, [pc, #480]	@ (8005360 <HAL_RCCEx_GetPeriphCLKFreq+0x1270>)
 8005180:	689b      	ldr	r3, [r3, #8]
 8005182:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 8005186:	2b00      	cmp	r3, #0
 8005188:	d005      	beq.n	8005196 <HAL_RCCEx_GetPeriphCLKFreq+0x10a6>
 800518a:	4b75      	ldr	r3, [pc, #468]	@ (8005360 <HAL_RCCEx_GetPeriphCLKFreq+0x1270>)
 800518c:	689b      	ldr	r3, [r3, #8]
 800518e:	0e1b      	lsrs	r3, r3, #24
 8005190:	f003 030f 	and.w	r3, r3, #15
 8005194:	e006      	b.n	80051a4 <HAL_RCCEx_GetPeriphCLKFreq+0x10b4>
 8005196:	4b72      	ldr	r3, [pc, #456]	@ (8005360 <HAL_RCCEx_GetPeriphCLKFreq+0x1270>)
 8005198:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 800519c:	041b      	lsls	r3, r3, #16
 800519e:	0e1b      	lsrs	r3, r3, #24
 80051a0:	f003 030f 	and.w	r3, r3, #15
 80051a4:	4a70      	ldr	r2, [pc, #448]	@ (8005368 <HAL_RCCEx_GetPeriphCLKFreq+0x1278>)
 80051a6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80051aa:	637b      	str	r3, [r7, #52]	@ 0x34
        }
        else
        {
          frequency = 0U;
        }
        break;
 80051ac:	e0d3      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
          frequency = 0U;
 80051ae:	2300      	movs	r3, #0
 80051b0:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 80051b2:	e0d0      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>

      default:

        frequency = 0U;
 80051b4:	2300      	movs	r3, #0
 80051b6:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 80051b8:	e0cd      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_OSPI)
 80051ba:	e9d7 2300 	ldrd	r2, r3, [r7]
 80051be:	f102 417c 	add.w	r1, r2, #4227858432	@ 0xfc000000
 80051c2:	430b      	orrs	r3, r1
 80051c4:	d155      	bne.n	8005272 <HAL_RCCEx_GetPeriphCLKFreq+0x1182>
  {
    /* Get the current OSPI kernel source */
    srcclk = __HAL_RCC_GET_OSPI_SOURCE();
 80051c6:	4b66      	ldr	r3, [pc, #408]	@ (8005360 <HAL_RCCEx_GetPeriphCLKFreq+0x1270>)
 80051c8:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 80051cc:	f403 1340 	and.w	r3, r3, #3145728	@ 0x300000
 80051d0:	633b      	str	r3, [r7, #48]	@ 0x30

    switch (srcclk)
 80051d2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80051d4:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
 80051d8:	d013      	beq.n	8005202 <HAL_RCCEx_GetPeriphCLKFreq+0x1112>
 80051da:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80051dc:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
 80051e0:	d844      	bhi.n	800526c <HAL_RCCEx_GetPeriphCLKFreq+0x117c>
 80051e2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80051e4:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 80051e8:	d013      	beq.n	8005212 <HAL_RCCEx_GetPeriphCLKFreq+0x1122>
 80051ea:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80051ec:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 80051f0:	d83c      	bhi.n	800526c <HAL_RCCEx_GetPeriphCLKFreq+0x117c>
 80051f2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80051f4:	2b00      	cmp	r3, #0
 80051f6:	d014      	beq.n	8005222 <HAL_RCCEx_GetPeriphCLKFreq+0x1132>
 80051f8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80051fa:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 80051fe:	d014      	beq.n	800522a <HAL_RCCEx_GetPeriphCLKFreq+0x113a>
 8005200:	e034      	b.n	800526c <HAL_RCCEx_GetPeriphCLKFreq+0x117c>
    {
      case RCC_OSPICLKSOURCE_PLL2:

        HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8005202:	f107 0318 	add.w	r3, r7, #24
 8005206:	4618      	mov	r0, r3
 8005208:	f7fe fcbe 	bl	8003b88 <HAL_RCCEx_GetPLL2ClockFreq>
        frequency = pll2_clocks.PLL2_Q_Frequency;
 800520c:	69fb      	ldr	r3, [r7, #28]
 800520e:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8005210:	e0a1      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>

      case RCC_OSPICLKSOURCE_PLL1:

        HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 8005212:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 8005216:	4618      	mov	r0, r3
 8005218:	f7fe fb5c 	bl	80038d4 <HAL_RCCEx_GetPLL1ClockFreq>
        frequency = pll1_clocks.PLL1_Q_Frequency;
 800521c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800521e:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8005220:	e099      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>

      case RCC_OSPICLKSOURCE_SYSCLK:

        frequency = HAL_RCC_GetSysClockFreq();
 8005222:	f7fd fc3b 	bl	8002a9c <HAL_RCC_GetSysClockFreq>
 8005226:	6378      	str	r0, [r7, #52]	@ 0x34
        break;
 8005228:	e095      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>

      case RCC_OSPICLKSOURCE_MSIK:

        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 800522a:	4b4d      	ldr	r3, [pc, #308]	@ (8005360 <HAL_RCCEx_GetPeriphCLKFreq+0x1270>)
 800522c:	681b      	ldr	r3, [r3, #0]
 800522e:	f003 0320 	and.w	r3, r3, #32
 8005232:	2b20      	cmp	r3, #32
 8005234:	d117      	bne.n	8005266 <HAL_RCCEx_GetPeriphCLKFreq+0x1176>
        {
          frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 8005236:	4b4a      	ldr	r3, [pc, #296]	@ (8005360 <HAL_RCCEx_GetPeriphCLKFreq+0x1270>)
 8005238:	689b      	ldr	r3, [r3, #8]
 800523a:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 800523e:	2b00      	cmp	r3, #0
 8005240:	d005      	beq.n	800524e <HAL_RCCEx_GetPeriphCLKFreq+0x115e>
 8005242:	4b47      	ldr	r3, [pc, #284]	@ (8005360 <HAL_RCCEx_GetPeriphCLKFreq+0x1270>)
 8005244:	689b      	ldr	r3, [r3, #8]
 8005246:	0e1b      	lsrs	r3, r3, #24
 8005248:	f003 030f 	and.w	r3, r3, #15
 800524c:	e006      	b.n	800525c <HAL_RCCEx_GetPeriphCLKFreq+0x116c>
 800524e:	4b44      	ldr	r3, [pc, #272]	@ (8005360 <HAL_RCCEx_GetPeriphCLKFreq+0x1270>)
 8005250:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8005254:	041b      	lsls	r3, r3, #16
 8005256:	0e1b      	lsrs	r3, r3, #24
 8005258:	f003 030f 	and.w	r3, r3, #15
 800525c:	4a42      	ldr	r2, [pc, #264]	@ (8005368 <HAL_RCCEx_GetPeriphCLKFreq+0x1278>)
 800525e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8005262:	637b      	str	r3, [r7, #52]	@ 0x34
        }
        else
        {
          frequency = 0U;
        }
        break;
 8005264:	e077      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
          frequency = 0U;
 8005266:	2300      	movs	r3, #0
 8005268:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 800526a:	e074      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>

      default:

        frequency = 0U;
 800526c:	2300      	movs	r3, #0
 800526e:	637b      	str	r3, [r7, #52]	@ 0x34
        break;
 8005270:	e071      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
        frequency = 0U;
        break;
    }
  }
#endif /* defined(HSPI1) */
  else if (PeriphClk == RCC_PERIPHCLK_DAC1)
 8005272:	e9d7 2300 	ldrd	r2, r3, [r7]
 8005276:	f102 4170 	add.w	r1, r2, #4026531840	@ 0xf0000000
 800527a:	430b      	orrs	r3, r1
 800527c:	d131      	bne.n	80052e2 <HAL_RCCEx_GetPeriphCLKFreq+0x11f2>
  {
    /* Get the current DAC1 kernel source */
    srcclk = __HAL_RCC_GET_DAC1_SOURCE();
 800527e:	4b38      	ldr	r3, [pc, #224]	@ (8005360 <HAL_RCCEx_GetPeriphCLKFreq+0x1270>)
 8005280:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 8005284:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 8005288:	633b      	str	r3, [r7, #48]	@ 0x30

    /* Check if LSE is ready and if DAC1 clock selection is LSE */
    if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_DAC1CLKSOURCE_LSE))
 800528a:	4b35      	ldr	r3, [pc, #212]	@ (8005360 <HAL_RCCEx_GetPeriphCLKFreq+0x1270>)
 800528c:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 8005290:	f003 0302 	and.w	r3, r3, #2
 8005294:	2b02      	cmp	r3, #2
 8005296:	d106      	bne.n	80052a6 <HAL_RCCEx_GetPeriphCLKFreq+0x11b6>
 8005298:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800529a:	2b00      	cmp	r3, #0
 800529c:	d103      	bne.n	80052a6 <HAL_RCCEx_GetPeriphCLKFreq+0x11b6>
    {
      frequency = LSE_VALUE;
 800529e:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 80052a2:	637b      	str	r3, [r7, #52]	@ 0x34
 80052a4:	e057      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    /* Check if LSI is ready and if DAC1 clock selection is LSI */
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIRDY)) && (srcclk == RCC_DAC1CLKSOURCE_LSI))
 80052a6:	4b2e      	ldr	r3, [pc, #184]	@ (8005360 <HAL_RCCEx_GetPeriphCLKFreq+0x1270>)
 80052a8:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 80052ac:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 80052b0:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 80052b4:	d112      	bne.n	80052dc <HAL_RCCEx_GetPeriphCLKFreq+0x11ec>
 80052b6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80052b8:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 80052bc:	d10e      	bne.n	80052dc <HAL_RCCEx_GetPeriphCLKFreq+0x11ec>
    {
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 80052be:	4b28      	ldr	r3, [pc, #160]	@ (8005360 <HAL_RCCEx_GetPeriphCLKFreq+0x1270>)
 80052c0:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
 80052c4:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 80052c8:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 80052cc:	d102      	bne.n	80052d4 <HAL_RCCEx_GetPeriphCLKFreq+0x11e4>
      {
        frequency = LSI_VALUE / 128U;
 80052ce:	23fa      	movs	r3, #250	@ 0xfa
 80052d0:	637b      	str	r3, [r7, #52]	@ 0x34
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 80052d2:	e040      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
      }
      else
      {
        frequency = LSI_VALUE;
 80052d4:	f44f 43fa 	mov.w	r3, #32000	@ 0x7d00
 80052d8:	637b      	str	r3, [r7, #52]	@ 0x34
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 80052da:	e03c      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
      }
    }
    /* Clock not enabled for DAC1*/
    else
    {
      frequency = 0U;
 80052dc:	2300      	movs	r3, #0
 80052de:	637b      	str	r3, [r7, #52]	@ 0x34
 80052e0:	e039      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }

  }
  else if (PeriphClk == RCC_PERIPHCLK_RNG)
 80052e2:	e9d7 2300 	ldrd	r2, r3, [r7]
 80052e6:	f5a2 2100 	sub.w	r1, r2, #524288	@ 0x80000
 80052ea:	430b      	orrs	r3, r1
 80052ec:	d131      	bne.n	8005352 <HAL_RCCEx_GetPeriphCLKFreq+0x1262>
  {
    /* Get the current RNG kernel source */
    srcclk = __HAL_RCC_GET_RNG_SOURCE();
 80052ee:	4b1c      	ldr	r3, [pc, #112]	@ (8005360 <HAL_RCCEx_GetPeriphCLKFreq+0x1270>)
 80052f0:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 80052f4:	f403 5340 	and.w	r3, r3, #12288	@ 0x3000
 80052f8:	633b      	str	r3, [r7, #48]	@ 0x30

    /* Check if HSI48 is ready and if RNG clock selection is HSI48 */
    if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSI48RDY)) && (srcclk == RCC_RNGCLKSOURCE_HSI48))
 80052fa:	4b19      	ldr	r3, [pc, #100]	@ (8005360 <HAL_RCCEx_GetPeriphCLKFreq+0x1270>)
 80052fc:	681b      	ldr	r3, [r3, #0]
 80052fe:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 8005302:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8005306:	d105      	bne.n	8005314 <HAL_RCCEx_GetPeriphCLKFreq+0x1224>
 8005308:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800530a:	2b00      	cmp	r3, #0
 800530c:	d102      	bne.n	8005314 <HAL_RCCEx_GetPeriphCLKFreq+0x1224>
    {
      frequency = HSI48_VALUE;
 800530e:	4b17      	ldr	r3, [pc, #92]	@ (800536c <HAL_RCCEx_GetPeriphCLKFreq+0x127c>)
 8005310:	637b      	str	r3, [r7, #52]	@ 0x34
 8005312:	e020      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }

    /* Check if HSI48 is ready and if RNG clock selection is HSI48_DIV2 */
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSI48RDY)) && (srcclk == RCC_RNGCLKSOURCE_HSI48_DIV2))
 8005314:	4b12      	ldr	r3, [pc, #72]	@ (8005360 <HAL_RCCEx_GetPeriphCLKFreq+0x1270>)
 8005316:	681b      	ldr	r3, [r3, #0]
 8005318:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 800531c:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8005320:	d106      	bne.n	8005330 <HAL_RCCEx_GetPeriphCLKFreq+0x1240>
 8005322:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8005324:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8005328:	d102      	bne.n	8005330 <HAL_RCCEx_GetPeriphCLKFreq+0x1240>
    {
      frequency = HSI48_VALUE >> 1U ;
 800532a:	4b11      	ldr	r3, [pc, #68]	@ (8005370 <HAL_RCCEx_GetPeriphCLKFreq+0x1280>)
 800532c:	637b      	str	r3, [r7, #52]	@ 0x34
 800532e:	e012      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }

    /* Check if HSI is ready and if RNG clock selection is HSI */
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_RNGCLKSOURCE_HSI))
 8005330:	4b0b      	ldr	r3, [pc, #44]	@ (8005360 <HAL_RCCEx_GetPeriphCLKFreq+0x1270>)
 8005332:	681b      	ldr	r3, [r3, #0]
 8005334:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8005338:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 800533c:	d106      	bne.n	800534c <HAL_RCCEx_GetPeriphCLKFreq+0x125c>
 800533e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8005340:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8005344:	d102      	bne.n	800534c <HAL_RCCEx_GetPeriphCLKFreq+0x125c>
    {
      frequency = HSI_VALUE;
 8005346:	4b07      	ldr	r3, [pc, #28]	@ (8005364 <HAL_RCCEx_GetPeriphCLKFreq+0x1274>)
 8005348:	637b      	str	r3, [r7, #52]	@ 0x34
 800534a:	e004      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
    }
    /* Clock not enabled for RNG */
    else
    {
      frequency = 0U;
 800534c:	2300      	movs	r3, #0
 800534e:	637b      	str	r3, [r7, #52]	@ 0x34
 8005350:	e001      	b.n	8005356 <HAL_RCCEx_GetPeriphCLKFreq+0x1266>
  }
#endif /* defined(USB_OTG_HS) */

  else
  {
    frequency = 0;
 8005352:	2300      	movs	r3, #0
 8005354:	637b      	str	r3, [r7, #52]	@ 0x34
  }
  return (frequency);
 8005356:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
}
 8005358:	4618      	mov	r0, r3
 800535a:	3738      	adds	r7, #56	@ 0x38
 800535c:	46bd      	mov	sp, r7
 800535e:	bd80      	pop	{r7, pc}
 8005360:	46020c00 	.word	0x46020c00
 8005364:	00f42400 	.word	0x00f42400
 8005368:	080116a4 	.word	0x080116a4
 800536c:	02dc6c00 	.word	0x02dc6c00
 8005370:	016e3600 	.word	0x016e3600

08005374 <RCCEx_PLL2_Config>:
  * @note   PLL2 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL2_Config(const RCC_PLL2InitTypeDef *pll2)
{
 8005374:	b580      	push	{r7, lr}
 8005376:	b084      	sub	sp, #16
 8005378:	af00      	add	r7, sp, #0
 800537a:	6078      	str	r0, [r7, #4]
  assert_param(IS_RCC_PLLP_VALUE(pll2->PLL2P));
  assert_param(IS_RCC_PLLQ_VALUE(pll2->PLL2Q));
  assert_param(IS_RCC_PLLR_VALUE(pll2->PLL2R));

  /* Disable  PLL2 */
  __HAL_RCC_PLL2_DISABLE();
 800537c:	4b47      	ldr	r3, [pc, #284]	@ (800549c <RCCEx_PLL2_Config+0x128>)
 800537e:	681b      	ldr	r3, [r3, #0]
 8005380:	4a46      	ldr	r2, [pc, #280]	@ (800549c <RCCEx_PLL2_Config+0x128>)
 8005382:	f023 6380 	bic.w	r3, r3, #67108864	@ 0x4000000
 8005386:	6013      	str	r3, [r2, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 8005388:	f7fb fdf8 	bl	8000f7c <HAL_GetTick>
 800538c:	60f8      	str	r0, [r7, #12]

  /* Wait till PLL is ready */
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
 800538e:	e008      	b.n	80053a2 <RCCEx_PLL2_Config+0x2e>
  {
    if ((HAL_GetTick() - tickstart) > PLL2_TIMEOUT_VALUE)
 8005390:	f7fb fdf4 	bl	8000f7c <HAL_GetTick>
 8005394:	4602      	mov	r2, r0
 8005396:	68fb      	ldr	r3, [r7, #12]
 8005398:	1ad3      	subs	r3, r2, r3
 800539a:	2b02      	cmp	r3, #2
 800539c:	d901      	bls.n	80053a2 <RCCEx_PLL2_Config+0x2e>
    {
      return HAL_TIMEOUT;
 800539e:	2303      	movs	r3, #3
 80053a0:	e077      	b.n	8005492 <RCCEx_PLL2_Config+0x11e>
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
 80053a2:	4b3e      	ldr	r3, [pc, #248]	@ (800549c <RCCEx_PLL2_Config+0x128>)
 80053a4:	681b      	ldr	r3, [r3, #0]
 80053a6:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 80053aa:	2b00      	cmp	r3, #0
 80053ac:	d1f0      	bne.n	8005390 <RCCEx_PLL2_Config+0x1c>
    }
  }

  /* Configure PLL2 multiplication and division factors */
  __HAL_RCC_PLL2_CONFIG(pll2->PLL2Source,
 80053ae:	4b3b      	ldr	r3, [pc, #236]	@ (800549c <RCCEx_PLL2_Config+0x128>)
 80053b0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80053b2:	f423 6370 	bic.w	r3, r3, #3840	@ 0xf00
 80053b6:	f023 0303 	bic.w	r3, r3, #3
 80053ba:	687a      	ldr	r2, [r7, #4]
 80053bc:	6811      	ldr	r1, [r2, #0]
 80053be:	687a      	ldr	r2, [r7, #4]
 80053c0:	6852      	ldr	r2, [r2, #4]
 80053c2:	3a01      	subs	r2, #1
 80053c4:	0212      	lsls	r2, r2, #8
 80053c6:	430a      	orrs	r2, r1
 80053c8:	4934      	ldr	r1, [pc, #208]	@ (800549c <RCCEx_PLL2_Config+0x128>)
 80053ca:	4313      	orrs	r3, r2
 80053cc:	62cb      	str	r3, [r1, #44]	@ 0x2c
 80053ce:	4b33      	ldr	r3, [pc, #204]	@ (800549c <RCCEx_PLL2_Config+0x128>)
 80053d0:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 80053d2:	4b33      	ldr	r3, [pc, #204]	@ (80054a0 <RCCEx_PLL2_Config+0x12c>)
 80053d4:	4013      	ands	r3, r2
 80053d6:	687a      	ldr	r2, [r7, #4]
 80053d8:	6892      	ldr	r2, [r2, #8]
 80053da:	3a01      	subs	r2, #1
 80053dc:	f3c2 0108 	ubfx	r1, r2, #0, #9
 80053e0:	687a      	ldr	r2, [r7, #4]
 80053e2:	68d2      	ldr	r2, [r2, #12]
 80053e4:	3a01      	subs	r2, #1
 80053e6:	0252      	lsls	r2, r2, #9
 80053e8:	b292      	uxth	r2, r2
 80053ea:	4311      	orrs	r1, r2
 80053ec:	687a      	ldr	r2, [r7, #4]
 80053ee:	6912      	ldr	r2, [r2, #16]
 80053f0:	3a01      	subs	r2, #1
 80053f2:	0412      	lsls	r2, r2, #16
 80053f4:	f402 02fe 	and.w	r2, r2, #8323072	@ 0x7f0000
 80053f8:	4311      	orrs	r1, r2
 80053fa:	687a      	ldr	r2, [r7, #4]
 80053fc:	6952      	ldr	r2, [r2, #20]
 80053fe:	3a01      	subs	r2, #1
 8005400:	0612      	lsls	r2, r2, #24
 8005402:	f002 42fe 	and.w	r2, r2, #2130706432	@ 0x7f000000
 8005406:	430a      	orrs	r2, r1
 8005408:	4924      	ldr	r1, [pc, #144]	@ (800549c <RCCEx_PLL2_Config+0x128>)
 800540a:	4313      	orrs	r3, r2
 800540c:	63cb      	str	r3, [r1, #60]	@ 0x3c
                        pll2->PLL2P,
                        pll2->PLL2Q,
                        pll2->PLL2R);

  /* Select PLL2 input reference frequency range: VCI */
  __HAL_RCC_PLL2_VCIRANGE(pll2->PLL2RGE);
 800540e:	4b23      	ldr	r3, [pc, #140]	@ (800549c <RCCEx_PLL2_Config+0x128>)
 8005410:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8005412:	f023 020c 	bic.w	r2, r3, #12
 8005416:	687b      	ldr	r3, [r7, #4]
 8005418:	699b      	ldr	r3, [r3, #24]
 800541a:	4920      	ldr	r1, [pc, #128]	@ (800549c <RCCEx_PLL2_Config+0x128>)
 800541c:	4313      	orrs	r3, r2
 800541e:	62cb      	str	r3, [r1, #44]	@ 0x2c

  /* Configure the PLL2 Clock output(s) */
  __HAL_RCC_PLL2CLKOUT_ENABLE(pll2->PLL2ClockOut);
 8005420:	4b1e      	ldr	r3, [pc, #120]	@ (800549c <RCCEx_PLL2_Config+0x128>)
 8005422:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8005424:	687b      	ldr	r3, [r7, #4]
 8005426:	6a1b      	ldr	r3, [r3, #32]
 8005428:	491c      	ldr	r1, [pc, #112]	@ (800549c <RCCEx_PLL2_Config+0x128>)
 800542a:	4313      	orrs	r3, r2
 800542c:	62cb      	str	r3, [r1, #44]	@ 0x2c

  /* Disable PLL2FRACN  */
  __HAL_RCC_PLL2FRACN_DISABLE();
 800542e:	4b1b      	ldr	r3, [pc, #108]	@ (800549c <RCCEx_PLL2_Config+0x128>)
 8005430:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8005432:	4a1a      	ldr	r2, [pc, #104]	@ (800549c <RCCEx_PLL2_Config+0x128>)
 8005434:	f023 0310 	bic.w	r3, r3, #16
 8005438:	62d3      	str	r3, [r2, #44]	@ 0x2c

  /* Configures PLL2 clock Fractional Part Of The Multiplication Factor */
  __HAL_RCC_PLL2FRACN_CONFIG(pll2->PLL2FRACN);
 800543a:	4b18      	ldr	r3, [pc, #96]	@ (800549c <RCCEx_PLL2_Config+0x128>)
 800543c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800543e:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
 8005442:	f023 03f8 	bic.w	r3, r3, #248	@ 0xf8
 8005446:	687a      	ldr	r2, [r7, #4]
 8005448:	69d2      	ldr	r2, [r2, #28]
 800544a:	00d2      	lsls	r2, r2, #3
 800544c:	4913      	ldr	r1, [pc, #76]	@ (800549c <RCCEx_PLL2_Config+0x128>)
 800544e:	4313      	orrs	r3, r2
 8005450:	640b      	str	r3, [r1, #64]	@ 0x40

  /* Enable PLL2FRACN  */
  __HAL_RCC_PLL2FRACN_ENABLE();
 8005452:	4b12      	ldr	r3, [pc, #72]	@ (800549c <RCCEx_PLL2_Config+0x128>)
 8005454:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8005456:	4a11      	ldr	r2, [pc, #68]	@ (800549c <RCCEx_PLL2_Config+0x128>)
 8005458:	f043 0310 	orr.w	r3, r3, #16
 800545c:	62d3      	str	r3, [r2, #44]	@ 0x2c

  /* Enable  PLL2 */
  __HAL_RCC_PLL2_ENABLE();
 800545e:	4b0f      	ldr	r3, [pc, #60]	@ (800549c <RCCEx_PLL2_Config+0x128>)
 8005460:	681b      	ldr	r3, [r3, #0]
 8005462:	4a0e      	ldr	r2, [pc, #56]	@ (800549c <RCCEx_PLL2_Config+0x128>)
 8005464:	f043 6380 	orr.w	r3, r3, #67108864	@ 0x4000000
 8005468:	6013      	str	r3, [r2, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 800546a:	f7fb fd87 	bl	8000f7c <HAL_GetTick>
 800546e:	60f8      	str	r0, [r7, #12]

  /* Wait till PLL2 is ready */
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
 8005470:	e008      	b.n	8005484 <RCCEx_PLL2_Config+0x110>
  {
    if ((HAL_GetTick() - tickstart) > PLL2_TIMEOUT_VALUE)
 8005472:	f7fb fd83 	bl	8000f7c <HAL_GetTick>
 8005476:	4602      	mov	r2, r0
 8005478:	68fb      	ldr	r3, [r7, #12]
 800547a:	1ad3      	subs	r3, r2, r3
 800547c:	2b02      	cmp	r3, #2
 800547e:	d901      	bls.n	8005484 <RCCEx_PLL2_Config+0x110>
    {
      return HAL_TIMEOUT;
 8005480:	2303      	movs	r3, #3
 8005482:	e006      	b.n	8005492 <RCCEx_PLL2_Config+0x11e>
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
 8005484:	4b05      	ldr	r3, [pc, #20]	@ (800549c <RCCEx_PLL2_Config+0x128>)
 8005486:	681b      	ldr	r3, [r3, #0]
 8005488:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 800548c:	2b00      	cmp	r3, #0
 800548e:	d0f0      	beq.n	8005472 <RCCEx_PLL2_Config+0xfe>
    }
  }
  return HAL_OK;
 8005490:	2300      	movs	r3, #0

}
 8005492:	4618      	mov	r0, r3
 8005494:	3710      	adds	r7, #16
 8005496:	46bd      	mov	sp, r7
 8005498:	bd80      	pop	{r7, pc}
 800549a:	bf00      	nop
 800549c:	46020c00 	.word	0x46020c00
 80054a0:	80800000 	.word	0x80800000

080054a4 <RCCEx_PLL3_Config>:
  *         contains the configuration parameters as well as VCI clock ranges.
  * @note   PLL3 is temporary disabled to apply new parameters
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL3_Config(const RCC_PLL3InitTypeDef *pll3)
{
 80054a4:	b580      	push	{r7, lr}
 80054a6:	b084      	sub	sp, #16
 80054a8:	af00      	add	r7, sp, #0
 80054aa:	6078      	str	r0, [r7, #4]
  assert_param(IS_RCC_PLLP_VALUE(pll3->PLL3P));
  assert_param(IS_RCC_PLLQ_VALUE(pll3->PLL3Q));
  assert_param(IS_RCC_PLLR_VALUE(pll3->PLL3R));

  /* Disable  PLL3 */
  __HAL_RCC_PLL3_DISABLE();
 80054ac:	4b47      	ldr	r3, [pc, #284]	@ (80055cc <RCCEx_PLL3_Config+0x128>)
 80054ae:	681b      	ldr	r3, [r3, #0]
 80054b0:	4a46      	ldr	r2, [pc, #280]	@ (80055cc <RCCEx_PLL3_Config+0x128>)
 80054b2:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
 80054b6:	6013      	str	r3, [r2, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 80054b8:	f7fb fd60 	bl	8000f7c <HAL_GetTick>
 80054bc:	60f8      	str	r0, [r7, #12]

  /* Wait till PLL is ready */
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
 80054be:	e008      	b.n	80054d2 <RCCEx_PLL3_Config+0x2e>
  {
    if ((HAL_GetTick() - tickstart) > PLL3_TIMEOUT_VALUE)
 80054c0:	f7fb fd5c 	bl	8000f7c <HAL_GetTick>
 80054c4:	4602      	mov	r2, r0
 80054c6:	68fb      	ldr	r3, [r7, #12]
 80054c8:	1ad3      	subs	r3, r2, r3
 80054ca:	2b02      	cmp	r3, #2
 80054cc:	d901      	bls.n	80054d2 <RCCEx_PLL3_Config+0x2e>
    {
      return HAL_TIMEOUT;
 80054ce:	2303      	movs	r3, #3
 80054d0:	e077      	b.n	80055c2 <RCCEx_PLL3_Config+0x11e>
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
 80054d2:	4b3e      	ldr	r3, [pc, #248]	@ (80055cc <RCCEx_PLL3_Config+0x128>)
 80054d4:	681b      	ldr	r3, [r3, #0]
 80054d6:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 80054da:	2b00      	cmp	r3, #0
 80054dc:	d1f0      	bne.n	80054c0 <RCCEx_PLL3_Config+0x1c>
    }
  }

  /* Configure PLL3 multiplication and division factors */
  __HAL_RCC_PLL3_CONFIG(pll3->PLL3Source,
 80054de:	4b3b      	ldr	r3, [pc, #236]	@ (80055cc <RCCEx_PLL3_Config+0x128>)
 80054e0:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80054e2:	f423 6370 	bic.w	r3, r3, #3840	@ 0xf00
 80054e6:	f023 0303 	bic.w	r3, r3, #3
 80054ea:	687a      	ldr	r2, [r7, #4]
 80054ec:	6811      	ldr	r1, [r2, #0]
 80054ee:	687a      	ldr	r2, [r7, #4]
 80054f0:	6852      	ldr	r2, [r2, #4]
 80054f2:	3a01      	subs	r2, #1
 80054f4:	0212      	lsls	r2, r2, #8
 80054f6:	430a      	orrs	r2, r1
 80054f8:	4934      	ldr	r1, [pc, #208]	@ (80055cc <RCCEx_PLL3_Config+0x128>)
 80054fa:	4313      	orrs	r3, r2
 80054fc:	630b      	str	r3, [r1, #48]	@ 0x30
 80054fe:	4b33      	ldr	r3, [pc, #204]	@ (80055cc <RCCEx_PLL3_Config+0x128>)
 8005500:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 8005502:	4b33      	ldr	r3, [pc, #204]	@ (80055d0 <RCCEx_PLL3_Config+0x12c>)
 8005504:	4013      	ands	r3, r2
 8005506:	687a      	ldr	r2, [r7, #4]
 8005508:	6892      	ldr	r2, [r2, #8]
 800550a:	3a01      	subs	r2, #1
 800550c:	f3c2 0108 	ubfx	r1, r2, #0, #9
 8005510:	687a      	ldr	r2, [r7, #4]
 8005512:	68d2      	ldr	r2, [r2, #12]
 8005514:	3a01      	subs	r2, #1
 8005516:	0252      	lsls	r2, r2, #9
 8005518:	b292      	uxth	r2, r2
 800551a:	4311      	orrs	r1, r2
 800551c:	687a      	ldr	r2, [r7, #4]
 800551e:	6912      	ldr	r2, [r2, #16]
 8005520:	3a01      	subs	r2, #1
 8005522:	0412      	lsls	r2, r2, #16
 8005524:	f402 02fe 	and.w	r2, r2, #8323072	@ 0x7f0000
 8005528:	4311      	orrs	r1, r2
 800552a:	687a      	ldr	r2, [r7, #4]
 800552c:	6952      	ldr	r2, [r2, #20]
 800552e:	3a01      	subs	r2, #1
 8005530:	0612      	lsls	r2, r2, #24
 8005532:	f002 42fe 	and.w	r2, r2, #2130706432	@ 0x7f000000
 8005536:	430a      	orrs	r2, r1
 8005538:	4924      	ldr	r1, [pc, #144]	@ (80055cc <RCCEx_PLL3_Config+0x128>)
 800553a:	4313      	orrs	r3, r2
 800553c:	644b      	str	r3, [r1, #68]	@ 0x44
                        pll3->PLL3P,
                        pll3->PLL3Q,
                        pll3->PLL3R);

  /* Select PLL3 input reference frequency range: VCI */
  __HAL_RCC_PLL3_VCIRANGE(pll3->PLL3RGE);
 800553e:	4b23      	ldr	r3, [pc, #140]	@ (80055cc <RCCEx_PLL3_Config+0x128>)
 8005540:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8005542:	f023 020c 	bic.w	r2, r3, #12
 8005546:	687b      	ldr	r3, [r7, #4]
 8005548:	699b      	ldr	r3, [r3, #24]
 800554a:	4920      	ldr	r1, [pc, #128]	@ (80055cc <RCCEx_PLL3_Config+0x128>)
 800554c:	4313      	orrs	r3, r2
 800554e:	630b      	str	r3, [r1, #48]	@ 0x30

  /* Configure the PLL3 Clock output(s) */
  __HAL_RCC_PLL3CLKOUT_ENABLE(pll3->PLL3ClockOut);
 8005550:	4b1e      	ldr	r3, [pc, #120]	@ (80055cc <RCCEx_PLL3_Config+0x128>)
 8005552:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8005554:	687b      	ldr	r3, [r7, #4]
 8005556:	6a1b      	ldr	r3, [r3, #32]
 8005558:	491c      	ldr	r1, [pc, #112]	@ (80055cc <RCCEx_PLL3_Config+0x128>)
 800555a:	4313      	orrs	r3, r2
 800555c:	630b      	str	r3, [r1, #48]	@ 0x30

  /* Disable PLL3FRACN  */
  __HAL_RCC_PLL3FRACN_DISABLE();
 800555e:	4b1b      	ldr	r3, [pc, #108]	@ (80055cc <RCCEx_PLL3_Config+0x128>)
 8005560:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8005562:	4a1a      	ldr	r2, [pc, #104]	@ (80055cc <RCCEx_PLL3_Config+0x128>)
 8005564:	f023 0310 	bic.w	r3, r3, #16
 8005568:	6313      	str	r3, [r2, #48]	@ 0x30

  /* Configures PLL3 clock Fractional Part Of The Multiplication Factor */
  __HAL_RCC_PLL3FRACN_CONFIG(pll3->PLL3FRACN);
 800556a:	4b18      	ldr	r3, [pc, #96]	@ (80055cc <RCCEx_PLL3_Config+0x128>)
 800556c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 800556e:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
 8005572:	f023 03f8 	bic.w	r3, r3, #248	@ 0xf8
 8005576:	687a      	ldr	r2, [r7, #4]
 8005578:	69d2      	ldr	r2, [r2, #28]
 800557a:	00d2      	lsls	r2, r2, #3
 800557c:	4913      	ldr	r1, [pc, #76]	@ (80055cc <RCCEx_PLL3_Config+0x128>)
 800557e:	4313      	orrs	r3, r2
 8005580:	648b      	str	r3, [r1, #72]	@ 0x48

  /* Enable PLL3FRACN  */
  __HAL_RCC_PLL3FRACN_ENABLE();
 8005582:	4b12      	ldr	r3, [pc, #72]	@ (80055cc <RCCEx_PLL3_Config+0x128>)
 8005584:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8005586:	4a11      	ldr	r2, [pc, #68]	@ (80055cc <RCCEx_PLL3_Config+0x128>)
 8005588:	f043 0310 	orr.w	r3, r3, #16
 800558c:	6313      	str	r3, [r2, #48]	@ 0x30

  /* Enable  PLL3 */
  __HAL_RCC_PLL3_ENABLE();
 800558e:	4b0f      	ldr	r3, [pc, #60]	@ (80055cc <RCCEx_PLL3_Config+0x128>)
 8005590:	681b      	ldr	r3, [r3, #0]
 8005592:	4a0e      	ldr	r2, [pc, #56]	@ (80055cc <RCCEx_PLL3_Config+0x128>)
 8005594:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 8005598:	6013      	str	r3, [r2, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 800559a:	f7fb fcef 	bl	8000f7c <HAL_GetTick>
 800559e:	60f8      	str	r0, [r7, #12]

  /* Wait till PLL3 is ready */
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
 80055a0:	e008      	b.n	80055b4 <RCCEx_PLL3_Config+0x110>
  {
    if ((HAL_GetTick() - tickstart) > PLL3_TIMEOUT_VALUE)
 80055a2:	f7fb fceb 	bl	8000f7c <HAL_GetTick>
 80055a6:	4602      	mov	r2, r0
 80055a8:	68fb      	ldr	r3, [r7, #12]
 80055aa:	1ad3      	subs	r3, r2, r3
 80055ac:	2b02      	cmp	r3, #2
 80055ae:	d901      	bls.n	80055b4 <RCCEx_PLL3_Config+0x110>
    {
      return HAL_TIMEOUT;
 80055b0:	2303      	movs	r3, #3
 80055b2:	e006      	b.n	80055c2 <RCCEx_PLL3_Config+0x11e>
  while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
 80055b4:	4b05      	ldr	r3, [pc, #20]	@ (80055cc <RCCEx_PLL3_Config+0x128>)
 80055b6:	681b      	ldr	r3, [r3, #0]
 80055b8:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 80055bc:	2b00      	cmp	r3, #0
 80055be:	d0f0      	beq.n	80055a2 <RCCEx_PLL3_Config+0xfe>
    }
  }
  return HAL_OK;
 80055c0:	2300      	movs	r3, #0
}
 80055c2:	4618      	mov	r0, r3
 80055c4:	3710      	adds	r7, #16
 80055c6:	46bd      	mov	sp, r7
 80055c8:	bd80      	pop	{r7, pc}
 80055ca:	bf00      	nop
 80055cc:	46020c00 	.word	0x46020c00
 80055d0:	80800000 	.word	0x80800000

080055d4 <HAL_SD_Init>:
            SD_HandleTypeDef and create the associated handle.
  * @param  hsd: Pointer to the SD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_Init(SD_HandleTypeDef *hsd)
{
 80055d4:	b580      	push	{r7, lr}
 80055d6:	b08a      	sub	sp, #40	@ 0x28
 80055d8:	af00      	add	r7, sp, #0
 80055da:	6078      	str	r0, [r7, #4]
  uint32_t speedgrade;
  uint32_t unitsize;
  uint32_t tickstart;

  /* Check the SD handle allocation */
  if (hsd == NULL)
 80055dc:	687b      	ldr	r3, [r7, #4]
 80055de:	2b00      	cmp	r3, #0
 80055e0:	d101      	bne.n	80055e6 <HAL_SD_Init+0x12>
  {
    return HAL_ERROR;
 80055e2:	2301      	movs	r3, #1
 80055e4:	e075      	b.n	80056d2 <HAL_SD_Init+0xfe>
  assert_param(IS_SDMMC_CLOCK_POWER_SAVE(hsd->Init.ClockPowerSave));
  assert_param(IS_SDMMC_BUS_WIDE(hsd->Init.BusWide));
  assert_param(IS_SDMMC_HARDWARE_FLOW_CONTROL(hsd->Init.HardwareFlowControl));
  assert_param(IS_SDMMC_CLKDIV(hsd->Init.ClockDiv));

  if (hsd->State == HAL_SD_STATE_RESET)
 80055e6:	687b      	ldr	r3, [r7, #4]
 80055e8:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 80055ec:	b2db      	uxtb	r3, r3
 80055ee:	2b00      	cmp	r3, #0
 80055f0:	d105      	bne.n	80055fe <HAL_SD_Init+0x2a>
  {
    /* Allocate lock resource and initialize it */
    hsd->Lock = HAL_UNLOCKED;
 80055f2:	687b      	ldr	r3, [r7, #4]
 80055f4:	2200      	movs	r2, #0
 80055f6:	761a      	strb	r2, [r3, #24]

    /* Init the low level hardware */
    hsd->MspInitCallback(hsd);
#else
    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_SD_MspInit(hsd);
 80055f8:	6878      	ldr	r0, [r7, #4]
 80055fa:	f7fb f8ff 	bl	80007fc <HAL_SD_MspInit>
#endif /* USE_HAL_SD_REGISTER_CALLBACKS */
  }

  hsd->State = HAL_SD_STATE_PROGRAMMING;
 80055fe:	687b      	ldr	r3, [r7, #4]
 8005600:	2204      	movs	r2, #4
 8005602:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

  /* Initialize the Card parameters */
  if (HAL_SD_InitCard(hsd) != HAL_OK)
 8005606:	6878      	ldr	r0, [r7, #4]
 8005608:	f000 f868 	bl	80056dc <HAL_SD_InitCard>
 800560c:	4603      	mov	r3, r0
 800560e:	2b00      	cmp	r3, #0
 8005610:	d001      	beq.n	8005616 <HAL_SD_Init+0x42>
  {
    return HAL_ERROR;
 8005612:	2301      	movs	r3, #1
 8005614:	e05d      	b.n	80056d2 <HAL_SD_Init+0xfe>
  }

  if (HAL_SD_GetCardStatus(hsd, &CardStatus) != HAL_OK)
 8005616:	f107 0308 	add.w	r3, r7, #8
 800561a:	4619      	mov	r1, r3
 800561c:	6878      	ldr	r0, [r7, #4]
 800561e:	f000 fd99 	bl	8006154 <HAL_SD_GetCardStatus>
 8005622:	4603      	mov	r3, r0
 8005624:	2b00      	cmp	r3, #0
 8005626:	d001      	beq.n	800562c <HAL_SD_Init+0x58>
  {
    return HAL_ERROR;
 8005628:	2301      	movs	r3, #1
 800562a:	e052      	b.n	80056d2 <HAL_SD_Init+0xfe>
  }
  /* Get Initial Card Speed from Card Status*/
  speedgrade = CardStatus.UhsSpeedGrade;
 800562c:	7e3b      	ldrb	r3, [r7, #24]
 800562e:	b2db      	uxtb	r3, r3
 8005630:	627b      	str	r3, [r7, #36]	@ 0x24
  unitsize = CardStatus.UhsAllocationUnitSize;
 8005632:	7e7b      	ldrb	r3, [r7, #25]
 8005634:	b2db      	uxtb	r3, r3
 8005636:	623b      	str	r3, [r7, #32]
  if ((hsd->SdCard.CardType == CARD_SDHC_SDXC) && ((speedgrade != 0U) || (unitsize != 0U)))
 8005638:	687b      	ldr	r3, [r7, #4]
 800563a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800563c:	2b01      	cmp	r3, #1
 800563e:	d10a      	bne.n	8005656 <HAL_SD_Init+0x82>
 8005640:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8005642:	2b00      	cmp	r3, #0
 8005644:	d102      	bne.n	800564c <HAL_SD_Init+0x78>
 8005646:	6a3b      	ldr	r3, [r7, #32]
 8005648:	2b00      	cmp	r3, #0
 800564a:	d004      	beq.n	8005656 <HAL_SD_Init+0x82>
  {
    hsd->SdCard.CardSpeed = CARD_ULTRA_HIGH_SPEED;
 800564c:	687b      	ldr	r3, [r7, #4]
 800564e:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8005652:	659a      	str	r2, [r3, #88]	@ 0x58
 8005654:	e00b      	b.n	800566e <HAL_SD_Init+0x9a>
  }
  else
  {
    if (hsd->SdCard.CardType == CARD_SDHC_SDXC)
 8005656:	687b      	ldr	r3, [r7, #4]
 8005658:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800565a:	2b01      	cmp	r3, #1
 800565c:	d104      	bne.n	8005668 <HAL_SD_Init+0x94>
    {
      hsd->SdCard.CardSpeed  = CARD_HIGH_SPEED;
 800565e:	687b      	ldr	r3, [r7, #4]
 8005660:	f44f 7280 	mov.w	r2, #256	@ 0x100
 8005664:	659a      	str	r2, [r3, #88]	@ 0x58
 8005666:	e002      	b.n	800566e <HAL_SD_Init+0x9a>
    }
    else
    {
      hsd->SdCard.CardSpeed  = CARD_NORMAL_SPEED;
 8005668:	687b      	ldr	r3, [r7, #4]
 800566a:	2200      	movs	r2, #0
 800566c:	659a      	str	r2, [r3, #88]	@ 0x58
    }

  }
  /* Configure the bus wide */
  if (HAL_SD_ConfigWideBusOperation(hsd, hsd->Init.BusWide) != HAL_OK)
 800566e:	687b      	ldr	r3, [r7, #4]
 8005670:	68db      	ldr	r3, [r3, #12]
 8005672:	4619      	mov	r1, r3
 8005674:	6878      	ldr	r0, [r7, #4]
 8005676:	f000 fe2b 	bl	80062d0 <HAL_SD_ConfigWideBusOperation>
 800567a:	4603      	mov	r3, r0
 800567c:	2b00      	cmp	r3, #0
 800567e:	d001      	beq.n	8005684 <HAL_SD_Init+0xb0>
  {
    return HAL_ERROR;
 8005680:	2301      	movs	r3, #1
 8005682:	e026      	b.n	80056d2 <HAL_SD_Init+0xfe>
  }

  /* Verify that SD card is ready to use after Initialization */
  tickstart = HAL_GetTick();
 8005684:	f7fb fc7a 	bl	8000f7c <HAL_GetTick>
 8005688:	61f8      	str	r0, [r7, #28]
  while ((HAL_SD_GetCardState(hsd) != HAL_SD_CARD_TRANSFER))
 800568a:	e011      	b.n	80056b0 <HAL_SD_Init+0xdc>
  {
    if ((HAL_GetTick() - tickstart) >=  SDMMC_SWDATATIMEOUT)
 800568c:	f7fb fc76 	bl	8000f7c <HAL_GetTick>
 8005690:	4602      	mov	r2, r0
 8005692:	69fb      	ldr	r3, [r7, #28]
 8005694:	1ad3      	subs	r3, r2, r3
 8005696:	f1b3 3fff 	cmp.w	r3, #4294967295
 800569a:	d109      	bne.n	80056b0 <HAL_SD_Init+0xdc>
    {
      hsd->ErrorCode = HAL_SD_ERROR_TIMEOUT;
 800569c:	687b      	ldr	r3, [r7, #4]
 800569e:	f04f 4200 	mov.w	r2, #2147483648	@ 0x80000000
 80056a2:	635a      	str	r2, [r3, #52]	@ 0x34
      hsd->State = HAL_SD_STATE_READY;
 80056a4:	687b      	ldr	r3, [r7, #4]
 80056a6:	2201      	movs	r2, #1
 80056a8:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
      return HAL_TIMEOUT;
 80056ac:	2303      	movs	r3, #3
 80056ae:	e010      	b.n	80056d2 <HAL_SD_Init+0xfe>
  while ((HAL_SD_GetCardState(hsd) != HAL_SD_CARD_TRANSFER))
 80056b0:	6878      	ldr	r0, [r7, #4]
 80056b2:	f000 ff1f 	bl	80064f4 <HAL_SD_GetCardState>
 80056b6:	4603      	mov	r3, r0
 80056b8:	2b04      	cmp	r3, #4
 80056ba:	d1e7      	bne.n	800568c <HAL_SD_Init+0xb8>
    }
  }

  /* Initialize the error code */
  hsd->ErrorCode = HAL_SD_ERROR_NONE;
 80056bc:	687b      	ldr	r3, [r7, #4]
 80056be:	2200      	movs	r2, #0
 80056c0:	635a      	str	r2, [r3, #52]	@ 0x34

  /* Initialize the SD operation */
  hsd->Context = SD_CONTEXT_NONE;
 80056c2:	687b      	ldr	r3, [r7, #4]
 80056c4:	2200      	movs	r2, #0
 80056c6:	62da      	str	r2, [r3, #44]	@ 0x2c

  /* Initialize the SD state */
  hsd->State = HAL_SD_STATE_READY;
 80056c8:	687b      	ldr	r3, [r7, #4]
 80056ca:	2201      	movs	r2, #1
 80056cc:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

  return HAL_OK;
 80056d0:	2300      	movs	r3, #0
}
 80056d2:	4618      	mov	r0, r3
 80056d4:	3728      	adds	r7, #40	@ 0x28
 80056d6:	46bd      	mov	sp, r7
 80056d8:	bd80      	pop	{r7, pc}
	...

080056dc <HAL_SD_InitCard>:
  * @note   This function initializes the SD card. It could be used when a card
            re-initialization is needed.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_InitCard(SD_HandleTypeDef *hsd)
{
 80056dc:	b590      	push	{r4, r7, lr}
 80056de:	b08d      	sub	sp, #52	@ 0x34
 80056e0:	af02      	add	r7, sp, #8
 80056e2:	6078      	str	r0, [r7, #4]
  uint32_t errorstate;
  SD_InitTypeDef Init;
  uint32_t sdmmc_clk;

  /* Default SDMMC peripheral configuration for SD card initialization */
  Init.ClockEdge           = SDMMC_CLOCK_EDGE_RISING;
 80056e4:	2300      	movs	r3, #0
 80056e6:	60fb      	str	r3, [r7, #12]
  Init.ClockPowerSave      = SDMMC_CLOCK_POWER_SAVE_DISABLE;
 80056e8:	2300      	movs	r3, #0
 80056ea:	613b      	str	r3, [r7, #16]
  Init.BusWide             = SDMMC_BUS_WIDE_1B;
 80056ec:	2300      	movs	r3, #0
 80056ee:	617b      	str	r3, [r7, #20]
  Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_DISABLE;
 80056f0:	2300      	movs	r3, #0
 80056f2:	61bb      	str	r3, [r7, #24]

  /* Init Clock should be less or equal to 400Khz*/
  sdmmc_clk = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SDMMC);
 80056f4:	f44f 1000 	mov.w	r0, #2097152	@ 0x200000
 80056f8:	f04f 0100 	mov.w	r1, #0
 80056fc:	f7fe fcf8 	bl	80040f0 <HAL_RCCEx_GetPeriphCLKFreq>
 8005700:	6278      	str	r0, [r7, #36]	@ 0x24
  if (sdmmc_clk == 0U)
 8005702:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8005704:	2b00      	cmp	r3, #0
 8005706:	d109      	bne.n	800571c <HAL_SD_InitCard+0x40>
  {
    hsd->State = HAL_SD_STATE_READY;
 8005708:	687b      	ldr	r3, [r7, #4]
 800570a:	2201      	movs	r2, #1
 800570c:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
    hsd->ErrorCode = SDMMC_ERROR_INVALID_PARAMETER;
 8005710:	687b      	ldr	r3, [r7, #4]
 8005712:	f04f 6200 	mov.w	r2, #134217728	@ 0x8000000
 8005716:	635a      	str	r2, [r3, #52]	@ 0x34
    return HAL_ERROR;
 8005718:	2301      	movs	r3, #1
 800571a:	e070      	b.n	80057fe <HAL_SD_InitCard+0x122>
  }
  Init.ClockDiv = sdmmc_clk / (2U * SD_INIT_FREQ);
 800571c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800571e:	0a1b      	lsrs	r3, r3, #8
 8005720:	4a39      	ldr	r2, [pc, #228]	@ (8005808 <HAL_SD_InitCard+0x12c>)
 8005722:	fba2 2303 	umull	r2, r3, r2, r3
 8005726:	091b      	lsrs	r3, r3, #4
 8005728:	61fb      	str	r3, [r7, #28]
  /* Set Transceiver polarity */
  hsd->Instance->POWER |= SDMMC_POWER_DIRPOL;
#endif /* USE_SD_TRANSCEIVER  */

  /* Initialize SDMMC peripheral interface with default configuration */
  (void)SDMMC_Init(hsd->Instance, Init);
 800572a:	687b      	ldr	r3, [r7, #4]
 800572c:	681c      	ldr	r4, [r3, #0]
 800572e:	466a      	mov	r2, sp
 8005730:	f107 0318 	add.w	r3, r7, #24
 8005734:	e893 0003 	ldmia.w	r3, {r0, r1}
 8005738:	e882 0003 	stmia.w	r2, {r0, r1}
 800573c:	f107 030c 	add.w	r3, r7, #12
 8005740:	cb0e      	ldmia	r3, {r1, r2, r3}
 8005742:	4620      	mov	r0, r4
 8005744:	f001 fff4 	bl	8007730 <SDMMC_Init>

  /* Set Power State to ON */
  (void)SDMMC_PowerState_ON(hsd->Instance);
 8005748:	687b      	ldr	r3, [r7, #4]
 800574a:	681b      	ldr	r3, [r3, #0]
 800574c:	4618      	mov	r0, r3
 800574e:	f002 f837 	bl	80077c0 <SDMMC_PowerState_ON>

  /* wait 74 Cycles: required power up waiting time before starting
     the SD initialization sequence */
  if (Init.ClockDiv != 0U)
 8005752:	69fb      	ldr	r3, [r7, #28]
 8005754:	2b00      	cmp	r3, #0
 8005756:	d005      	beq.n	8005764 <HAL_SD_InitCard+0x88>
  {
    sdmmc_clk = sdmmc_clk / (2U * Init.ClockDiv);
 8005758:	69fb      	ldr	r3, [r7, #28]
 800575a:	005b      	lsls	r3, r3, #1
 800575c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800575e:	fbb2 f3f3 	udiv	r3, r2, r3
 8005762:	627b      	str	r3, [r7, #36]	@ 0x24
  }

  if (sdmmc_clk != 0U)
 8005764:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8005766:	2b00      	cmp	r3, #0
 8005768:	d007      	beq.n	800577a <HAL_SD_InitCard+0x9e>
  {
    HAL_Delay(1U + (74U * 1000U / (sdmmc_clk)));
 800576a:	4a28      	ldr	r2, [pc, #160]	@ (800580c <HAL_SD_InitCard+0x130>)
 800576c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800576e:	fbb2 f3f3 	udiv	r3, r2, r3
 8005772:	3301      	adds	r3, #1
 8005774:	4618      	mov	r0, r3
 8005776:	f7fb fc0d 	bl	8000f94 <HAL_Delay>
  }

  /* Identify card operating voltage */
  errorstate = SD_PowerON(hsd);
 800577a:	6878      	ldr	r0, [r7, #4]
 800577c:	f000 ffa8 	bl	80066d0 <SD_PowerON>
 8005780:	6238      	str	r0, [r7, #32]
  if (errorstate != HAL_SD_ERROR_NONE)
 8005782:	6a3b      	ldr	r3, [r7, #32]
 8005784:	2b00      	cmp	r3, #0
 8005786:	d00b      	beq.n	80057a0 <HAL_SD_InitCard+0xc4>
  {
    hsd->State = HAL_SD_STATE_READY;
 8005788:	687b      	ldr	r3, [r7, #4]
 800578a:	2201      	movs	r2, #1
 800578c:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
    hsd->ErrorCode |= errorstate;
 8005790:	687b      	ldr	r3, [r7, #4]
 8005792:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8005794:	6a3b      	ldr	r3, [r7, #32]
 8005796:	431a      	orrs	r2, r3
 8005798:	687b      	ldr	r3, [r7, #4]
 800579a:	635a      	str	r2, [r3, #52]	@ 0x34
    return HAL_ERROR;
 800579c:	2301      	movs	r3, #1
 800579e:	e02e      	b.n	80057fe <HAL_SD_InitCard+0x122>
  }

  /* Card initialization */
  errorstate = SD_InitCard(hsd);
 80057a0:	6878      	ldr	r0, [r7, #4]
 80057a2:	f000 fec7 	bl	8006534 <SD_InitCard>
 80057a6:	6238      	str	r0, [r7, #32]
  if (errorstate != HAL_SD_ERROR_NONE)
 80057a8:	6a3b      	ldr	r3, [r7, #32]
 80057aa:	2b00      	cmp	r3, #0
 80057ac:	d00b      	beq.n	80057c6 <HAL_SD_InitCard+0xea>
  {
    hsd->State = HAL_SD_STATE_READY;
 80057ae:	687b      	ldr	r3, [r7, #4]
 80057b0:	2201      	movs	r2, #1
 80057b2:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
    hsd->ErrorCode |= errorstate;
 80057b6:	687b      	ldr	r3, [r7, #4]
 80057b8:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 80057ba:	6a3b      	ldr	r3, [r7, #32]
 80057bc:	431a      	orrs	r2, r3
 80057be:	687b      	ldr	r3, [r7, #4]
 80057c0:	635a      	str	r2, [r3, #52]	@ 0x34
    return HAL_ERROR;
 80057c2:	2301      	movs	r3, #1
 80057c4:	e01b      	b.n	80057fe <HAL_SD_InitCard+0x122>
  }

  /* Set Block Size for Card */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
 80057c6:	687b      	ldr	r3, [r7, #4]
 80057c8:	681b      	ldr	r3, [r3, #0]
 80057ca:	f44f 7100 	mov.w	r1, #512	@ 0x200
 80057ce:	4618      	mov	r0, r3
 80057d0:	f002 f88c 	bl	80078ec <SDMMC_CmdBlockLength>
 80057d4:	6238      	str	r0, [r7, #32]
  if (errorstate != HAL_SD_ERROR_NONE)
 80057d6:	6a3b      	ldr	r3, [r7, #32]
 80057d8:	2b00      	cmp	r3, #0
 80057da:	d00f      	beq.n	80057fc <HAL_SD_InitCard+0x120>
  {
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 80057dc:	687b      	ldr	r3, [r7, #4]
 80057de:	681b      	ldr	r3, [r3, #0]
 80057e0:	4a0b      	ldr	r2, [pc, #44]	@ (8005810 <HAL_SD_InitCard+0x134>)
 80057e2:	639a      	str	r2, [r3, #56]	@ 0x38
    hsd->ErrorCode |= errorstate;
 80057e4:	687b      	ldr	r3, [r7, #4]
 80057e6:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 80057e8:	6a3b      	ldr	r3, [r7, #32]
 80057ea:	431a      	orrs	r2, r3
 80057ec:	687b      	ldr	r3, [r7, #4]
 80057ee:	635a      	str	r2, [r3, #52]	@ 0x34
    hsd->State = HAL_SD_STATE_READY;
 80057f0:	687b      	ldr	r3, [r7, #4]
 80057f2:	2201      	movs	r2, #1
 80057f4:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
    return HAL_ERROR;
 80057f8:	2301      	movs	r3, #1
 80057fa:	e000      	b.n	80057fe <HAL_SD_InitCard+0x122>
  }

  return HAL_OK;
 80057fc:	2300      	movs	r3, #0
}
 80057fe:	4618      	mov	r0, r3
 8005800:	372c      	adds	r7, #44	@ 0x2c
 8005802:	46bd      	mov	sp, r7
 8005804:	bd90      	pop	{r4, r7, pc}
 8005806:	bf00      	nop
 8005808:	014f8b59 	.word	0x014f8b59
 800580c:	00012110 	.word	0x00012110
 8005810:	1fe00fff 	.word	0x1fe00fff

08005814 <HAL_SD_ReadBlocks_DMA>:
  * @param  NumberOfBlocks: Number of blocks to read.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_ReadBlocks_DMA(SD_HandleTypeDef *hsd, uint8_t *pData, uint32_t BlockAdd,
                                        uint32_t NumberOfBlocks)
{
 8005814:	b580      	push	{r7, lr}
 8005816:	b08c      	sub	sp, #48	@ 0x30
 8005818:	af00      	add	r7, sp, #0
 800581a:	60f8      	str	r0, [r7, #12]
 800581c:	60b9      	str	r1, [r7, #8]
 800581e:	607a      	str	r2, [r7, #4]
 8005820:	603b      	str	r3, [r7, #0]
  SDMMC_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t add = BlockAdd;
 8005822:	687b      	ldr	r3, [r7, #4]
 8005824:	62bb      	str	r3, [r7, #40]	@ 0x28

  if (NULL == pData)
 8005826:	68bb      	ldr	r3, [r7, #8]
 8005828:	2b00      	cmp	r3, #0
 800582a:	d107      	bne.n	800583c <HAL_SD_ReadBlocks_DMA+0x28>
  {
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 800582c:	68fb      	ldr	r3, [r7, #12]
 800582e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8005830:	f043 6200 	orr.w	r2, r3, #134217728	@ 0x8000000
 8005834:	68fb      	ldr	r3, [r7, #12]
 8005836:	635a      	str	r2, [r3, #52]	@ 0x34
    return HAL_ERROR;
 8005838:	2301      	movs	r3, #1
 800583a:	e08d      	b.n	8005958 <HAL_SD_ReadBlocks_DMA+0x144>
  }

  if (hsd->State == HAL_SD_STATE_READY)
 800583c:	68fb      	ldr	r3, [r7, #12]
 800583e:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 8005842:	b2db      	uxtb	r3, r3
 8005844:	2b01      	cmp	r3, #1
 8005846:	f040 8086 	bne.w	8005956 <HAL_SD_ReadBlocks_DMA+0x142>
  {
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
 800584a:	68fb      	ldr	r3, [r7, #12]
 800584c:	2200      	movs	r2, #0
 800584e:	635a      	str	r2, [r3, #52]	@ 0x34

    if ((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 8005850:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8005852:	683b      	ldr	r3, [r7, #0]
 8005854:	441a      	add	r2, r3
 8005856:	68fb      	ldr	r3, [r7, #12]
 8005858:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800585a:	429a      	cmp	r2, r3
 800585c:	d907      	bls.n	800586e <HAL_SD_ReadBlocks_DMA+0x5a>
    {
      hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
 800585e:	68fb      	ldr	r3, [r7, #12]
 8005860:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8005862:	f043 7200 	orr.w	r2, r3, #33554432	@ 0x2000000
 8005866:	68fb      	ldr	r3, [r7, #12]
 8005868:	635a      	str	r2, [r3, #52]	@ 0x34
      return HAL_ERROR;
 800586a:	2301      	movs	r3, #1
 800586c:	e074      	b.n	8005958 <HAL_SD_ReadBlocks_DMA+0x144>
    }

    hsd->State = HAL_SD_STATE_BUSY;
 800586e:	68fb      	ldr	r3, [r7, #12]
 8005870:	2203      	movs	r2, #3
 8005872:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

    /* Initialize data control register */
    hsd->Instance->DCTRL = 0U;
 8005876:	68fb      	ldr	r3, [r7, #12]
 8005878:	681b      	ldr	r3, [r3, #0]
 800587a:	2200      	movs	r2, #0
 800587c:	62da      	str	r2, [r3, #44]	@ 0x2c

    hsd->pRxBuffPtr = pData;
 800587e:	68fb      	ldr	r3, [r7, #12]
 8005880:	68ba      	ldr	r2, [r7, #8]
 8005882:	625a      	str	r2, [r3, #36]	@ 0x24
    hsd->RxXferSize = BLOCKSIZE * NumberOfBlocks;
 8005884:	683b      	ldr	r3, [r7, #0]
 8005886:	025a      	lsls	r2, r3, #9
 8005888:	68fb      	ldr	r3, [r7, #12]
 800588a:	629a      	str	r2, [r3, #40]	@ 0x28

    if (hsd->SdCard.CardType != CARD_SDHC_SDXC)
 800588c:	68fb      	ldr	r3, [r7, #12]
 800588e:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8005890:	2b01      	cmp	r3, #1
 8005892:	d002      	beq.n	800589a <HAL_SD_ReadBlocks_DMA+0x86>
    {
      add *= BLOCKSIZE;
 8005894:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8005896:	025b      	lsls	r3, r3, #9
 8005898:	62bb      	str	r3, [r7, #40]	@ 0x28
    }

    /* Configure the SD DPSM (Data Path State Machine) */
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
 800589a:	f04f 33ff 	mov.w	r3, #4294967295
 800589e:	613b      	str	r3, [r7, #16]
    config.DataLength    = BLOCKSIZE * NumberOfBlocks;
 80058a0:	683b      	ldr	r3, [r7, #0]
 80058a2:	025b      	lsls	r3, r3, #9
 80058a4:	617b      	str	r3, [r7, #20]
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
 80058a6:	2390      	movs	r3, #144	@ 0x90
 80058a8:	61bb      	str	r3, [r7, #24]
    config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 80058aa:	2302      	movs	r3, #2
 80058ac:	61fb      	str	r3, [r7, #28]
    config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
 80058ae:	2300      	movs	r3, #0
 80058b0:	623b      	str	r3, [r7, #32]
    config.DPSM          = SDMMC_DPSM_DISABLE;
 80058b2:	2300      	movs	r3, #0
 80058b4:	627b      	str	r3, [r7, #36]	@ 0x24
    (void)SDMMC_ConfigData(hsd->Instance, &config);
 80058b6:	68fb      	ldr	r3, [r7, #12]
 80058b8:	681b      	ldr	r3, [r3, #0]
 80058ba:	f107 0210 	add.w	r2, r7, #16
 80058be:	4611      	mov	r1, r2
 80058c0:	4618      	mov	r0, r3
 80058c2:	f001 ffe7 	bl	8007894 <SDMMC_ConfigData>

    __SDMMC_CMDTRANS_ENABLE(hsd->Instance);
 80058c6:	68fb      	ldr	r3, [r7, #12]
 80058c8:	681b      	ldr	r3, [r3, #0]
 80058ca:	68da      	ldr	r2, [r3, #12]
 80058cc:	68fb      	ldr	r3, [r7, #12]
 80058ce:	681b      	ldr	r3, [r3, #0]
 80058d0:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 80058d4:	60da      	str	r2, [r3, #12]
    hsd->Instance->IDMABASER = (uint32_t) pData ;
 80058d6:	68fb      	ldr	r3, [r7, #12]
 80058d8:	681b      	ldr	r3, [r3, #0]
 80058da:	68ba      	ldr	r2, [r7, #8]
 80058dc:	659a      	str	r2, [r3, #88]	@ 0x58
    hsd->Instance->IDMACTRL  = SDMMC_ENABLE_IDMA_SINGLE_BUFF;
 80058de:	68fb      	ldr	r3, [r7, #12]
 80058e0:	681b      	ldr	r3, [r3, #0]
 80058e2:	2201      	movs	r2, #1
 80058e4:	651a      	str	r2, [r3, #80]	@ 0x50

    /* Read Blocks in DMA mode */
    if (NumberOfBlocks > 1U)
 80058e6:	683b      	ldr	r3, [r7, #0]
 80058e8:	2b01      	cmp	r3, #1
 80058ea:	d90a      	bls.n	8005902 <HAL_SD_ReadBlocks_DMA+0xee>
    {
      hsd->Context = (SD_CONTEXT_READ_MULTIPLE_BLOCK | SD_CONTEXT_DMA);
 80058ec:	68fb      	ldr	r3, [r7, #12]
 80058ee:	2282      	movs	r2, #130	@ 0x82
 80058f0:	62da      	str	r2, [r3, #44]	@ 0x2c

      /* Read Multi Block command */
      errorstate = SDMMC_CmdReadMultiBlock(hsd->Instance, add);
 80058f2:	68fb      	ldr	r3, [r7, #12]
 80058f4:	681b      	ldr	r3, [r3, #0]
 80058f6:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 80058f8:	4618      	mov	r0, r3
 80058fa:	f002 f83d 	bl	8007978 <SDMMC_CmdReadMultiBlock>
 80058fe:	62f8      	str	r0, [r7, #44]	@ 0x2c
 8005900:	e009      	b.n	8005916 <HAL_SD_ReadBlocks_DMA+0x102>
    }
    else
    {
      hsd->Context = (SD_CONTEXT_READ_SINGLE_BLOCK | SD_CONTEXT_DMA);
 8005902:	68fb      	ldr	r3, [r7, #12]
 8005904:	2281      	movs	r2, #129	@ 0x81
 8005906:	62da      	str	r2, [r3, #44]	@ 0x2c

      /* Read Single Block command */
      errorstate = SDMMC_CmdReadSingleBlock(hsd->Instance, add);
 8005908:	68fb      	ldr	r3, [r7, #12]
 800590a:	681b      	ldr	r3, [r3, #0]
 800590c:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 800590e:	4618      	mov	r0, r3
 8005910:	f002 f80f 	bl	8007932 <SDMMC_CmdReadSingleBlock>
 8005914:	62f8      	str	r0, [r7, #44]	@ 0x2c
    }
    if (errorstate != HAL_SD_ERROR_NONE)
 8005916:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8005918:	2b00      	cmp	r3, #0
 800591a:	d012      	beq.n	8005942 <HAL_SD_ReadBlocks_DMA+0x12e>
    {
      /* Clear all the static flags */
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800591c:	68fb      	ldr	r3, [r7, #12]
 800591e:	681b      	ldr	r3, [r3, #0]
 8005920:	4a0f      	ldr	r2, [pc, #60]	@ (8005960 <HAL_SD_ReadBlocks_DMA+0x14c>)
 8005922:	639a      	str	r2, [r3, #56]	@ 0x38
      hsd->ErrorCode |= errorstate;
 8005924:	68fb      	ldr	r3, [r7, #12]
 8005926:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8005928:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800592a:	431a      	orrs	r2, r3
 800592c:	68fb      	ldr	r3, [r7, #12]
 800592e:	635a      	str	r2, [r3, #52]	@ 0x34
      hsd->State = HAL_SD_STATE_READY;
 8005930:	68fb      	ldr	r3, [r7, #12]
 8005932:	2201      	movs	r2, #1
 8005934:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
      hsd->Context = SD_CONTEXT_NONE;
 8005938:	68fb      	ldr	r3, [r7, #12]
 800593a:	2200      	movs	r2, #0
 800593c:	62da      	str	r2, [r3, #44]	@ 0x2c
      return HAL_ERROR;
 800593e:	2301      	movs	r3, #1
 8005940:	e00a      	b.n	8005958 <HAL_SD_ReadBlocks_DMA+0x144>
    }

    /* Enable transfer interrupts */
    __HAL_SD_ENABLE_IT(hsd, (SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT | SDMMC_IT_RXOVERR | SDMMC_IT_DATAEND));
 8005942:	68fb      	ldr	r3, [r7, #12]
 8005944:	681b      	ldr	r3, [r3, #0]
 8005946:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 8005948:	68fb      	ldr	r3, [r7, #12]
 800594a:	681b      	ldr	r3, [r3, #0]
 800594c:	f442 7295 	orr.w	r2, r2, #298	@ 0x12a
 8005950:	63da      	str	r2, [r3, #60]	@ 0x3c

    return HAL_OK;
 8005952:	2300      	movs	r3, #0
 8005954:	e000      	b.n	8005958 <HAL_SD_ReadBlocks_DMA+0x144>
  }
  else
  {
    return HAL_BUSY;
 8005956:	2302      	movs	r3, #2
  }
}
 8005958:	4618      	mov	r0, r3
 800595a:	3730      	adds	r7, #48	@ 0x30
 800595c:	46bd      	mov	sp, r7
 800595e:	bd80      	pop	{r7, pc}
 8005960:	1fe00fff 	.word	0x1fe00fff

08005964 <HAL_SD_WriteBlocks_DMA>:
  * @param  NumberOfBlocks: Number of blocks to write
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_WriteBlocks_DMA(SD_HandleTypeDef *hsd, const uint8_t *pData, uint32_t BlockAdd,
                                         uint32_t NumberOfBlocks)
{
 8005964:	b580      	push	{r7, lr}
 8005966:	b08c      	sub	sp, #48	@ 0x30
 8005968:	af00      	add	r7, sp, #0
 800596a:	60f8      	str	r0, [r7, #12]
 800596c:	60b9      	str	r1, [r7, #8]
 800596e:	607a      	str	r2, [r7, #4]
 8005970:	603b      	str	r3, [r7, #0]
  SDMMC_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t add = BlockAdd;
 8005972:	687b      	ldr	r3, [r7, #4]
 8005974:	62bb      	str	r3, [r7, #40]	@ 0x28

  if (NULL == pData)
 8005976:	68bb      	ldr	r3, [r7, #8]
 8005978:	2b00      	cmp	r3, #0
 800597a:	d107      	bne.n	800598c <HAL_SD_WriteBlocks_DMA+0x28>
  {
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 800597c:	68fb      	ldr	r3, [r7, #12]
 800597e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8005980:	f043 6200 	orr.w	r2, r3, #134217728	@ 0x8000000
 8005984:	68fb      	ldr	r3, [r7, #12]
 8005986:	635a      	str	r2, [r3, #52]	@ 0x34
    return HAL_ERROR;
 8005988:	2301      	movs	r3, #1
 800598a:	e08d      	b.n	8005aa8 <HAL_SD_WriteBlocks_DMA+0x144>
  }

  if (hsd->State == HAL_SD_STATE_READY)
 800598c:	68fb      	ldr	r3, [r7, #12]
 800598e:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 8005992:	b2db      	uxtb	r3, r3
 8005994:	2b01      	cmp	r3, #1
 8005996:	f040 8086 	bne.w	8005aa6 <HAL_SD_WriteBlocks_DMA+0x142>
  {
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
 800599a:	68fb      	ldr	r3, [r7, #12]
 800599c:	2200      	movs	r2, #0
 800599e:	635a      	str	r2, [r3, #52]	@ 0x34

    if ((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 80059a0:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 80059a2:	683b      	ldr	r3, [r7, #0]
 80059a4:	441a      	add	r2, r3
 80059a6:	68fb      	ldr	r3, [r7, #12]
 80059a8:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 80059aa:	429a      	cmp	r2, r3
 80059ac:	d907      	bls.n	80059be <HAL_SD_WriteBlocks_DMA+0x5a>
    {
      hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
 80059ae:	68fb      	ldr	r3, [r7, #12]
 80059b0:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80059b2:	f043 7200 	orr.w	r2, r3, #33554432	@ 0x2000000
 80059b6:	68fb      	ldr	r3, [r7, #12]
 80059b8:	635a      	str	r2, [r3, #52]	@ 0x34
      return HAL_ERROR;
 80059ba:	2301      	movs	r3, #1
 80059bc:	e074      	b.n	8005aa8 <HAL_SD_WriteBlocks_DMA+0x144>
    }

    hsd->State = HAL_SD_STATE_BUSY;
 80059be:	68fb      	ldr	r3, [r7, #12]
 80059c0:	2203      	movs	r2, #3
 80059c2:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

    /* Initialize data control register */
    hsd->Instance->DCTRL = 0U;
 80059c6:	68fb      	ldr	r3, [r7, #12]
 80059c8:	681b      	ldr	r3, [r3, #0]
 80059ca:	2200      	movs	r2, #0
 80059cc:	62da      	str	r2, [r3, #44]	@ 0x2c

    hsd->pTxBuffPtr = pData;
 80059ce:	68fb      	ldr	r3, [r7, #12]
 80059d0:	68ba      	ldr	r2, [r7, #8]
 80059d2:	61da      	str	r2, [r3, #28]
    hsd->TxXferSize = BLOCKSIZE * NumberOfBlocks;
 80059d4:	683b      	ldr	r3, [r7, #0]
 80059d6:	025a      	lsls	r2, r3, #9
 80059d8:	68fb      	ldr	r3, [r7, #12]
 80059da:	621a      	str	r2, [r3, #32]

    if (hsd->SdCard.CardType != CARD_SDHC_SDXC)
 80059dc:	68fb      	ldr	r3, [r7, #12]
 80059de:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80059e0:	2b01      	cmp	r3, #1
 80059e2:	d002      	beq.n	80059ea <HAL_SD_WriteBlocks_DMA+0x86>
    {
      add *= BLOCKSIZE;
 80059e4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80059e6:	025b      	lsls	r3, r3, #9
 80059e8:	62bb      	str	r3, [r7, #40]	@ 0x28
    }

    /* Configure the SD DPSM (Data Path State Machine) */
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
 80059ea:	f04f 33ff 	mov.w	r3, #4294967295
 80059ee:	613b      	str	r3, [r7, #16]
    config.DataLength    = BLOCKSIZE * NumberOfBlocks;
 80059f0:	683b      	ldr	r3, [r7, #0]
 80059f2:	025b      	lsls	r3, r3, #9
 80059f4:	617b      	str	r3, [r7, #20]
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
 80059f6:	2390      	movs	r3, #144	@ 0x90
 80059f8:	61bb      	str	r3, [r7, #24]
    config.TransferDir   = SDMMC_TRANSFER_DIR_TO_CARD;
 80059fa:	2300      	movs	r3, #0
 80059fc:	61fb      	str	r3, [r7, #28]
    config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
 80059fe:	2300      	movs	r3, #0
 8005a00:	623b      	str	r3, [r7, #32]
    config.DPSM          = SDMMC_DPSM_DISABLE;
 8005a02:	2300      	movs	r3, #0
 8005a04:	627b      	str	r3, [r7, #36]	@ 0x24
    (void)SDMMC_ConfigData(hsd->Instance, &config);
 8005a06:	68fb      	ldr	r3, [r7, #12]
 8005a08:	681b      	ldr	r3, [r3, #0]
 8005a0a:	f107 0210 	add.w	r2, r7, #16
 8005a0e:	4611      	mov	r1, r2
 8005a10:	4618      	mov	r0, r3
 8005a12:	f001 ff3f 	bl	8007894 <SDMMC_ConfigData>

    __SDMMC_CMDTRANS_ENABLE(hsd->Instance);
 8005a16:	68fb      	ldr	r3, [r7, #12]
 8005a18:	681b      	ldr	r3, [r3, #0]
 8005a1a:	68da      	ldr	r2, [r3, #12]
 8005a1c:	68fb      	ldr	r3, [r7, #12]
 8005a1e:	681b      	ldr	r3, [r3, #0]
 8005a20:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 8005a24:	60da      	str	r2, [r3, #12]

    hsd->Instance->IDMABASER = (uint32_t) pData ;
 8005a26:	68fb      	ldr	r3, [r7, #12]
 8005a28:	681b      	ldr	r3, [r3, #0]
 8005a2a:	68ba      	ldr	r2, [r7, #8]
 8005a2c:	659a      	str	r2, [r3, #88]	@ 0x58
    hsd->Instance->IDMACTRL  = SDMMC_ENABLE_IDMA_SINGLE_BUFF;
 8005a2e:	68fb      	ldr	r3, [r7, #12]
 8005a30:	681b      	ldr	r3, [r3, #0]
 8005a32:	2201      	movs	r2, #1
 8005a34:	651a      	str	r2, [r3, #80]	@ 0x50

    /* Write Blocks in Polling mode */
    if (NumberOfBlocks > 1U)
 8005a36:	683b      	ldr	r3, [r7, #0]
 8005a38:	2b01      	cmp	r3, #1
 8005a3a:	d90a      	bls.n	8005a52 <HAL_SD_WriteBlocks_DMA+0xee>
    {
      hsd->Context = (SD_CONTEXT_WRITE_MULTIPLE_BLOCK | SD_CONTEXT_DMA);
 8005a3c:	68fb      	ldr	r3, [r7, #12]
 8005a3e:	22a0      	movs	r2, #160	@ 0xa0
 8005a40:	62da      	str	r2, [r3, #44]	@ 0x2c

      /* Write Multi Block command */
      errorstate = SDMMC_CmdWriteMultiBlock(hsd->Instance, add);
 8005a42:	68fb      	ldr	r3, [r7, #12]
 8005a44:	681b      	ldr	r3, [r3, #0]
 8005a46:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 8005a48:	4618      	mov	r0, r3
 8005a4a:	f001 ffdb 	bl	8007a04 <SDMMC_CmdWriteMultiBlock>
 8005a4e:	62f8      	str	r0, [r7, #44]	@ 0x2c
 8005a50:	e009      	b.n	8005a66 <HAL_SD_WriteBlocks_DMA+0x102>
    }
    else
    {
      hsd->Context = (SD_CONTEXT_WRITE_SINGLE_BLOCK | SD_CONTEXT_DMA);
 8005a52:	68fb      	ldr	r3, [r7, #12]
 8005a54:	2290      	movs	r2, #144	@ 0x90
 8005a56:	62da      	str	r2, [r3, #44]	@ 0x2c

      /* Write Single Block command */
      errorstate = SDMMC_CmdWriteSingleBlock(hsd->Instance, add);
 8005a58:	68fb      	ldr	r3, [r7, #12]
 8005a5a:	681b      	ldr	r3, [r3, #0]
 8005a5c:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 8005a5e:	4618      	mov	r0, r3
 8005a60:	f001 ffad 	bl	80079be <SDMMC_CmdWriteSingleBlock>
 8005a64:	62f8      	str	r0, [r7, #44]	@ 0x2c
    }
    if (errorstate != HAL_SD_ERROR_NONE)
 8005a66:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8005a68:	2b00      	cmp	r3, #0
 8005a6a:	d012      	beq.n	8005a92 <HAL_SD_WriteBlocks_DMA+0x12e>
    {
      /* Clear all the static flags */
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8005a6c:	68fb      	ldr	r3, [r7, #12]
 8005a6e:	681b      	ldr	r3, [r3, #0]
 8005a70:	4a0f      	ldr	r2, [pc, #60]	@ (8005ab0 <HAL_SD_WriteBlocks_DMA+0x14c>)
 8005a72:	639a      	str	r2, [r3, #56]	@ 0x38
      hsd->ErrorCode |= errorstate;
 8005a74:	68fb      	ldr	r3, [r7, #12]
 8005a76:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8005a78:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8005a7a:	431a      	orrs	r2, r3
 8005a7c:	68fb      	ldr	r3, [r7, #12]
 8005a7e:	635a      	str	r2, [r3, #52]	@ 0x34
      hsd->State = HAL_SD_STATE_READY;
 8005a80:	68fb      	ldr	r3, [r7, #12]
 8005a82:	2201      	movs	r2, #1
 8005a84:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
      hsd->Context = SD_CONTEXT_NONE;
 8005a88:	68fb      	ldr	r3, [r7, #12]
 8005a8a:	2200      	movs	r2, #0
 8005a8c:	62da      	str	r2, [r3, #44]	@ 0x2c
      return HAL_ERROR;
 8005a8e:	2301      	movs	r3, #1
 8005a90:	e00a      	b.n	8005aa8 <HAL_SD_WriteBlocks_DMA+0x144>
    }

    /* Enable transfer interrupts */
    __HAL_SD_ENABLE_IT(hsd, (SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT | SDMMC_IT_TXUNDERR | SDMMC_IT_DATAEND));
 8005a92:	68fb      	ldr	r3, [r7, #12]
 8005a94:	681b      	ldr	r3, [r3, #0]
 8005a96:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 8005a98:	68fb      	ldr	r3, [r7, #12]
 8005a9a:	681b      	ldr	r3, [r3, #0]
 8005a9c:	f442 728d 	orr.w	r2, r2, #282	@ 0x11a
 8005aa0:	63da      	str	r2, [r3, #60]	@ 0x3c

    return HAL_OK;
 8005aa2:	2300      	movs	r3, #0
 8005aa4:	e000      	b.n	8005aa8 <HAL_SD_WriteBlocks_DMA+0x144>
  }
  else
  {
    return HAL_BUSY;
 8005aa6:	2302      	movs	r3, #2
  }
}
 8005aa8:	4618      	mov	r0, r3
 8005aaa:	3730      	adds	r7, #48	@ 0x30
 8005aac:	46bd      	mov	sp, r7
 8005aae:	bd80      	pop	{r7, pc}
 8005ab0:	1fe00fff 	.word	0x1fe00fff

08005ab4 <HAL_SD_IRQHandler>:
  * @brief  This function handles SD card interrupt request.
  * @param  hsd: Pointer to SD handle
  * @retval None
  */
void HAL_SD_IRQHandler(SD_HandleTypeDef *hsd)
{
 8005ab4:	b580      	push	{r7, lr}
 8005ab6:	b084      	sub	sp, #16
 8005ab8:	af00      	add	r7, sp, #0
 8005aba:	6078      	str	r0, [r7, #4]
  uint32_t errorstate;
  uint32_t context = hsd->Context;
 8005abc:	687b      	ldr	r3, [r7, #4]
 8005abe:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8005ac0:	60fb      	str	r3, [r7, #12]

  /* Check for SDMMC interrupt flags */
  if ((__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF) != RESET) && ((context & SD_CONTEXT_IT) != 0U))
 8005ac2:	687b      	ldr	r3, [r7, #4]
 8005ac4:	681b      	ldr	r3, [r3, #0]
 8005ac6:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8005ac8:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 8005acc:	2b00      	cmp	r3, #0
 8005ace:	d008      	beq.n	8005ae2 <HAL_SD_IRQHandler+0x2e>
 8005ad0:	68fb      	ldr	r3, [r7, #12]
 8005ad2:	f003 0308 	and.w	r3, r3, #8
 8005ad6:	2b00      	cmp	r3, #0
 8005ad8:	d003      	beq.n	8005ae2 <HAL_SD_IRQHandler+0x2e>
  {
    SD_Read_IT(hsd);
 8005ada:	6878      	ldr	r0, [r7, #4]
 8005adc:	f001 f8e4 	bl	8006ca8 <SD_Read_IT>
 8005ae0:	e186      	b.n	8005df0 <HAL_SD_IRQHandler+0x33c>
  }

  else if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DATAEND) != RESET)
 8005ae2:	687b      	ldr	r3, [r7, #4]
 8005ae4:	681b      	ldr	r3, [r3, #0]
 8005ae6:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8005ae8:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8005aec:	2b00      	cmp	r3, #0
 8005aee:	f000 80ae 	beq.w	8005c4e <HAL_SD_IRQHandler+0x19a>
  {
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DATAEND);
 8005af2:	687b      	ldr	r3, [r7, #4]
 8005af4:	681b      	ldr	r3, [r3, #0]
 8005af6:	f44f 7280 	mov.w	r2, #256	@ 0x100
 8005afa:	639a      	str	r2, [r3, #56]	@ 0x38

    __HAL_SD_DISABLE_IT(hsd, SDMMC_IT_DATAEND  | SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT | \
 8005afc:	687b      	ldr	r3, [r7, #4]
 8005afe:	681b      	ldr	r3, [r3, #0]
 8005b00:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8005b02:	687a      	ldr	r2, [r7, #4]
 8005b04:	6812      	ldr	r2, [r2, #0]
 8005b06:	f423 4341 	bic.w	r3, r3, #49408	@ 0xc100
 8005b0a:	f023 033a 	bic.w	r3, r3, #58	@ 0x3a
 8005b0e:	63d3      	str	r3, [r2, #60]	@ 0x3c
                        SDMMC_IT_TXUNDERR | SDMMC_IT_RXOVERR  | SDMMC_IT_TXFIFOHE | \
                        SDMMC_IT_RXFIFOHF);

    __HAL_SD_DISABLE_IT(hsd, SDMMC_IT_IDMABTC);
 8005b10:	687b      	ldr	r3, [r7, #4]
 8005b12:	681b      	ldr	r3, [r3, #0]
 8005b14:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 8005b16:	687b      	ldr	r3, [r7, #4]
 8005b18:	681b      	ldr	r3, [r3, #0]
 8005b1a:	f022 5280 	bic.w	r2, r2, #268435456	@ 0x10000000
 8005b1e:	63da      	str	r2, [r3, #60]	@ 0x3c
    __SDMMC_CMDTRANS_DISABLE(hsd->Instance);
 8005b20:	687b      	ldr	r3, [r7, #4]
 8005b22:	681b      	ldr	r3, [r3, #0]
 8005b24:	68da      	ldr	r2, [r3, #12]
 8005b26:	687b      	ldr	r3, [r7, #4]
 8005b28:	681b      	ldr	r3, [r3, #0]
 8005b2a:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
 8005b2e:	60da      	str	r2, [r3, #12]

    if ((context & SD_CONTEXT_IT) != 0U)
 8005b30:	68fb      	ldr	r3, [r7, #12]
 8005b32:	f003 0308 	and.w	r3, r3, #8
 8005b36:	2b00      	cmp	r3, #0
 8005b38:	d038      	beq.n	8005bac <HAL_SD_IRQHandler+0xf8>
    {
      if (((context & SD_CONTEXT_READ_MULTIPLE_BLOCK) != 0U) || ((context & SD_CONTEXT_WRITE_MULTIPLE_BLOCK) != 0U))
 8005b3a:	68fb      	ldr	r3, [r7, #12]
 8005b3c:	f003 0302 	and.w	r3, r3, #2
 8005b40:	2b00      	cmp	r3, #0
 8005b42:	d104      	bne.n	8005b4e <HAL_SD_IRQHandler+0x9a>
 8005b44:	68fb      	ldr	r3, [r7, #12]
 8005b46:	f003 0320 	and.w	r3, r3, #32
 8005b4a:	2b00      	cmp	r3, #0
 8005b4c:	d011      	beq.n	8005b72 <HAL_SD_IRQHandler+0xbe>
      {
        errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
 8005b4e:	687b      	ldr	r3, [r7, #4]
 8005b50:	681b      	ldr	r3, [r3, #0]
 8005b52:	4618      	mov	r0, r3
 8005b54:	f001 ff7a 	bl	8007a4c <SDMMC_CmdStopTransfer>
 8005b58:	60b8      	str	r0, [r7, #8]
        if (errorstate != HAL_SD_ERROR_NONE)
 8005b5a:	68bb      	ldr	r3, [r7, #8]
 8005b5c:	2b00      	cmp	r3, #0
 8005b5e:	d008      	beq.n	8005b72 <HAL_SD_IRQHandler+0xbe>
        {
          hsd->ErrorCode |= errorstate;
 8005b60:	687b      	ldr	r3, [r7, #4]
 8005b62:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8005b64:	68bb      	ldr	r3, [r7, #8]
 8005b66:	431a      	orrs	r2, r3
 8005b68:	687b      	ldr	r3, [r7, #4]
 8005b6a:	635a      	str	r2, [r3, #52]	@ 0x34
#if defined (USE_HAL_SD_REGISTER_CALLBACKS) && (USE_HAL_SD_REGISTER_CALLBACKS == 1U)
          hsd->ErrorCallback(hsd);
#else
          HAL_SD_ErrorCallback(hsd);
 8005b6c:	6878      	ldr	r0, [r7, #4]
 8005b6e:	f000 f943 	bl	8005df8 <HAL_SD_ErrorCallback>
#endif /* USE_HAL_SD_REGISTER_CALLBACKS */
        }
      }

      /* Clear all the static flags */
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 8005b72:	687b      	ldr	r3, [r7, #4]
 8005b74:	681b      	ldr	r3, [r3, #0]
 8005b76:	4a9b      	ldr	r2, [pc, #620]	@ (8005de4 <HAL_SD_IRQHandler+0x330>)
 8005b78:	639a      	str	r2, [r3, #56]	@ 0x38

      hsd->State = HAL_SD_STATE_READY;
 8005b7a:	687b      	ldr	r3, [r7, #4]
 8005b7c:	2201      	movs	r2, #1
 8005b7e:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
      hsd->Context = SD_CONTEXT_NONE;
 8005b82:	687b      	ldr	r3, [r7, #4]
 8005b84:	2200      	movs	r2, #0
 8005b86:	62da      	str	r2, [r3, #44]	@ 0x2c
      if (((context & SD_CONTEXT_READ_SINGLE_BLOCK) != 0U) || ((context & SD_CONTEXT_READ_MULTIPLE_BLOCK) != 0U))
 8005b88:	68fb      	ldr	r3, [r7, #12]
 8005b8a:	f003 0301 	and.w	r3, r3, #1
 8005b8e:	2b00      	cmp	r3, #0
 8005b90:	d104      	bne.n	8005b9c <HAL_SD_IRQHandler+0xe8>
 8005b92:	68fb      	ldr	r3, [r7, #12]
 8005b94:	f003 0302 	and.w	r3, r3, #2
 8005b98:	2b00      	cmp	r3, #0
 8005b9a:	d003      	beq.n	8005ba4 <HAL_SD_IRQHandler+0xf0>
      {
#if defined (USE_HAL_SD_REGISTER_CALLBACKS) && (USE_HAL_SD_REGISTER_CALLBACKS == 1U)
        hsd->RxCpltCallback(hsd);
#else
        HAL_SD_RxCpltCallback(hsd);
 8005b9c:	6878      	ldr	r0, [r7, #4]
 8005b9e:	f002 fcd1 	bl	8008544 <HAL_SD_RxCpltCallback>
 8005ba2:	e125      	b.n	8005df0 <HAL_SD_IRQHandler+0x33c>
      else
      {
#if defined (USE_HAL_SD_REGISTER_CALLBACKS) && (USE_HAL_SD_REGISTER_CALLBACKS == 1U)
        hsd->TxCpltCallback(hsd);
#else
        HAL_SD_TxCpltCallback(hsd);
 8005ba4:	6878      	ldr	r0, [r7, #4]
 8005ba6:	f002 fcbd 	bl	8008524 <HAL_SD_TxCpltCallback>
  }
  else
  {
    /* Nothing to do */
  }
}
 8005baa:	e121      	b.n	8005df0 <HAL_SD_IRQHandler+0x33c>
    else if ((context & SD_CONTEXT_DMA) != 0U)
 8005bac:	68fb      	ldr	r3, [r7, #12]
 8005bae:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8005bb2:	2b00      	cmp	r3, #0
 8005bb4:	f000 811c 	beq.w	8005df0 <HAL_SD_IRQHandler+0x33c>
      hsd->Instance->DLEN = 0;
 8005bb8:	687b      	ldr	r3, [r7, #4]
 8005bba:	681b      	ldr	r3, [r3, #0]
 8005bbc:	2200      	movs	r2, #0
 8005bbe:	629a      	str	r2, [r3, #40]	@ 0x28
      hsd->Instance->DCTRL = 0;
 8005bc0:	687b      	ldr	r3, [r7, #4]
 8005bc2:	681b      	ldr	r3, [r3, #0]
 8005bc4:	2200      	movs	r2, #0
 8005bc6:	62da      	str	r2, [r3, #44]	@ 0x2c
      hsd->Instance->IDMACTRL = SDMMC_DISABLE_IDMA;
 8005bc8:	687b      	ldr	r3, [r7, #4]
 8005bca:	681b      	ldr	r3, [r3, #0]
 8005bcc:	2200      	movs	r2, #0
 8005bce:	651a      	str	r2, [r3, #80]	@ 0x50
      if (((context & SD_CONTEXT_READ_MULTIPLE_BLOCK) != 0U) || ((context & SD_CONTEXT_WRITE_MULTIPLE_BLOCK) != 0U))
 8005bd0:	68fb      	ldr	r3, [r7, #12]
 8005bd2:	f003 0302 	and.w	r3, r3, #2
 8005bd6:	2b00      	cmp	r3, #0
 8005bd8:	d104      	bne.n	8005be4 <HAL_SD_IRQHandler+0x130>
 8005bda:	68fb      	ldr	r3, [r7, #12]
 8005bdc:	f003 0320 	and.w	r3, r3, #32
 8005be0:	2b00      	cmp	r3, #0
 8005be2:	d011      	beq.n	8005c08 <HAL_SD_IRQHandler+0x154>
        errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
 8005be4:	687b      	ldr	r3, [r7, #4]
 8005be6:	681b      	ldr	r3, [r3, #0]
 8005be8:	4618      	mov	r0, r3
 8005bea:	f001 ff2f 	bl	8007a4c <SDMMC_CmdStopTransfer>
 8005bee:	60b8      	str	r0, [r7, #8]
        if (errorstate != HAL_SD_ERROR_NONE)
 8005bf0:	68bb      	ldr	r3, [r7, #8]
 8005bf2:	2b00      	cmp	r3, #0
 8005bf4:	d008      	beq.n	8005c08 <HAL_SD_IRQHandler+0x154>
          hsd->ErrorCode |= errorstate;
 8005bf6:	687b      	ldr	r3, [r7, #4]
 8005bf8:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8005bfa:	68bb      	ldr	r3, [r7, #8]
 8005bfc:	431a      	orrs	r2, r3
 8005bfe:	687b      	ldr	r3, [r7, #4]
 8005c00:	635a      	str	r2, [r3, #52]	@ 0x34
          HAL_SD_ErrorCallback(hsd);
 8005c02:	6878      	ldr	r0, [r7, #4]
 8005c04:	f000 f8f8 	bl	8005df8 <HAL_SD_ErrorCallback>
      hsd->State = HAL_SD_STATE_READY;
 8005c08:	687b      	ldr	r3, [r7, #4]
 8005c0a:	2201      	movs	r2, #1
 8005c0c:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
      hsd->Context = SD_CONTEXT_NONE;
 8005c10:	687b      	ldr	r3, [r7, #4]
 8005c12:	2200      	movs	r2, #0
 8005c14:	62da      	str	r2, [r3, #44]	@ 0x2c
      if (((context & SD_CONTEXT_WRITE_SINGLE_BLOCK) != 0U) || ((context & SD_CONTEXT_WRITE_MULTIPLE_BLOCK) != 0U))
 8005c16:	68fb      	ldr	r3, [r7, #12]
 8005c18:	f003 0310 	and.w	r3, r3, #16
 8005c1c:	2b00      	cmp	r3, #0
 8005c1e:	d104      	bne.n	8005c2a <HAL_SD_IRQHandler+0x176>
 8005c20:	68fb      	ldr	r3, [r7, #12]
 8005c22:	f003 0320 	and.w	r3, r3, #32
 8005c26:	2b00      	cmp	r3, #0
 8005c28:	d002      	beq.n	8005c30 <HAL_SD_IRQHandler+0x17c>
        HAL_SD_TxCpltCallback(hsd);
 8005c2a:	6878      	ldr	r0, [r7, #4]
 8005c2c:	f002 fc7a 	bl	8008524 <HAL_SD_TxCpltCallback>
      if (((context & SD_CONTEXT_READ_SINGLE_BLOCK) != 0U) || ((context & SD_CONTEXT_READ_MULTIPLE_BLOCK) != 0U))
 8005c30:	68fb      	ldr	r3, [r7, #12]
 8005c32:	f003 0301 	and.w	r3, r3, #1
 8005c36:	2b00      	cmp	r3, #0
 8005c38:	d105      	bne.n	8005c46 <HAL_SD_IRQHandler+0x192>
 8005c3a:	68fb      	ldr	r3, [r7, #12]
 8005c3c:	f003 0302 	and.w	r3, r3, #2
 8005c40:	2b00      	cmp	r3, #0
 8005c42:	f000 80d5 	beq.w	8005df0 <HAL_SD_IRQHandler+0x33c>
        HAL_SD_RxCpltCallback(hsd);
 8005c46:	6878      	ldr	r0, [r7, #4]
 8005c48:	f002 fc7c 	bl	8008544 <HAL_SD_RxCpltCallback>
}
 8005c4c:	e0d0      	b.n	8005df0 <HAL_SD_IRQHandler+0x33c>
  else if ((__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXFIFOHE) != RESET) && ((context & SD_CONTEXT_IT) != 0U))
 8005c4e:	687b      	ldr	r3, [r7, #4]
 8005c50:	681b      	ldr	r3, [r3, #0]
 8005c52:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8005c54:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 8005c58:	2b00      	cmp	r3, #0
 8005c5a:	d008      	beq.n	8005c6e <HAL_SD_IRQHandler+0x1ba>
 8005c5c:	68fb      	ldr	r3, [r7, #12]
 8005c5e:	f003 0308 	and.w	r3, r3, #8
 8005c62:	2b00      	cmp	r3, #0
 8005c64:	d003      	beq.n	8005c6e <HAL_SD_IRQHandler+0x1ba>
    SD_Write_IT(hsd);
 8005c66:	6878      	ldr	r0, [r7, #4]
 8005c68:	f001 f864 	bl	8006d34 <SD_Write_IT>
 8005c6c:	e0c0      	b.n	8005df0 <HAL_SD_IRQHandler+0x33c>
  else if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_RXOVERR |
 8005c6e:	687b      	ldr	r3, [r7, #4]
 8005c70:	681b      	ldr	r3, [r3, #0]
 8005c72:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8005c74:	f003 033a 	and.w	r3, r3, #58	@ 0x3a
 8005c78:	2b00      	cmp	r3, #0
 8005c7a:	f000 809d 	beq.w	8005db8 <HAL_SD_IRQHandler+0x304>
    if (__HAL_SD_GET_FLAG(hsd, SDMMC_IT_DCRCFAIL) != RESET)
 8005c7e:	687b      	ldr	r3, [r7, #4]
 8005c80:	681b      	ldr	r3, [r3, #0]
 8005c82:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8005c84:	f003 0302 	and.w	r3, r3, #2
 8005c88:	2b00      	cmp	r3, #0
 8005c8a:	d005      	beq.n	8005c98 <HAL_SD_IRQHandler+0x1e4>
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_CRC_FAIL;
 8005c8c:	687b      	ldr	r3, [r7, #4]
 8005c8e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8005c90:	f043 0202 	orr.w	r2, r3, #2
 8005c94:	687b      	ldr	r3, [r7, #4]
 8005c96:	635a      	str	r2, [r3, #52]	@ 0x34
    if (__HAL_SD_GET_FLAG(hsd, SDMMC_IT_DTIMEOUT) != RESET)
 8005c98:	687b      	ldr	r3, [r7, #4]
 8005c9a:	681b      	ldr	r3, [r3, #0]
 8005c9c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8005c9e:	f003 0308 	and.w	r3, r3, #8
 8005ca2:	2b00      	cmp	r3, #0
 8005ca4:	d005      	beq.n	8005cb2 <HAL_SD_IRQHandler+0x1fe>
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT;
 8005ca6:	687b      	ldr	r3, [r7, #4]
 8005ca8:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8005caa:	f043 0208 	orr.w	r2, r3, #8
 8005cae:	687b      	ldr	r3, [r7, #4]
 8005cb0:	635a      	str	r2, [r3, #52]	@ 0x34
    if (__HAL_SD_GET_FLAG(hsd, SDMMC_IT_RXOVERR) != RESET)
 8005cb2:	687b      	ldr	r3, [r7, #4]
 8005cb4:	681b      	ldr	r3, [r3, #0]
 8005cb6:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8005cb8:	f003 0320 	and.w	r3, r3, #32
 8005cbc:	2b00      	cmp	r3, #0
 8005cbe:	d005      	beq.n	8005ccc <HAL_SD_IRQHandler+0x218>
      hsd->ErrorCode |= HAL_SD_ERROR_RX_OVERRUN;
 8005cc0:	687b      	ldr	r3, [r7, #4]
 8005cc2:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8005cc4:	f043 0220 	orr.w	r2, r3, #32
 8005cc8:	687b      	ldr	r3, [r7, #4]
 8005cca:	635a      	str	r2, [r3, #52]	@ 0x34
    if (__HAL_SD_GET_FLAG(hsd, SDMMC_IT_TXUNDERR) != RESET)
 8005ccc:	687b      	ldr	r3, [r7, #4]
 8005cce:	681b      	ldr	r3, [r3, #0]
 8005cd0:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8005cd2:	f003 0310 	and.w	r3, r3, #16
 8005cd6:	2b00      	cmp	r3, #0
 8005cd8:	d005      	beq.n	8005ce6 <HAL_SD_IRQHandler+0x232>
      hsd->ErrorCode |= HAL_SD_ERROR_TX_UNDERRUN;
 8005cda:	687b      	ldr	r3, [r7, #4]
 8005cdc:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8005cde:	f043 0210 	orr.w	r2, r3, #16
 8005ce2:	687b      	ldr	r3, [r7, #4]
 8005ce4:	635a      	str	r2, [r3, #52]	@ 0x34
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 8005ce6:	687b      	ldr	r3, [r7, #4]
 8005ce8:	681b      	ldr	r3, [r3, #0]
 8005cea:	4a3e      	ldr	r2, [pc, #248]	@ (8005de4 <HAL_SD_IRQHandler+0x330>)
 8005cec:	639a      	str	r2, [r3, #56]	@ 0x38
    __HAL_SD_DISABLE_IT(hsd, SDMMC_IT_DATAEND | SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT | \
 8005cee:	687b      	ldr	r3, [r7, #4]
 8005cf0:	681b      	ldr	r3, [r3, #0]
 8005cf2:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 8005cf4:	687b      	ldr	r3, [r7, #4]
 8005cf6:	681b      	ldr	r3, [r3, #0]
 8005cf8:	f422 729d 	bic.w	r2, r2, #314	@ 0x13a
 8005cfc:	63da      	str	r2, [r3, #60]	@ 0x3c
    __SDMMC_CMDTRANS_DISABLE(hsd->Instance);
 8005cfe:	687b      	ldr	r3, [r7, #4]
 8005d00:	681b      	ldr	r3, [r3, #0]
 8005d02:	68da      	ldr	r2, [r3, #12]
 8005d04:	687b      	ldr	r3, [r7, #4]
 8005d06:	681b      	ldr	r3, [r3, #0]
 8005d08:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
 8005d0c:	60da      	str	r2, [r3, #12]
    hsd->Instance->DCTRL |= SDMMC_DCTRL_FIFORST;
 8005d0e:	687b      	ldr	r3, [r7, #4]
 8005d10:	681b      	ldr	r3, [r3, #0]
 8005d12:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8005d14:	687b      	ldr	r3, [r7, #4]
 8005d16:	681b      	ldr	r3, [r3, #0]
 8005d18:	f442 5200 	orr.w	r2, r2, #8192	@ 0x2000
 8005d1c:	62da      	str	r2, [r3, #44]	@ 0x2c
    hsd->Instance->CMD |= SDMMC_CMD_CMDSTOP;
 8005d1e:	687b      	ldr	r3, [r7, #4]
 8005d20:	681b      	ldr	r3, [r3, #0]
 8005d22:	68da      	ldr	r2, [r3, #12]
 8005d24:	687b      	ldr	r3, [r7, #4]
 8005d26:	681b      	ldr	r3, [r3, #0]
 8005d28:	f042 0280 	orr.w	r2, r2, #128	@ 0x80
 8005d2c:	60da      	str	r2, [r3, #12]
    hsd->ErrorCode |= SDMMC_CmdStopTransfer(hsd->Instance);
 8005d2e:	687b      	ldr	r3, [r7, #4]
 8005d30:	681b      	ldr	r3, [r3, #0]
 8005d32:	4618      	mov	r0, r3
 8005d34:	f001 fe8a 	bl	8007a4c <SDMMC_CmdStopTransfer>
 8005d38:	4602      	mov	r2, r0
 8005d3a:	687b      	ldr	r3, [r7, #4]
 8005d3c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8005d3e:	431a      	orrs	r2, r3
 8005d40:	687b      	ldr	r3, [r7, #4]
 8005d42:	635a      	str	r2, [r3, #52]	@ 0x34
    hsd->Instance->CMD &= ~(SDMMC_CMD_CMDSTOP);
 8005d44:	687b      	ldr	r3, [r7, #4]
 8005d46:	681b      	ldr	r3, [r3, #0]
 8005d48:	68da      	ldr	r2, [r3, #12]
 8005d4a:	687b      	ldr	r3, [r7, #4]
 8005d4c:	681b      	ldr	r3, [r3, #0]
 8005d4e:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
 8005d52:	60da      	str	r2, [r3, #12]
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DABORT);
 8005d54:	687b      	ldr	r3, [r7, #4]
 8005d56:	681b      	ldr	r3, [r3, #0]
 8005d58:	f44f 6200 	mov.w	r2, #2048	@ 0x800
 8005d5c:	639a      	str	r2, [r3, #56]	@ 0x38
    if ((context & SD_CONTEXT_IT) != 0U)
 8005d5e:	68fb      	ldr	r3, [r7, #12]
 8005d60:	f003 0308 	and.w	r3, r3, #8
 8005d64:	2b00      	cmp	r3, #0
 8005d66:	d00a      	beq.n	8005d7e <HAL_SD_IRQHandler+0x2ca>
      hsd->State = HAL_SD_STATE_READY;
 8005d68:	687b      	ldr	r3, [r7, #4]
 8005d6a:	2201      	movs	r2, #1
 8005d6c:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
      hsd->Context = SD_CONTEXT_NONE;
 8005d70:	687b      	ldr	r3, [r7, #4]
 8005d72:	2200      	movs	r2, #0
 8005d74:	62da      	str	r2, [r3, #44]	@ 0x2c
      HAL_SD_ErrorCallback(hsd);
 8005d76:	6878      	ldr	r0, [r7, #4]
 8005d78:	f000 f83e 	bl	8005df8 <HAL_SD_ErrorCallback>
}
 8005d7c:	e038      	b.n	8005df0 <HAL_SD_IRQHandler+0x33c>
    else if ((context & SD_CONTEXT_DMA) != 0U)
 8005d7e:	68fb      	ldr	r3, [r7, #12]
 8005d80:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8005d84:	2b00      	cmp	r3, #0
 8005d86:	d033      	beq.n	8005df0 <HAL_SD_IRQHandler+0x33c>
      if (hsd->ErrorCode != HAL_SD_ERROR_NONE)
 8005d88:	687b      	ldr	r3, [r7, #4]
 8005d8a:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8005d8c:	2b00      	cmp	r3, #0
 8005d8e:	d02f      	beq.n	8005df0 <HAL_SD_IRQHandler+0x33c>
        __HAL_SD_DISABLE_IT(hsd, SDMMC_IT_IDMABTC);
 8005d90:	687b      	ldr	r3, [r7, #4]
 8005d92:	681b      	ldr	r3, [r3, #0]
 8005d94:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 8005d96:	687b      	ldr	r3, [r7, #4]
 8005d98:	681b      	ldr	r3, [r3, #0]
 8005d9a:	f022 5280 	bic.w	r2, r2, #268435456	@ 0x10000000
 8005d9e:	63da      	str	r2, [r3, #60]	@ 0x3c
        hsd->Instance->IDMACTRL = SDMMC_DISABLE_IDMA;
 8005da0:	687b      	ldr	r3, [r7, #4]
 8005da2:	681b      	ldr	r3, [r3, #0]
 8005da4:	2200      	movs	r2, #0
 8005da6:	651a      	str	r2, [r3, #80]	@ 0x50
        hsd->State = HAL_SD_STATE_READY;
 8005da8:	687b      	ldr	r3, [r7, #4]
 8005daa:	2201      	movs	r2, #1
 8005dac:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
        HAL_SD_ErrorCallback(hsd);
 8005db0:	6878      	ldr	r0, [r7, #4]
 8005db2:	f000 f821 	bl	8005df8 <HAL_SD_ErrorCallback>
}
 8005db6:	e01b      	b.n	8005df0 <HAL_SD_IRQHandler+0x33c>
  else if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_IDMABTC) != RESET)
 8005db8:	687b      	ldr	r3, [r7, #4]
 8005dba:	681b      	ldr	r3, [r3, #0]
 8005dbc:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8005dbe:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 8005dc2:	2b00      	cmp	r3, #0
 8005dc4:	d014      	beq.n	8005df0 <HAL_SD_IRQHandler+0x33c>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_IDMABTC);
 8005dc6:	687b      	ldr	r3, [r7, #4]
 8005dc8:	681b      	ldr	r3, [r3, #0]
 8005dca:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8005dce:	639a      	str	r2, [r3, #56]	@ 0x38
    if ((context & SD_CONTEXT_WRITE_MULTIPLE_BLOCK) != 0U)
 8005dd0:	68fb      	ldr	r3, [r7, #12]
 8005dd2:	f003 0320 	and.w	r3, r3, #32
 8005dd6:	2b00      	cmp	r3, #0
 8005dd8:	d006      	beq.n	8005de8 <HAL_SD_IRQHandler+0x334>
      HAL_SDEx_Write_DMALnkLstBufCpltCallback(hsd);
 8005dda:	6878      	ldr	r0, [r7, #4]
 8005ddc:	f000 fffe 	bl	8006ddc <HAL_SDEx_Write_DMALnkLstBufCpltCallback>
}
 8005de0:	e006      	b.n	8005df0 <HAL_SD_IRQHandler+0x33c>
 8005de2:	bf00      	nop
 8005de4:	18000f3a 	.word	0x18000f3a
      HAL_SDEx_Read_DMALnkLstBufCpltCallback(hsd);
 8005de8:	6878      	ldr	r0, [r7, #4]
 8005dea:	f000 ffed 	bl	8006dc8 <HAL_SDEx_Read_DMALnkLstBufCpltCallback>
}
 8005dee:	e7ff      	b.n	8005df0 <HAL_SD_IRQHandler+0x33c>
 8005df0:	bf00      	nop
 8005df2:	3710      	adds	r7, #16
 8005df4:	46bd      	mov	sp, r7
 8005df6:	bd80      	pop	{r7, pc}

08005df8 <HAL_SD_ErrorCallback>:
  * @brief SD error callbacks
  * @param hsd: Pointer SD handle
  * @retval None
  */
__weak void HAL_SD_ErrorCallback(SD_HandleTypeDef *hsd)
{
 8005df8:	b480      	push	{r7}
 8005dfa:	b083      	sub	sp, #12
 8005dfc:	af00      	add	r7, sp, #0
 8005dfe:	6078      	str	r0, [r7, #4]
  UNUSED(hsd);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SD_ErrorCallback can be implemented in the user file
   */
}
 8005e00:	bf00      	nop
 8005e02:	370c      	adds	r7, #12
 8005e04:	46bd      	mov	sp, r7
 8005e06:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005e0a:	4770      	bx	lr

08005e0c <HAL_SD_GetCardCSD>:
  * @param  pCSD: Pointer to a HAL_SD_CardCSDTypeDef structure that
  *         contains all CSD register parameters
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_GetCardCSD(SD_HandleTypeDef *hsd, HAL_SD_CardCSDTypeDef *pCSD)
{
 8005e0c:	b480      	push	{r7}
 8005e0e:	b083      	sub	sp, #12
 8005e10:	af00      	add	r7, sp, #0
 8005e12:	6078      	str	r0, [r7, #4]
 8005e14:	6039      	str	r1, [r7, #0]
  pCSD->CSDStruct = (uint8_t)((hsd->CSD[0] & 0xC0000000U) >> 30U);
 8005e16:	687b      	ldr	r3, [r7, #4]
 8005e18:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8005e1a:	0f9b      	lsrs	r3, r3, #30
 8005e1c:	b2da      	uxtb	r2, r3
 8005e1e:	683b      	ldr	r3, [r7, #0]
 8005e20:	701a      	strb	r2, [r3, #0]

  pCSD->SysSpecVersion = (uint8_t)((hsd->CSD[0] & 0x3C000000U) >> 26U);
 8005e22:	687b      	ldr	r3, [r7, #4]
 8005e24:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8005e26:	0e9b      	lsrs	r3, r3, #26
 8005e28:	b2db      	uxtb	r3, r3
 8005e2a:	f003 030f 	and.w	r3, r3, #15
 8005e2e:	b2da      	uxtb	r2, r3
 8005e30:	683b      	ldr	r3, [r7, #0]
 8005e32:	705a      	strb	r2, [r3, #1]

  pCSD->Reserved1 = (uint8_t)((hsd->CSD[0] & 0x03000000U) >> 24U);
 8005e34:	687b      	ldr	r3, [r7, #4]
 8005e36:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8005e38:	0e1b      	lsrs	r3, r3, #24
 8005e3a:	b2db      	uxtb	r3, r3
 8005e3c:	f003 0303 	and.w	r3, r3, #3
 8005e40:	b2da      	uxtb	r2, r3
 8005e42:	683b      	ldr	r3, [r7, #0]
 8005e44:	709a      	strb	r2, [r3, #2]

  pCSD->TAAC = (uint8_t)((hsd->CSD[0] & 0x00FF0000U) >> 16U);
 8005e46:	687b      	ldr	r3, [r7, #4]
 8005e48:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8005e4a:	0c1b      	lsrs	r3, r3, #16
 8005e4c:	b2da      	uxtb	r2, r3
 8005e4e:	683b      	ldr	r3, [r7, #0]
 8005e50:	70da      	strb	r2, [r3, #3]

  pCSD->NSAC = (uint8_t)((hsd->CSD[0] & 0x0000FF00U) >> 8U);
 8005e52:	687b      	ldr	r3, [r7, #4]
 8005e54:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8005e56:	0a1b      	lsrs	r3, r3, #8
 8005e58:	b2da      	uxtb	r2, r3
 8005e5a:	683b      	ldr	r3, [r7, #0]
 8005e5c:	711a      	strb	r2, [r3, #4]

  pCSD->MaxBusClkFrec = (uint8_t)(hsd->CSD[0] & 0x000000FFU);
 8005e5e:	687b      	ldr	r3, [r7, #4]
 8005e60:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8005e62:	b2da      	uxtb	r2, r3
 8005e64:	683b      	ldr	r3, [r7, #0]
 8005e66:	715a      	strb	r2, [r3, #5]

  pCSD->CardComdClasses = (uint16_t)((hsd->CSD[1] & 0xFFF00000U) >> 20U);
 8005e68:	687b      	ldr	r3, [r7, #4]
 8005e6a:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8005e6c:	0d1b      	lsrs	r3, r3, #20
 8005e6e:	b29a      	uxth	r2, r3
 8005e70:	683b      	ldr	r3, [r7, #0]
 8005e72:	80da      	strh	r2, [r3, #6]

  pCSD->RdBlockLen = (uint8_t)((hsd->CSD[1] & 0x000F0000U) >> 16U);
 8005e74:	687b      	ldr	r3, [r7, #4]
 8005e76:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8005e78:	0c1b      	lsrs	r3, r3, #16
 8005e7a:	b2db      	uxtb	r3, r3
 8005e7c:	f003 030f 	and.w	r3, r3, #15
 8005e80:	b2da      	uxtb	r2, r3
 8005e82:	683b      	ldr	r3, [r7, #0]
 8005e84:	721a      	strb	r2, [r3, #8]

  pCSD->PartBlockRead   = (uint8_t)((hsd->CSD[1] & 0x00008000U) >> 15U);
 8005e86:	687b      	ldr	r3, [r7, #4]
 8005e88:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8005e8a:	0bdb      	lsrs	r3, r3, #15
 8005e8c:	b2db      	uxtb	r3, r3
 8005e8e:	f003 0301 	and.w	r3, r3, #1
 8005e92:	b2da      	uxtb	r2, r3
 8005e94:	683b      	ldr	r3, [r7, #0]
 8005e96:	725a      	strb	r2, [r3, #9]

  pCSD->WrBlockMisalign = (uint8_t)((hsd->CSD[1] & 0x00004000U) >> 14U);
 8005e98:	687b      	ldr	r3, [r7, #4]
 8005e9a:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8005e9c:	0b9b      	lsrs	r3, r3, #14
 8005e9e:	b2db      	uxtb	r3, r3
 8005ea0:	f003 0301 	and.w	r3, r3, #1
 8005ea4:	b2da      	uxtb	r2, r3
 8005ea6:	683b      	ldr	r3, [r7, #0]
 8005ea8:	729a      	strb	r2, [r3, #10]

  pCSD->RdBlockMisalign = (uint8_t)((hsd->CSD[1] & 0x00002000U) >> 13U);
 8005eaa:	687b      	ldr	r3, [r7, #4]
 8005eac:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8005eae:	0b5b      	lsrs	r3, r3, #13
 8005eb0:	b2db      	uxtb	r3, r3
 8005eb2:	f003 0301 	and.w	r3, r3, #1
 8005eb6:	b2da      	uxtb	r2, r3
 8005eb8:	683b      	ldr	r3, [r7, #0]
 8005eba:	72da      	strb	r2, [r3, #11]

  pCSD->DSRImpl = (uint8_t)((hsd->CSD[1] & 0x00001000U) >> 12U);
 8005ebc:	687b      	ldr	r3, [r7, #4]
 8005ebe:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8005ec0:	0b1b      	lsrs	r3, r3, #12
 8005ec2:	b2db      	uxtb	r3, r3
 8005ec4:	f003 0301 	and.w	r3, r3, #1
 8005ec8:	b2da      	uxtb	r2, r3
 8005eca:	683b      	ldr	r3, [r7, #0]
 8005ecc:	731a      	strb	r2, [r3, #12]

  pCSD->Reserved2 = 0U; /*!< Reserved */
 8005ece:	683b      	ldr	r3, [r7, #0]
 8005ed0:	2200      	movs	r2, #0
 8005ed2:	735a      	strb	r2, [r3, #13]

  if (hsd->SdCard.CardType == CARD_SDSC)
 8005ed4:	687b      	ldr	r3, [r7, #4]
 8005ed6:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8005ed8:	2b00      	cmp	r3, #0
 8005eda:	d163      	bne.n	8005fa4 <HAL_SD_GetCardCSD+0x198>
  {
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x000003FFU) << 2U) | ((hsd->CSD[2] & 0xC0000000U) >> 30U));
 8005edc:	687b      	ldr	r3, [r7, #4]
 8005ede:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8005ee0:	009a      	lsls	r2, r3, #2
 8005ee2:	f640 73fc 	movw	r3, #4092	@ 0xffc
 8005ee6:	4013      	ands	r3, r2
 8005ee8:	687a      	ldr	r2, [r7, #4]
 8005eea:	6e52      	ldr	r2, [r2, #100]	@ 0x64
 8005eec:	0f92      	lsrs	r2, r2, #30
 8005eee:	431a      	orrs	r2, r3
 8005ef0:	683b      	ldr	r3, [r7, #0]
 8005ef2:	611a      	str	r2, [r3, #16]

    pCSD->MaxRdCurrentVDDMin = (uint8_t)((hsd->CSD[2] & 0x38000000U) >> 27U);
 8005ef4:	687b      	ldr	r3, [r7, #4]
 8005ef6:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8005ef8:	0edb      	lsrs	r3, r3, #27
 8005efa:	b2db      	uxtb	r3, r3
 8005efc:	f003 0307 	and.w	r3, r3, #7
 8005f00:	b2da      	uxtb	r2, r3
 8005f02:	683b      	ldr	r3, [r7, #0]
 8005f04:	751a      	strb	r2, [r3, #20]

    pCSD->MaxRdCurrentVDDMax = (uint8_t)((hsd->CSD[2] & 0x07000000U) >> 24U);
 8005f06:	687b      	ldr	r3, [r7, #4]
 8005f08:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8005f0a:	0e1b      	lsrs	r3, r3, #24
 8005f0c:	b2db      	uxtb	r3, r3
 8005f0e:	f003 0307 	and.w	r3, r3, #7
 8005f12:	b2da      	uxtb	r2, r3
 8005f14:	683b      	ldr	r3, [r7, #0]
 8005f16:	755a      	strb	r2, [r3, #21]

    pCSD->MaxWrCurrentVDDMin = (uint8_t)((hsd->CSD[2] & 0x00E00000U) >> 21U);
 8005f18:	687b      	ldr	r3, [r7, #4]
 8005f1a:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8005f1c:	0d5b      	lsrs	r3, r3, #21
 8005f1e:	b2db      	uxtb	r3, r3
 8005f20:	f003 0307 	and.w	r3, r3, #7
 8005f24:	b2da      	uxtb	r2, r3
 8005f26:	683b      	ldr	r3, [r7, #0]
 8005f28:	759a      	strb	r2, [r3, #22]

    pCSD->MaxWrCurrentVDDMax = (uint8_t)((hsd->CSD[2] & 0x001C0000U) >> 18U);
 8005f2a:	687b      	ldr	r3, [r7, #4]
 8005f2c:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8005f2e:	0c9b      	lsrs	r3, r3, #18
 8005f30:	b2db      	uxtb	r3, r3
 8005f32:	f003 0307 	and.w	r3, r3, #7
 8005f36:	b2da      	uxtb	r2, r3
 8005f38:	683b      	ldr	r3, [r7, #0]
 8005f3a:	75da      	strb	r2, [r3, #23]

    pCSD->DeviceSizeMul = (uint8_t)((hsd->CSD[2] & 0x00038000U) >> 15U);
 8005f3c:	687b      	ldr	r3, [r7, #4]
 8005f3e:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8005f40:	0bdb      	lsrs	r3, r3, #15
 8005f42:	b2db      	uxtb	r3, r3
 8005f44:	f003 0307 	and.w	r3, r3, #7
 8005f48:	b2da      	uxtb	r2, r3
 8005f4a:	683b      	ldr	r3, [r7, #0]
 8005f4c:	761a      	strb	r2, [r3, #24]

    hsd->SdCard.BlockNbr  = (pCSD->DeviceSize + 1U) ;
 8005f4e:	683b      	ldr	r3, [r7, #0]
 8005f50:	691b      	ldr	r3, [r3, #16]
 8005f52:	1c5a      	adds	r2, r3, #1
 8005f54:	687b      	ldr	r3, [r7, #4]
 8005f56:	649a      	str	r2, [r3, #72]	@ 0x48
    hsd->SdCard.BlockNbr *= (1UL << ((pCSD->DeviceSizeMul & 0x07U) + 2U));
 8005f58:	683b      	ldr	r3, [r7, #0]
 8005f5a:	7e1b      	ldrb	r3, [r3, #24]
 8005f5c:	b2db      	uxtb	r3, r3
 8005f5e:	f003 0307 	and.w	r3, r3, #7
 8005f62:	3302      	adds	r3, #2
 8005f64:	2201      	movs	r2, #1
 8005f66:	fa02 f303 	lsl.w	r3, r2, r3
 8005f6a:	687a      	ldr	r2, [r7, #4]
 8005f6c:	6c92      	ldr	r2, [r2, #72]	@ 0x48
 8005f6e:	fb03 f202 	mul.w	r2, r3, r2
 8005f72:	687b      	ldr	r3, [r7, #4]
 8005f74:	649a      	str	r2, [r3, #72]	@ 0x48
    hsd->SdCard.BlockSize = (1UL << (pCSD->RdBlockLen & 0x0FU));
 8005f76:	683b      	ldr	r3, [r7, #0]
 8005f78:	7a1b      	ldrb	r3, [r3, #8]
 8005f7a:	b2db      	uxtb	r3, r3
 8005f7c:	f003 030f 	and.w	r3, r3, #15
 8005f80:	2201      	movs	r2, #1
 8005f82:	409a      	lsls	r2, r3
 8005f84:	687b      	ldr	r3, [r7, #4]
 8005f86:	64da      	str	r2, [r3, #76]	@ 0x4c

    hsd->SdCard.LogBlockNbr = (hsd->SdCard.BlockNbr) * ((hsd->SdCard.BlockSize) / BLOCKSIZE);
 8005f88:	687b      	ldr	r3, [r7, #4]
 8005f8a:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8005f8c:	687a      	ldr	r2, [r7, #4]
 8005f8e:	6cd2      	ldr	r2, [r2, #76]	@ 0x4c
 8005f90:	0a52      	lsrs	r2, r2, #9
 8005f92:	fb03 f202 	mul.w	r2, r3, r2
 8005f96:	687b      	ldr	r3, [r7, #4]
 8005f98:	651a      	str	r2, [r3, #80]	@ 0x50
    hsd->SdCard.LogBlockSize = BLOCKSIZE;
 8005f9a:	687b      	ldr	r3, [r7, #4]
 8005f9c:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8005fa0:	655a      	str	r2, [r3, #84]	@ 0x54
 8005fa2:	e031      	b.n	8006008 <HAL_SD_GetCardCSD+0x1fc>
  }
  else if (hsd->SdCard.CardType == CARD_SDHC_SDXC)
 8005fa4:	687b      	ldr	r3, [r7, #4]
 8005fa6:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8005fa8:	2b01      	cmp	r3, #1
 8005faa:	d11d      	bne.n	8005fe8 <HAL_SD_GetCardCSD+0x1dc>
  {
    /* Byte 7 */
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x0000003FU) << 16U) | ((hsd->CSD[2] & 0xFFFF0000U) >> 16U));
 8005fac:	687b      	ldr	r3, [r7, #4]
 8005fae:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8005fb0:	041b      	lsls	r3, r3, #16
 8005fb2:	f403 127c 	and.w	r2, r3, #4128768	@ 0x3f0000
 8005fb6:	687b      	ldr	r3, [r7, #4]
 8005fb8:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8005fba:	0c1b      	lsrs	r3, r3, #16
 8005fbc:	431a      	orrs	r2, r3
 8005fbe:	683b      	ldr	r3, [r7, #0]
 8005fc0:	611a      	str	r2, [r3, #16]

    hsd->SdCard.BlockNbr = ((pCSD->DeviceSize + 1U) * 1024U);
 8005fc2:	683b      	ldr	r3, [r7, #0]
 8005fc4:	691b      	ldr	r3, [r3, #16]
 8005fc6:	3301      	adds	r3, #1
 8005fc8:	029a      	lsls	r2, r3, #10
 8005fca:	687b      	ldr	r3, [r7, #4]
 8005fcc:	649a      	str	r2, [r3, #72]	@ 0x48
    hsd->SdCard.LogBlockNbr = hsd->SdCard.BlockNbr;
 8005fce:	687b      	ldr	r3, [r7, #4]
 8005fd0:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
 8005fd2:	687b      	ldr	r3, [r7, #4]
 8005fd4:	651a      	str	r2, [r3, #80]	@ 0x50
    hsd->SdCard.BlockSize = BLOCKSIZE;
 8005fd6:	687b      	ldr	r3, [r7, #4]
 8005fd8:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8005fdc:	64da      	str	r2, [r3, #76]	@ 0x4c
    hsd->SdCard.LogBlockSize = hsd->SdCard.BlockSize;
 8005fde:	687b      	ldr	r3, [r7, #4]
 8005fe0:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8005fe2:	687b      	ldr	r3, [r7, #4]
 8005fe4:	655a      	str	r2, [r3, #84]	@ 0x54
 8005fe6:	e00f      	b.n	8006008 <HAL_SD_GetCardCSD+0x1fc>
  }
  else
  {
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8005fe8:	687b      	ldr	r3, [r7, #4]
 8005fea:	681b      	ldr	r3, [r3, #0]
 8005fec:	4a58      	ldr	r2, [pc, #352]	@ (8006150 <HAL_SD_GetCardCSD+0x344>)
 8005fee:	639a      	str	r2, [r3, #56]	@ 0x38
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 8005ff0:	687b      	ldr	r3, [r7, #4]
 8005ff2:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8005ff4:	f043 5280 	orr.w	r2, r3, #268435456	@ 0x10000000
 8005ff8:	687b      	ldr	r3, [r7, #4]
 8005ffa:	635a      	str	r2, [r3, #52]	@ 0x34
    hsd->State = HAL_SD_STATE_READY;
 8005ffc:	687b      	ldr	r3, [r7, #4]
 8005ffe:	2201      	movs	r2, #1
 8006000:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
    return HAL_ERROR;
 8006004:	2301      	movs	r3, #1
 8006006:	e09d      	b.n	8006144 <HAL_SD_GetCardCSD+0x338>
  }

  pCSD->EraseGrSize = (uint8_t)((hsd->CSD[2] & 0x00004000U) >> 14U);
 8006008:	687b      	ldr	r3, [r7, #4]
 800600a:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 800600c:	0b9b      	lsrs	r3, r3, #14
 800600e:	b2db      	uxtb	r3, r3
 8006010:	f003 0301 	and.w	r3, r3, #1
 8006014:	b2da      	uxtb	r2, r3
 8006016:	683b      	ldr	r3, [r7, #0]
 8006018:	765a      	strb	r2, [r3, #25]

  pCSD->EraseGrMul = (uint8_t)((hsd->CSD[2] & 0x00003F80U) >> 7U);
 800601a:	687b      	ldr	r3, [r7, #4]
 800601c:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 800601e:	09db      	lsrs	r3, r3, #7
 8006020:	b2db      	uxtb	r3, r3
 8006022:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8006026:	b2da      	uxtb	r2, r3
 8006028:	683b      	ldr	r3, [r7, #0]
 800602a:	769a      	strb	r2, [r3, #26]

  pCSD->WrProtectGrSize = (uint8_t)(hsd->CSD[2] & 0x0000007FU);
 800602c:	687b      	ldr	r3, [r7, #4]
 800602e:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8006030:	b2db      	uxtb	r3, r3
 8006032:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8006036:	b2da      	uxtb	r2, r3
 8006038:	683b      	ldr	r3, [r7, #0]
 800603a:	76da      	strb	r2, [r3, #27]

  pCSD->WrProtectGrEnable = (uint8_t)((hsd->CSD[3] & 0x80000000U) >> 31U);
 800603c:	687b      	ldr	r3, [r7, #4]
 800603e:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 8006040:	0fdb      	lsrs	r3, r3, #31
 8006042:	b2da      	uxtb	r2, r3
 8006044:	683b      	ldr	r3, [r7, #0]
 8006046:	771a      	strb	r2, [r3, #28]

  pCSD->ManDeflECC = (uint8_t)((hsd->CSD[3] & 0x60000000U) >> 29U);
 8006048:	687b      	ldr	r3, [r7, #4]
 800604a:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 800604c:	0f5b      	lsrs	r3, r3, #29
 800604e:	b2db      	uxtb	r3, r3
 8006050:	f003 0303 	and.w	r3, r3, #3
 8006054:	b2da      	uxtb	r2, r3
 8006056:	683b      	ldr	r3, [r7, #0]
 8006058:	775a      	strb	r2, [r3, #29]

  pCSD->WrSpeedFact = (uint8_t)((hsd->CSD[3] & 0x1C000000U) >> 26U);
 800605a:	687b      	ldr	r3, [r7, #4]
 800605c:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 800605e:	0e9b      	lsrs	r3, r3, #26
 8006060:	b2db      	uxtb	r3, r3
 8006062:	f003 0307 	and.w	r3, r3, #7
 8006066:	b2da      	uxtb	r2, r3
 8006068:	683b      	ldr	r3, [r7, #0]
 800606a:	779a      	strb	r2, [r3, #30]

  pCSD->MaxWrBlockLen = (uint8_t)((hsd->CSD[3] & 0x03C00000U) >> 22U);
 800606c:	687b      	ldr	r3, [r7, #4]
 800606e:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 8006070:	0d9b      	lsrs	r3, r3, #22
 8006072:	b2db      	uxtb	r3, r3
 8006074:	f003 030f 	and.w	r3, r3, #15
 8006078:	b2da      	uxtb	r2, r3
 800607a:	683b      	ldr	r3, [r7, #0]
 800607c:	77da      	strb	r2, [r3, #31]

  pCSD->WriteBlockPaPartial = (uint8_t)((hsd->CSD[3] & 0x00200000U) >> 21U);
 800607e:	687b      	ldr	r3, [r7, #4]
 8006080:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 8006082:	0d5b      	lsrs	r3, r3, #21
 8006084:	b2db      	uxtb	r3, r3
 8006086:	f003 0301 	and.w	r3, r3, #1
 800608a:	b2da      	uxtb	r2, r3
 800608c:	683b      	ldr	r3, [r7, #0]
 800608e:	f883 2020 	strb.w	r2, [r3, #32]

  pCSD->Reserved3 = 0;
 8006092:	683b      	ldr	r3, [r7, #0]
 8006094:	2200      	movs	r2, #0
 8006096:	f883 2021 	strb.w	r2, [r3, #33]	@ 0x21

  pCSD->ContentProtectAppli = (uint8_t)((hsd->CSD[3] & 0x00010000U) >> 16U);
 800609a:	687b      	ldr	r3, [r7, #4]
 800609c:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 800609e:	0c1b      	lsrs	r3, r3, #16
 80060a0:	b2db      	uxtb	r3, r3
 80060a2:	f003 0301 	and.w	r3, r3, #1
 80060a6:	b2da      	uxtb	r2, r3
 80060a8:	683b      	ldr	r3, [r7, #0]
 80060aa:	f883 2022 	strb.w	r2, [r3, #34]	@ 0x22

  pCSD->FileFormatGroup = (uint8_t)((hsd->CSD[3] & 0x00008000U) >> 15U);
 80060ae:	687b      	ldr	r3, [r7, #4]
 80060b0:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 80060b2:	0bdb      	lsrs	r3, r3, #15
 80060b4:	b2db      	uxtb	r3, r3
 80060b6:	f003 0301 	and.w	r3, r3, #1
 80060ba:	b2da      	uxtb	r2, r3
 80060bc:	683b      	ldr	r3, [r7, #0]
 80060be:	f883 2023 	strb.w	r2, [r3, #35]	@ 0x23

  pCSD->CopyFlag = (uint8_t)((hsd->CSD[3] & 0x00004000U) >> 14U);
 80060c2:	687b      	ldr	r3, [r7, #4]
 80060c4:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 80060c6:	0b9b      	lsrs	r3, r3, #14
 80060c8:	b2db      	uxtb	r3, r3
 80060ca:	f003 0301 	and.w	r3, r3, #1
 80060ce:	b2da      	uxtb	r2, r3
 80060d0:	683b      	ldr	r3, [r7, #0]
 80060d2:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24

  pCSD->PermWrProtect = (uint8_t)((hsd->CSD[3] & 0x00002000U) >> 13U);
 80060d6:	687b      	ldr	r3, [r7, #4]
 80060d8:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 80060da:	0b5b      	lsrs	r3, r3, #13
 80060dc:	b2db      	uxtb	r3, r3
 80060de:	f003 0301 	and.w	r3, r3, #1
 80060e2:	b2da      	uxtb	r2, r3
 80060e4:	683b      	ldr	r3, [r7, #0]
 80060e6:	f883 2025 	strb.w	r2, [r3, #37]	@ 0x25

  pCSD->TempWrProtect = (uint8_t)((hsd->CSD[3] & 0x00001000U) >> 12U);
 80060ea:	687b      	ldr	r3, [r7, #4]
 80060ec:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 80060ee:	0b1b      	lsrs	r3, r3, #12
 80060f0:	b2db      	uxtb	r3, r3
 80060f2:	f003 0301 	and.w	r3, r3, #1
 80060f6:	b2da      	uxtb	r2, r3
 80060f8:	683b      	ldr	r3, [r7, #0]
 80060fa:	f883 2026 	strb.w	r2, [r3, #38]	@ 0x26

  pCSD->FileFormat = (uint8_t)((hsd->CSD[3] & 0x00000C00U) >> 10U);
 80060fe:	687b      	ldr	r3, [r7, #4]
 8006100:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 8006102:	0a9b      	lsrs	r3, r3, #10
 8006104:	b2db      	uxtb	r3, r3
 8006106:	f003 0303 	and.w	r3, r3, #3
 800610a:	b2da      	uxtb	r2, r3
 800610c:	683b      	ldr	r3, [r7, #0]
 800610e:	f883 2027 	strb.w	r2, [r3, #39]	@ 0x27

  pCSD->ECC = (uint8_t)((hsd->CSD[3] & 0x00000300U) >> 8U);
 8006112:	687b      	ldr	r3, [r7, #4]
 8006114:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 8006116:	0a1b      	lsrs	r3, r3, #8
 8006118:	b2db      	uxtb	r3, r3
 800611a:	f003 0303 	and.w	r3, r3, #3
 800611e:	b2da      	uxtb	r2, r3
 8006120:	683b      	ldr	r3, [r7, #0]
 8006122:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28

  pCSD->CSD_CRC = (uint8_t)((hsd->CSD[3] & 0x000000FEU) >> 1U);
 8006126:	687b      	ldr	r3, [r7, #4]
 8006128:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 800612a:	085b      	lsrs	r3, r3, #1
 800612c:	b2db      	uxtb	r3, r3
 800612e:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8006132:	b2da      	uxtb	r2, r3
 8006134:	683b      	ldr	r3, [r7, #0]
 8006136:	f883 2029 	strb.w	r2, [r3, #41]	@ 0x29

  pCSD->Reserved4 = 1;
 800613a:	683b      	ldr	r3, [r7, #0]
 800613c:	2201      	movs	r2, #1
 800613e:	f883 202a 	strb.w	r2, [r3, #42]	@ 0x2a

  return HAL_OK;
 8006142:	2300      	movs	r3, #0
}
 8006144:	4618      	mov	r0, r3
 8006146:	370c      	adds	r7, #12
 8006148:	46bd      	mov	sp, r7
 800614a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800614e:	4770      	bx	lr
 8006150:	1fe00fff 	.word	0x1fe00fff

08006154 <HAL_SD_GetCardStatus>:
  * @param  pStatus: Pointer to the HAL_SD_CardStatusTypeDef structure that
  *         will contain the SD card status information
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_GetCardStatus(SD_HandleTypeDef *hsd, HAL_SD_CardStatusTypeDef *pStatus)
{
 8006154:	b580      	push	{r7, lr}
 8006156:	b094      	sub	sp, #80	@ 0x50
 8006158:	af00      	add	r7, sp, #0
 800615a:	6078      	str	r0, [r7, #4]
 800615c:	6039      	str	r1, [r7, #0]
  uint32_t sd_status[16];
  uint32_t errorstate;
  HAL_StatusTypeDef status = HAL_OK;
 800615e:	2300      	movs	r3, #0
 8006160:	f887 304f 	strb.w	r3, [r7, #79]	@ 0x4f

  if (hsd->State == HAL_SD_STATE_BUSY)
 8006164:	687b      	ldr	r3, [r7, #4]
 8006166:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 800616a:	b2db      	uxtb	r3, r3
 800616c:	2b03      	cmp	r3, #3
 800616e:	d101      	bne.n	8006174 <HAL_SD_GetCardStatus+0x20>
  {
    return HAL_ERROR;
 8006170:	2301      	movs	r3, #1
 8006172:	e0a7      	b.n	80062c4 <HAL_SD_GetCardStatus+0x170>
  }

  errorstate = SD_SendSDStatus(hsd, sd_status);
 8006174:	f107 0308 	add.w	r3, r7, #8
 8006178:	4619      	mov	r1, r3
 800617a:	6878      	ldr	r0, [r7, #4]
 800617c:	f000 fb36 	bl	80067ec <SD_SendSDStatus>
 8006180:	64b8      	str	r0, [r7, #72]	@ 0x48
  if (errorstate != HAL_SD_ERROR_NONE)
 8006182:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8006184:	2b00      	cmp	r3, #0
 8006186:	d011      	beq.n	80061ac <HAL_SD_GetCardStatus+0x58>
  {
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8006188:	687b      	ldr	r3, [r7, #4]
 800618a:	681b      	ldr	r3, [r3, #0]
 800618c:	4a4f      	ldr	r2, [pc, #316]	@ (80062cc <HAL_SD_GetCardStatus+0x178>)
 800618e:	639a      	str	r2, [r3, #56]	@ 0x38
    hsd->ErrorCode |= errorstate;
 8006190:	687b      	ldr	r3, [r7, #4]
 8006192:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8006194:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8006196:	431a      	orrs	r2, r3
 8006198:	687b      	ldr	r3, [r7, #4]
 800619a:	635a      	str	r2, [r3, #52]	@ 0x34
    hsd->State = HAL_SD_STATE_READY;
 800619c:	687b      	ldr	r3, [r7, #4]
 800619e:	2201      	movs	r2, #1
 80061a0:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
    status = HAL_ERROR;
 80061a4:	2301      	movs	r3, #1
 80061a6:	f887 304f 	strb.w	r3, [r7, #79]	@ 0x4f
 80061aa:	e070      	b.n	800628e <HAL_SD_GetCardStatus+0x13a>
  }
  else
  {
    pStatus->DataBusWidth = (uint8_t)((sd_status[0] & 0xC0U) >> 6U);
 80061ac:	68bb      	ldr	r3, [r7, #8]
 80061ae:	099b      	lsrs	r3, r3, #6
 80061b0:	b2db      	uxtb	r3, r3
 80061b2:	f003 0303 	and.w	r3, r3, #3
 80061b6:	b2da      	uxtb	r2, r3
 80061b8:	683b      	ldr	r3, [r7, #0]
 80061ba:	701a      	strb	r2, [r3, #0]

    pStatus->SecuredMode = (uint8_t)((sd_status[0] & 0x20U) >> 5U);
 80061bc:	68bb      	ldr	r3, [r7, #8]
 80061be:	095b      	lsrs	r3, r3, #5
 80061c0:	b2db      	uxtb	r3, r3
 80061c2:	f003 0301 	and.w	r3, r3, #1
 80061c6:	b2da      	uxtb	r2, r3
 80061c8:	683b      	ldr	r3, [r7, #0]
 80061ca:	705a      	strb	r2, [r3, #1]

    pStatus->CardType = (uint16_t)(((sd_status[0] & 0x00FF0000U) >> 8U) | ((sd_status[0] & 0xFF000000U) >> 24U));
 80061cc:	68bb      	ldr	r3, [r7, #8]
 80061ce:	0a1b      	lsrs	r3, r3, #8
 80061d0:	b29b      	uxth	r3, r3
 80061d2:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
 80061d6:	b29a      	uxth	r2, r3
 80061d8:	68bb      	ldr	r3, [r7, #8]
 80061da:	0e1b      	lsrs	r3, r3, #24
 80061dc:	b29b      	uxth	r3, r3
 80061de:	4313      	orrs	r3, r2
 80061e0:	b29a      	uxth	r2, r3
 80061e2:	683b      	ldr	r3, [r7, #0]
 80061e4:	805a      	strh	r2, [r3, #2]

    pStatus->ProtectedAreaSize = (((sd_status[1] & 0xFFU) << 24U)    | ((sd_status[1] & 0xFF00U) << 8U) |
 80061e6:	68fb      	ldr	r3, [r7, #12]
 80061e8:	061a      	lsls	r2, r3, #24
 80061ea:	68fb      	ldr	r3, [r7, #12]
 80061ec:	021b      	lsls	r3, r3, #8
 80061ee:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
 80061f2:	431a      	orrs	r2, r3
                                  ((sd_status[1] & 0xFF0000U) >> 8U) | ((sd_status[1] & 0xFF000000U) >> 24U));
 80061f4:	68fb      	ldr	r3, [r7, #12]
 80061f6:	0a1b      	lsrs	r3, r3, #8
 80061f8:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
    pStatus->ProtectedAreaSize = (((sd_status[1] & 0xFFU) << 24U)    | ((sd_status[1] & 0xFF00U) << 8U) |
 80061fc:	431a      	orrs	r2, r3
                                  ((sd_status[1] & 0xFF0000U) >> 8U) | ((sd_status[1] & 0xFF000000U) >> 24U));
 80061fe:	68fb      	ldr	r3, [r7, #12]
 8006200:	0e1b      	lsrs	r3, r3, #24
 8006202:	431a      	orrs	r2, r3
    pStatus->ProtectedAreaSize = (((sd_status[1] & 0xFFU) << 24U)    | ((sd_status[1] & 0xFF00U) << 8U) |
 8006204:	683b      	ldr	r3, [r7, #0]
 8006206:	605a      	str	r2, [r3, #4]

    pStatus->SpeedClass = (uint8_t)(sd_status[2] & 0xFFU);
 8006208:	693b      	ldr	r3, [r7, #16]
 800620a:	b2da      	uxtb	r2, r3
 800620c:	683b      	ldr	r3, [r7, #0]
 800620e:	721a      	strb	r2, [r3, #8]

    pStatus->PerformanceMove = (uint8_t)((sd_status[2] & 0xFF00U) >> 8U);
 8006210:	693b      	ldr	r3, [r7, #16]
 8006212:	0a1b      	lsrs	r3, r3, #8
 8006214:	b2da      	uxtb	r2, r3
 8006216:	683b      	ldr	r3, [r7, #0]
 8006218:	725a      	strb	r2, [r3, #9]

    pStatus->AllocationUnitSize = (uint8_t)((sd_status[2] & 0xF00000U) >> 20U);
 800621a:	693b      	ldr	r3, [r7, #16]
 800621c:	0d1b      	lsrs	r3, r3, #20
 800621e:	b2db      	uxtb	r3, r3
 8006220:	f003 030f 	and.w	r3, r3, #15
 8006224:	b2da      	uxtb	r2, r3
 8006226:	683b      	ldr	r3, [r7, #0]
 8006228:	729a      	strb	r2, [r3, #10]

    pStatus->EraseSize = (uint16_t)(((sd_status[2] & 0xFF000000U) >> 16U) | (sd_status[3] & 0xFFU));
 800622a:	693b      	ldr	r3, [r7, #16]
 800622c:	0c1b      	lsrs	r3, r3, #16
 800622e:	b29b      	uxth	r3, r3
 8006230:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
 8006234:	b29a      	uxth	r2, r3
 8006236:	697b      	ldr	r3, [r7, #20]
 8006238:	b29b      	uxth	r3, r3
 800623a:	b2db      	uxtb	r3, r3
 800623c:	b29b      	uxth	r3, r3
 800623e:	4313      	orrs	r3, r2
 8006240:	b29a      	uxth	r2, r3
 8006242:	683b      	ldr	r3, [r7, #0]
 8006244:	819a      	strh	r2, [r3, #12]

    pStatus->EraseTimeout = (uint8_t)((sd_status[3] & 0xFC00U) >> 10U);
 8006246:	697b      	ldr	r3, [r7, #20]
 8006248:	0a9b      	lsrs	r3, r3, #10
 800624a:	b2db      	uxtb	r3, r3
 800624c:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 8006250:	b2da      	uxtb	r2, r3
 8006252:	683b      	ldr	r3, [r7, #0]
 8006254:	739a      	strb	r2, [r3, #14]

    pStatus->EraseOffset = (uint8_t)((sd_status[3] & 0x0300U) >> 8U);
 8006256:	697b      	ldr	r3, [r7, #20]
 8006258:	0a1b      	lsrs	r3, r3, #8
 800625a:	b2db      	uxtb	r3, r3
 800625c:	f003 0303 	and.w	r3, r3, #3
 8006260:	b2da      	uxtb	r2, r3
 8006262:	683b      	ldr	r3, [r7, #0]
 8006264:	73da      	strb	r2, [r3, #15]

    pStatus->UhsSpeedGrade = (uint8_t)((sd_status[3] & 0x00F0U) >> 4U);
 8006266:	697b      	ldr	r3, [r7, #20]
 8006268:	091b      	lsrs	r3, r3, #4
 800626a:	b2db      	uxtb	r3, r3
 800626c:	f003 030f 	and.w	r3, r3, #15
 8006270:	b2da      	uxtb	r2, r3
 8006272:	683b      	ldr	r3, [r7, #0]
 8006274:	741a      	strb	r2, [r3, #16]
    pStatus->UhsAllocationUnitSize = (uint8_t)(sd_status[3] & 0x000FU) ;
 8006276:	697b      	ldr	r3, [r7, #20]
 8006278:	b2db      	uxtb	r3, r3
 800627a:	f003 030f 	and.w	r3, r3, #15
 800627e:	b2da      	uxtb	r2, r3
 8006280:	683b      	ldr	r3, [r7, #0]
 8006282:	745a      	strb	r2, [r3, #17]
    pStatus->VideoSpeedClass = (uint8_t)((sd_status[4] & 0xFF000000U) >> 24U);
 8006284:	69bb      	ldr	r3, [r7, #24]
 8006286:	0e1b      	lsrs	r3, r3, #24
 8006288:	b2da      	uxtb	r2, r3
 800628a:	683b      	ldr	r3, [r7, #0]
 800628c:	749a      	strb	r2, [r3, #18]
  }

  /* Set Block Size for Card */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
 800628e:	687b      	ldr	r3, [r7, #4]
 8006290:	681b      	ldr	r3, [r3, #0]
 8006292:	f44f 7100 	mov.w	r1, #512	@ 0x200
 8006296:	4618      	mov	r0, r3
 8006298:	f001 fb28 	bl	80078ec <SDMMC_CmdBlockLength>
 800629c:	64b8      	str	r0, [r7, #72]	@ 0x48
  if (errorstate != HAL_SD_ERROR_NONE)
 800629e:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80062a0:	2b00      	cmp	r3, #0
 80062a2:	d00d      	beq.n	80062c0 <HAL_SD_GetCardStatus+0x16c>
  {
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 80062a4:	687b      	ldr	r3, [r7, #4]
 80062a6:	681b      	ldr	r3, [r3, #0]
 80062a8:	4a08      	ldr	r2, [pc, #32]	@ (80062cc <HAL_SD_GetCardStatus+0x178>)
 80062aa:	639a      	str	r2, [r3, #56]	@ 0x38
    hsd->ErrorCode = errorstate;
 80062ac:	687b      	ldr	r3, [r7, #4]
 80062ae:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 80062b0:	635a      	str	r2, [r3, #52]	@ 0x34
    hsd->State = HAL_SD_STATE_READY;
 80062b2:	687b      	ldr	r3, [r7, #4]
 80062b4:	2201      	movs	r2, #1
 80062b6:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
    status = HAL_ERROR;
 80062ba:	2301      	movs	r3, #1
 80062bc:	f887 304f 	strb.w	r3, [r7, #79]	@ 0x4f
  }

  return status;
 80062c0:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
}
 80062c4:	4618      	mov	r0, r3
 80062c6:	3750      	adds	r7, #80	@ 0x50
 80062c8:	46bd      	mov	sp, r7
 80062ca:	bd80      	pop	{r7, pc}
 80062cc:	1fe00fff 	.word	0x1fe00fff

080062d0 <HAL_SD_ConfigWideBusOperation>:
  *            @arg SDMMC_BUS_WIDE_4B: 4-bit data transfer
  *            @arg SDMMC_BUS_WIDE_1B: 1-bit data transfer
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_ConfigWideBusOperation(SD_HandleTypeDef *hsd, uint32_t WideMode)
{
 80062d0:	b590      	push	{r4, r7, lr}
 80062d2:	b08d      	sub	sp, #52	@ 0x34
 80062d4:	af02      	add	r7, sp, #8
 80062d6:	6078      	str	r0, [r7, #4]
 80062d8:	6039      	str	r1, [r7, #0]
  SDMMC_InitTypeDef Init;
  uint32_t errorstate;
  uint32_t sdmmc_clk;

  HAL_StatusTypeDef status = HAL_OK;
 80062da:	2300      	movs	r3, #0
 80062dc:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27

  /* Check the parameters */
  assert_param(IS_SDMMC_BUS_WIDE(WideMode));

  /* Change State */
  hsd->State = HAL_SD_STATE_BUSY;
 80062e0:	687b      	ldr	r3, [r7, #4]
 80062e2:	2203      	movs	r2, #3
 80062e4:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

  if (hsd->SdCard.CardType != CARD_SECURED)
 80062e8:	687b      	ldr	r3, [r7, #4]
 80062ea:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80062ec:	2b03      	cmp	r3, #3
 80062ee:	d02e      	beq.n	800634e <HAL_SD_ConfigWideBusOperation+0x7e>
  {
    if (WideMode == SDMMC_BUS_WIDE_8B)
 80062f0:	683b      	ldr	r3, [r7, #0]
 80062f2:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 80062f6:	d106      	bne.n	8006306 <HAL_SD_ConfigWideBusOperation+0x36>
    {
      hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 80062f8:	687b      	ldr	r3, [r7, #4]
 80062fa:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80062fc:	f043 5280 	orr.w	r2, r3, #268435456	@ 0x10000000
 8006300:	687b      	ldr	r3, [r7, #4]
 8006302:	635a      	str	r2, [r3, #52]	@ 0x34
 8006304:	e029      	b.n	800635a <HAL_SD_ConfigWideBusOperation+0x8a>
    }
    else if (WideMode == SDMMC_BUS_WIDE_4B)
 8006306:	683b      	ldr	r3, [r7, #0]
 8006308:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 800630c:	d10a      	bne.n	8006324 <HAL_SD_ConfigWideBusOperation+0x54>
    {
      errorstate = SD_WideBus_Enable(hsd);
 800630e:	6878      	ldr	r0, [r7, #4]
 8006310:	f000 fb64 	bl	80069dc <SD_WideBus_Enable>
 8006314:	6238      	str	r0, [r7, #32]

      hsd->ErrorCode |= errorstate;
 8006316:	687b      	ldr	r3, [r7, #4]
 8006318:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 800631a:	6a3b      	ldr	r3, [r7, #32]
 800631c:	431a      	orrs	r2, r3
 800631e:	687b      	ldr	r3, [r7, #4]
 8006320:	635a      	str	r2, [r3, #52]	@ 0x34
 8006322:	e01a      	b.n	800635a <HAL_SD_ConfigWideBusOperation+0x8a>
    }
    else if (WideMode == SDMMC_BUS_WIDE_1B)
 8006324:	683b      	ldr	r3, [r7, #0]
 8006326:	2b00      	cmp	r3, #0
 8006328:	d10a      	bne.n	8006340 <HAL_SD_ConfigWideBusOperation+0x70>
    {
      errorstate = SD_WideBus_Disable(hsd);
 800632a:	6878      	ldr	r0, [r7, #4]
 800632c:	f000 fba1 	bl	8006a72 <SD_WideBus_Disable>
 8006330:	6238      	str	r0, [r7, #32]

      hsd->ErrorCode |= errorstate;
 8006332:	687b      	ldr	r3, [r7, #4]
 8006334:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8006336:	6a3b      	ldr	r3, [r7, #32]
 8006338:	431a      	orrs	r2, r3
 800633a:	687b      	ldr	r3, [r7, #4]
 800633c:	635a      	str	r2, [r3, #52]	@ 0x34
 800633e:	e00c      	b.n	800635a <HAL_SD_ConfigWideBusOperation+0x8a>
    }
    else
    {
      /* WideMode is not a valid argument*/
      hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 8006340:	687b      	ldr	r3, [r7, #4]
 8006342:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8006344:	f043 6200 	orr.w	r2, r3, #134217728	@ 0x8000000
 8006348:	687b      	ldr	r3, [r7, #4]
 800634a:	635a      	str	r2, [r3, #52]	@ 0x34
 800634c:	e005      	b.n	800635a <HAL_SD_ConfigWideBusOperation+0x8a>
    }
  }
  else
  {
    /* SD Card does not support this feature */
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 800634e:	687b      	ldr	r3, [r7, #4]
 8006350:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8006352:	f043 5280 	orr.w	r2, r3, #268435456	@ 0x10000000
 8006356:	687b      	ldr	r3, [r7, #4]
 8006358:	635a      	str	r2, [r3, #52]	@ 0x34
  }

  if (hsd->ErrorCode != HAL_SD_ERROR_NONE)
 800635a:	687b      	ldr	r3, [r7, #4]
 800635c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800635e:	2b00      	cmp	r3, #0
 8006360:	d007      	beq.n	8006372 <HAL_SD_ConfigWideBusOperation+0xa2>
  {
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8006362:	687b      	ldr	r3, [r7, #4]
 8006364:	681b      	ldr	r3, [r3, #0]
 8006366:	4a5f      	ldr	r2, [pc, #380]	@ (80064e4 <HAL_SD_ConfigWideBusOperation+0x214>)
 8006368:	639a      	str	r2, [r3, #56]	@ 0x38
    status = HAL_ERROR;
 800636a:	2301      	movs	r3, #1
 800636c:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
 8006370:	e096      	b.n	80064a0 <HAL_SD_ConfigWideBusOperation+0x1d0>
  }
  else
  {
    sdmmc_clk = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SDMMC);
 8006372:	f44f 1000 	mov.w	r0, #2097152	@ 0x200000
 8006376:	f04f 0100 	mov.w	r1, #0
 800637a:	f7fd feb9 	bl	80040f0 <HAL_RCCEx_GetPeriphCLKFreq>
 800637e:	61f8      	str	r0, [r7, #28]
    if (sdmmc_clk != 0U)
 8006380:	69fb      	ldr	r3, [r7, #28]
 8006382:	2b00      	cmp	r3, #0
 8006384:	f000 8083 	beq.w	800648e <HAL_SD_ConfigWideBusOperation+0x1be>
    {
      /* Configure the SDMMC peripheral */
      Init.ClockEdge           = hsd->Init.ClockEdge;
 8006388:	687b      	ldr	r3, [r7, #4]
 800638a:	685b      	ldr	r3, [r3, #4]
 800638c:	60bb      	str	r3, [r7, #8]
      Init.ClockPowerSave      = hsd->Init.ClockPowerSave;
 800638e:	687b      	ldr	r3, [r7, #4]
 8006390:	689b      	ldr	r3, [r3, #8]
 8006392:	60fb      	str	r3, [r7, #12]
      Init.BusWide             = WideMode;
 8006394:	683b      	ldr	r3, [r7, #0]
 8006396:	613b      	str	r3, [r7, #16]
      Init.HardwareFlowControl = hsd->Init.HardwareFlowControl;
 8006398:	687b      	ldr	r3, [r7, #4]
 800639a:	691b      	ldr	r3, [r3, #16]
 800639c:	617b      	str	r3, [r7, #20]

      /* Check if user Clock div < Normal speed 25Mhz, no change in Clockdiv */
      if (hsd->Init.ClockDiv >= (sdmmc_clk / (2U * SD_NORMAL_SPEED_FREQ)))
 800639e:	687b      	ldr	r3, [r7, #4]
 80063a0:	695a      	ldr	r2, [r3, #20]
 80063a2:	69fb      	ldr	r3, [r7, #28]
 80063a4:	4950      	ldr	r1, [pc, #320]	@ (80064e8 <HAL_SD_ConfigWideBusOperation+0x218>)
 80063a6:	fba1 1303 	umull	r1, r3, r1, r3
 80063aa:	0e1b      	lsrs	r3, r3, #24
 80063ac:	429a      	cmp	r2, r3
 80063ae:	d303      	bcc.n	80063b8 <HAL_SD_ConfigWideBusOperation+0xe8>
      {
        Init.ClockDiv = hsd->Init.ClockDiv;
 80063b0:	687b      	ldr	r3, [r7, #4]
 80063b2:	695b      	ldr	r3, [r3, #20]
 80063b4:	61bb      	str	r3, [r7, #24]
 80063b6:	e05a      	b.n	800646e <HAL_SD_ConfigWideBusOperation+0x19e>
      }
      else if (hsd->SdCard.CardSpeed == CARD_ULTRA_HIGH_SPEED)
 80063b8:	687b      	ldr	r3, [r7, #4]
 80063ba:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 80063bc:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 80063c0:	d103      	bne.n	80063ca <HAL_SD_ConfigWideBusOperation+0xfa>
      {
        /* UltraHigh speed SD card,user Clock div */
        Init.ClockDiv = hsd->Init.ClockDiv;
 80063c2:	687b      	ldr	r3, [r7, #4]
 80063c4:	695b      	ldr	r3, [r3, #20]
 80063c6:	61bb      	str	r3, [r7, #24]
 80063c8:	e051      	b.n	800646e <HAL_SD_ConfigWideBusOperation+0x19e>
      }
      else if (hsd->SdCard.CardSpeed == CARD_HIGH_SPEED)
 80063ca:	687b      	ldr	r3, [r7, #4]
 80063cc:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 80063ce:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 80063d2:	d126      	bne.n	8006422 <HAL_SD_ConfigWideBusOperation+0x152>
      {
        /* High speed SD card, Max Frequency = 50Mhz */
        if (hsd->Init.ClockDiv == 0U)
 80063d4:	687b      	ldr	r3, [r7, #4]
 80063d6:	695b      	ldr	r3, [r3, #20]
 80063d8:	2b00      	cmp	r3, #0
 80063da:	d10e      	bne.n	80063fa <HAL_SD_ConfigWideBusOperation+0x12a>
        {
          if (sdmmc_clk > SD_HIGH_SPEED_FREQ)
 80063dc:	69fb      	ldr	r3, [r7, #28]
 80063de:	4a43      	ldr	r2, [pc, #268]	@ (80064ec <HAL_SD_ConfigWideBusOperation+0x21c>)
 80063e0:	4293      	cmp	r3, r2
 80063e2:	d906      	bls.n	80063f2 <HAL_SD_ConfigWideBusOperation+0x122>
          {
            Init.ClockDiv = sdmmc_clk / (2U * SD_HIGH_SPEED_FREQ);
 80063e4:	69fb      	ldr	r3, [r7, #28]
 80063e6:	4a40      	ldr	r2, [pc, #256]	@ (80064e8 <HAL_SD_ConfigWideBusOperation+0x218>)
 80063e8:	fba2 2303 	umull	r2, r3, r2, r3
 80063ec:	0e5b      	lsrs	r3, r3, #25
 80063ee:	61bb      	str	r3, [r7, #24]
 80063f0:	e03d      	b.n	800646e <HAL_SD_ConfigWideBusOperation+0x19e>
          }
          else
          {
            Init.ClockDiv = hsd->Init.ClockDiv;
 80063f2:	687b      	ldr	r3, [r7, #4]
 80063f4:	695b      	ldr	r3, [r3, #20]
 80063f6:	61bb      	str	r3, [r7, #24]
 80063f8:	e039      	b.n	800646e <HAL_SD_ConfigWideBusOperation+0x19e>
          }
        }
        else
        {
          if ((sdmmc_clk / (2U * hsd->Init.ClockDiv)) > SD_HIGH_SPEED_FREQ)
 80063fa:	687b      	ldr	r3, [r7, #4]
 80063fc:	695b      	ldr	r3, [r3, #20]
 80063fe:	005b      	lsls	r3, r3, #1
 8006400:	69fa      	ldr	r2, [r7, #28]
 8006402:	fbb2 f3f3 	udiv	r3, r2, r3
 8006406:	4a39      	ldr	r2, [pc, #228]	@ (80064ec <HAL_SD_ConfigWideBusOperation+0x21c>)
 8006408:	4293      	cmp	r3, r2
 800640a:	d906      	bls.n	800641a <HAL_SD_ConfigWideBusOperation+0x14a>
          {
            Init.ClockDiv = sdmmc_clk / (2U * SD_HIGH_SPEED_FREQ);
 800640c:	69fb      	ldr	r3, [r7, #28]
 800640e:	4a36      	ldr	r2, [pc, #216]	@ (80064e8 <HAL_SD_ConfigWideBusOperation+0x218>)
 8006410:	fba2 2303 	umull	r2, r3, r2, r3
 8006414:	0e5b      	lsrs	r3, r3, #25
 8006416:	61bb      	str	r3, [r7, #24]
 8006418:	e029      	b.n	800646e <HAL_SD_ConfigWideBusOperation+0x19e>
          }
          else
          {
            Init.ClockDiv = hsd->Init.ClockDiv;
 800641a:	687b      	ldr	r3, [r7, #4]
 800641c:	695b      	ldr	r3, [r3, #20]
 800641e:	61bb      	str	r3, [r7, #24]
 8006420:	e025      	b.n	800646e <HAL_SD_ConfigWideBusOperation+0x19e>
        }
      }
      else
      {
        /* No High speed SD card, Max Frequency = 25Mhz */
        if (hsd->Init.ClockDiv == 0U)
 8006422:	687b      	ldr	r3, [r7, #4]
 8006424:	695b      	ldr	r3, [r3, #20]
 8006426:	2b00      	cmp	r3, #0
 8006428:	d10e      	bne.n	8006448 <HAL_SD_ConfigWideBusOperation+0x178>
        {
          if (sdmmc_clk > SD_NORMAL_SPEED_FREQ)
 800642a:	69fb      	ldr	r3, [r7, #28]
 800642c:	4a30      	ldr	r2, [pc, #192]	@ (80064f0 <HAL_SD_ConfigWideBusOperation+0x220>)
 800642e:	4293      	cmp	r3, r2
 8006430:	d906      	bls.n	8006440 <HAL_SD_ConfigWideBusOperation+0x170>
          {
            Init.ClockDiv = sdmmc_clk / (2U * SD_NORMAL_SPEED_FREQ);
 8006432:	69fb      	ldr	r3, [r7, #28]
 8006434:	4a2c      	ldr	r2, [pc, #176]	@ (80064e8 <HAL_SD_ConfigWideBusOperation+0x218>)
 8006436:	fba2 2303 	umull	r2, r3, r2, r3
 800643a:	0e1b      	lsrs	r3, r3, #24
 800643c:	61bb      	str	r3, [r7, #24]
 800643e:	e016      	b.n	800646e <HAL_SD_ConfigWideBusOperation+0x19e>
          }
          else
          {
            Init.ClockDiv = hsd->Init.ClockDiv;
 8006440:	687b      	ldr	r3, [r7, #4]
 8006442:	695b      	ldr	r3, [r3, #20]
 8006444:	61bb      	str	r3, [r7, #24]
 8006446:	e012      	b.n	800646e <HAL_SD_ConfigWideBusOperation+0x19e>
          }
        }
        else
        {
          if ((sdmmc_clk / (2U * hsd->Init.ClockDiv)) > SD_NORMAL_SPEED_FREQ)
 8006448:	687b      	ldr	r3, [r7, #4]
 800644a:	695b      	ldr	r3, [r3, #20]
 800644c:	005b      	lsls	r3, r3, #1
 800644e:	69fa      	ldr	r2, [r7, #28]
 8006450:	fbb2 f3f3 	udiv	r3, r2, r3
 8006454:	4a26      	ldr	r2, [pc, #152]	@ (80064f0 <HAL_SD_ConfigWideBusOperation+0x220>)
 8006456:	4293      	cmp	r3, r2
 8006458:	d906      	bls.n	8006468 <HAL_SD_ConfigWideBusOperation+0x198>
          {
            Init.ClockDiv = sdmmc_clk / (2U * SD_NORMAL_SPEED_FREQ);
 800645a:	69fb      	ldr	r3, [r7, #28]
 800645c:	4a22      	ldr	r2, [pc, #136]	@ (80064e8 <HAL_SD_ConfigWideBusOperation+0x218>)
 800645e:	fba2 2303 	umull	r2, r3, r2, r3
 8006462:	0e1b      	lsrs	r3, r3, #24
 8006464:	61bb      	str	r3, [r7, #24]
 8006466:	e002      	b.n	800646e <HAL_SD_ConfigWideBusOperation+0x19e>
          }
          else
          {
            Init.ClockDiv = hsd->Init.ClockDiv;
 8006468:	687b      	ldr	r3, [r7, #4]
 800646a:	695b      	ldr	r3, [r3, #20]
 800646c:	61bb      	str	r3, [r7, #24]

#if (USE_SD_TRANSCEIVER != 0U)
      Init.TranceiverPresent = hsd->Init.TranceiverPresent;
#endif /* USE_SD_TRANSCEIVER */

      (void)SDMMC_Init(hsd->Instance, Init);
 800646e:	687b      	ldr	r3, [r7, #4]
 8006470:	681c      	ldr	r4, [r3, #0]
 8006472:	466a      	mov	r2, sp
 8006474:	f107 0314 	add.w	r3, r7, #20
 8006478:	e893 0003 	ldmia.w	r3, {r0, r1}
 800647c:	e882 0003 	stmia.w	r2, {r0, r1}
 8006480:	f107 0308 	add.w	r3, r7, #8
 8006484:	cb0e      	ldmia	r3, {r1, r2, r3}
 8006486:	4620      	mov	r0, r4
 8006488:	f001 f952 	bl	8007730 <SDMMC_Init>
 800648c:	e008      	b.n	80064a0 <HAL_SD_ConfigWideBusOperation+0x1d0>
    }
    else
    {
      hsd->ErrorCode |= SDMMC_ERROR_INVALID_PARAMETER;
 800648e:	687b      	ldr	r3, [r7, #4]
 8006490:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8006492:	f043 6200 	orr.w	r2, r3, #134217728	@ 0x8000000
 8006496:	687b      	ldr	r3, [r7, #4]
 8006498:	635a      	str	r2, [r3, #52]	@ 0x34
      status = HAL_ERROR;
 800649a:	2301      	movs	r3, #1
 800649c:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    }
  }

  /* Set Block Size for Card */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
 80064a0:	687b      	ldr	r3, [r7, #4]
 80064a2:	681b      	ldr	r3, [r3, #0]
 80064a4:	f44f 7100 	mov.w	r1, #512	@ 0x200
 80064a8:	4618      	mov	r0, r3
 80064aa:	f001 fa1f 	bl	80078ec <SDMMC_CmdBlockLength>
 80064ae:	6238      	str	r0, [r7, #32]
  if (errorstate != HAL_SD_ERROR_NONE)
 80064b0:	6a3b      	ldr	r3, [r7, #32]
 80064b2:	2b00      	cmp	r3, #0
 80064b4:	d00c      	beq.n	80064d0 <HAL_SD_ConfigWideBusOperation+0x200>
  {
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 80064b6:	687b      	ldr	r3, [r7, #4]
 80064b8:	681b      	ldr	r3, [r3, #0]
 80064ba:	4a0a      	ldr	r2, [pc, #40]	@ (80064e4 <HAL_SD_ConfigWideBusOperation+0x214>)
 80064bc:	639a      	str	r2, [r3, #56]	@ 0x38
    hsd->ErrorCode |= errorstate;
 80064be:	687b      	ldr	r3, [r7, #4]
 80064c0:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 80064c2:	6a3b      	ldr	r3, [r7, #32]
 80064c4:	431a      	orrs	r2, r3
 80064c6:	687b      	ldr	r3, [r7, #4]
 80064c8:	635a      	str	r2, [r3, #52]	@ 0x34
    status = HAL_ERROR;
 80064ca:	2301      	movs	r3, #1
 80064cc:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  }

  /* Change State */
  hsd->State = HAL_SD_STATE_READY;
 80064d0:	687b      	ldr	r3, [r7, #4]
 80064d2:	2201      	movs	r2, #1
 80064d4:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

  return status;
 80064d8:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
}
 80064dc:	4618      	mov	r0, r3
 80064de:	372c      	adds	r7, #44	@ 0x2c
 80064e0:	46bd      	mov	sp, r7
 80064e2:	bd90      	pop	{r4, r7, pc}
 80064e4:	1fe00fff 	.word	0x1fe00fff
 80064e8:	55e63b89 	.word	0x55e63b89
 80064ec:	02faf080 	.word	0x02faf080
 80064f0:	017d7840 	.word	0x017d7840

080064f4 <HAL_SD_GetCardState>:
  * @brief  Gets the current sd card data state.
  * @param  hsd: pointer to SD handle
  * @retval Card state
  */
HAL_SD_CardStateTypeDef HAL_SD_GetCardState(SD_HandleTypeDef *hsd)
{
 80064f4:	b580      	push	{r7, lr}
 80064f6:	b086      	sub	sp, #24
 80064f8:	af00      	add	r7, sp, #0
 80064fa:	6078      	str	r0, [r7, #4]
  uint32_t cardstate;
  uint32_t errorstate;
  uint32_t resp1 = 0;
 80064fc:	2300      	movs	r3, #0
 80064fe:	60fb      	str	r3, [r7, #12]

  errorstate = SD_SendStatus(hsd, &resp1);
 8006500:	f107 030c 	add.w	r3, r7, #12
 8006504:	4619      	mov	r1, r3
 8006506:	6878      	ldr	r0, [r7, #4]
 8006508:	f000 fa40 	bl	800698c <SD_SendStatus>
 800650c:	6178      	str	r0, [r7, #20]
  if (errorstate != HAL_SD_ERROR_NONE)
 800650e:	697b      	ldr	r3, [r7, #20]
 8006510:	2b00      	cmp	r3, #0
 8006512:	d005      	beq.n	8006520 <HAL_SD_GetCardState+0x2c>
  {
    hsd->ErrorCode |= errorstate;
 8006514:	687b      	ldr	r3, [r7, #4]
 8006516:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8006518:	697b      	ldr	r3, [r7, #20]
 800651a:	431a      	orrs	r2, r3
 800651c:	687b      	ldr	r3, [r7, #4]
 800651e:	635a      	str	r2, [r3, #52]	@ 0x34
  }

  cardstate = ((resp1 >> 9U) & 0x0FU);
 8006520:	68fb      	ldr	r3, [r7, #12]
 8006522:	0a5b      	lsrs	r3, r3, #9
 8006524:	f003 030f 	and.w	r3, r3, #15
 8006528:	613b      	str	r3, [r7, #16]

  return (HAL_SD_CardStateTypeDef)cardstate;
 800652a:	693b      	ldr	r3, [r7, #16]
}
 800652c:	4618      	mov	r0, r3
 800652e:	3718      	adds	r7, #24
 8006530:	46bd      	mov	sp, r7
 8006532:	bd80      	pop	{r7, pc}

08006534 <SD_InitCard>:
  * @brief  Initializes the sd card.
  * @param  hsd: Pointer to SD handle
  * @retval SD Card error state
  */
static uint32_t SD_InitCard(SD_HandleTypeDef *hsd)
{
 8006534:	b580      	push	{r7, lr}
 8006536:	b090      	sub	sp, #64	@ 0x40
 8006538:	af00      	add	r7, sp, #0
 800653a:	6078      	str	r0, [r7, #4]
  HAL_SD_CardCSDTypeDef CSD;
  uint32_t errorstate;
  uint16_t sd_rca = 0U;
 800653c:	2300      	movs	r3, #0
 800653e:	817b      	strh	r3, [r7, #10]
  uint32_t tickstart = HAL_GetTick();
 8006540:	f7fa fd1c 	bl	8000f7c <HAL_GetTick>
 8006544:	63f8      	str	r0, [r7, #60]	@ 0x3c

  /* Check the power State */
  if (SDMMC_GetPowerState(hsd->Instance) == 0U)
 8006546:	687b      	ldr	r3, [r7, #4]
 8006548:	681b      	ldr	r3, [r3, #0]
 800654a:	4618      	mov	r0, r3
 800654c:	f001 f949 	bl	80077e2 <SDMMC_GetPowerState>
 8006550:	4603      	mov	r3, r0
 8006552:	2b00      	cmp	r3, #0
 8006554:	d102      	bne.n	800655c <SD_InitCard+0x28>
  {
    /* Power off */
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
 8006556:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
 800655a:	e0b5      	b.n	80066c8 <SD_InitCard+0x194>
  }

  if (hsd->SdCard.CardType != CARD_SECURED)
 800655c:	687b      	ldr	r3, [r7, #4]
 800655e:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8006560:	2b03      	cmp	r3, #3
 8006562:	d02e      	beq.n	80065c2 <SD_InitCard+0x8e>
  {
    /* Send CMD2 ALL_SEND_CID */
    errorstate = SDMMC_CmdSendCID(hsd->Instance);
 8006564:	687b      	ldr	r3, [r7, #4]
 8006566:	681b      	ldr	r3, [r3, #0]
 8006568:	4618      	mov	r0, r3
 800656a:	f001 fb94 	bl	8007c96 <SDMMC_CmdSendCID>
 800656e:	63b8      	str	r0, [r7, #56]	@ 0x38
    if (errorstate != HAL_SD_ERROR_NONE)
 8006570:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8006572:	2b00      	cmp	r3, #0
 8006574:	d001      	beq.n	800657a <SD_InitCard+0x46>
    {
      return errorstate;
 8006576:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8006578:	e0a6      	b.n	80066c8 <SD_InitCard+0x194>
    }
    else
    {
      /* Get Card identification number data */
      hsd->CID[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 800657a:	687b      	ldr	r3, [r7, #4]
 800657c:	681b      	ldr	r3, [r3, #0]
 800657e:	2100      	movs	r1, #0
 8006580:	4618      	mov	r0, r3
 8006582:	f001 f974 	bl	800786e <SDMMC_GetResponse>
 8006586:	4602      	mov	r2, r0
 8006588:	687b      	ldr	r3, [r7, #4]
 800658a:	66da      	str	r2, [r3, #108]	@ 0x6c
      hsd->CID[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 800658c:	687b      	ldr	r3, [r7, #4]
 800658e:	681b      	ldr	r3, [r3, #0]
 8006590:	2104      	movs	r1, #4
 8006592:	4618      	mov	r0, r3
 8006594:	f001 f96b 	bl	800786e <SDMMC_GetResponse>
 8006598:	4602      	mov	r2, r0
 800659a:	687b      	ldr	r3, [r7, #4]
 800659c:	671a      	str	r2, [r3, #112]	@ 0x70
      hsd->CID[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 800659e:	687b      	ldr	r3, [r7, #4]
 80065a0:	681b      	ldr	r3, [r3, #0]
 80065a2:	2108      	movs	r1, #8
 80065a4:	4618      	mov	r0, r3
 80065a6:	f001 f962 	bl	800786e <SDMMC_GetResponse>
 80065aa:	4602      	mov	r2, r0
 80065ac:	687b      	ldr	r3, [r7, #4]
 80065ae:	675a      	str	r2, [r3, #116]	@ 0x74
      hsd->CID[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
 80065b0:	687b      	ldr	r3, [r7, #4]
 80065b2:	681b      	ldr	r3, [r3, #0]
 80065b4:	210c      	movs	r1, #12
 80065b6:	4618      	mov	r0, r3
 80065b8:	f001 f959 	bl	800786e <SDMMC_GetResponse>
 80065bc:	4602      	mov	r2, r0
 80065be:	687b      	ldr	r3, [r7, #4]
 80065c0:	679a      	str	r2, [r3, #120]	@ 0x78
    }
  }

  if (hsd->SdCard.CardType != CARD_SECURED)
 80065c2:	687b      	ldr	r3, [r7, #4]
 80065c4:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80065c6:	2b03      	cmp	r3, #3
 80065c8:	d01d      	beq.n	8006606 <SD_InitCard+0xd2>
  {
    /* Send CMD3 SET_REL_ADDR with argument 0 */
    /* SD Card publishes its RCA. */
    while (sd_rca == 0U)
 80065ca:	e019      	b.n	8006600 <SD_InitCard+0xcc>
    {
      errorstate = SDMMC_CmdSetRelAdd(hsd->Instance, &sd_rca);
 80065cc:	687b      	ldr	r3, [r7, #4]
 80065ce:	681b      	ldr	r3, [r3, #0]
 80065d0:	f107 020a 	add.w	r2, r7, #10
 80065d4:	4611      	mov	r1, r2
 80065d6:	4618      	mov	r0, r3
 80065d8:	f001 fb9c 	bl	8007d14 <SDMMC_CmdSetRelAdd>
 80065dc:	63b8      	str	r0, [r7, #56]	@ 0x38
      if (errorstate != HAL_SD_ERROR_NONE)
 80065de:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80065e0:	2b00      	cmp	r3, #0
 80065e2:	d001      	beq.n	80065e8 <SD_InitCard+0xb4>
      {
        return errorstate;
 80065e4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80065e6:	e06f      	b.n	80066c8 <SD_InitCard+0x194>
      }
      if ((HAL_GetTick() - tickstart) >=  SDMMC_CMDTIMEOUT)
 80065e8:	f7fa fcc8 	bl	8000f7c <HAL_GetTick>
 80065ec:	4602      	mov	r2, r0
 80065ee:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80065f0:	1ad3      	subs	r3, r2, r3
 80065f2:	f241 3287 	movw	r2, #4999	@ 0x1387
 80065f6:	4293      	cmp	r3, r2
 80065f8:	d902      	bls.n	8006600 <SD_InitCard+0xcc>
      {
        return HAL_SD_ERROR_TIMEOUT;
 80065fa:	f04f 4300 	mov.w	r3, #2147483648	@ 0x80000000
 80065fe:	e063      	b.n	80066c8 <SD_InitCard+0x194>
    while (sd_rca == 0U)
 8006600:	897b      	ldrh	r3, [r7, #10]
 8006602:	2b00      	cmp	r3, #0
 8006604:	d0e2      	beq.n	80065cc <SD_InitCard+0x98>
      }
    }
  }
  if (hsd->SdCard.CardType != CARD_SECURED)
 8006606:	687b      	ldr	r3, [r7, #4]
 8006608:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800660a:	2b03      	cmp	r3, #3
 800660c:	d036      	beq.n	800667c <SD_InitCard+0x148>
  {
    /* Get the SD card RCA */
    hsd->SdCard.RelCardAdd = sd_rca;
 800660e:	897b      	ldrh	r3, [r7, #10]
 8006610:	461a      	mov	r2, r3
 8006612:	687b      	ldr	r3, [r7, #4]
 8006614:	645a      	str	r2, [r3, #68]	@ 0x44

    /* Send CMD9 SEND_CSD with argument as card's RCA */
    errorstate = SDMMC_CmdSendCSD(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 8006616:	687b      	ldr	r3, [r7, #4]
 8006618:	681a      	ldr	r2, [r3, #0]
 800661a:	687b      	ldr	r3, [r7, #4]
 800661c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800661e:	041b      	lsls	r3, r3, #16
 8006620:	4619      	mov	r1, r3
 8006622:	4610      	mov	r0, r2
 8006624:	f001 fb56 	bl	8007cd4 <SDMMC_CmdSendCSD>
 8006628:	63b8      	str	r0, [r7, #56]	@ 0x38
    if (errorstate != HAL_SD_ERROR_NONE)
 800662a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800662c:	2b00      	cmp	r3, #0
 800662e:	d001      	beq.n	8006634 <SD_InitCard+0x100>
    {
      return errorstate;
 8006630:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8006632:	e049      	b.n	80066c8 <SD_InitCard+0x194>
    }
    else
    {
      /* Get Card Specific Data */
      hsd->CSD[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 8006634:	687b      	ldr	r3, [r7, #4]
 8006636:	681b      	ldr	r3, [r3, #0]
 8006638:	2100      	movs	r1, #0
 800663a:	4618      	mov	r0, r3
 800663c:	f001 f917 	bl	800786e <SDMMC_GetResponse>
 8006640:	4602      	mov	r2, r0
 8006642:	687b      	ldr	r3, [r7, #4]
 8006644:	65da      	str	r2, [r3, #92]	@ 0x5c
      hsd->CSD[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 8006646:	687b      	ldr	r3, [r7, #4]
 8006648:	681b      	ldr	r3, [r3, #0]
 800664a:	2104      	movs	r1, #4
 800664c:	4618      	mov	r0, r3
 800664e:	f001 f90e 	bl	800786e <SDMMC_GetResponse>
 8006652:	4602      	mov	r2, r0
 8006654:	687b      	ldr	r3, [r7, #4]
 8006656:	661a      	str	r2, [r3, #96]	@ 0x60
      hsd->CSD[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 8006658:	687b      	ldr	r3, [r7, #4]
 800665a:	681b      	ldr	r3, [r3, #0]
 800665c:	2108      	movs	r1, #8
 800665e:	4618      	mov	r0, r3
 8006660:	f001 f905 	bl	800786e <SDMMC_GetResponse>
 8006664:	4602      	mov	r2, r0
 8006666:	687b      	ldr	r3, [r7, #4]
 8006668:	665a      	str	r2, [r3, #100]	@ 0x64
      hsd->CSD[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
 800666a:	687b      	ldr	r3, [r7, #4]
 800666c:	681b      	ldr	r3, [r3, #0]
 800666e:	210c      	movs	r1, #12
 8006670:	4618      	mov	r0, r3
 8006672:	f001 f8fc 	bl	800786e <SDMMC_GetResponse>
 8006676:	4602      	mov	r2, r0
 8006678:	687b      	ldr	r3, [r7, #4]
 800667a:	669a      	str	r2, [r3, #104]	@ 0x68
    }
  }

  /* Get the Card Class */
  hsd->SdCard.Class = (SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2) >> 20U);
 800667c:	687b      	ldr	r3, [r7, #4]
 800667e:	681b      	ldr	r3, [r3, #0]
 8006680:	2104      	movs	r1, #4
 8006682:	4618      	mov	r0, r3
 8006684:	f001 f8f3 	bl	800786e <SDMMC_GetResponse>
 8006688:	4603      	mov	r3, r0
 800668a:	0d1a      	lsrs	r2, r3, #20
 800668c:	687b      	ldr	r3, [r7, #4]
 800668e:	641a      	str	r2, [r3, #64]	@ 0x40

  /* Get CSD parameters */
  if (HAL_SD_GetCardCSD(hsd, &CSD) != HAL_OK)
 8006690:	f107 030c 	add.w	r3, r7, #12
 8006694:	4619      	mov	r1, r3
 8006696:	6878      	ldr	r0, [r7, #4]
 8006698:	f7ff fbb8 	bl	8005e0c <HAL_SD_GetCardCSD>
 800669c:	4603      	mov	r3, r0
 800669e:	2b00      	cmp	r3, #0
 80066a0:	d002      	beq.n	80066a8 <SD_InitCard+0x174>
  {
    return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 80066a2:	f04f 5380 	mov.w	r3, #268435456	@ 0x10000000
 80066a6:	e00f      	b.n	80066c8 <SD_InitCard+0x194>
  }

  /* Select the Card */
  errorstate = SDMMC_CmdSelDesel(hsd->Instance, (uint32_t)(((uint32_t)hsd->SdCard.RelCardAdd) << 16U));
 80066a8:	687b      	ldr	r3, [r7, #4]
 80066aa:	681a      	ldr	r2, [r3, #0]
 80066ac:	687b      	ldr	r3, [r7, #4]
 80066ae:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80066b0:	041b      	lsls	r3, r3, #16
 80066b2:	4619      	mov	r1, r3
 80066b4:	4610      	mov	r0, r2
 80066b6:	f001 fa05 	bl	8007ac4 <SDMMC_CmdSelDesel>
 80066ba:	63b8      	str	r0, [r7, #56]	@ 0x38
  if (errorstate != HAL_SD_ERROR_NONE)
 80066bc:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80066be:	2b00      	cmp	r3, #0
 80066c0:	d001      	beq.n	80066c6 <SD_InitCard+0x192>
  {
    return errorstate;
 80066c2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80066c4:	e000      	b.n	80066c8 <SD_InitCard+0x194>
  }

  /* All cards are initialized */
  return HAL_SD_ERROR_NONE;
 80066c6:	2300      	movs	r3, #0
}
 80066c8:	4618      	mov	r0, r3
 80066ca:	3740      	adds	r7, #64	@ 0x40
 80066cc:	46bd      	mov	sp, r7
 80066ce:	bd80      	pop	{r7, pc}

080066d0 <SD_PowerON>:
  *         in the SD handle.
  * @param  hsd: Pointer to SD handle
  * @retval error state
  */
static uint32_t SD_PowerON(SD_HandleTypeDef *hsd)
{
 80066d0:	b580      	push	{r7, lr}
 80066d2:	b086      	sub	sp, #24
 80066d4:	af00      	add	r7, sp, #0
 80066d6:	6078      	str	r0, [r7, #4]
  __IO uint32_t count = 0U;
 80066d8:	2300      	movs	r3, #0
 80066da:	60bb      	str	r3, [r7, #8]
  uint32_t response = 0U;
 80066dc:	2300      	movs	r3, #0
 80066de:	617b      	str	r3, [r7, #20]
  uint32_t validvoltage = 0U;
 80066e0:	2300      	movs	r3, #0
 80066e2:	613b      	str	r3, [r7, #16]
#if (USE_SD_TRANSCEIVER != 0U)
  uint32_t tickstart = HAL_GetTick();
#endif /* USE_SD_TRANSCEIVER  */

  /* CMD0: GO_IDLE_STATE */
  errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
 80066e4:	687b      	ldr	r3, [r7, #4]
 80066e6:	681b      	ldr	r3, [r3, #0]
 80066e8:	4618      	mov	r0, r3
 80066ea:	f001 fa0e 	bl	8007b0a <SDMMC_CmdGoIdleState>
 80066ee:	60f8      	str	r0, [r7, #12]
  if (errorstate != HAL_SD_ERROR_NONE)
 80066f0:	68fb      	ldr	r3, [r7, #12]
 80066f2:	2b00      	cmp	r3, #0
 80066f4:	d001      	beq.n	80066fa <SD_PowerON+0x2a>
  {
    return errorstate;
 80066f6:	68fb      	ldr	r3, [r7, #12]
 80066f8:	e072      	b.n	80067e0 <SD_PowerON+0x110>
  }

  /* CMD8: SEND_IF_COND: Command available only on V2.0 cards */
  errorstate = SDMMC_CmdOperCond(hsd->Instance);
 80066fa:	687b      	ldr	r3, [r7, #4]
 80066fc:	681b      	ldr	r3, [r3, #0]
 80066fe:	4618      	mov	r0, r3
 8006700:	f001 fa21 	bl	8007b46 <SDMMC_CmdOperCond>
 8006704:	60f8      	str	r0, [r7, #12]
  if (errorstate == SDMMC_ERROR_TIMEOUT) /* No response to CMD8 */
 8006706:	68fb      	ldr	r3, [r7, #12]
 8006708:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 800670c:	d10d      	bne.n	800672a <SD_PowerON+0x5a>
  {
    hsd->SdCard.CardVersion = CARD_V1_X;
 800670e:	687b      	ldr	r3, [r7, #4]
 8006710:	2200      	movs	r2, #0
 8006712:	63da      	str	r2, [r3, #60]	@ 0x3c
    /* CMD0: GO_IDLE_STATE */
    errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
 8006714:	687b      	ldr	r3, [r7, #4]
 8006716:	681b      	ldr	r3, [r3, #0]
 8006718:	4618      	mov	r0, r3
 800671a:	f001 f9f6 	bl	8007b0a <SDMMC_CmdGoIdleState>
 800671e:	60f8      	str	r0, [r7, #12]
    if (errorstate != HAL_SD_ERROR_NONE)
 8006720:	68fb      	ldr	r3, [r7, #12]
 8006722:	2b00      	cmp	r3, #0
 8006724:	d004      	beq.n	8006730 <SD_PowerON+0x60>
    {
      return errorstate;
 8006726:	68fb      	ldr	r3, [r7, #12]
 8006728:	e05a      	b.n	80067e0 <SD_PowerON+0x110>
    }

  }
  else
  {
    hsd->SdCard.CardVersion = CARD_V2_X;
 800672a:	687b      	ldr	r3, [r7, #4]
 800672c:	2201      	movs	r2, #1
 800672e:	63da      	str	r2, [r3, #60]	@ 0x3c
  }

  if (hsd->SdCard.CardVersion == CARD_V2_X)
 8006730:	687b      	ldr	r3, [r7, #4]
 8006732:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8006734:	2b01      	cmp	r3, #1
 8006736:	d137      	bne.n	80067a8 <SD_PowerON+0xd8>
  {
    /* SEND CMD55 APP_CMD with RCA as 0 */
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, 0);
 8006738:	687b      	ldr	r3, [r7, #4]
 800673a:	681b      	ldr	r3, [r3, #0]
 800673c:	2100      	movs	r1, #0
 800673e:	4618      	mov	r0, r3
 8006740:	f001 fa21 	bl	8007b86 <SDMMC_CmdAppCommand>
 8006744:	60f8      	str	r0, [r7, #12]
    if (errorstate != HAL_SD_ERROR_NONE)
 8006746:	68fb      	ldr	r3, [r7, #12]
 8006748:	2b00      	cmp	r3, #0
 800674a:	d02d      	beq.n	80067a8 <SD_PowerON+0xd8>
    {
      return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 800674c:	f04f 5380 	mov.w	r3, #268435456	@ 0x10000000
 8006750:	e046      	b.n	80067e0 <SD_PowerON+0x110>
  /* SD CARD */
  /* Send ACMD41 SD_APP_OP_COND with Argument 0x80100000 */
  while ((count < SDMMC_MAX_VOLT_TRIAL) && (validvoltage == 0U))
  {
    /* SEND CMD55 APP_CMD with RCA as 0 */
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, 0);
 8006752:	687b      	ldr	r3, [r7, #4]
 8006754:	681b      	ldr	r3, [r3, #0]
 8006756:	2100      	movs	r1, #0
 8006758:	4618      	mov	r0, r3
 800675a:	f001 fa14 	bl	8007b86 <SDMMC_CmdAppCommand>
 800675e:	60f8      	str	r0, [r7, #12]
    if (errorstate != HAL_SD_ERROR_NONE)
 8006760:	68fb      	ldr	r3, [r7, #12]
 8006762:	2b00      	cmp	r3, #0
 8006764:	d001      	beq.n	800676a <SD_PowerON+0x9a>
    {
      return errorstate;
 8006766:	68fb      	ldr	r3, [r7, #12]
 8006768:	e03a      	b.n	80067e0 <SD_PowerON+0x110>
    }

    /* Send CMD41 */
    errorstate = SDMMC_CmdAppOperCommand(hsd->Instance, SDMMC_VOLTAGE_WINDOW_SD | SDMMC_HIGH_CAPACITY |
 800676a:	687b      	ldr	r3, [r7, #4]
 800676c:	681b      	ldr	r3, [r3, #0]
 800676e:	491e      	ldr	r1, [pc, #120]	@ (80067e8 <SD_PowerON+0x118>)
 8006770:	4618      	mov	r0, r3
 8006772:	f001 fa2b 	bl	8007bcc <SDMMC_CmdAppOperCommand>
 8006776:	60f8      	str	r0, [r7, #12]
                                         SD_SWITCH_1_8V_CAPACITY);
    if (errorstate != HAL_SD_ERROR_NONE)
 8006778:	68fb      	ldr	r3, [r7, #12]
 800677a:	2b00      	cmp	r3, #0
 800677c:	d002      	beq.n	8006784 <SD_PowerON+0xb4>
    {
      return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 800677e:	f04f 5380 	mov.w	r3, #268435456	@ 0x10000000
 8006782:	e02d      	b.n	80067e0 <SD_PowerON+0x110>
    }

    /* Get command response */
    response = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 8006784:	687b      	ldr	r3, [r7, #4]
 8006786:	681b      	ldr	r3, [r3, #0]
 8006788:	2100      	movs	r1, #0
 800678a:	4618      	mov	r0, r3
 800678c:	f001 f86f 	bl	800786e <SDMMC_GetResponse>
 8006790:	6178      	str	r0, [r7, #20]

    /* Get operating voltage*/
    validvoltage = (((response >> 31U) == 1U) ? 1U : 0U);
 8006792:	697b      	ldr	r3, [r7, #20]
 8006794:	0fdb      	lsrs	r3, r3, #31
 8006796:	2b01      	cmp	r3, #1
 8006798:	d101      	bne.n	800679e <SD_PowerON+0xce>
 800679a:	2301      	movs	r3, #1
 800679c:	e000      	b.n	80067a0 <SD_PowerON+0xd0>
 800679e:	2300      	movs	r3, #0
 80067a0:	613b      	str	r3, [r7, #16]

    count++;
 80067a2:	68bb      	ldr	r3, [r7, #8]
 80067a4:	3301      	adds	r3, #1
 80067a6:	60bb      	str	r3, [r7, #8]
  while ((count < SDMMC_MAX_VOLT_TRIAL) && (validvoltage == 0U))
 80067a8:	68bb      	ldr	r3, [r7, #8]
 80067aa:	f64f 72fe 	movw	r2, #65534	@ 0xfffe
 80067ae:	4293      	cmp	r3, r2
 80067b0:	d802      	bhi.n	80067b8 <SD_PowerON+0xe8>
 80067b2:	693b      	ldr	r3, [r7, #16]
 80067b4:	2b00      	cmp	r3, #0
 80067b6:	d0cc      	beq.n	8006752 <SD_PowerON+0x82>
  }

  if (count >= SDMMC_MAX_VOLT_TRIAL)
 80067b8:	68bb      	ldr	r3, [r7, #8]
 80067ba:	f64f 72fe 	movw	r2, #65534	@ 0xfffe
 80067be:	4293      	cmp	r3, r2
 80067c0:	d902      	bls.n	80067c8 <SD_PowerON+0xf8>
  {
    return HAL_SD_ERROR_INVALID_VOLTRANGE;
 80067c2:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
 80067c6:	e00b      	b.n	80067e0 <SD_PowerON+0x110>
  }

  /* Set default card type */
  hsd->SdCard.CardType = CARD_SDSC;
 80067c8:	687b      	ldr	r3, [r7, #4]
 80067ca:	2200      	movs	r2, #0
 80067cc:	639a      	str	r2, [r3, #56]	@ 0x38

  if ((response & SDMMC_HIGH_CAPACITY) == SDMMC_HIGH_CAPACITY)
 80067ce:	697b      	ldr	r3, [r7, #20]
 80067d0:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
 80067d4:	2b00      	cmp	r3, #0
 80067d6:	d002      	beq.n	80067de <SD_PowerON+0x10e>
  {
    hsd->SdCard.CardType = CARD_SDHC_SDXC;
 80067d8:	687b      	ldr	r3, [r7, #4]
 80067da:	2201      	movs	r2, #1
 80067dc:	639a      	str	r2, [r3, #56]	@ 0x38
      }
    }
#endif /* USE_SD_TRANSCEIVER  */
  }

  return HAL_SD_ERROR_NONE;
 80067de:	2300      	movs	r3, #0
}
 80067e0:	4618      	mov	r0, r3
 80067e2:	3718      	adds	r7, #24
 80067e4:	46bd      	mov	sp, r7
 80067e6:	bd80      	pop	{r7, pc}
 80067e8:	c1100000 	.word	0xc1100000

080067ec <SD_SendSDStatus>:
  * @param  pSDstatus: Pointer to the buffer that will contain the SD card status
  *         SD Status register)
  * @retval error state
  */
static uint32_t SD_SendSDStatus(SD_HandleTypeDef *hsd, uint32_t *pSDstatus)
{
 80067ec:	b580      	push	{r7, lr}
 80067ee:	b08c      	sub	sp, #48	@ 0x30
 80067f0:	af00      	add	r7, sp, #0
 80067f2:	6078      	str	r0, [r7, #4]
 80067f4:	6039      	str	r1, [r7, #0]
  SDMMC_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t tickstart = HAL_GetTick();
 80067f6:	f7fa fbc1 	bl	8000f7c <HAL_GetTick>
 80067fa:	6278      	str	r0, [r7, #36]	@ 0x24
  uint32_t count;
  uint32_t *pData = pSDstatus;
 80067fc:	683b      	ldr	r3, [r7, #0]
 80067fe:	62bb      	str	r3, [r7, #40]	@ 0x28

  /* Check SD response */
  if ((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 8006800:	687b      	ldr	r3, [r7, #4]
 8006802:	681b      	ldr	r3, [r3, #0]
 8006804:	2100      	movs	r1, #0
 8006806:	4618      	mov	r0, r3
 8006808:	f001 f831 	bl	800786e <SDMMC_GetResponse>
 800680c:	4603      	mov	r3, r0
 800680e:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 8006812:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 8006816:	d102      	bne.n	800681e <SD_SendSDStatus+0x32>
  {
    return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
 8006818:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 800681c:	e0b0      	b.n	8006980 <SD_SendSDStatus+0x194>
  }

  /* Set block size for card if it is not equal to current block size for card */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, 64U);
 800681e:	687b      	ldr	r3, [r7, #4]
 8006820:	681b      	ldr	r3, [r3, #0]
 8006822:	2140      	movs	r1, #64	@ 0x40
 8006824:	4618      	mov	r0, r3
 8006826:	f001 f861 	bl	80078ec <SDMMC_CmdBlockLength>
 800682a:	6238      	str	r0, [r7, #32]
  if (errorstate != HAL_SD_ERROR_NONE)
 800682c:	6a3b      	ldr	r3, [r7, #32]
 800682e:	2b00      	cmp	r3, #0
 8006830:	d005      	beq.n	800683e <SD_SendSDStatus+0x52>
  {
    hsd->ErrorCode |= HAL_SD_ERROR_NONE;
 8006832:	687b      	ldr	r3, [r7, #4]
 8006834:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8006836:	687b      	ldr	r3, [r7, #4]
 8006838:	635a      	str	r2, [r3, #52]	@ 0x34
    return errorstate;
 800683a:	6a3b      	ldr	r3, [r7, #32]
 800683c:	e0a0      	b.n	8006980 <SD_SendSDStatus+0x194>
  }

  /* Send CMD55 */
  errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 800683e:	687b      	ldr	r3, [r7, #4]
 8006840:	681a      	ldr	r2, [r3, #0]
 8006842:	687b      	ldr	r3, [r7, #4]
 8006844:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8006846:	041b      	lsls	r3, r3, #16
 8006848:	4619      	mov	r1, r3
 800684a:	4610      	mov	r0, r2
 800684c:	f001 f99b 	bl	8007b86 <SDMMC_CmdAppCommand>
 8006850:	6238      	str	r0, [r7, #32]
  if (errorstate != HAL_SD_ERROR_NONE)
 8006852:	6a3b      	ldr	r3, [r7, #32]
 8006854:	2b00      	cmp	r3, #0
 8006856:	d005      	beq.n	8006864 <SD_SendSDStatus+0x78>
  {
    hsd->ErrorCode |= HAL_SD_ERROR_NONE;
 8006858:	687b      	ldr	r3, [r7, #4]
 800685a:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 800685c:	687b      	ldr	r3, [r7, #4]
 800685e:	635a      	str	r2, [r3, #52]	@ 0x34
    return errorstate;
 8006860:	6a3b      	ldr	r3, [r7, #32]
 8006862:	e08d      	b.n	8006980 <SD_SendSDStatus+0x194>
  }

  /* Configure the SD DPSM (Data Path State Machine) */
  config.DataTimeOut   = SDMMC_DATATIMEOUT;
 8006864:	f04f 33ff 	mov.w	r3, #4294967295
 8006868:	60bb      	str	r3, [r7, #8]
  config.DataLength    = 64U;
 800686a:	2340      	movs	r3, #64	@ 0x40
 800686c:	60fb      	str	r3, [r7, #12]
  config.DataBlockSize = SDMMC_DATABLOCK_SIZE_64B;
 800686e:	2360      	movs	r3, #96	@ 0x60
 8006870:	613b      	str	r3, [r7, #16]
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 8006872:	2302      	movs	r3, #2
 8006874:	617b      	str	r3, [r7, #20]
  config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
 8006876:	2300      	movs	r3, #0
 8006878:	61bb      	str	r3, [r7, #24]
  config.DPSM          = SDMMC_DPSM_ENABLE;
 800687a:	2301      	movs	r3, #1
 800687c:	61fb      	str	r3, [r7, #28]
  (void)SDMMC_ConfigData(hsd->Instance, &config);
 800687e:	687b      	ldr	r3, [r7, #4]
 8006880:	681b      	ldr	r3, [r3, #0]
 8006882:	f107 0208 	add.w	r2, r7, #8
 8006886:	4611      	mov	r1, r2
 8006888:	4618      	mov	r0, r3
 800688a:	f001 f803 	bl	8007894 <SDMMC_ConfigData>

  /* Send ACMD13 (SD_APP_STAUS)  with argument as card's RCA */
  errorstate = SDMMC_CmdStatusRegister(hsd->Instance);
 800688e:	687b      	ldr	r3, [r7, #4]
 8006890:	681b      	ldr	r3, [r3, #0]
 8006892:	4618      	mov	r0, r3
 8006894:	f001 fa83 	bl	8007d9e <SDMMC_CmdStatusRegister>
 8006898:	6238      	str	r0, [r7, #32]
  if (errorstate != HAL_SD_ERROR_NONE)
 800689a:	6a3b      	ldr	r3, [r7, #32]
 800689c:	2b00      	cmp	r3, #0
 800689e:	d02b      	beq.n	80068f8 <SD_SendSDStatus+0x10c>
  {
    hsd->ErrorCode |= HAL_SD_ERROR_NONE;
 80068a0:	687b      	ldr	r3, [r7, #4]
 80068a2:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 80068a4:	687b      	ldr	r3, [r7, #4]
 80068a6:	635a      	str	r2, [r3, #52]	@ 0x34
    return errorstate;
 80068a8:	6a3b      	ldr	r3, [r7, #32]
 80068aa:	e069      	b.n	8006980 <SD_SendSDStatus+0x194>
  }

  /* Get status data */
  while (!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
  {
    if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF))
 80068ac:	687b      	ldr	r3, [r7, #4]
 80068ae:	681b      	ldr	r3, [r3, #0]
 80068b0:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80068b2:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 80068b6:	2b00      	cmp	r3, #0
 80068b8:	d013      	beq.n	80068e2 <SD_SendSDStatus+0xf6>
    {
      for (count = 0U; count < 8U; count++)
 80068ba:	2300      	movs	r3, #0
 80068bc:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80068be:	e00d      	b.n	80068dc <SD_SendSDStatus+0xf0>
      {
        *pData = SDMMC_ReadFIFO(hsd->Instance);
 80068c0:	687b      	ldr	r3, [r7, #4]
 80068c2:	681b      	ldr	r3, [r3, #0]
 80068c4:	4618      	mov	r0, r3
 80068c6:	f000 ff5d 	bl	8007784 <SDMMC_ReadFIFO>
 80068ca:	4602      	mov	r2, r0
 80068cc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80068ce:	601a      	str	r2, [r3, #0]
        pData++;
 80068d0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80068d2:	3304      	adds	r3, #4
 80068d4:	62bb      	str	r3, [r7, #40]	@ 0x28
      for (count = 0U; count < 8U; count++)
 80068d6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80068d8:	3301      	adds	r3, #1
 80068da:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80068dc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80068de:	2b07      	cmp	r3, #7
 80068e0:	d9ee      	bls.n	80068c0 <SD_SendSDStatus+0xd4>
      }
    }

    if ((HAL_GetTick() - tickstart) >=  SDMMC_SWDATATIMEOUT)
 80068e2:	f7fa fb4b 	bl	8000f7c <HAL_GetTick>
 80068e6:	4602      	mov	r2, r0
 80068e8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80068ea:	1ad3      	subs	r3, r2, r3
 80068ec:	f1b3 3fff 	cmp.w	r3, #4294967295
 80068f0:	d102      	bne.n	80068f8 <SD_SendSDStatus+0x10c>
    {
      return HAL_SD_ERROR_TIMEOUT;
 80068f2:	f04f 4300 	mov.w	r3, #2147483648	@ 0x80000000
 80068f6:	e043      	b.n	8006980 <SD_SendSDStatus+0x194>
  while (!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
 80068f8:	687b      	ldr	r3, [r7, #4]
 80068fa:	681b      	ldr	r3, [r3, #0]
 80068fc:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80068fe:	f403 7395 	and.w	r3, r3, #298	@ 0x12a
 8006902:	2b00      	cmp	r3, #0
 8006904:	d0d2      	beq.n	80068ac <SD_SendSDStatus+0xc0>
    }
  }

  if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
 8006906:	687b      	ldr	r3, [r7, #4]
 8006908:	681b      	ldr	r3, [r3, #0]
 800690a:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800690c:	f003 0308 	and.w	r3, r3, #8
 8006910:	2b00      	cmp	r3, #0
 8006912:	d001      	beq.n	8006918 <SD_SendSDStatus+0x12c>
  {
    return HAL_SD_ERROR_DATA_TIMEOUT;
 8006914:	2308      	movs	r3, #8
 8006916:	e033      	b.n	8006980 <SD_SendSDStatus+0x194>
  }
  else if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
 8006918:	687b      	ldr	r3, [r7, #4]
 800691a:	681b      	ldr	r3, [r3, #0]
 800691c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800691e:	f003 0302 	and.w	r3, r3, #2
 8006922:	2b00      	cmp	r3, #0
 8006924:	d001      	beq.n	800692a <SD_SendSDStatus+0x13e>
  {
    return HAL_SD_ERROR_DATA_CRC_FAIL;
 8006926:	2302      	movs	r3, #2
 8006928:	e02a      	b.n	8006980 <SD_SendSDStatus+0x194>
  }
  else if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
 800692a:	687b      	ldr	r3, [r7, #4]
 800692c:	681b      	ldr	r3, [r3, #0]
 800692e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8006930:	f003 0320 	and.w	r3, r3, #32
 8006934:	2b00      	cmp	r3, #0
 8006936:	d017      	beq.n	8006968 <SD_SendSDStatus+0x17c>
  {
    return HAL_SD_ERROR_RX_OVERRUN;
 8006938:	2320      	movs	r3, #32
 800693a:	e021      	b.n	8006980 <SD_SendSDStatus+0x194>
    /* Nothing to do */
  }

  while ((__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DPSMACT)))
  {
    *pData = SDMMC_ReadFIFO(hsd->Instance);
 800693c:	687b      	ldr	r3, [r7, #4]
 800693e:	681b      	ldr	r3, [r3, #0]
 8006940:	4618      	mov	r0, r3
 8006942:	f000 ff1f 	bl	8007784 <SDMMC_ReadFIFO>
 8006946:	4602      	mov	r2, r0
 8006948:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800694a:	601a      	str	r2, [r3, #0]
    pData++;
 800694c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800694e:	3304      	adds	r3, #4
 8006950:	62bb      	str	r3, [r7, #40]	@ 0x28

    if ((HAL_GetTick() - tickstart) >=  SDMMC_SWDATATIMEOUT)
 8006952:	f7fa fb13 	bl	8000f7c <HAL_GetTick>
 8006956:	4602      	mov	r2, r0
 8006958:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800695a:	1ad3      	subs	r3, r2, r3
 800695c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8006960:	d102      	bne.n	8006968 <SD_SendSDStatus+0x17c>
    {
      return HAL_SD_ERROR_TIMEOUT;
 8006962:	f04f 4300 	mov.w	r3, #2147483648	@ 0x80000000
 8006966:	e00b      	b.n	8006980 <SD_SendSDStatus+0x194>
  while ((__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DPSMACT)))
 8006968:	687b      	ldr	r3, [r7, #4]
 800696a:	681b      	ldr	r3, [r3, #0]
 800696c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800696e:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
 8006972:	2b00      	cmp	r3, #0
 8006974:	d1e2      	bne.n	800693c <SD_SendSDStatus+0x150>
    }
  }

  /* Clear all the static status flags*/
  __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 8006976:	687b      	ldr	r3, [r7, #4]
 8006978:	681b      	ldr	r3, [r3, #0]
 800697a:	4a03      	ldr	r2, [pc, #12]	@ (8006988 <SD_SendSDStatus+0x19c>)
 800697c:	639a      	str	r2, [r3, #56]	@ 0x38

  return HAL_SD_ERROR_NONE;
 800697e:	2300      	movs	r3, #0
}
 8006980:	4618      	mov	r0, r3
 8006982:	3730      	adds	r7, #48	@ 0x30
 8006984:	46bd      	mov	sp, r7
 8006986:	bd80      	pop	{r7, pc}
 8006988:	18000f3a 	.word	0x18000f3a

0800698c <SD_SendStatus>:
  * @param  pCardStatus: pointer to the buffer that will contain the SD card
  *         status (Card Status register)
  * @retval error state
  */
static uint32_t SD_SendStatus(SD_HandleTypeDef *hsd, uint32_t *pCardStatus)
{
 800698c:	b580      	push	{r7, lr}
 800698e:	b084      	sub	sp, #16
 8006990:	af00      	add	r7, sp, #0
 8006992:	6078      	str	r0, [r7, #4]
 8006994:	6039      	str	r1, [r7, #0]
  uint32_t errorstate;

  if (pCardStatus == NULL)
 8006996:	683b      	ldr	r3, [r7, #0]
 8006998:	2b00      	cmp	r3, #0
 800699a:	d102      	bne.n	80069a2 <SD_SendStatus+0x16>
  {
    return HAL_SD_ERROR_PARAM;
 800699c:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
 80069a0:	e018      	b.n	80069d4 <SD_SendStatus+0x48>
  }

  /* Send Status command */
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 80069a2:	687b      	ldr	r3, [r7, #4]
 80069a4:	681a      	ldr	r2, [r3, #0]
 80069a6:	687b      	ldr	r3, [r7, #4]
 80069a8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80069aa:	041b      	lsls	r3, r3, #16
 80069ac:	4619      	mov	r1, r3
 80069ae:	4610      	mov	r0, r2
 80069b0:	f001 f9d2 	bl	8007d58 <SDMMC_CmdSendStatus>
 80069b4:	60f8      	str	r0, [r7, #12]
  if (errorstate != HAL_SD_ERROR_NONE)
 80069b6:	68fb      	ldr	r3, [r7, #12]
 80069b8:	2b00      	cmp	r3, #0
 80069ba:	d001      	beq.n	80069c0 <SD_SendStatus+0x34>
  {
    return errorstate;
 80069bc:	68fb      	ldr	r3, [r7, #12]
 80069be:	e009      	b.n	80069d4 <SD_SendStatus+0x48>
  }

  /* Get SD card status */
  *pCardStatus = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 80069c0:	687b      	ldr	r3, [r7, #4]
 80069c2:	681b      	ldr	r3, [r3, #0]
 80069c4:	2100      	movs	r1, #0
 80069c6:	4618      	mov	r0, r3
 80069c8:	f000 ff51 	bl	800786e <SDMMC_GetResponse>
 80069cc:	4602      	mov	r2, r0
 80069ce:	683b      	ldr	r3, [r7, #0]
 80069d0:	601a      	str	r2, [r3, #0]

  return HAL_SD_ERROR_NONE;
 80069d2:	2300      	movs	r3, #0
}
 80069d4:	4618      	mov	r0, r3
 80069d6:	3710      	adds	r7, #16
 80069d8:	46bd      	mov	sp, r7
 80069da:	bd80      	pop	{r7, pc}

080069dc <SD_WideBus_Enable>:
  * @brief  Enables the SDMMC wide bus mode.
  * @param  hsd: pointer to SD handle
  * @retval error state
  */
static uint32_t SD_WideBus_Enable(SD_HandleTypeDef *hsd)
{
 80069dc:	b580      	push	{r7, lr}
 80069de:	b086      	sub	sp, #24
 80069e0:	af00      	add	r7, sp, #0
 80069e2:	6078      	str	r0, [r7, #4]
  uint32_t scr[2U] = {0UL, 0UL};
 80069e4:	2300      	movs	r3, #0
 80069e6:	60fb      	str	r3, [r7, #12]
 80069e8:	2300      	movs	r3, #0
 80069ea:	613b      	str	r3, [r7, #16]
  uint32_t errorstate;

  if ((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 80069ec:	687b      	ldr	r3, [r7, #4]
 80069ee:	681b      	ldr	r3, [r3, #0]
 80069f0:	2100      	movs	r1, #0
 80069f2:	4618      	mov	r0, r3
 80069f4:	f000 ff3b 	bl	800786e <SDMMC_GetResponse>
 80069f8:	4603      	mov	r3, r0
 80069fa:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 80069fe:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 8006a02:	d102      	bne.n	8006a0a <SD_WideBus_Enable+0x2e>
  {
    return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
 8006a04:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8006a08:	e02f      	b.n	8006a6a <SD_WideBus_Enable+0x8e>
  }

  /* Get SCR Register */
  errorstate = SD_FindSCR(hsd, scr);
 8006a0a:	f107 030c 	add.w	r3, r7, #12
 8006a0e:	4619      	mov	r1, r3
 8006a10:	6878      	ldr	r0, [r7, #4]
 8006a12:	f000 f879 	bl	8006b08 <SD_FindSCR>
 8006a16:	6178      	str	r0, [r7, #20]
  if (errorstate != HAL_SD_ERROR_NONE)
 8006a18:	697b      	ldr	r3, [r7, #20]
 8006a1a:	2b00      	cmp	r3, #0
 8006a1c:	d001      	beq.n	8006a22 <SD_WideBus_Enable+0x46>
  {
    return errorstate;
 8006a1e:	697b      	ldr	r3, [r7, #20]
 8006a20:	e023      	b.n	8006a6a <SD_WideBus_Enable+0x8e>
  }

  /* If requested card supports wide bus operation */
  if ((scr[1U] & SDMMC_WIDE_BUS_SUPPORT) != SDMMC_ALLZERO)
 8006a22:	693b      	ldr	r3, [r7, #16]
 8006a24:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
 8006a28:	2b00      	cmp	r3, #0
 8006a2a:	d01c      	beq.n	8006a66 <SD_WideBus_Enable+0x8a>
  {
    /* Send CMD55 APP_CMD with argument as card's RCA.*/
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 8006a2c:	687b      	ldr	r3, [r7, #4]
 8006a2e:	681a      	ldr	r2, [r3, #0]
 8006a30:	687b      	ldr	r3, [r7, #4]
 8006a32:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8006a34:	041b      	lsls	r3, r3, #16
 8006a36:	4619      	mov	r1, r3
 8006a38:	4610      	mov	r0, r2
 8006a3a:	f001 f8a4 	bl	8007b86 <SDMMC_CmdAppCommand>
 8006a3e:	6178      	str	r0, [r7, #20]
    if (errorstate != HAL_SD_ERROR_NONE)
 8006a40:	697b      	ldr	r3, [r7, #20]
 8006a42:	2b00      	cmp	r3, #0
 8006a44:	d001      	beq.n	8006a4a <SD_WideBus_Enable+0x6e>
    {
      return errorstate;
 8006a46:	697b      	ldr	r3, [r7, #20]
 8006a48:	e00f      	b.n	8006a6a <SD_WideBus_Enable+0x8e>
    }

    /* Send ACMD6 APP_CMD with argument as 2 for wide bus mode */
    errorstate = SDMMC_CmdBusWidth(hsd->Instance, 2U);
 8006a4a:	687b      	ldr	r3, [r7, #4]
 8006a4c:	681b      	ldr	r3, [r3, #0]
 8006a4e:	2102      	movs	r1, #2
 8006a50:	4618      	mov	r0, r3
 8006a52:	f001 f8db 	bl	8007c0c <SDMMC_CmdBusWidth>
 8006a56:	6178      	str	r0, [r7, #20]
    if (errorstate != HAL_SD_ERROR_NONE)
 8006a58:	697b      	ldr	r3, [r7, #20]
 8006a5a:	2b00      	cmp	r3, #0
 8006a5c:	d001      	beq.n	8006a62 <SD_WideBus_Enable+0x86>
    {
      return errorstate;
 8006a5e:	697b      	ldr	r3, [r7, #20]
 8006a60:	e003      	b.n	8006a6a <SD_WideBus_Enable+0x8e>
    }

    return HAL_SD_ERROR_NONE;
 8006a62:	2300      	movs	r3, #0
 8006a64:	e001      	b.n	8006a6a <SD_WideBus_Enable+0x8e>
  }
  else
  {
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
 8006a66:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
  }
}
 8006a6a:	4618      	mov	r0, r3
 8006a6c:	3718      	adds	r7, #24
 8006a6e:	46bd      	mov	sp, r7
 8006a70:	bd80      	pop	{r7, pc}

08006a72 <SD_WideBus_Disable>:
  * @brief  Disables the SDMMC wide bus mode.
  * @param  hsd: Pointer to SD handle
  * @retval error state
  */
static uint32_t SD_WideBus_Disable(SD_HandleTypeDef *hsd)
{
 8006a72:	b580      	push	{r7, lr}
 8006a74:	b086      	sub	sp, #24
 8006a76:	af00      	add	r7, sp, #0
 8006a78:	6078      	str	r0, [r7, #4]
  uint32_t scr[2U] = {0UL, 0UL};
 8006a7a:	2300      	movs	r3, #0
 8006a7c:	60fb      	str	r3, [r7, #12]
 8006a7e:	2300      	movs	r3, #0
 8006a80:	613b      	str	r3, [r7, #16]
  uint32_t errorstate;

  if ((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 8006a82:	687b      	ldr	r3, [r7, #4]
 8006a84:	681b      	ldr	r3, [r3, #0]
 8006a86:	2100      	movs	r1, #0
 8006a88:	4618      	mov	r0, r3
 8006a8a:	f000 fef0 	bl	800786e <SDMMC_GetResponse>
 8006a8e:	4603      	mov	r3, r0
 8006a90:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 8006a94:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 8006a98:	d102      	bne.n	8006aa0 <SD_WideBus_Disable+0x2e>
  {
    return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
 8006a9a:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8006a9e:	e02f      	b.n	8006b00 <SD_WideBus_Disable+0x8e>
  }

  /* Get SCR Register */
  errorstate = SD_FindSCR(hsd, scr);
 8006aa0:	f107 030c 	add.w	r3, r7, #12
 8006aa4:	4619      	mov	r1, r3
 8006aa6:	6878      	ldr	r0, [r7, #4]
 8006aa8:	f000 f82e 	bl	8006b08 <SD_FindSCR>
 8006aac:	6178      	str	r0, [r7, #20]
  if (errorstate != HAL_SD_ERROR_NONE)
 8006aae:	697b      	ldr	r3, [r7, #20]
 8006ab0:	2b00      	cmp	r3, #0
 8006ab2:	d001      	beq.n	8006ab8 <SD_WideBus_Disable+0x46>
  {
    return errorstate;
 8006ab4:	697b      	ldr	r3, [r7, #20]
 8006ab6:	e023      	b.n	8006b00 <SD_WideBus_Disable+0x8e>
  }

  /* If requested card supports 1 bit mode operation */
  if ((scr[1U] & SDMMC_SINGLE_BUS_SUPPORT) != SDMMC_ALLZERO)
 8006ab8:	693b      	ldr	r3, [r7, #16]
 8006aba:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 8006abe:	2b00      	cmp	r3, #0
 8006ac0:	d01c      	beq.n	8006afc <SD_WideBus_Disable+0x8a>
  {
    /* Send CMD55 APP_CMD with argument as card's RCA */
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 8006ac2:	687b      	ldr	r3, [r7, #4]
 8006ac4:	681a      	ldr	r2, [r3, #0]
 8006ac6:	687b      	ldr	r3, [r7, #4]
 8006ac8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8006aca:	041b      	lsls	r3, r3, #16
 8006acc:	4619      	mov	r1, r3
 8006ace:	4610      	mov	r0, r2
 8006ad0:	f001 f859 	bl	8007b86 <SDMMC_CmdAppCommand>
 8006ad4:	6178      	str	r0, [r7, #20]
    if (errorstate != HAL_SD_ERROR_NONE)
 8006ad6:	697b      	ldr	r3, [r7, #20]
 8006ad8:	2b00      	cmp	r3, #0
 8006ada:	d001      	beq.n	8006ae0 <SD_WideBus_Disable+0x6e>
    {
      return errorstate;
 8006adc:	697b      	ldr	r3, [r7, #20]
 8006ade:	e00f      	b.n	8006b00 <SD_WideBus_Disable+0x8e>
    }

    /* Send ACMD6 APP_CMD with argument as 0 for single bus mode */
    errorstate = SDMMC_CmdBusWidth(hsd->Instance, 0U);
 8006ae0:	687b      	ldr	r3, [r7, #4]
 8006ae2:	681b      	ldr	r3, [r3, #0]
 8006ae4:	2100      	movs	r1, #0
 8006ae6:	4618      	mov	r0, r3
 8006ae8:	f001 f890 	bl	8007c0c <SDMMC_CmdBusWidth>
 8006aec:	6178      	str	r0, [r7, #20]
    if (errorstate != HAL_SD_ERROR_NONE)
 8006aee:	697b      	ldr	r3, [r7, #20]
 8006af0:	2b00      	cmp	r3, #0
 8006af2:	d001      	beq.n	8006af8 <SD_WideBus_Disable+0x86>
    {
      return errorstate;
 8006af4:	697b      	ldr	r3, [r7, #20]
 8006af6:	e003      	b.n	8006b00 <SD_WideBus_Disable+0x8e>
    }

    return HAL_SD_ERROR_NONE;
 8006af8:	2300      	movs	r3, #0
 8006afa:	e001      	b.n	8006b00 <SD_WideBus_Disable+0x8e>
  }
  else
  {
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
 8006afc:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
  }
}
 8006b00:	4618      	mov	r0, r3
 8006b02:	3718      	adds	r7, #24
 8006b04:	46bd      	mov	sp, r7
 8006b06:	bd80      	pop	{r7, pc}

08006b08 <SD_FindSCR>:
  * @param  hsd: Pointer to SD handle
  * @param  pSCR: pointer to the buffer that will contain the SCR value
  * @retval error state
  */
static uint32_t SD_FindSCR(SD_HandleTypeDef *hsd, uint32_t *pSCR)
{
 8006b08:	b580      	push	{r7, lr}
 8006b0a:	b08e      	sub	sp, #56	@ 0x38
 8006b0c:	af00      	add	r7, sp, #0
 8006b0e:	6078      	str	r0, [r7, #4]
 8006b10:	6039      	str	r1, [r7, #0]
  SDMMC_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t tickstart = HAL_GetTick();
 8006b12:	f7fa fa33 	bl	8000f7c <HAL_GetTick>
 8006b16:	6338      	str	r0, [r7, #48]	@ 0x30
  uint32_t index = 0U;
 8006b18:	2300      	movs	r3, #0
 8006b1a:	637b      	str	r3, [r7, #52]	@ 0x34
  uint32_t tempscr[2U] = {0UL, 0UL};
 8006b1c:	2300      	movs	r3, #0
 8006b1e:	60bb      	str	r3, [r7, #8]
 8006b20:	2300      	movs	r3, #0
 8006b22:	60fb      	str	r3, [r7, #12]
  uint32_t *scr = pSCR;
 8006b24:	683b      	ldr	r3, [r7, #0]
 8006b26:	62fb      	str	r3, [r7, #44]	@ 0x2c

  /* Set Block Size To 8 Bytes */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, 8U);
 8006b28:	687b      	ldr	r3, [r7, #4]
 8006b2a:	681b      	ldr	r3, [r3, #0]
 8006b2c:	2108      	movs	r1, #8
 8006b2e:	4618      	mov	r0, r3
 8006b30:	f000 fedc 	bl	80078ec <SDMMC_CmdBlockLength>
 8006b34:	62b8      	str	r0, [r7, #40]	@ 0x28
  if (errorstate != HAL_SD_ERROR_NONE)
 8006b36:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8006b38:	2b00      	cmp	r3, #0
 8006b3a:	d001      	beq.n	8006b40 <SD_FindSCR+0x38>
  {
    return errorstate;
 8006b3c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8006b3e:	e0ad      	b.n	8006c9c <SD_FindSCR+0x194>
  }

  /* Send CMD55 APP_CMD with argument as card's RCA */
  errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)((hsd->SdCard.RelCardAdd) << 16U));
 8006b40:	687b      	ldr	r3, [r7, #4]
 8006b42:	681a      	ldr	r2, [r3, #0]
 8006b44:	687b      	ldr	r3, [r7, #4]
 8006b46:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8006b48:	041b      	lsls	r3, r3, #16
 8006b4a:	4619      	mov	r1, r3
 8006b4c:	4610      	mov	r0, r2
 8006b4e:	f001 f81a 	bl	8007b86 <SDMMC_CmdAppCommand>
 8006b52:	62b8      	str	r0, [r7, #40]	@ 0x28
  if (errorstate != HAL_SD_ERROR_NONE)
 8006b54:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8006b56:	2b00      	cmp	r3, #0
 8006b58:	d001      	beq.n	8006b5e <SD_FindSCR+0x56>
  {
    return errorstate;
 8006b5a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8006b5c:	e09e      	b.n	8006c9c <SD_FindSCR+0x194>
  }

  config.DataTimeOut   = SDMMC_DATATIMEOUT;
 8006b5e:	f04f 33ff 	mov.w	r3, #4294967295
 8006b62:	613b      	str	r3, [r7, #16]
  config.DataLength    = 8U;
 8006b64:	2308      	movs	r3, #8
 8006b66:	617b      	str	r3, [r7, #20]
  config.DataBlockSize = SDMMC_DATABLOCK_SIZE_8B;
 8006b68:	2330      	movs	r3, #48	@ 0x30
 8006b6a:	61bb      	str	r3, [r7, #24]
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 8006b6c:	2302      	movs	r3, #2
 8006b6e:	61fb      	str	r3, [r7, #28]
  config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
 8006b70:	2300      	movs	r3, #0
 8006b72:	623b      	str	r3, [r7, #32]
  config.DPSM          = SDMMC_DPSM_ENABLE;
 8006b74:	2301      	movs	r3, #1
 8006b76:	627b      	str	r3, [r7, #36]	@ 0x24
  (void)SDMMC_ConfigData(hsd->Instance, &config);
 8006b78:	687b      	ldr	r3, [r7, #4]
 8006b7a:	681b      	ldr	r3, [r3, #0]
 8006b7c:	f107 0210 	add.w	r2, r7, #16
 8006b80:	4611      	mov	r1, r2
 8006b82:	4618      	mov	r0, r3
 8006b84:	f000 fe86 	bl	8007894 <SDMMC_ConfigData>

  /* Send ACMD51 SD_APP_SEND_SCR with argument as 0 */
  errorstate = SDMMC_CmdSendSCR(hsd->Instance);
 8006b88:	687b      	ldr	r3, [r7, #4]
 8006b8a:	681b      	ldr	r3, [r3, #0]
 8006b8c:	4618      	mov	r0, r3
 8006b8e:	f001 f860 	bl	8007c52 <SDMMC_CmdSendSCR>
 8006b92:	62b8      	str	r0, [r7, #40]	@ 0x28
  if (errorstate != HAL_SD_ERROR_NONE)
 8006b94:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8006b96:	2b00      	cmp	r3, #0
 8006b98:	d027      	beq.n	8006bea <SD_FindSCR+0xe2>
  {
    return errorstate;
 8006b9a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8006b9c:	e07e      	b.n	8006c9c <SD_FindSCR+0x194>
  }

  while (!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DBCKEND |
                            SDMMC_FLAG_DATAEND))
  {
    if ((!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOE)) && (index == 0U))
 8006b9e:	687b      	ldr	r3, [r7, #4]
 8006ba0:	681b      	ldr	r3, [r3, #0]
 8006ba2:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8006ba4:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
 8006ba8:	2b00      	cmp	r3, #0
 8006baa:	d113      	bne.n	8006bd4 <SD_FindSCR+0xcc>
 8006bac:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8006bae:	2b00      	cmp	r3, #0
 8006bb0:	d110      	bne.n	8006bd4 <SD_FindSCR+0xcc>
    {
      tempscr[0] = SDMMC_ReadFIFO(hsd->Instance);
 8006bb2:	687b      	ldr	r3, [r7, #4]
 8006bb4:	681b      	ldr	r3, [r3, #0]
 8006bb6:	4618      	mov	r0, r3
 8006bb8:	f000 fde4 	bl	8007784 <SDMMC_ReadFIFO>
 8006bbc:	4603      	mov	r3, r0
 8006bbe:	60bb      	str	r3, [r7, #8]
      tempscr[1] = SDMMC_ReadFIFO(hsd->Instance);
 8006bc0:	687b      	ldr	r3, [r7, #4]
 8006bc2:	681b      	ldr	r3, [r3, #0]
 8006bc4:	4618      	mov	r0, r3
 8006bc6:	f000 fddd 	bl	8007784 <SDMMC_ReadFIFO>
 8006bca:	4603      	mov	r3, r0
 8006bcc:	60fb      	str	r3, [r7, #12]
      index++;
 8006bce:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8006bd0:	3301      	adds	r3, #1
 8006bd2:	637b      	str	r3, [r7, #52]	@ 0x34
    }

    if ((HAL_GetTick() - tickstart) >=  SDMMC_SWDATATIMEOUT)
 8006bd4:	f7fa f9d2 	bl	8000f7c <HAL_GetTick>
 8006bd8:	4602      	mov	r2, r0
 8006bda:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8006bdc:	1ad3      	subs	r3, r2, r3
 8006bde:	f1b3 3fff 	cmp.w	r3, #4294967295
 8006be2:	d102      	bne.n	8006bea <SD_FindSCR+0xe2>
    {
      return HAL_SD_ERROR_TIMEOUT;
 8006be4:	f04f 4300 	mov.w	r3, #2147483648	@ 0x80000000
 8006be8:	e058      	b.n	8006c9c <SD_FindSCR+0x194>
  while (!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DBCKEND |
 8006bea:	687b      	ldr	r3, [r7, #4]
 8006bec:	681b      	ldr	r3, [r3, #0]
 8006bee:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8006bf0:	f240 532a 	movw	r3, #1322	@ 0x52a
 8006bf4:	4013      	ands	r3, r2
 8006bf6:	2b00      	cmp	r3, #0
 8006bf8:	d0d1      	beq.n	8006b9e <SD_FindSCR+0x96>
    }
  }

  if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
 8006bfa:	687b      	ldr	r3, [r7, #4]
 8006bfc:	681b      	ldr	r3, [r3, #0]
 8006bfe:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8006c00:	f003 0308 	and.w	r3, r3, #8
 8006c04:	2b00      	cmp	r3, #0
 8006c06:	d005      	beq.n	8006c14 <SD_FindSCR+0x10c>
  {
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DTIMEOUT);
 8006c08:	687b      	ldr	r3, [r7, #4]
 8006c0a:	681b      	ldr	r3, [r3, #0]
 8006c0c:	2208      	movs	r2, #8
 8006c0e:	639a      	str	r2, [r3, #56]	@ 0x38

    return HAL_SD_ERROR_DATA_TIMEOUT;
 8006c10:	2308      	movs	r3, #8
 8006c12:	e043      	b.n	8006c9c <SD_FindSCR+0x194>
  }
  else if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
 8006c14:	687b      	ldr	r3, [r7, #4]
 8006c16:	681b      	ldr	r3, [r3, #0]
 8006c18:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8006c1a:	f003 0302 	and.w	r3, r3, #2
 8006c1e:	2b00      	cmp	r3, #0
 8006c20:	d005      	beq.n	8006c2e <SD_FindSCR+0x126>
  {
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DCRCFAIL);
 8006c22:	687b      	ldr	r3, [r7, #4]
 8006c24:	681b      	ldr	r3, [r3, #0]
 8006c26:	2202      	movs	r2, #2
 8006c28:	639a      	str	r2, [r3, #56]	@ 0x38

    return HAL_SD_ERROR_DATA_CRC_FAIL;
 8006c2a:	2302      	movs	r3, #2
 8006c2c:	e036      	b.n	8006c9c <SD_FindSCR+0x194>
  }
  else if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
 8006c2e:	687b      	ldr	r3, [r7, #4]
 8006c30:	681b      	ldr	r3, [r3, #0]
 8006c32:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8006c34:	f003 0320 	and.w	r3, r3, #32
 8006c38:	2b00      	cmp	r3, #0
 8006c3a:	d005      	beq.n	8006c48 <SD_FindSCR+0x140>
  {
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_RXOVERR);
 8006c3c:	687b      	ldr	r3, [r7, #4]
 8006c3e:	681b      	ldr	r3, [r3, #0]
 8006c40:	2220      	movs	r2, #32
 8006c42:	639a      	str	r2, [r3, #56]	@ 0x38

    return HAL_SD_ERROR_RX_OVERRUN;
 8006c44:	2320      	movs	r3, #32
 8006c46:	e029      	b.n	8006c9c <SD_FindSCR+0x194>
  }
  else
  {
    /* No error flag set */
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 8006c48:	687b      	ldr	r3, [r7, #4]
 8006c4a:	681b      	ldr	r3, [r3, #0]
 8006c4c:	4a15      	ldr	r2, [pc, #84]	@ (8006ca4 <SD_FindSCR+0x19c>)
 8006c4e:	639a      	str	r2, [r3, #56]	@ 0x38

    *scr = (((tempscr[1] & SDMMC_0TO7BITS) << 24U)  | ((tempscr[1] & SDMMC_8TO15BITS) << 8U) | \
 8006c50:	68fb      	ldr	r3, [r7, #12]
 8006c52:	061a      	lsls	r2, r3, #24
 8006c54:	68fb      	ldr	r3, [r7, #12]
 8006c56:	021b      	lsls	r3, r3, #8
 8006c58:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
 8006c5c:	431a      	orrs	r2, r3
            ((tempscr[1] & SDMMC_16TO23BITS) >> 8U) | ((tempscr[1] & SDMMC_24TO31BITS) >> 24U));
 8006c5e:	68fb      	ldr	r3, [r7, #12]
 8006c60:	0a1b      	lsrs	r3, r3, #8
 8006c62:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
    *scr = (((tempscr[1] & SDMMC_0TO7BITS) << 24U)  | ((tempscr[1] & SDMMC_8TO15BITS) << 8U) | \
 8006c66:	431a      	orrs	r2, r3
            ((tempscr[1] & SDMMC_16TO23BITS) >> 8U) | ((tempscr[1] & SDMMC_24TO31BITS) >> 24U));
 8006c68:	68fb      	ldr	r3, [r7, #12]
 8006c6a:	0e1b      	lsrs	r3, r3, #24
 8006c6c:	431a      	orrs	r2, r3
    *scr = (((tempscr[1] & SDMMC_0TO7BITS) << 24U)  | ((tempscr[1] & SDMMC_8TO15BITS) << 8U) | \
 8006c6e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8006c70:	601a      	str	r2, [r3, #0]
    scr++;
 8006c72:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8006c74:	3304      	adds	r3, #4
 8006c76:	62fb      	str	r3, [r7, #44]	@ 0x2c
    *scr = (((tempscr[0] & SDMMC_0TO7BITS) << 24U)  | ((tempscr[0] & SDMMC_8TO15BITS) << 8U) | \
 8006c78:	68bb      	ldr	r3, [r7, #8]
 8006c7a:	061a      	lsls	r2, r3, #24
 8006c7c:	68bb      	ldr	r3, [r7, #8]
 8006c7e:	021b      	lsls	r3, r3, #8
 8006c80:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
 8006c84:	431a      	orrs	r2, r3
            ((tempscr[0] & SDMMC_16TO23BITS) >> 8U) | ((tempscr[0] & SDMMC_24TO31BITS) >> 24U));
 8006c86:	68bb      	ldr	r3, [r7, #8]
 8006c88:	0a1b      	lsrs	r3, r3, #8
 8006c8a:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
    *scr = (((tempscr[0] & SDMMC_0TO7BITS) << 24U)  | ((tempscr[0] & SDMMC_8TO15BITS) << 8U) | \
 8006c8e:	431a      	orrs	r2, r3
            ((tempscr[0] & SDMMC_16TO23BITS) >> 8U) | ((tempscr[0] & SDMMC_24TO31BITS) >> 24U));
 8006c90:	68bb      	ldr	r3, [r7, #8]
 8006c92:	0e1b      	lsrs	r3, r3, #24
 8006c94:	431a      	orrs	r2, r3
    *scr = (((tempscr[0] & SDMMC_0TO7BITS) << 24U)  | ((tempscr[0] & SDMMC_8TO15BITS) << 8U) | \
 8006c96:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8006c98:	601a      	str	r2, [r3, #0]

  }

  return HAL_SD_ERROR_NONE;
 8006c9a:	2300      	movs	r3, #0
}
 8006c9c:	4618      	mov	r0, r3
 8006c9e:	3738      	adds	r7, #56	@ 0x38
 8006ca0:	46bd      	mov	sp, r7
 8006ca2:	bd80      	pop	{r7, pc}
 8006ca4:	18000f3a 	.word	0x18000f3a

08006ca8 <SD_Read_IT>:
  * @param  hsd: pointer to a SD_HandleTypeDef structure that contains
  *              the configuration information.
  * @retval None
  */
static void SD_Read_IT(SD_HandleTypeDef *hsd)
{
 8006ca8:	b580      	push	{r7, lr}
 8006caa:	b086      	sub	sp, #24
 8006cac:	af00      	add	r7, sp, #0
 8006cae:	6078      	str	r0, [r7, #4]
  uint32_t count;
  uint32_t data;
  uint8_t *tmp;

  tmp = hsd->pRxBuffPtr;
 8006cb0:	687b      	ldr	r3, [r7, #4]
 8006cb2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8006cb4:	613b      	str	r3, [r7, #16]

  if (hsd->RxXferSize >= SDMMC_FIFO_SIZE)
 8006cb6:	687b      	ldr	r3, [r7, #4]
 8006cb8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8006cba:	2b1f      	cmp	r3, #31
 8006cbc:	d936      	bls.n	8006d2c <SD_Read_IT+0x84>
  {
    /* Read data from SDMMC Rx FIFO */
    for (count = 0U; count < (SDMMC_FIFO_SIZE / 4U); count++)
 8006cbe:	2300      	movs	r3, #0
 8006cc0:	617b      	str	r3, [r7, #20]
 8006cc2:	e027      	b.n	8006d14 <SD_Read_IT+0x6c>
    {
      data = SDMMC_ReadFIFO(hsd->Instance);
 8006cc4:	687b      	ldr	r3, [r7, #4]
 8006cc6:	681b      	ldr	r3, [r3, #0]
 8006cc8:	4618      	mov	r0, r3
 8006cca:	f000 fd5b 	bl	8007784 <SDMMC_ReadFIFO>
 8006cce:	60f8      	str	r0, [r7, #12]
      *tmp = (uint8_t)(data & 0xFFU);
 8006cd0:	68fb      	ldr	r3, [r7, #12]
 8006cd2:	b2da      	uxtb	r2, r3
 8006cd4:	693b      	ldr	r3, [r7, #16]
 8006cd6:	701a      	strb	r2, [r3, #0]
      tmp++;
 8006cd8:	693b      	ldr	r3, [r7, #16]
 8006cda:	3301      	adds	r3, #1
 8006cdc:	613b      	str	r3, [r7, #16]
      *tmp = (uint8_t)((data >> 8U) & 0xFFU);
 8006cde:	68fb      	ldr	r3, [r7, #12]
 8006ce0:	0a1b      	lsrs	r3, r3, #8
 8006ce2:	b2da      	uxtb	r2, r3
 8006ce4:	693b      	ldr	r3, [r7, #16]
 8006ce6:	701a      	strb	r2, [r3, #0]
      tmp++;
 8006ce8:	693b      	ldr	r3, [r7, #16]
 8006cea:	3301      	adds	r3, #1
 8006cec:	613b      	str	r3, [r7, #16]
      *tmp = (uint8_t)((data >> 16U) & 0xFFU);
 8006cee:	68fb      	ldr	r3, [r7, #12]
 8006cf0:	0c1b      	lsrs	r3, r3, #16
 8006cf2:	b2da      	uxtb	r2, r3
 8006cf4:	693b      	ldr	r3, [r7, #16]
 8006cf6:	701a      	strb	r2, [r3, #0]
      tmp++;
 8006cf8:	693b      	ldr	r3, [r7, #16]
 8006cfa:	3301      	adds	r3, #1
 8006cfc:	613b      	str	r3, [r7, #16]
      *tmp = (uint8_t)((data >> 24U) & 0xFFU);
 8006cfe:	68fb      	ldr	r3, [r7, #12]
 8006d00:	0e1b      	lsrs	r3, r3, #24
 8006d02:	b2da      	uxtb	r2, r3
 8006d04:	693b      	ldr	r3, [r7, #16]
 8006d06:	701a      	strb	r2, [r3, #0]
      tmp++;
 8006d08:	693b      	ldr	r3, [r7, #16]
 8006d0a:	3301      	adds	r3, #1
 8006d0c:	613b      	str	r3, [r7, #16]
    for (count = 0U; count < (SDMMC_FIFO_SIZE / 4U); count++)
 8006d0e:	697b      	ldr	r3, [r7, #20]
 8006d10:	3301      	adds	r3, #1
 8006d12:	617b      	str	r3, [r7, #20]
 8006d14:	697b      	ldr	r3, [r7, #20]
 8006d16:	2b07      	cmp	r3, #7
 8006d18:	d9d4      	bls.n	8006cc4 <SD_Read_IT+0x1c>
    }

    hsd->pRxBuffPtr = tmp;
 8006d1a:	687b      	ldr	r3, [r7, #4]
 8006d1c:	693a      	ldr	r2, [r7, #16]
 8006d1e:	625a      	str	r2, [r3, #36]	@ 0x24
    hsd->RxXferSize -= SDMMC_FIFO_SIZE;
 8006d20:	687b      	ldr	r3, [r7, #4]
 8006d22:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8006d24:	f1a3 0220 	sub.w	r2, r3, #32
 8006d28:	687b      	ldr	r3, [r7, #4]
 8006d2a:	629a      	str	r2, [r3, #40]	@ 0x28
  }
}
 8006d2c:	bf00      	nop
 8006d2e:	3718      	adds	r7, #24
 8006d30:	46bd      	mov	sp, r7
 8006d32:	bd80      	pop	{r7, pc}

08006d34 <SD_Write_IT>:
  * @param  hsd: pointer to a SD_HandleTypeDef structure that contains
  *              the configuration information.
  * @retval None
  */
static void SD_Write_IT(SD_HandleTypeDef *hsd)
{
 8006d34:	b580      	push	{r7, lr}
 8006d36:	b086      	sub	sp, #24
 8006d38:	af00      	add	r7, sp, #0
 8006d3a:	6078      	str	r0, [r7, #4]
  uint32_t count;
  uint32_t data;
  const uint8_t *tmp;

  tmp = hsd->pTxBuffPtr;
 8006d3c:	687b      	ldr	r3, [r7, #4]
 8006d3e:	69db      	ldr	r3, [r3, #28]
 8006d40:	613b      	str	r3, [r7, #16]

  if (hsd->TxXferSize >= SDMMC_FIFO_SIZE)
 8006d42:	687b      	ldr	r3, [r7, #4]
 8006d44:	6a1b      	ldr	r3, [r3, #32]
 8006d46:	2b1f      	cmp	r3, #31
 8006d48:	d93a      	bls.n	8006dc0 <SD_Write_IT+0x8c>
  {
    /* Write data to SDMMC Tx FIFO */
    for (count = 0U; count < (SDMMC_FIFO_SIZE / 4U); count++)
 8006d4a:	2300      	movs	r3, #0
 8006d4c:	617b      	str	r3, [r7, #20]
 8006d4e:	e02b      	b.n	8006da8 <SD_Write_IT+0x74>
    {
      data = (uint32_t)(*tmp);
 8006d50:	693b      	ldr	r3, [r7, #16]
 8006d52:	781b      	ldrb	r3, [r3, #0]
 8006d54:	60fb      	str	r3, [r7, #12]
      tmp++;
 8006d56:	693b      	ldr	r3, [r7, #16]
 8006d58:	3301      	adds	r3, #1
 8006d5a:	613b      	str	r3, [r7, #16]
      data |= ((uint32_t)(*tmp) << 8U);
 8006d5c:	693b      	ldr	r3, [r7, #16]
 8006d5e:	781b      	ldrb	r3, [r3, #0]
 8006d60:	021a      	lsls	r2, r3, #8
 8006d62:	68fb      	ldr	r3, [r7, #12]
 8006d64:	4313      	orrs	r3, r2
 8006d66:	60fb      	str	r3, [r7, #12]
      tmp++;
 8006d68:	693b      	ldr	r3, [r7, #16]
 8006d6a:	3301      	adds	r3, #1
 8006d6c:	613b      	str	r3, [r7, #16]
      data |= ((uint32_t)(*tmp) << 16U);
 8006d6e:	693b      	ldr	r3, [r7, #16]
 8006d70:	781b      	ldrb	r3, [r3, #0]
 8006d72:	041a      	lsls	r2, r3, #16
 8006d74:	68fb      	ldr	r3, [r7, #12]
 8006d76:	4313      	orrs	r3, r2
 8006d78:	60fb      	str	r3, [r7, #12]
      tmp++;
 8006d7a:	693b      	ldr	r3, [r7, #16]
 8006d7c:	3301      	adds	r3, #1
 8006d7e:	613b      	str	r3, [r7, #16]
      data |= ((uint32_t)(*tmp) << 24U);
 8006d80:	693b      	ldr	r3, [r7, #16]
 8006d82:	781b      	ldrb	r3, [r3, #0]
 8006d84:	061a      	lsls	r2, r3, #24
 8006d86:	68fb      	ldr	r3, [r7, #12]
 8006d88:	4313      	orrs	r3, r2
 8006d8a:	60fb      	str	r3, [r7, #12]
      tmp++;
 8006d8c:	693b      	ldr	r3, [r7, #16]
 8006d8e:	3301      	adds	r3, #1
 8006d90:	613b      	str	r3, [r7, #16]
      (void)SDMMC_WriteFIFO(hsd->Instance, &data);
 8006d92:	687b      	ldr	r3, [r7, #4]
 8006d94:	681b      	ldr	r3, [r3, #0]
 8006d96:	f107 020c 	add.w	r2, r7, #12
 8006d9a:	4611      	mov	r1, r2
 8006d9c:	4618      	mov	r0, r3
 8006d9e:	f000 fcfe 	bl	800779e <SDMMC_WriteFIFO>
    for (count = 0U; count < (SDMMC_FIFO_SIZE / 4U); count++)
 8006da2:	697b      	ldr	r3, [r7, #20]
 8006da4:	3301      	adds	r3, #1
 8006da6:	617b      	str	r3, [r7, #20]
 8006da8:	697b      	ldr	r3, [r7, #20]
 8006daa:	2b07      	cmp	r3, #7
 8006dac:	d9d0      	bls.n	8006d50 <SD_Write_IT+0x1c>
    }

    hsd->pTxBuffPtr = tmp;
 8006dae:	687b      	ldr	r3, [r7, #4]
 8006db0:	693a      	ldr	r2, [r7, #16]
 8006db2:	61da      	str	r2, [r3, #28]
    hsd->TxXferSize -= SDMMC_FIFO_SIZE;
 8006db4:	687b      	ldr	r3, [r7, #4]
 8006db6:	6a1b      	ldr	r3, [r3, #32]
 8006db8:	f1a3 0220 	sub.w	r2, r3, #32
 8006dbc:	687b      	ldr	r3, [r7, #4]
 8006dbe:	621a      	str	r2, [r3, #32]
  }
}
 8006dc0:	bf00      	nop
 8006dc2:	3718      	adds	r7, #24
 8006dc4:	46bd      	mov	sp, r7
 8006dc6:	bd80      	pop	{r7, pc}

08006dc8 <HAL_SDEx_Read_DMALnkLstBufCpltCallback>:
  * @brief Read DMA Linked list node Transfer completed callbacks
  * @param hsd: SD handle
  * @retval None
  */
__weak void HAL_SDEx_Read_DMALnkLstBufCpltCallback(SD_HandleTypeDef *hsd)
{
 8006dc8:	b480      	push	{r7}
 8006dca:	b083      	sub	sp, #12
 8006dcc:	af00      	add	r7, sp, #0
 8006dce:	6078      	str	r0, [r7, #4]
  UNUSED(hsd);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SDEx_Read_DMALnkLstBufCpltCallback can be implemented in the user file
   */
}
 8006dd0:	bf00      	nop
 8006dd2:	370c      	adds	r7, #12
 8006dd4:	46bd      	mov	sp, r7
 8006dd6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006dda:	4770      	bx	lr

08006ddc <HAL_SDEx_Write_DMALnkLstBufCpltCallback>:
  * @brief Read DMA Linked list node Transfer completed callbacks
  * @param hsd: SD handle
  * @retval None
  */
__weak void HAL_SDEx_Write_DMALnkLstBufCpltCallback(SD_HandleTypeDef *hsd)
{
 8006ddc:	b480      	push	{r7}
 8006dde:	b083      	sub	sp, #12
 8006de0:	af00      	add	r7, sp, #0
 8006de2:	6078      	str	r0, [r7, #4]
  UNUSED(hsd);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SDEx_Write_DMALnkLstBufCpltCallback can be implemented in the user file
   */
}
 8006de4:	bf00      	nop
 8006de6:	370c      	adds	r7, #12
 8006de8:	46bd      	mov	sp, r7
 8006dea:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006dee:	4770      	bx	lr

08006df0 <HAL_UART_Init>:
  *        parameters in the UART_InitTypeDef and initialize the associated handle.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
 8006df0:	b580      	push	{r7, lr}
 8006df2:	b082      	sub	sp, #8
 8006df4:	af00      	add	r7, sp, #0
 8006df6:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if (huart == NULL)
 8006df8:	687b      	ldr	r3, [r7, #4]
 8006dfa:	2b00      	cmp	r3, #0
 8006dfc:	d101      	bne.n	8006e02 <HAL_UART_Init+0x12>
  {
    return HAL_ERROR;
 8006dfe:	2301      	movs	r3, #1
 8006e00:	e042      	b.n	8006e88 <HAL_UART_Init+0x98>
  {
    /* Check the parameters */
    assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));
  }

  if (huart->gState == HAL_UART_STATE_RESET)
 8006e02:	687b      	ldr	r3, [r7, #4]
 8006e04:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8006e08:	2b00      	cmp	r3, #0
 8006e0a:	d106      	bne.n	8006e1a <HAL_UART_Init+0x2a>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
 8006e0c:	687b      	ldr	r3, [r7, #4]
 8006e0e:	2200      	movs	r2, #0
 8006e10:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

    /* Init the low level hardware */
    huart->MspInitCallback(huart);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
 8006e14:	6878      	ldr	r0, [r7, #4]
 8006e16:	f000 f83b 	bl	8006e90 <HAL_UART_MspInit>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
  }

  huart->gState = HAL_UART_STATE_BUSY;
 8006e1a:	687b      	ldr	r3, [r7, #4]
 8006e1c:	2224      	movs	r2, #36	@ 0x24
 8006e1e:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  __HAL_UART_DISABLE(huart);
 8006e22:	687b      	ldr	r3, [r7, #4]
 8006e24:	681b      	ldr	r3, [r3, #0]
 8006e26:	681a      	ldr	r2, [r3, #0]
 8006e28:	687b      	ldr	r3, [r7, #4]
 8006e2a:	681b      	ldr	r3, [r3, #0]
 8006e2c:	f022 0201 	bic.w	r2, r2, #1
 8006e30:	601a      	str	r2, [r3, #0]

  /* Perform advanced settings configuration */
  /* For some items, configuration requires to be done prior TE and RE bits are set */
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 8006e32:	687b      	ldr	r3, [r7, #4]
 8006e34:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8006e36:	2b00      	cmp	r3, #0
 8006e38:	d002      	beq.n	8006e40 <HAL_UART_Init+0x50>
  {
    UART_AdvFeatureConfig(huart);
 8006e3a:	6878      	ldr	r0, [r7, #4]
 8006e3c:	f000 fa58 	bl	80072f0 <UART_AdvFeatureConfig>
  }

  /* Set the UART Communication parameters */
  if (UART_SetConfig(huart) == HAL_ERROR)
 8006e40:	6878      	ldr	r0, [r7, #4]
 8006e42:	f000 f8bd 	bl	8006fc0 <UART_SetConfig>
 8006e46:	4603      	mov	r3, r0
 8006e48:	2b01      	cmp	r3, #1
 8006e4a:	d101      	bne.n	8006e50 <HAL_UART_Init+0x60>
  {
    return HAL_ERROR;
 8006e4c:	2301      	movs	r3, #1
 8006e4e:	e01b      	b.n	8006e88 <HAL_UART_Init+0x98>
  }

  /* In asynchronous mode, the following bits must be kept cleared:
  - LINEN and CLKEN bits in the USART_CR2 register,
  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8006e50:	687b      	ldr	r3, [r7, #4]
 8006e52:	681b      	ldr	r3, [r3, #0]
 8006e54:	685a      	ldr	r2, [r3, #4]
 8006e56:	687b      	ldr	r3, [r7, #4]
 8006e58:	681b      	ldr	r3, [r3, #0]
 8006e5a:	f422 4290 	bic.w	r2, r2, #18432	@ 0x4800
 8006e5e:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 8006e60:	687b      	ldr	r3, [r7, #4]
 8006e62:	681b      	ldr	r3, [r3, #0]
 8006e64:	689a      	ldr	r2, [r3, #8]
 8006e66:	687b      	ldr	r3, [r7, #4]
 8006e68:	681b      	ldr	r3, [r3, #0]
 8006e6a:	f022 022a 	bic.w	r2, r2, #42	@ 0x2a
 8006e6e:	609a      	str	r2, [r3, #8]

  __HAL_UART_ENABLE(huart);
 8006e70:	687b      	ldr	r3, [r7, #4]
 8006e72:	681b      	ldr	r3, [r3, #0]
 8006e74:	681a      	ldr	r2, [r3, #0]
 8006e76:	687b      	ldr	r3, [r7, #4]
 8006e78:	681b      	ldr	r3, [r3, #0]
 8006e7a:	f042 0201 	orr.w	r2, r2, #1
 8006e7e:	601a      	str	r2, [r3, #0]

  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
  return (UART_CheckIdleState(huart));
 8006e80:	6878      	ldr	r0, [r7, #4]
 8006e82:	f000 fad7 	bl	8007434 <UART_CheckIdleState>
 8006e86:	4603      	mov	r3, r0
}
 8006e88:	4618      	mov	r0, r3
 8006e8a:	3708      	adds	r7, #8
 8006e8c:	46bd      	mov	sp, r7
 8006e8e:	bd80      	pop	{r7, pc}

08006e90 <HAL_UART_MspInit>:
  * @brief Initialize the UART MSP.
  * @param huart UART handle.
  * @retval None
  */
__weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
{
 8006e90:	b480      	push	{r7}
 8006e92:	b083      	sub	sp, #12
 8006e94:	af00      	add	r7, sp, #0
 8006e96:	6078      	str	r0, [r7, #4]
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UART_MspInit can be implemented in the user file
   */
}
 8006e98:	bf00      	nop
 8006e9a:	370c      	adds	r7, #12
 8006e9c:	46bd      	mov	sp, r7
 8006e9e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006ea2:	4770      	bx	lr

08006ea4 <HAL_UART_Transmit>:
  * @param Size    Amount of data elements (u8 or u16) to be sent.
  * @param Timeout Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8006ea4:	b580      	push	{r7, lr}
 8006ea6:	b08a      	sub	sp, #40	@ 0x28
 8006ea8:	af02      	add	r7, sp, #8
 8006eaa:	60f8      	str	r0, [r7, #12]
 8006eac:	60b9      	str	r1, [r7, #8]
 8006eae:	603b      	str	r3, [r7, #0]
 8006eb0:	4613      	mov	r3, r2
 8006eb2:	80fb      	strh	r3, [r7, #6]
  const uint8_t  *pdata8bits;
  const uint16_t *pdata16bits;
  uint32_t tickstart;

  /* Check that a Tx process is not already ongoing */
  if (huart->gState == HAL_UART_STATE_READY)
 8006eb4:	68fb      	ldr	r3, [r7, #12]
 8006eb6:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8006eba:	2b20      	cmp	r3, #32
 8006ebc:	d17b      	bne.n	8006fb6 <HAL_UART_Transmit+0x112>
  {
    if ((pData == NULL) || (Size == 0U))
 8006ebe:	68bb      	ldr	r3, [r7, #8]
 8006ec0:	2b00      	cmp	r3, #0
 8006ec2:	d002      	beq.n	8006eca <HAL_UART_Transmit+0x26>
 8006ec4:	88fb      	ldrh	r3, [r7, #6]
 8006ec6:	2b00      	cmp	r3, #0
 8006ec8:	d101      	bne.n	8006ece <HAL_UART_Transmit+0x2a>
    {
      return  HAL_ERROR;
 8006eca:	2301      	movs	r3, #1
 8006ecc:	e074      	b.n	8006fb8 <HAL_UART_Transmit+0x114>
    {
      CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
    }

#endif /* USART_DMAREQUESTS_SW_WA */
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8006ece:	68fb      	ldr	r3, [r7, #12]
 8006ed0:	2200      	movs	r2, #0
 8006ed2:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8006ed6:	68fb      	ldr	r3, [r7, #12]
 8006ed8:	2221      	movs	r2, #33	@ 0x21
 8006eda:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

    /* Init tickstart for timeout management */
    tickstart = HAL_GetTick();
 8006ede:	f7fa f84d 	bl	8000f7c <HAL_GetTick>
 8006ee2:	6178      	str	r0, [r7, #20]

    huart->TxXferSize  = Size;
 8006ee4:	68fb      	ldr	r3, [r7, #12]
 8006ee6:	88fa      	ldrh	r2, [r7, #6]
 8006ee8:	f8a3 2054 	strh.w	r2, [r3, #84]	@ 0x54
    huart->TxXferCount = Size;
 8006eec:	68fb      	ldr	r3, [r7, #12]
 8006eee:	88fa      	ldrh	r2, [r7, #6]
 8006ef0:	f8a3 2056 	strh.w	r2, [r3, #86]	@ 0x56

    /* In case of 9bits/No Parity transfer, pData needs to be handled as a uint16_t pointer */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8006ef4:	68fb      	ldr	r3, [r7, #12]
 8006ef6:	689b      	ldr	r3, [r3, #8]
 8006ef8:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8006efc:	d108      	bne.n	8006f10 <HAL_UART_Transmit+0x6c>
 8006efe:	68fb      	ldr	r3, [r7, #12]
 8006f00:	691b      	ldr	r3, [r3, #16]
 8006f02:	2b00      	cmp	r3, #0
 8006f04:	d104      	bne.n	8006f10 <HAL_UART_Transmit+0x6c>
    {
      pdata8bits  = NULL;
 8006f06:	2300      	movs	r3, #0
 8006f08:	61fb      	str	r3, [r7, #28]
      pdata16bits = (const uint16_t *) pData;
 8006f0a:	68bb      	ldr	r3, [r7, #8]
 8006f0c:	61bb      	str	r3, [r7, #24]
 8006f0e:	e003      	b.n	8006f18 <HAL_UART_Transmit+0x74>
    }
    else
    {
      pdata8bits  = pData;
 8006f10:	68bb      	ldr	r3, [r7, #8]
 8006f12:	61fb      	str	r3, [r7, #28]
      pdata16bits = NULL;
 8006f14:	2300      	movs	r3, #0
 8006f16:	61bb      	str	r3, [r7, #24]
    }

    while (huart->TxXferCount > 0U)
 8006f18:	e030      	b.n	8006f7c <HAL_UART_Transmit+0xd8>
    {
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 8006f1a:	683b      	ldr	r3, [r7, #0]
 8006f1c:	9300      	str	r3, [sp, #0]
 8006f1e:	697b      	ldr	r3, [r7, #20]
 8006f20:	2200      	movs	r2, #0
 8006f22:	2180      	movs	r1, #128	@ 0x80
 8006f24:	68f8      	ldr	r0, [r7, #12]
 8006f26:	f000 fb2f 	bl	8007588 <UART_WaitOnFlagUntilTimeout>
 8006f2a:	4603      	mov	r3, r0
 8006f2c:	2b00      	cmp	r3, #0
 8006f2e:	d005      	beq.n	8006f3c <HAL_UART_Transmit+0x98>
      {

        huart->gState = HAL_UART_STATE_READY;
 8006f30:	68fb      	ldr	r3, [r7, #12]
 8006f32:	2220      	movs	r2, #32
 8006f34:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

        return HAL_TIMEOUT;
 8006f38:	2303      	movs	r3, #3
 8006f3a:	e03d      	b.n	8006fb8 <HAL_UART_Transmit+0x114>
      }
      if (pdata8bits == NULL)
 8006f3c:	69fb      	ldr	r3, [r7, #28]
 8006f3e:	2b00      	cmp	r3, #0
 8006f40:	d10b      	bne.n	8006f5a <HAL_UART_Transmit+0xb6>
      {
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 8006f42:	69bb      	ldr	r3, [r7, #24]
 8006f44:	881b      	ldrh	r3, [r3, #0]
 8006f46:	461a      	mov	r2, r3
 8006f48:	68fb      	ldr	r3, [r7, #12]
 8006f4a:	681b      	ldr	r3, [r3, #0]
 8006f4c:	f3c2 0208 	ubfx	r2, r2, #0, #9
 8006f50:	629a      	str	r2, [r3, #40]	@ 0x28
        pdata16bits++;
 8006f52:	69bb      	ldr	r3, [r7, #24]
 8006f54:	3302      	adds	r3, #2
 8006f56:	61bb      	str	r3, [r7, #24]
 8006f58:	e007      	b.n	8006f6a <HAL_UART_Transmit+0xc6>
      }
      else
      {
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 8006f5a:	69fb      	ldr	r3, [r7, #28]
 8006f5c:	781a      	ldrb	r2, [r3, #0]
 8006f5e:	68fb      	ldr	r3, [r7, #12]
 8006f60:	681b      	ldr	r3, [r3, #0]
 8006f62:	629a      	str	r2, [r3, #40]	@ 0x28
        pdata8bits++;
 8006f64:	69fb      	ldr	r3, [r7, #28]
 8006f66:	3301      	adds	r3, #1
 8006f68:	61fb      	str	r3, [r7, #28]
      }
      huart->TxXferCount--;
 8006f6a:	68fb      	ldr	r3, [r7, #12]
 8006f6c:	f8b3 3056 	ldrh.w	r3, [r3, #86]	@ 0x56
 8006f70:	b29b      	uxth	r3, r3
 8006f72:	3b01      	subs	r3, #1
 8006f74:	b29a      	uxth	r2, r3
 8006f76:	68fb      	ldr	r3, [r7, #12]
 8006f78:	f8a3 2056 	strh.w	r2, [r3, #86]	@ 0x56
    while (huart->TxXferCount > 0U)
 8006f7c:	68fb      	ldr	r3, [r7, #12]
 8006f7e:	f8b3 3056 	ldrh.w	r3, [r3, #86]	@ 0x56
 8006f82:	b29b      	uxth	r3, r3
 8006f84:	2b00      	cmp	r3, #0
 8006f86:	d1c8      	bne.n	8006f1a <HAL_UART_Transmit+0x76>
    }

    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 8006f88:	683b      	ldr	r3, [r7, #0]
 8006f8a:	9300      	str	r3, [sp, #0]
 8006f8c:	697b      	ldr	r3, [r7, #20]
 8006f8e:	2200      	movs	r2, #0
 8006f90:	2140      	movs	r1, #64	@ 0x40
 8006f92:	68f8      	ldr	r0, [r7, #12]
 8006f94:	f000 faf8 	bl	8007588 <UART_WaitOnFlagUntilTimeout>
 8006f98:	4603      	mov	r3, r0
 8006f9a:	2b00      	cmp	r3, #0
 8006f9c:	d005      	beq.n	8006faa <HAL_UART_Transmit+0x106>
    {
      huart->gState = HAL_UART_STATE_READY;
 8006f9e:	68fb      	ldr	r3, [r7, #12]
 8006fa0:	2220      	movs	r2, #32
 8006fa2:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

      return HAL_TIMEOUT;
 8006fa6:	2303      	movs	r3, #3
 8006fa8:	e006      	b.n	8006fb8 <HAL_UART_Transmit+0x114>
    }

    /* At end of Tx process, restore huart->gState to Ready */
    huart->gState = HAL_UART_STATE_READY;
 8006faa:	68fb      	ldr	r3, [r7, #12]
 8006fac:	2220      	movs	r2, #32
 8006fae:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

    return HAL_OK;
 8006fb2:	2300      	movs	r3, #0
 8006fb4:	e000      	b.n	8006fb8 <HAL_UART_Transmit+0x114>
  }
  else
  {
    return HAL_BUSY;
 8006fb6:	2302      	movs	r3, #2
  }
}
 8006fb8:	4618      	mov	r0, r3
 8006fba:	3720      	adds	r7, #32
 8006fbc:	46bd      	mov	sp, r7
 8006fbe:	bd80      	pop	{r7, pc}

08006fc0 <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
 8006fc0:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8006fc4:	b094      	sub	sp, #80	@ 0x50
 8006fc6:	af00      	add	r7, sp, #0
 8006fc8:	62f8      	str	r0, [r7, #44]	@ 0x2c
  uint32_t tmpreg;
  uint16_t brrtemp;
  uint32_t clocksource;
  uint32_t usartdiv;
  HAL_StatusTypeDef ret               = HAL_OK;
 8006fca:	2300      	movs	r3, #0
 8006fcc:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
  uint32_t pclk;

  /* Check the parameters */
  assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
  if (UART_INSTANCE_LOWPOWER(huart))
 8006fd0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8006fd2:	681a      	ldr	r2, [r3, #0]
 8006fd4:	4b9b      	ldr	r3, [pc, #620]	@ (8007244 <UART_SetConfig+0x284>)
 8006fd6:	429a      	cmp	r2, r3
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8006fd8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8006fda:	689a      	ldr	r2, [r3, #8]
 8006fdc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8006fde:	691b      	ldr	r3, [r3, #16]
 8006fe0:	431a      	orrs	r2, r3
 8006fe2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8006fe4:	695b      	ldr	r3, [r3, #20]
 8006fe6:	431a      	orrs	r2, r3
 8006fe8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8006fea:	69db      	ldr	r3, [r3, #28]
 8006fec:	4313      	orrs	r3, r2
 8006fee:	64fb      	str	r3, [r7, #76]	@ 0x4c
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8006ff0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8006ff2:	681b      	ldr	r3, [r3, #0]
 8006ff4:	681b      	ldr	r3, [r3, #0]
 8006ff6:	4994      	ldr	r1, [pc, #592]	@ (8007248 <UART_SetConfig+0x288>)
 8006ff8:	4019      	ands	r1, r3
 8006ffa:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8006ffc:	681a      	ldr	r2, [r3, #0]
 8006ffe:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8007000:	430b      	orrs	r3, r1
 8007002:	6013      	str	r3, [r2, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8007004:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8007006:	681b      	ldr	r3, [r3, #0]
 8007008:	685b      	ldr	r3, [r3, #4]
 800700a:	f423 5040 	bic.w	r0, r3, #12288	@ 0x3000
 800700e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8007010:	68d9      	ldr	r1, [r3, #12]
 8007012:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8007014:	681a      	ldr	r2, [r3, #0]
 8007016:	ea40 0301 	orr.w	r3, r0, r1
 800701a:	6053      	str	r3, [r2, #4]
  /* Configure
  * - UART HardWare Flow Control: set CTSE and RTSE bits according
  *   to huart->Init.HwFlowCtl value
  * - one-bit sampling method versus three samples' majority rule according
  *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 800701c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800701e:	699b      	ldr	r3, [r3, #24]
 8007020:	64fb      	str	r3, [r7, #76]	@ 0x4c

  if (!(UART_INSTANCE_LOWPOWER(huart)))
 8007022:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8007024:	681a      	ldr	r2, [r3, #0]
 8007026:	4b87      	ldr	r3, [pc, #540]	@ (8007244 <UART_SetConfig+0x284>)
 8007028:	429a      	cmp	r2, r3
 800702a:	d009      	beq.n	8007040 <UART_SetConfig+0x80>
 800702c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800702e:	681a      	ldr	r2, [r3, #0]
 8007030:	4b86      	ldr	r3, [pc, #536]	@ (800724c <UART_SetConfig+0x28c>)
 8007032:	429a      	cmp	r2, r3
 8007034:	d004      	beq.n	8007040 <UART_SetConfig+0x80>
  {
    tmpreg |= huart->Init.OneBitSampling;
 8007036:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8007038:	6a1a      	ldr	r2, [r3, #32]
 800703a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800703c:	4313      	orrs	r3, r2
 800703e:	64fb      	str	r3, [r7, #76]	@ 0x4c
  }
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 8007040:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8007042:	681b      	ldr	r3, [r3, #0]
 8007044:	689b      	ldr	r3, [r3, #8]
 8007046:	f023 416e 	bic.w	r1, r3, #3992977408	@ 0xee000000
 800704a:	f421 6130 	bic.w	r1, r1, #2816	@ 0xb00
 800704e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8007050:	681a      	ldr	r2, [r3, #0]
 8007052:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8007054:	430b      	orrs	r3, r1
 8007056:	6093      	str	r3, [r2, #8]

  /*-------------------------- USART PRESC Configuration -----------------------*/
  /* Configure
  * - UART Clock Prescaler : set PRESCALER according to huart->Init.ClockPrescaler value */
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 8007058:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800705a:	681b      	ldr	r3, [r3, #0]
 800705c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800705e:	f023 000f 	bic.w	r0, r3, #15
 8007062:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8007064:	6a59      	ldr	r1, [r3, #36]	@ 0x24
 8007066:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8007068:	681a      	ldr	r2, [r3, #0]
 800706a:	ea40 0301 	orr.w	r3, r0, r1
 800706e:	62d3      	str	r3, [r2, #44]	@ 0x2c

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 8007070:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8007072:	681a      	ldr	r2, [r3, #0]
 8007074:	4b76      	ldr	r3, [pc, #472]	@ (8007250 <UART_SetConfig+0x290>)
 8007076:	429a      	cmp	r2, r3
 8007078:	d102      	bne.n	8007080 <UART_SetConfig+0xc0>
 800707a:	2301      	movs	r3, #1
 800707c:	64bb      	str	r3, [r7, #72]	@ 0x48
 800707e:	e021      	b.n	80070c4 <UART_SetConfig+0x104>
 8007080:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8007082:	681a      	ldr	r2, [r3, #0]
 8007084:	4b73      	ldr	r3, [pc, #460]	@ (8007254 <UART_SetConfig+0x294>)
 8007086:	429a      	cmp	r2, r3
 8007088:	d102      	bne.n	8007090 <UART_SetConfig+0xd0>
 800708a:	2304      	movs	r3, #4
 800708c:	64bb      	str	r3, [r7, #72]	@ 0x48
 800708e:	e019      	b.n	80070c4 <UART_SetConfig+0x104>
 8007090:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8007092:	681a      	ldr	r2, [r3, #0]
 8007094:	4b70      	ldr	r3, [pc, #448]	@ (8007258 <UART_SetConfig+0x298>)
 8007096:	429a      	cmp	r2, r3
 8007098:	d102      	bne.n	80070a0 <UART_SetConfig+0xe0>
 800709a:	2308      	movs	r3, #8
 800709c:	64bb      	str	r3, [r7, #72]	@ 0x48
 800709e:	e011      	b.n	80070c4 <UART_SetConfig+0x104>
 80070a0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80070a2:	681a      	ldr	r2, [r3, #0]
 80070a4:	4b6d      	ldr	r3, [pc, #436]	@ (800725c <UART_SetConfig+0x29c>)
 80070a6:	429a      	cmp	r2, r3
 80070a8:	d102      	bne.n	80070b0 <UART_SetConfig+0xf0>
 80070aa:	2310      	movs	r3, #16
 80070ac:	64bb      	str	r3, [r7, #72]	@ 0x48
 80070ae:	e009      	b.n	80070c4 <UART_SetConfig+0x104>
 80070b0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80070b2:	681a      	ldr	r2, [r3, #0]
 80070b4:	4b63      	ldr	r3, [pc, #396]	@ (8007244 <UART_SetConfig+0x284>)
 80070b6:	429a      	cmp	r2, r3
 80070b8:	d102      	bne.n	80070c0 <UART_SetConfig+0x100>
 80070ba:	2320      	movs	r3, #32
 80070bc:	64bb      	str	r3, [r7, #72]	@ 0x48
 80070be:	e001      	b.n	80070c4 <UART_SetConfig+0x104>
 80070c0:	2300      	movs	r3, #0
 80070c2:	64bb      	str	r3, [r7, #72]	@ 0x48

  /* Check LPUART instance */
  if (UART_INSTANCE_LOWPOWER(huart))
 80070c4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80070c6:	681a      	ldr	r2, [r3, #0]
 80070c8:	4b5e      	ldr	r3, [pc, #376]	@ (8007244 <UART_SetConfig+0x284>)
 80070ca:	429a      	cmp	r2, r3
 80070cc:	d004      	beq.n	80070d8 <UART_SetConfig+0x118>
 80070ce:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80070d0:	681a      	ldr	r2, [r3, #0]
 80070d2:	4b5e      	ldr	r3, [pc, #376]	@ (800724c <UART_SetConfig+0x28c>)
 80070d4:	429a      	cmp	r2, r3
 80070d6:	d172      	bne.n	80071be <UART_SetConfig+0x1fe>
  {
    /* Retrieve frequency clock */
    pclk = HAL_RCCEx_GetPeriphCLKFreq(clocksource);
 80070d8:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80070da:	2200      	movs	r2, #0
 80070dc:	623b      	str	r3, [r7, #32]
 80070de:	627a      	str	r2, [r7, #36]	@ 0x24
 80070e0:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 80070e4:	f7fd f804 	bl	80040f0 <HAL_RCCEx_GetPeriphCLKFreq>
 80070e8:	6438      	str	r0, [r7, #64]	@ 0x40

    /* If proper clock source reported */
    if (pclk != 0U)
 80070ea:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80070ec:	2b00      	cmp	r3, #0
 80070ee:	f000 80e7 	beq.w	80072c0 <UART_SetConfig+0x300>
    {
      /* Compute clock after Prescaler */
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 80070f2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80070f4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80070f6:	4a5a      	ldr	r2, [pc, #360]	@ (8007260 <UART_SetConfig+0x2a0>)
 80070f8:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 80070fc:	461a      	mov	r2, r3
 80070fe:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8007100:	fbb3 f3f2 	udiv	r3, r3, r2
 8007104:	637b      	str	r3, [r7, #52]	@ 0x34

      /* Ensure that Frequency clock is in the range [3 * baudrate, 4096 * baudrate] */
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 8007106:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8007108:	685a      	ldr	r2, [r3, #4]
 800710a:	4613      	mov	r3, r2
 800710c:	005b      	lsls	r3, r3, #1
 800710e:	4413      	add	r3, r2
 8007110:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8007112:	429a      	cmp	r2, r3
 8007114:	d305      	bcc.n	8007122 <UART_SetConfig+0x162>
          (lpuart_ker_ck_pres > (4096U * huart->Init.BaudRate)))
 8007116:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8007118:	685b      	ldr	r3, [r3, #4]
 800711a:	031b      	lsls	r3, r3, #12
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 800711c:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 800711e:	429a      	cmp	r2, r3
 8007120:	d903      	bls.n	800712a <UART_SetConfig+0x16a>
      {
        ret = HAL_ERROR;
 8007122:	2301      	movs	r3, #1
 8007124:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
 8007128:	e048      	b.n	80071bc <UART_SetConfig+0x1fc>
      }
      else
      {
        /* Check computed UsartDiv value is in allocated range
           (it is forbidden to write values lower than 0x300 in the LPUART_BRR register) */
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800712a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800712c:	2200      	movs	r2, #0
 800712e:	61bb      	str	r3, [r7, #24]
 8007130:	61fa      	str	r2, [r7, #28]
 8007132:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8007134:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8007136:	4a4a      	ldr	r2, [pc, #296]	@ (8007260 <UART_SetConfig+0x2a0>)
 8007138:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 800713c:	b29b      	uxth	r3, r3
 800713e:	2200      	movs	r2, #0
 8007140:	613b      	str	r3, [r7, #16]
 8007142:	617a      	str	r2, [r7, #20]
 8007144:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 8007148:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 800714c:	f7f9 f894 	bl	8000278 <__aeabi_uldivmod>
 8007150:	4602      	mov	r2, r0
 8007152:	460b      	mov	r3, r1
 8007154:	4610      	mov	r0, r2
 8007156:	4619      	mov	r1, r3
 8007158:	f04f 0200 	mov.w	r2, #0
 800715c:	f04f 0300 	mov.w	r3, #0
 8007160:	020b      	lsls	r3, r1, #8
 8007162:	ea43 6310 	orr.w	r3, r3, r0, lsr #24
 8007166:	0202      	lsls	r2, r0, #8
 8007168:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 800716a:	6849      	ldr	r1, [r1, #4]
 800716c:	0849      	lsrs	r1, r1, #1
 800716e:	2000      	movs	r0, #0
 8007170:	460c      	mov	r4, r1
 8007172:	4605      	mov	r5, r0
 8007174:	eb12 0804 	adds.w	r8, r2, r4
 8007178:	eb43 0905 	adc.w	r9, r3, r5
 800717c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800717e:	685b      	ldr	r3, [r3, #4]
 8007180:	2200      	movs	r2, #0
 8007182:	60bb      	str	r3, [r7, #8]
 8007184:	60fa      	str	r2, [r7, #12]
 8007186:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 800718a:	4640      	mov	r0, r8
 800718c:	4649      	mov	r1, r9
 800718e:	f7f9 f873 	bl	8000278 <__aeabi_uldivmod>
 8007192:	4602      	mov	r2, r0
 8007194:	460b      	mov	r3, r1
 8007196:	4613      	mov	r3, r2
 8007198:	63fb      	str	r3, [r7, #60]	@ 0x3c
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 800719a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800719c:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 80071a0:	d308      	bcc.n	80071b4 <UART_SetConfig+0x1f4>
 80071a2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80071a4:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 80071a8:	d204      	bcs.n	80071b4 <UART_SetConfig+0x1f4>
        {
          huart->Instance->BRR = usartdiv;
 80071aa:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80071ac:	681b      	ldr	r3, [r3, #0]
 80071ae:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 80071b0:	60da      	str	r2, [r3, #12]
 80071b2:	e003      	b.n	80071bc <UART_SetConfig+0x1fc>
        }
        else
        {
          ret = HAL_ERROR;
 80071b4:	2301      	movs	r3, #1
 80071b6:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
    if (pclk != 0U)
 80071ba:	e081      	b.n	80072c0 <UART_SetConfig+0x300>
 80071bc:	e080      	b.n	80072c0 <UART_SetConfig+0x300>
      } /* if ( (lpuart_ker_ck_pres < (3 * huart->Init.BaudRate) ) ||
                (lpuart_ker_ck_pres > (4096 * huart->Init.BaudRate) )) */
    } /* if (pclk != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80071be:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80071c0:	69db      	ldr	r3, [r3, #28]
 80071c2:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 80071c6:	d14d      	bne.n	8007264 <UART_SetConfig+0x2a4>
  {
    pclk = HAL_RCCEx_GetPeriphCLKFreq(clocksource);
 80071c8:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80071ca:	2200      	movs	r2, #0
 80071cc:	603b      	str	r3, [r7, #0]
 80071ce:	607a      	str	r2, [r7, #4]
 80071d0:	e9d7 0100 	ldrd	r0, r1, [r7]
 80071d4:	f7fc ff8c 	bl	80040f0 <HAL_RCCEx_GetPeriphCLKFreq>
 80071d8:	6438      	str	r0, [r7, #64]	@ 0x40

    /* USARTDIV must be greater than or equal to 0d16 */
    if (pclk != 0U)
 80071da:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80071dc:	2b00      	cmp	r3, #0
 80071de:	d06f      	beq.n	80072c0 <UART_SetConfig+0x300>
    {
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 80071e0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80071e2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80071e4:	4a1e      	ldr	r2, [pc, #120]	@ (8007260 <UART_SetConfig+0x2a0>)
 80071e6:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 80071ea:	461a      	mov	r2, r3
 80071ec:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80071ee:	fbb3 f3f2 	udiv	r3, r3, r2
 80071f2:	005a      	lsls	r2, r3, #1
 80071f4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80071f6:	685b      	ldr	r3, [r3, #4]
 80071f8:	085b      	lsrs	r3, r3, #1
 80071fa:	441a      	add	r2, r3
 80071fc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80071fe:	685b      	ldr	r3, [r3, #4]
 8007200:	fbb2 f3f3 	udiv	r3, r2, r3
 8007204:	63fb      	str	r3, [r7, #60]	@ 0x3c
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8007206:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8007208:	2b0f      	cmp	r3, #15
 800720a:	d916      	bls.n	800723a <UART_SetConfig+0x27a>
 800720c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800720e:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8007212:	d212      	bcs.n	800723a <UART_SetConfig+0x27a>
      {
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 8007214:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8007216:	b29b      	uxth	r3, r3
 8007218:	f023 030f 	bic.w	r3, r3, #15
 800721c:	877b      	strh	r3, [r7, #58]	@ 0x3a
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 800721e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8007220:	085b      	lsrs	r3, r3, #1
 8007222:	b29b      	uxth	r3, r3
 8007224:	f003 0307 	and.w	r3, r3, #7
 8007228:	b29a      	uxth	r2, r3
 800722a:	8f7b      	ldrh	r3, [r7, #58]	@ 0x3a
 800722c:	4313      	orrs	r3, r2
 800722e:	877b      	strh	r3, [r7, #58]	@ 0x3a
        huart->Instance->BRR = brrtemp;
 8007230:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8007232:	681b      	ldr	r3, [r3, #0]
 8007234:	8f7a      	ldrh	r2, [r7, #58]	@ 0x3a
 8007236:	60da      	str	r2, [r3, #12]
 8007238:	e042      	b.n	80072c0 <UART_SetConfig+0x300>
      }
      else
      {
        ret = HAL_ERROR;
 800723a:	2301      	movs	r3, #1
 800723c:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
 8007240:	e03e      	b.n	80072c0 <UART_SetConfig+0x300>
 8007242:	bf00      	nop
 8007244:	46002400 	.word	0x46002400
 8007248:	cfff69f3 	.word	0xcfff69f3
 800724c:	56002400 	.word	0x56002400
 8007250:	40013800 	.word	0x40013800
 8007254:	40004800 	.word	0x40004800
 8007258:	40004c00 	.word	0x40004c00
 800725c:	40005000 	.word	0x40005000
 8007260:	08011764 	.word	0x08011764
      }
    }
  }
  else
  {
    pclk = HAL_RCCEx_GetPeriphCLKFreq(clocksource);
 8007264:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8007266:	2200      	movs	r2, #0
 8007268:	469a      	mov	sl, r3
 800726a:	4693      	mov	fp, r2
 800726c:	4650      	mov	r0, sl
 800726e:	4659      	mov	r1, fp
 8007270:	f7fc ff3e 	bl	80040f0 <HAL_RCCEx_GetPeriphCLKFreq>
 8007274:	6438      	str	r0, [r7, #64]	@ 0x40

    if (pclk != 0U)
 8007276:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8007278:	2b00      	cmp	r3, #0
 800727a:	d021      	beq.n	80072c0 <UART_SetConfig+0x300>
    {
      /* USARTDIV must be greater than or equal to 0d16 */
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800727c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800727e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8007280:	4a1a      	ldr	r2, [pc, #104]	@ (80072ec <UART_SetConfig+0x32c>)
 8007282:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8007286:	461a      	mov	r2, r3
 8007288:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800728a:	fbb3 f2f2 	udiv	r2, r3, r2
 800728e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8007290:	685b      	ldr	r3, [r3, #4]
 8007292:	085b      	lsrs	r3, r3, #1
 8007294:	441a      	add	r2, r3
 8007296:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8007298:	685b      	ldr	r3, [r3, #4]
 800729a:	fbb2 f3f3 	udiv	r3, r2, r3
 800729e:	63fb      	str	r3, [r7, #60]	@ 0x3c
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 80072a0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80072a2:	2b0f      	cmp	r3, #15
 80072a4:	d909      	bls.n	80072ba <UART_SetConfig+0x2fa>
 80072a6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80072a8:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 80072ac:	d205      	bcs.n	80072ba <UART_SetConfig+0x2fa>
      {
        huart->Instance->BRR = (uint16_t)usartdiv;
 80072ae:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80072b0:	b29a      	uxth	r2, r3
 80072b2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80072b4:	681b      	ldr	r3, [r3, #0]
 80072b6:	60da      	str	r2, [r3, #12]
 80072b8:	e002      	b.n	80072c0 <UART_SetConfig+0x300>
      }
      else
      {
        ret = HAL_ERROR;
 80072ba:	2301      	movs	r3, #1
 80072bc:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
      }
    }
  }

  /* Initialize the number of data to process during RX/TX ISR execution */
  huart->NbTxDataToProcess = 1;
 80072c0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80072c2:	2201      	movs	r2, #1
 80072c4:	f8a3 206a 	strh.w	r2, [r3, #106]	@ 0x6a
  huart->NbRxDataToProcess = 1;
 80072c8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80072ca:	2201      	movs	r2, #1
 80072cc:	f8a3 2068 	strh.w	r2, [r3, #104]	@ 0x68

  /* Clear ISR function pointers */
  huart->RxISR = NULL;
 80072d0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80072d2:	2200      	movs	r2, #0
 80072d4:	675a      	str	r2, [r3, #116]	@ 0x74
  huart->TxISR = NULL;
 80072d6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80072d8:	2200      	movs	r2, #0
 80072da:	679a      	str	r2, [r3, #120]	@ 0x78

  return ret;
 80072dc:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
}
 80072e0:	4618      	mov	r0, r3
 80072e2:	3750      	adds	r7, #80	@ 0x50
 80072e4:	46bd      	mov	sp, r7
 80072e6:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 80072ea:	bf00      	nop
 80072ec:	08011764 	.word	0x08011764

080072f0 <UART_AdvFeatureConfig>:
  * @brief Configure the UART peripheral advanced features.
  * @param huart UART handle.
  * @retval None
  */
void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
{
 80072f0:	b480      	push	{r7}
 80072f2:	b083      	sub	sp, #12
 80072f4:	af00      	add	r7, sp, #0
 80072f6:	6078      	str	r0, [r7, #4]
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 80072f8:	687b      	ldr	r3, [r7, #4]
 80072fa:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80072fc:	f003 0308 	and.w	r3, r3, #8
 8007300:	2b00      	cmp	r3, #0
 8007302:	d00a      	beq.n	800731a <UART_AdvFeatureConfig+0x2a>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 8007304:	687b      	ldr	r3, [r7, #4]
 8007306:	681b      	ldr	r3, [r3, #0]
 8007308:	685b      	ldr	r3, [r3, #4]
 800730a:	f423 4100 	bic.w	r1, r3, #32768	@ 0x8000
 800730e:	687b      	ldr	r3, [r7, #4]
 8007310:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 8007312:	687b      	ldr	r3, [r7, #4]
 8007314:	681b      	ldr	r3, [r3, #0]
 8007316:	430a      	orrs	r2, r1
 8007318:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 800731a:	687b      	ldr	r3, [r7, #4]
 800731c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800731e:	f003 0301 	and.w	r3, r3, #1
 8007322:	2b00      	cmp	r3, #0
 8007324:	d00a      	beq.n	800733c <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 8007326:	687b      	ldr	r3, [r7, #4]
 8007328:	681b      	ldr	r3, [r3, #0]
 800732a:	685b      	ldr	r3, [r3, #4]
 800732c:	f423 3100 	bic.w	r1, r3, #131072	@ 0x20000
 8007330:	687b      	ldr	r3, [r7, #4]
 8007332:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8007334:	687b      	ldr	r3, [r7, #4]
 8007336:	681b      	ldr	r3, [r3, #0]
 8007338:	430a      	orrs	r2, r1
 800733a:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 800733c:	687b      	ldr	r3, [r7, #4]
 800733e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8007340:	f003 0302 	and.w	r3, r3, #2
 8007344:	2b00      	cmp	r3, #0
 8007346:	d00a      	beq.n	800735e <UART_AdvFeatureConfig+0x6e>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 8007348:	687b      	ldr	r3, [r7, #4]
 800734a:	681b      	ldr	r3, [r3, #0]
 800734c:	685b      	ldr	r3, [r3, #4]
 800734e:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
 8007352:	687b      	ldr	r3, [r7, #4]
 8007354:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8007356:	687b      	ldr	r3, [r7, #4]
 8007358:	681b      	ldr	r3, [r3, #0]
 800735a:	430a      	orrs	r2, r1
 800735c:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 800735e:	687b      	ldr	r3, [r7, #4]
 8007360:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8007362:	f003 0304 	and.w	r3, r3, #4
 8007366:	2b00      	cmp	r3, #0
 8007368:	d00a      	beq.n	8007380 <UART_AdvFeatureConfig+0x90>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 800736a:	687b      	ldr	r3, [r7, #4]
 800736c:	681b      	ldr	r3, [r3, #0]
 800736e:	685b      	ldr	r3, [r3, #4]
 8007370:	f423 2180 	bic.w	r1, r3, #262144	@ 0x40000
 8007374:	687b      	ldr	r3, [r7, #4]
 8007376:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8007378:	687b      	ldr	r3, [r7, #4]
 800737a:	681b      	ldr	r3, [r3, #0]
 800737c:	430a      	orrs	r2, r1
 800737e:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 8007380:	687b      	ldr	r3, [r7, #4]
 8007382:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8007384:	f003 0310 	and.w	r3, r3, #16
 8007388:	2b00      	cmp	r3, #0
 800738a:	d00a      	beq.n	80073a2 <UART_AdvFeatureConfig+0xb2>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 800738c:	687b      	ldr	r3, [r7, #4]
 800738e:	681b      	ldr	r3, [r3, #0]
 8007390:	689b      	ldr	r3, [r3, #8]
 8007392:	f423 5180 	bic.w	r1, r3, #4096	@ 0x1000
 8007396:	687b      	ldr	r3, [r7, #4]
 8007398:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 800739a:	687b      	ldr	r3, [r7, #4]
 800739c:	681b      	ldr	r3, [r3, #0]
 800739e:	430a      	orrs	r2, r1
 80073a0:	609a      	str	r2, [r3, #8]
  }

#if defined(HAL_DMA_MODULE_ENABLED)
  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 80073a2:	687b      	ldr	r3, [r7, #4]
 80073a4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80073a6:	f003 0320 	and.w	r3, r3, #32
 80073aa:	2b00      	cmp	r3, #0
 80073ac:	d00a      	beq.n	80073c4 <UART_AdvFeatureConfig+0xd4>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 80073ae:	687b      	ldr	r3, [r7, #4]
 80073b0:	681b      	ldr	r3, [r3, #0]
 80073b2:	689b      	ldr	r3, [r3, #8]
 80073b4:	f423 5100 	bic.w	r1, r3, #8192	@ 0x2000
 80073b8:	687b      	ldr	r3, [r7, #4]
 80073ba:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 80073bc:	687b      	ldr	r3, [r7, #4]
 80073be:	681b      	ldr	r3, [r3, #0]
 80073c0:	430a      	orrs	r2, r1
 80073c2:	609a      	str	r2, [r3, #8]
  }
#endif /* HAL_DMA_MODULE_ENABLED */

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 80073c4:	687b      	ldr	r3, [r7, #4]
 80073c6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80073c8:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 80073cc:	2b00      	cmp	r3, #0
 80073ce:	d01a      	beq.n	8007406 <UART_AdvFeatureConfig+0x116>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 80073d0:	687b      	ldr	r3, [r7, #4]
 80073d2:	681b      	ldr	r3, [r3, #0]
 80073d4:	685b      	ldr	r3, [r3, #4]
 80073d6:	f423 1180 	bic.w	r1, r3, #1048576	@ 0x100000
 80073da:	687b      	ldr	r3, [r7, #4]
 80073dc:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 80073de:	687b      	ldr	r3, [r7, #4]
 80073e0:	681b      	ldr	r3, [r3, #0]
 80073e2:	430a      	orrs	r2, r1
 80073e4:	605a      	str	r2, [r3, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 80073e6:	687b      	ldr	r3, [r7, #4]
 80073e8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80073ea:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 80073ee:	d10a      	bne.n	8007406 <UART_AdvFeatureConfig+0x116>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 80073f0:	687b      	ldr	r3, [r7, #4]
 80073f2:	681b      	ldr	r3, [r3, #0]
 80073f4:	685b      	ldr	r3, [r3, #4]
 80073f6:	f423 01c0 	bic.w	r1, r3, #6291456	@ 0x600000
 80073fa:	687b      	ldr	r3, [r7, #4]
 80073fc:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
 80073fe:	687b      	ldr	r3, [r7, #4]
 8007400:	681b      	ldr	r3, [r3, #0]
 8007402:	430a      	orrs	r2, r1
 8007404:	605a      	str	r2, [r3, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 8007406:	687b      	ldr	r3, [r7, #4]
 8007408:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800740a:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 800740e:	2b00      	cmp	r3, #0
 8007410:	d00a      	beq.n	8007428 <UART_AdvFeatureConfig+0x138>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 8007412:	687b      	ldr	r3, [r7, #4]
 8007414:	681b      	ldr	r3, [r3, #0]
 8007416:	685b      	ldr	r3, [r3, #4]
 8007418:	f423 2100 	bic.w	r1, r3, #524288	@ 0x80000
 800741c:	687b      	ldr	r3, [r7, #4]
 800741e:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8007420:	687b      	ldr	r3, [r7, #4]
 8007422:	681b      	ldr	r3, [r3, #0]
 8007424:	430a      	orrs	r2, r1
 8007426:	605a      	str	r2, [r3, #4]
  }
}
 8007428:	bf00      	nop
 800742a:	370c      	adds	r7, #12
 800742c:	46bd      	mov	sp, r7
 800742e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007432:	4770      	bx	lr

08007434 <UART_CheckIdleState>:
  * @brief Check the UART Idle State.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
 8007434:	b580      	push	{r7, lr}
 8007436:	b098      	sub	sp, #96	@ 0x60
 8007438:	af02      	add	r7, sp, #8
 800743a:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800743c:	687b      	ldr	r3, [r7, #4]
 800743e:	2200      	movs	r2, #0
 8007440:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90

  /* Init tickstart for timeout management */
  tickstart = HAL_GetTick();
 8007444:	f7f9 fd9a 	bl	8000f7c <HAL_GetTick>
 8007448:	6578      	str	r0, [r7, #84]	@ 0x54

  /* Check if the Transmitter is enabled */
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 800744a:	687b      	ldr	r3, [r7, #4]
 800744c:	681b      	ldr	r3, [r3, #0]
 800744e:	681b      	ldr	r3, [r3, #0]
 8007450:	f003 0308 	and.w	r3, r3, #8
 8007454:	2b08      	cmp	r3, #8
 8007456:	d12f      	bne.n	80074b8 <UART_CheckIdleState+0x84>
  {
    /* Wait until TEACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8007458:	f06f 437e 	mvn.w	r3, #4261412864	@ 0xfe000000
 800745c:	9300      	str	r3, [sp, #0]
 800745e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8007460:	2200      	movs	r2, #0
 8007462:	f44f 1100 	mov.w	r1, #2097152	@ 0x200000
 8007466:	6878      	ldr	r0, [r7, #4]
 8007468:	f000 f88e 	bl	8007588 <UART_WaitOnFlagUntilTimeout>
 800746c:	4603      	mov	r3, r0
 800746e:	2b00      	cmp	r3, #0
 8007470:	d022      	beq.n	80074b8 <UART_CheckIdleState+0x84>
    {
      /* Disable TXE interrupt for the interrupt process */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE_TXFNFIE));
 8007472:	687b      	ldr	r3, [r7, #4]
 8007474:	681b      	ldr	r3, [r3, #0]
 8007476:	63bb      	str	r3, [r7, #56]	@ 0x38
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8007478:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800747a:	e853 3f00 	ldrex	r3, [r3]
 800747e:	637b      	str	r3, [r7, #52]	@ 0x34
   return(result);
 8007480:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8007482:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 8007486:	653b      	str	r3, [r7, #80]	@ 0x50
 8007488:	687b      	ldr	r3, [r7, #4]
 800748a:	681b      	ldr	r3, [r3, #0]
 800748c:	461a      	mov	r2, r3
 800748e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8007490:	647b      	str	r3, [r7, #68]	@ 0x44
 8007492:	643a      	str	r2, [r7, #64]	@ 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8007494:	6c39      	ldr	r1, [r7, #64]	@ 0x40
 8007496:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8007498:	e841 2300 	strex	r3, r2, [r1]
 800749c:	63fb      	str	r3, [r7, #60]	@ 0x3c
   return(result);
 800749e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80074a0:	2b00      	cmp	r3, #0
 80074a2:	d1e6      	bne.n	8007472 <UART_CheckIdleState+0x3e>

      huart->gState = HAL_UART_STATE_READY;
 80074a4:	687b      	ldr	r3, [r7, #4]
 80074a6:	2220      	movs	r2, #32
 80074a8:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

      __HAL_UNLOCK(huart);
 80074ac:	687b      	ldr	r3, [r7, #4]
 80074ae:	2200      	movs	r2, #0
 80074b0:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

      /* Timeout occurred */
      return HAL_TIMEOUT;
 80074b4:	2303      	movs	r3, #3
 80074b6:	e063      	b.n	8007580 <UART_CheckIdleState+0x14c>
    }
  }

  /* Check if the Receiver is enabled */
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 80074b8:	687b      	ldr	r3, [r7, #4]
 80074ba:	681b      	ldr	r3, [r3, #0]
 80074bc:	681b      	ldr	r3, [r3, #0]
 80074be:	f003 0304 	and.w	r3, r3, #4
 80074c2:	2b04      	cmp	r3, #4
 80074c4:	d149      	bne.n	800755a <UART_CheckIdleState+0x126>
  {
    /* Wait until REACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 80074c6:	f06f 437e 	mvn.w	r3, #4261412864	@ 0xfe000000
 80074ca:	9300      	str	r3, [sp, #0]
 80074cc:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80074ce:	2200      	movs	r2, #0
 80074d0:	f44f 0180 	mov.w	r1, #4194304	@ 0x400000
 80074d4:	6878      	ldr	r0, [r7, #4]
 80074d6:	f000 f857 	bl	8007588 <UART_WaitOnFlagUntilTimeout>
 80074da:	4603      	mov	r3, r0
 80074dc:	2b00      	cmp	r3, #0
 80074de:	d03c      	beq.n	800755a <UART_CheckIdleState+0x126>
    {
      /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error)
      interrupts for the interrupt process */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 80074e0:	687b      	ldr	r3, [r7, #4]
 80074e2:	681b      	ldr	r3, [r3, #0]
 80074e4:	627b      	str	r3, [r7, #36]	@ 0x24
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80074e6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80074e8:	e853 3f00 	ldrex	r3, [r3]
 80074ec:	623b      	str	r3, [r7, #32]
   return(result);
 80074ee:	6a3b      	ldr	r3, [r7, #32]
 80074f0:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
 80074f4:	64fb      	str	r3, [r7, #76]	@ 0x4c
 80074f6:	687b      	ldr	r3, [r7, #4]
 80074f8:	681b      	ldr	r3, [r3, #0]
 80074fa:	461a      	mov	r2, r3
 80074fc:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80074fe:	633b      	str	r3, [r7, #48]	@ 0x30
 8007500:	62fa      	str	r2, [r7, #44]	@ 0x2c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8007502:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8007504:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8007506:	e841 2300 	strex	r3, r2, [r1]
 800750a:	62bb      	str	r3, [r7, #40]	@ 0x28
   return(result);
 800750c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800750e:	2b00      	cmp	r3, #0
 8007510:	d1e6      	bne.n	80074e0 <UART_CheckIdleState+0xac>
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8007512:	687b      	ldr	r3, [r7, #4]
 8007514:	681b      	ldr	r3, [r3, #0]
 8007516:	3308      	adds	r3, #8
 8007518:	613b      	str	r3, [r7, #16]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800751a:	693b      	ldr	r3, [r7, #16]
 800751c:	e853 3f00 	ldrex	r3, [r3]
 8007520:	60fb      	str	r3, [r7, #12]
   return(result);
 8007522:	68fb      	ldr	r3, [r7, #12]
 8007524:	f023 0301 	bic.w	r3, r3, #1
 8007528:	64bb      	str	r3, [r7, #72]	@ 0x48
 800752a:	687b      	ldr	r3, [r7, #4]
 800752c:	681b      	ldr	r3, [r3, #0]
 800752e:	3308      	adds	r3, #8
 8007530:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8007532:	61fa      	str	r2, [r7, #28]
 8007534:	61bb      	str	r3, [r7, #24]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8007536:	69b9      	ldr	r1, [r7, #24]
 8007538:	69fa      	ldr	r2, [r7, #28]
 800753a:	e841 2300 	strex	r3, r2, [r1]
 800753e:	617b      	str	r3, [r7, #20]
   return(result);
 8007540:	697b      	ldr	r3, [r7, #20]
 8007542:	2b00      	cmp	r3, #0
 8007544:	d1e5      	bne.n	8007512 <UART_CheckIdleState+0xde>

      huart->RxState = HAL_UART_STATE_READY;
 8007546:	687b      	ldr	r3, [r7, #4]
 8007548:	2220      	movs	r2, #32
 800754a:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c

      __HAL_UNLOCK(huart);
 800754e:	687b      	ldr	r3, [r7, #4]
 8007550:	2200      	movs	r2, #0
 8007552:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

      /* Timeout occurred */
      return HAL_TIMEOUT;
 8007556:	2303      	movs	r3, #3
 8007558:	e012      	b.n	8007580 <UART_CheckIdleState+0x14c>
    }
  }

  /* Initialize the UART State */
  huart->gState = HAL_UART_STATE_READY;
 800755a:	687b      	ldr	r3, [r7, #4]
 800755c:	2220      	movs	r2, #32
 800755e:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
  huart->RxState = HAL_UART_STATE_READY;
 8007562:	687b      	ldr	r3, [r7, #4]
 8007564:	2220      	movs	r2, #32
 8007566:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800756a:	687b      	ldr	r3, [r7, #4]
 800756c:	2200      	movs	r2, #0
 800756e:	66da      	str	r2, [r3, #108]	@ 0x6c
  huart->RxEventType = HAL_UART_RXEVENT_TC;
 8007570:	687b      	ldr	r3, [r7, #4]
 8007572:	2200      	movs	r2, #0
 8007574:	671a      	str	r2, [r3, #112]	@ 0x70

  __HAL_UNLOCK(huart);
 8007576:	687b      	ldr	r3, [r7, #4]
 8007578:	2200      	movs	r2, #0
 800757a:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

  return HAL_OK;
 800757e:	2300      	movs	r3, #0
}
 8007580:	4618      	mov	r0, r3
 8007582:	3758      	adds	r7, #88	@ 0x58
 8007584:	46bd      	mov	sp, r7
 8007586:	bd80      	pop	{r7, pc}

08007588 <UART_WaitOnFlagUntilTimeout>:
  * @param Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                              uint32_t Tickstart, uint32_t Timeout)
{
 8007588:	b580      	push	{r7, lr}
 800758a:	b084      	sub	sp, #16
 800758c:	af00      	add	r7, sp, #0
 800758e:	60f8      	str	r0, [r7, #12]
 8007590:	60b9      	str	r1, [r7, #8]
 8007592:	603b      	str	r3, [r7, #0]
 8007594:	4613      	mov	r3, r2
 8007596:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8007598:	e04f      	b.n	800763a <UART_WaitOnFlagUntilTimeout+0xb2>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 800759a:	69bb      	ldr	r3, [r7, #24]
 800759c:	f1b3 3fff 	cmp.w	r3, #4294967295
 80075a0:	d04b      	beq.n	800763a <UART_WaitOnFlagUntilTimeout+0xb2>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80075a2:	f7f9 fceb 	bl	8000f7c <HAL_GetTick>
 80075a6:	4602      	mov	r2, r0
 80075a8:	683b      	ldr	r3, [r7, #0]
 80075aa:	1ad3      	subs	r3, r2, r3
 80075ac:	69ba      	ldr	r2, [r7, #24]
 80075ae:	429a      	cmp	r2, r3
 80075b0:	d302      	bcc.n	80075b8 <UART_WaitOnFlagUntilTimeout+0x30>
 80075b2:	69bb      	ldr	r3, [r7, #24]
 80075b4:	2b00      	cmp	r3, #0
 80075b6:	d101      	bne.n	80075bc <UART_WaitOnFlagUntilTimeout+0x34>
      {

        return HAL_TIMEOUT;
 80075b8:	2303      	movs	r3, #3
 80075ba:	e04e      	b.n	800765a <UART_WaitOnFlagUntilTimeout+0xd2>
      }

      if ((READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U) && (Flag != UART_FLAG_TXE) && (Flag != UART_FLAG_TC))
 80075bc:	68fb      	ldr	r3, [r7, #12]
 80075be:	681b      	ldr	r3, [r3, #0]
 80075c0:	681b      	ldr	r3, [r3, #0]
 80075c2:	f003 0304 	and.w	r3, r3, #4
 80075c6:	2b00      	cmp	r3, #0
 80075c8:	d037      	beq.n	800763a <UART_WaitOnFlagUntilTimeout+0xb2>
 80075ca:	68bb      	ldr	r3, [r7, #8]
 80075cc:	2b80      	cmp	r3, #128	@ 0x80
 80075ce:	d034      	beq.n	800763a <UART_WaitOnFlagUntilTimeout+0xb2>
 80075d0:	68bb      	ldr	r3, [r7, #8]
 80075d2:	2b40      	cmp	r3, #64	@ 0x40
 80075d4:	d031      	beq.n	800763a <UART_WaitOnFlagUntilTimeout+0xb2>
      {
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_ORE) == SET)
 80075d6:	68fb      	ldr	r3, [r7, #12]
 80075d8:	681b      	ldr	r3, [r3, #0]
 80075da:	69db      	ldr	r3, [r3, #28]
 80075dc:	f003 0308 	and.w	r3, r3, #8
 80075e0:	2b08      	cmp	r3, #8
 80075e2:	d110      	bne.n	8007606 <UART_WaitOnFlagUntilTimeout+0x7e>
        {
          /* Clear Overrun Error flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
 80075e4:	68fb      	ldr	r3, [r7, #12]
 80075e6:	681b      	ldr	r3, [r3, #0]
 80075e8:	2208      	movs	r2, #8
 80075ea:	621a      	str	r2, [r3, #32]

          /* Blocking error : transfer is aborted
          Set the UART state ready to be able to start again the process,
          Disable Rx Interrupts if ongoing */
          UART_EndRxTransfer(huart);
 80075ec:	68f8      	ldr	r0, [r7, #12]
 80075ee:	f000 f838 	bl	8007662 <UART_EndRxTransfer>

          huart->ErrorCode = HAL_UART_ERROR_ORE;
 80075f2:	68fb      	ldr	r3, [r7, #12]
 80075f4:	2208      	movs	r2, #8
 80075f6:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
 80075fa:	68fb      	ldr	r3, [r7, #12]
 80075fc:	2200      	movs	r2, #0
 80075fe:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

          return HAL_ERROR;
 8007602:	2301      	movs	r3, #1
 8007604:	e029      	b.n	800765a <UART_WaitOnFlagUntilTimeout+0xd2>
        }
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 8007606:	68fb      	ldr	r3, [r7, #12]
 8007608:	681b      	ldr	r3, [r3, #0]
 800760a:	69db      	ldr	r3, [r3, #28]
 800760c:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 8007610:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 8007614:	d111      	bne.n	800763a <UART_WaitOnFlagUntilTimeout+0xb2>
        {
          /* Clear Receiver Timeout flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 8007616:	68fb      	ldr	r3, [r7, #12]
 8007618:	681b      	ldr	r3, [r3, #0]
 800761a:	f44f 6200 	mov.w	r2, #2048	@ 0x800
 800761e:	621a      	str	r2, [r3, #32]

          /* Blocking error : transfer is aborted
          Set the UART state ready to be able to start again the process,
          Disable Rx Interrupts if ongoing */
          UART_EndRxTransfer(huart);
 8007620:	68f8      	ldr	r0, [r7, #12]
 8007622:	f000 f81e 	bl	8007662 <UART_EndRxTransfer>

          huart->ErrorCode = HAL_UART_ERROR_RTO;
 8007626:	68fb      	ldr	r3, [r7, #12]
 8007628:	2220      	movs	r2, #32
 800762a:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
 800762e:	68fb      	ldr	r3, [r7, #12]
 8007630:	2200      	movs	r2, #0
 8007632:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

          return HAL_TIMEOUT;
 8007636:	2303      	movs	r3, #3
 8007638:	e00f      	b.n	800765a <UART_WaitOnFlagUntilTimeout+0xd2>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 800763a:	68fb      	ldr	r3, [r7, #12]
 800763c:	681b      	ldr	r3, [r3, #0]
 800763e:	69da      	ldr	r2, [r3, #28]
 8007640:	68bb      	ldr	r3, [r7, #8]
 8007642:	4013      	ands	r3, r2
 8007644:	68ba      	ldr	r2, [r7, #8]
 8007646:	429a      	cmp	r2, r3
 8007648:	bf0c      	ite	eq
 800764a:	2301      	moveq	r3, #1
 800764c:	2300      	movne	r3, #0
 800764e:	b2db      	uxtb	r3, r3
 8007650:	461a      	mov	r2, r3
 8007652:	79fb      	ldrb	r3, [r7, #7]
 8007654:	429a      	cmp	r2, r3
 8007656:	d0a0      	beq.n	800759a <UART_WaitOnFlagUntilTimeout+0x12>
        }
      }
    }
  }
  return HAL_OK;
 8007658:	2300      	movs	r3, #0
}
 800765a:	4618      	mov	r0, r3
 800765c:	3710      	adds	r7, #16
 800765e:	46bd      	mov	sp, r7
 8007660:	bd80      	pop	{r7, pc}

08007662 <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
 8007662:	b480      	push	{r7}
 8007664:	b095      	sub	sp, #84	@ 0x54
 8007666:	af00      	add	r7, sp, #0
 8007668:	6078      	str	r0, [r7, #4]
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 800766a:	687b      	ldr	r3, [r7, #4]
 800766c:	681b      	ldr	r3, [r3, #0]
 800766e:	637b      	str	r3, [r7, #52]	@ 0x34
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8007670:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8007672:	e853 3f00 	ldrex	r3, [r3]
 8007676:	633b      	str	r3, [r7, #48]	@ 0x30
   return(result);
 8007678:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800767a:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
 800767e:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8007680:	687b      	ldr	r3, [r7, #4]
 8007682:	681b      	ldr	r3, [r3, #0]
 8007684:	461a      	mov	r2, r3
 8007686:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8007688:	643b      	str	r3, [r7, #64]	@ 0x40
 800768a:	63fa      	str	r2, [r7, #60]	@ 0x3c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800768c:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 800768e:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8007690:	e841 2300 	strex	r3, r2, [r1]
 8007694:	63bb      	str	r3, [r7, #56]	@ 0x38
   return(result);
 8007696:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8007698:	2b00      	cmp	r3, #0
 800769a:	d1e6      	bne.n	800766a <UART_EndRxTransfer+0x8>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 800769c:	687b      	ldr	r3, [r7, #4]
 800769e:	681b      	ldr	r3, [r3, #0]
 80076a0:	3308      	adds	r3, #8
 80076a2:	623b      	str	r3, [r7, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80076a4:	6a3b      	ldr	r3, [r7, #32]
 80076a6:	e853 3f00 	ldrex	r3, [r3]
 80076aa:	61fb      	str	r3, [r7, #28]
   return(result);
 80076ac:	69fb      	ldr	r3, [r7, #28]
 80076ae:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
 80076b2:	f023 0301 	bic.w	r3, r3, #1
 80076b6:	64bb      	str	r3, [r7, #72]	@ 0x48
 80076b8:	687b      	ldr	r3, [r7, #4]
 80076ba:	681b      	ldr	r3, [r3, #0]
 80076bc:	3308      	adds	r3, #8
 80076be:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 80076c0:	62fa      	str	r2, [r7, #44]	@ 0x2c
 80076c2:	62bb      	str	r3, [r7, #40]	@ 0x28
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80076c4:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 80076c6:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80076c8:	e841 2300 	strex	r3, r2, [r1]
 80076cc:	627b      	str	r3, [r7, #36]	@ 0x24
   return(result);
 80076ce:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80076d0:	2b00      	cmp	r3, #0
 80076d2:	d1e3      	bne.n	800769c <UART_EndRxTransfer+0x3a>

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 80076d4:	687b      	ldr	r3, [r7, #4]
 80076d6:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 80076d8:	2b01      	cmp	r3, #1
 80076da:	d118      	bne.n	800770e <UART_EndRxTransfer+0xac>
  {
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 80076dc:	687b      	ldr	r3, [r7, #4]
 80076de:	681b      	ldr	r3, [r3, #0]
 80076e0:	60fb      	str	r3, [r7, #12]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80076e2:	68fb      	ldr	r3, [r7, #12]
 80076e4:	e853 3f00 	ldrex	r3, [r3]
 80076e8:	60bb      	str	r3, [r7, #8]
   return(result);
 80076ea:	68bb      	ldr	r3, [r7, #8]
 80076ec:	f023 0310 	bic.w	r3, r3, #16
 80076f0:	647b      	str	r3, [r7, #68]	@ 0x44
 80076f2:	687b      	ldr	r3, [r7, #4]
 80076f4:	681b      	ldr	r3, [r3, #0]
 80076f6:	461a      	mov	r2, r3
 80076f8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80076fa:	61bb      	str	r3, [r7, #24]
 80076fc:	617a      	str	r2, [r7, #20]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80076fe:	6979      	ldr	r1, [r7, #20]
 8007700:	69ba      	ldr	r2, [r7, #24]
 8007702:	e841 2300 	strex	r3, r2, [r1]
 8007706:	613b      	str	r3, [r7, #16]
   return(result);
 8007708:	693b      	ldr	r3, [r7, #16]
 800770a:	2b00      	cmp	r3, #0
 800770c:	d1e6      	bne.n	80076dc <UART_EndRxTransfer+0x7a>
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 800770e:	687b      	ldr	r3, [r7, #4]
 8007710:	2220      	movs	r2, #32
 8007712:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8007716:	687b      	ldr	r3, [r7, #4]
 8007718:	2200      	movs	r2, #0
 800771a:	66da      	str	r2, [r3, #108]	@ 0x6c

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
 800771c:	687b      	ldr	r3, [r7, #4]
 800771e:	2200      	movs	r2, #0
 8007720:	675a      	str	r2, [r3, #116]	@ 0x74
}
 8007722:	bf00      	nop
 8007724:	3754      	adds	r7, #84	@ 0x54
 8007726:	46bd      	mov	sp, r7
 8007728:	f85d 7b04 	ldr.w	r7, [sp], #4
 800772c:	4770      	bx	lr
	...

08007730 <SDMMC_Init>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @param  Init: SDMMC initialization structure
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_Init(SDMMC_TypeDef *SDMMCx, SDMMC_InitTypeDef Init)
{
 8007730:	b084      	sub	sp, #16
 8007732:	b480      	push	{r7}
 8007734:	b085      	sub	sp, #20
 8007736:	af00      	add	r7, sp, #0
 8007738:	6078      	str	r0, [r7, #4]
 800773a:	f107 001c 	add.w	r0, r7, #28
 800773e:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  uint32_t tmpreg = 0;
 8007742:	2300      	movs	r3, #0
 8007744:	60fb      	str	r3, [r7, #12]
  assert_param(IS_SDMMC_BUS_WIDE(Init.BusWide));
  assert_param(IS_SDMMC_HARDWARE_FLOW_CONTROL(Init.HardwareFlowControl));
  assert_param(IS_SDMMC_CLKDIV(Init.ClockDiv));

  /* Set SDMMC configuration parameters */
  tmpreg |= (Init.ClockEdge           | \
 8007746:	69fa      	ldr	r2, [r7, #28]
             Init.ClockPowerSave      | \
 8007748:	6a3b      	ldr	r3, [r7, #32]
  tmpreg |= (Init.ClockEdge           | \
 800774a:	431a      	orrs	r2, r3
             Init.BusWide             | \
 800774c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
             Init.ClockPowerSave      | \
 800774e:	431a      	orrs	r2, r3
             Init.HardwareFlowControl | \
 8007750:	6abb      	ldr	r3, [r7, #40]	@ 0x28
             Init.BusWide             | \
 8007752:	431a      	orrs	r2, r3
             Init.ClockDiv
 8007754:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
             Init.HardwareFlowControl | \
 8007756:	4313      	orrs	r3, r2
  tmpreg |= (Init.ClockEdge           | \
 8007758:	68fa      	ldr	r2, [r7, #12]
 800775a:	4313      	orrs	r3, r2
 800775c:	60fb      	str	r3, [r7, #12]
            );

  /* Write to SDMMC CLKCR */
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);
 800775e:	687b      	ldr	r3, [r7, #4]
 8007760:	685a      	ldr	r2, [r3, #4]
 8007762:	4b07      	ldr	r3, [pc, #28]	@ (8007780 <SDMMC_Init+0x50>)
 8007764:	4013      	ands	r3, r2
 8007766:	68fa      	ldr	r2, [r7, #12]
 8007768:	431a      	orrs	r2, r3
 800776a:	687b      	ldr	r3, [r7, #4]
 800776c:	605a      	str	r2, [r3, #4]

  return HAL_OK;
 800776e:	2300      	movs	r3, #0
}
 8007770:	4618      	mov	r0, r3
 8007772:	3714      	adds	r7, #20
 8007774:	46bd      	mov	sp, r7
 8007776:	f85d 7b04 	ldr.w	r7, [sp], #4
 800777a:	b004      	add	sp, #16
 800777c:	4770      	bx	lr
 800777e:	bf00      	nop
 8007780:	ffc02c00 	.word	0xffc02c00

08007784 <SDMMC_ReadFIFO>:
  * @brief  Read data (word) from Rx FIFO in blocking mode (polling)
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_ReadFIFO(const SDMMC_TypeDef *SDMMCx)
{
 8007784:	b480      	push	{r7}
 8007786:	b083      	sub	sp, #12
 8007788:	af00      	add	r7, sp, #0
 800778a:	6078      	str	r0, [r7, #4]
  /* Read data from Rx FIFO */
  return (SDMMCx->FIFO);
 800778c:	687b      	ldr	r3, [r7, #4]
 800778e:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
}
 8007792:	4618      	mov	r0, r3
 8007794:	370c      	adds	r7, #12
 8007796:	46bd      	mov	sp, r7
 8007798:	f85d 7b04 	ldr.w	r7, [sp], #4
 800779c:	4770      	bx	lr

0800779e <SDMMC_WriteFIFO>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @param  pWriteData: pointer to data to write
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_WriteFIFO(SDMMC_TypeDef *SDMMCx, uint32_t *pWriteData)
{
 800779e:	b480      	push	{r7}
 80077a0:	b083      	sub	sp, #12
 80077a2:	af00      	add	r7, sp, #0
 80077a4:	6078      	str	r0, [r7, #4]
 80077a6:	6039      	str	r1, [r7, #0]
  /* Write data to FIFO */
  SDMMCx->FIFO = *pWriteData;
 80077a8:	683b      	ldr	r3, [r7, #0]
 80077aa:	681a      	ldr	r2, [r3, #0]
 80077ac:	687b      	ldr	r3, [r7, #4]
 80077ae:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

  return HAL_OK;
 80077b2:	2300      	movs	r3, #0
}
 80077b4:	4618      	mov	r0, r3
 80077b6:	370c      	adds	r7, #12
 80077b8:	46bd      	mov	sp, r7
 80077ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 80077be:	4770      	bx	lr

080077c0 <SDMMC_PowerState_ON>:
  * @brief  Set SDMMC Power state to ON.
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_PowerState_ON(SDMMC_TypeDef *SDMMCx)
{
 80077c0:	b480      	push	{r7}
 80077c2:	b083      	sub	sp, #12
 80077c4:	af00      	add	r7, sp, #0
 80077c6:	6078      	str	r0, [r7, #4]
  /* Set power state to ON */
  SDMMCx->POWER |= SDMMC_POWER_PWRCTRL;
 80077c8:	687b      	ldr	r3, [r7, #4]
 80077ca:	681b      	ldr	r3, [r3, #0]
 80077cc:	f043 0203 	orr.w	r2, r3, #3
 80077d0:	687b      	ldr	r3, [r7, #4]
 80077d2:	601a      	str	r2, [r3, #0]

  return HAL_OK;
 80077d4:	2300      	movs	r3, #0
}
 80077d6:	4618      	mov	r0, r3
 80077d8:	370c      	adds	r7, #12
 80077da:	46bd      	mov	sp, r7
 80077dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80077e0:	4770      	bx	lr

080077e2 <SDMMC_GetPowerState>:
  *            - 0x00: Power OFF
  *            - 0x02: Power UP
  *            - 0x03: Power ON
  */
uint32_t SDMMC_GetPowerState(const SDMMC_TypeDef *SDMMCx)
{
 80077e2:	b480      	push	{r7}
 80077e4:	b083      	sub	sp, #12
 80077e6:	af00      	add	r7, sp, #0
 80077e8:	6078      	str	r0, [r7, #4]
  return (SDMMCx->POWER & SDMMC_POWER_PWRCTRL);
 80077ea:	687b      	ldr	r3, [r7, #4]
 80077ec:	681b      	ldr	r3, [r3, #0]
 80077ee:	f003 0303 	and.w	r3, r3, #3
}
 80077f2:	4618      	mov	r0, r3
 80077f4:	370c      	adds	r7, #12
 80077f6:	46bd      	mov	sp, r7
 80077f8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80077fc:	4770      	bx	lr
	...

08007800 <SDMMC_SendCommand>:
  * @param  Command: pointer to a SDMMC_CmdInitTypeDef structure that contains
  *         the configuration information for the SDMMC command
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_SendCommand(SDMMC_TypeDef *SDMMCx, const SDMMC_CmdInitTypeDef *Command)
{
 8007800:	b480      	push	{r7}
 8007802:	b085      	sub	sp, #20
 8007804:	af00      	add	r7, sp, #0
 8007806:	6078      	str	r0, [r7, #4]
 8007808:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
 800780a:	2300      	movs	r3, #0
 800780c:	60fb      	str	r3, [r7, #12]
  assert_param(IS_SDMMC_RESPONSE(Command->Response));
  assert_param(IS_SDMMC_WAIT(Command->WaitForInterrupt));
  assert_param(IS_SDMMC_CPSM(Command->CPSM));

  /* Set the SDMMC Argument value */
  SDMMCx->ARG = Command->Argument;
 800780e:	683b      	ldr	r3, [r7, #0]
 8007810:	681a      	ldr	r2, [r3, #0]
 8007812:	687b      	ldr	r3, [r7, #4]
 8007814:	609a      	str	r2, [r3, #8]

  /* Set SDMMC command parameters */
  tmpreg |= (uint32_t)(Command->CmdIndex         | \
 8007816:	683b      	ldr	r3, [r7, #0]
 8007818:	685a      	ldr	r2, [r3, #4]
                       Command->Response         | \
 800781a:	683b      	ldr	r3, [r7, #0]
 800781c:	689b      	ldr	r3, [r3, #8]
  tmpreg |= (uint32_t)(Command->CmdIndex         | \
 800781e:	431a      	orrs	r2, r3
                       Command->WaitForInterrupt | \
 8007820:	683b      	ldr	r3, [r7, #0]
 8007822:	68db      	ldr	r3, [r3, #12]
                       Command->Response         | \
 8007824:	431a      	orrs	r2, r3
                       Command->CPSM);
 8007826:	683b      	ldr	r3, [r7, #0]
 8007828:	691b      	ldr	r3, [r3, #16]
                       Command->WaitForInterrupt | \
 800782a:	4313      	orrs	r3, r2
  tmpreg |= (uint32_t)(Command->CmdIndex         | \
 800782c:	68fa      	ldr	r2, [r7, #12]
 800782e:	4313      	orrs	r3, r2
 8007830:	60fb      	str	r3, [r7, #12]

  /* Write to SDMMC CMD register */
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 8007832:	687b      	ldr	r3, [r7, #4]
 8007834:	68da      	ldr	r2, [r3, #12]
 8007836:	4b06      	ldr	r3, [pc, #24]	@ (8007850 <SDMMC_SendCommand+0x50>)
 8007838:	4013      	ands	r3, r2
 800783a:	68fa      	ldr	r2, [r7, #12]
 800783c:	431a      	orrs	r2, r3
 800783e:	687b      	ldr	r3, [r7, #4]
 8007840:	60da      	str	r2, [r3, #12]

  return HAL_OK;
 8007842:	2300      	movs	r3, #0
}
 8007844:	4618      	mov	r0, r3
 8007846:	3714      	adds	r7, #20
 8007848:	46bd      	mov	sp, r7
 800784a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800784e:	4770      	bx	lr
 8007850:	fffee0c0 	.word	0xfffee0c0

08007854 <SDMMC_GetCommandResponse>:
  * @brief  Return the command index of last command for which response received
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval Command index of the last command response received
  */
uint8_t SDMMC_GetCommandResponse(const SDMMC_TypeDef *SDMMCx)
{
 8007854:	b480      	push	{r7}
 8007856:	b083      	sub	sp, #12
 8007858:	af00      	add	r7, sp, #0
 800785a:	6078      	str	r0, [r7, #4]
  return (uint8_t)(SDMMCx->RESPCMD);
 800785c:	687b      	ldr	r3, [r7, #4]
 800785e:	691b      	ldr	r3, [r3, #16]
 8007860:	b2db      	uxtb	r3, r3
}
 8007862:	4618      	mov	r0, r3
 8007864:	370c      	adds	r7, #12
 8007866:	46bd      	mov	sp, r7
 8007868:	f85d 7b04 	ldr.w	r7, [sp], #4
 800786c:	4770      	bx	lr

0800786e <SDMMC_GetResponse>:
  *            @arg SDMMC_RESP3: Response Register 3
  *            @arg SDMMC_RESP4: Response Register 4
  * @retval The Corresponding response register value
  */
uint32_t SDMMC_GetResponse(const SDMMC_TypeDef *SDMMCx, uint32_t Response)
{
 800786e:	b480      	push	{r7}
 8007870:	b085      	sub	sp, #20
 8007872:	af00      	add	r7, sp, #0
 8007874:	6078      	str	r0, [r7, #4]
 8007876:	6039      	str	r1, [r7, #0]

  /* Check the parameters */
  assert_param(IS_SDMMC_RESP(Response));

  /* Get the response */
  tmp = (uint32_t)(&(SDMMCx->RESP1)) + Response;
 8007878:	687b      	ldr	r3, [r7, #4]
 800787a:	3314      	adds	r3, #20
 800787c:	461a      	mov	r2, r3
 800787e:	683b      	ldr	r3, [r7, #0]
 8007880:	4413      	add	r3, r2
 8007882:	60fb      	str	r3, [r7, #12]

  return (*(__IO uint32_t *) tmp);
 8007884:	68fb      	ldr	r3, [r7, #12]
 8007886:	681b      	ldr	r3, [r3, #0]
}
 8007888:	4618      	mov	r0, r3
 800788a:	3714      	adds	r7, #20
 800788c:	46bd      	mov	sp, r7
 800788e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007892:	4770      	bx	lr

08007894 <SDMMC_ConfigData>:
  * @param  Data : pointer to a SDMMC_DataInitTypeDef structure
  *         that contains the configuration information for the SDMMC data.
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_ConfigData(SDMMC_TypeDef *SDMMCx, const SDMMC_DataInitTypeDef *Data)
{
 8007894:	b480      	push	{r7}
 8007896:	b085      	sub	sp, #20
 8007898:	af00      	add	r7, sp, #0
 800789a:	6078      	str	r0, [r7, #4]
 800789c:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
 800789e:	2300      	movs	r3, #0
 80078a0:	60fb      	str	r3, [r7, #12]
  assert_param(IS_SDMMC_TRANSFER_DIR(Data->TransferDir));
  assert_param(IS_SDMMC_TRANSFER_MODE(Data->TransferMode));
  assert_param(IS_SDMMC_DPSM(Data->DPSM));

  /* Set the SDMMC Data TimeOut value */
  SDMMCx->DTIMER = Data->DataTimeOut;
 80078a2:	683b      	ldr	r3, [r7, #0]
 80078a4:	681a      	ldr	r2, [r3, #0]
 80078a6:	687b      	ldr	r3, [r7, #4]
 80078a8:	625a      	str	r2, [r3, #36]	@ 0x24

  /* Set the SDMMC DataLength value */
  SDMMCx->DLEN = Data->DataLength;
 80078aa:	683b      	ldr	r3, [r7, #0]
 80078ac:	685a      	ldr	r2, [r3, #4]
 80078ae:	687b      	ldr	r3, [r7, #4]
 80078b0:	629a      	str	r2, [r3, #40]	@ 0x28

  /* Set the SDMMC data configuration parameters */
  tmpreg |= (uint32_t)(Data->DataBlockSize | \
 80078b2:	683b      	ldr	r3, [r7, #0]
 80078b4:	689a      	ldr	r2, [r3, #8]
                       Data->TransferDir   | \
 80078b6:	683b      	ldr	r3, [r7, #0]
 80078b8:	68db      	ldr	r3, [r3, #12]
  tmpreg |= (uint32_t)(Data->DataBlockSize | \
 80078ba:	431a      	orrs	r2, r3
                       Data->TransferMode  | \
 80078bc:	683b      	ldr	r3, [r7, #0]
 80078be:	691b      	ldr	r3, [r3, #16]
                       Data->TransferDir   | \
 80078c0:	431a      	orrs	r2, r3
                       Data->DPSM);
 80078c2:	683b      	ldr	r3, [r7, #0]
 80078c4:	695b      	ldr	r3, [r3, #20]
                       Data->TransferMode  | \
 80078c6:	4313      	orrs	r3, r2
  tmpreg |= (uint32_t)(Data->DataBlockSize | \
 80078c8:	68fa      	ldr	r2, [r7, #12]
 80078ca:	4313      	orrs	r3, r2
 80078cc:	60fb      	str	r3, [r7, #12]

  /* Write to SDMMC DCTRL */
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
 80078ce:	687b      	ldr	r3, [r7, #4]
 80078d0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80078d2:	f023 02ff 	bic.w	r2, r3, #255	@ 0xff
 80078d6:	68fb      	ldr	r3, [r7, #12]
 80078d8:	431a      	orrs	r2, r3
 80078da:	687b      	ldr	r3, [r7, #4]
 80078dc:	62da      	str	r2, [r3, #44]	@ 0x2c

  return HAL_OK;
 80078de:	2300      	movs	r3, #0

}
 80078e0:	4618      	mov	r0, r3
 80078e2:	3714      	adds	r7, #20
 80078e4:	46bd      	mov	sp, r7
 80078e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80078ea:	4770      	bx	lr

080078ec <SDMMC_CmdBlockLength>:
  * @brief  Send the Data Block Length command and check the response
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdBlockLength(SDMMC_TypeDef *SDMMCx, uint32_t BlockSize)
{
 80078ec:	b580      	push	{r7, lr}
 80078ee:	b088      	sub	sp, #32
 80078f0:	af00      	add	r7, sp, #0
 80078f2:	6078      	str	r0, [r7, #4]
 80078f4:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)BlockSize;
 80078f6:	683b      	ldr	r3, [r7, #0]
 80078f8:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_BLOCKLEN;
 80078fa:	2310      	movs	r3, #16
 80078fc:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 80078fe:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8007902:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 8007904:	2300      	movs	r3, #0
 8007906:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 8007908:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 800790c:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800790e:	f107 0308 	add.w	r3, r7, #8
 8007912:	4619      	mov	r1, r3
 8007914:	6878      	ldr	r0, [r7, #4]
 8007916:	f7ff ff73 	bl	8007800 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SET_BLOCKLEN, SDMMC_CMDTIMEOUT);
 800791a:	f241 3288 	movw	r2, #5000	@ 0x1388
 800791e:	2110      	movs	r1, #16
 8007920:	6878      	ldr	r0, [r7, #4]
 8007922:	f000 fa5f 	bl	8007de4 <SDMMC_GetCmdResp1>
 8007926:	61f8      	str	r0, [r7, #28]

  return errorstate;
 8007928:	69fb      	ldr	r3, [r7, #28]
}
 800792a:	4618      	mov	r0, r3
 800792c:	3720      	adds	r7, #32
 800792e:	46bd      	mov	sp, r7
 8007930:	bd80      	pop	{r7, pc}

08007932 <SDMMC_CmdReadSingleBlock>:
  * @brief  Send the Read Single Block command and check the response
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdReadSingleBlock(SDMMC_TypeDef *SDMMCx, uint32_t ReadAdd)
{
 8007932:	b580      	push	{r7, lr}
 8007934:	b088      	sub	sp, #32
 8007936:	af00      	add	r7, sp, #0
 8007938:	6078      	str	r0, [r7, #4]
 800793a:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)ReadAdd;
 800793c:	683b      	ldr	r3, [r7, #0]
 800793e:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_READ_SINGLE_BLOCK;
 8007940:	2311      	movs	r3, #17
 8007942:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 8007944:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8007948:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800794a:	2300      	movs	r3, #0
 800794c:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800794e:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8007952:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 8007954:	f107 0308 	add.w	r3, r7, #8
 8007958:	4619      	mov	r1, r3
 800795a:	6878      	ldr	r0, [r7, #4]
 800795c:	f7ff ff50 	bl	8007800 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_READ_SINGLE_BLOCK, SDMMC_CMDTIMEOUT);
 8007960:	f241 3288 	movw	r2, #5000	@ 0x1388
 8007964:	2111      	movs	r1, #17
 8007966:	6878      	ldr	r0, [r7, #4]
 8007968:	f000 fa3c 	bl	8007de4 <SDMMC_GetCmdResp1>
 800796c:	61f8      	str	r0, [r7, #28]

  return errorstate;
 800796e:	69fb      	ldr	r3, [r7, #28]
}
 8007970:	4618      	mov	r0, r3
 8007972:	3720      	adds	r7, #32
 8007974:	46bd      	mov	sp, r7
 8007976:	bd80      	pop	{r7, pc}

08007978 <SDMMC_CmdReadMultiBlock>:
  * @brief  Send the Read Multi Block command and check the response
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdReadMultiBlock(SDMMC_TypeDef *SDMMCx, uint32_t ReadAdd)
{
 8007978:	b580      	push	{r7, lr}
 800797a:	b088      	sub	sp, #32
 800797c:	af00      	add	r7, sp, #0
 800797e:	6078      	str	r0, [r7, #4]
 8007980:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)ReadAdd;
 8007982:	683b      	ldr	r3, [r7, #0]
 8007984:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_READ_MULT_BLOCK;
 8007986:	2312      	movs	r3, #18
 8007988:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800798a:	f44f 7380 	mov.w	r3, #256	@ 0x100
 800798e:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 8007990:	2300      	movs	r3, #0
 8007992:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 8007994:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8007998:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800799a:	f107 0308 	add.w	r3, r7, #8
 800799e:	4619      	mov	r1, r3
 80079a0:	6878      	ldr	r0, [r7, #4]
 80079a2:	f7ff ff2d 	bl	8007800 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_READ_MULT_BLOCK, SDMMC_CMDTIMEOUT);
 80079a6:	f241 3288 	movw	r2, #5000	@ 0x1388
 80079aa:	2112      	movs	r1, #18
 80079ac:	6878      	ldr	r0, [r7, #4]
 80079ae:	f000 fa19 	bl	8007de4 <SDMMC_GetCmdResp1>
 80079b2:	61f8      	str	r0, [r7, #28]

  return errorstate;
 80079b4:	69fb      	ldr	r3, [r7, #28]
}
 80079b6:	4618      	mov	r0, r3
 80079b8:	3720      	adds	r7, #32
 80079ba:	46bd      	mov	sp, r7
 80079bc:	bd80      	pop	{r7, pc}

080079be <SDMMC_CmdWriteSingleBlock>:
  * @brief  Send the Write Single Block command and check the response
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdWriteSingleBlock(SDMMC_TypeDef *SDMMCx, uint32_t WriteAdd)
{
 80079be:	b580      	push	{r7, lr}
 80079c0:	b088      	sub	sp, #32
 80079c2:	af00      	add	r7, sp, #0
 80079c4:	6078      	str	r0, [r7, #4]
 80079c6:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)WriteAdd;
 80079c8:	683b      	ldr	r3, [r7, #0]
 80079ca:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_WRITE_SINGLE_BLOCK;
 80079cc:	2318      	movs	r3, #24
 80079ce:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 80079d0:	f44f 7380 	mov.w	r3, #256	@ 0x100
 80079d4:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 80079d6:	2300      	movs	r3, #0
 80079d8:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 80079da:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 80079de:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 80079e0:	f107 0308 	add.w	r3, r7, #8
 80079e4:	4619      	mov	r1, r3
 80079e6:	6878      	ldr	r0, [r7, #4]
 80079e8:	f7ff ff0a 	bl	8007800 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_WRITE_SINGLE_BLOCK, SDMMC_CMDTIMEOUT);
 80079ec:	f241 3288 	movw	r2, #5000	@ 0x1388
 80079f0:	2118      	movs	r1, #24
 80079f2:	6878      	ldr	r0, [r7, #4]
 80079f4:	f000 f9f6 	bl	8007de4 <SDMMC_GetCmdResp1>
 80079f8:	61f8      	str	r0, [r7, #28]

  return errorstate;
 80079fa:	69fb      	ldr	r3, [r7, #28]
}
 80079fc:	4618      	mov	r0, r3
 80079fe:	3720      	adds	r7, #32
 8007a00:	46bd      	mov	sp, r7
 8007a02:	bd80      	pop	{r7, pc}

08007a04 <SDMMC_CmdWriteMultiBlock>:
  * @brief  Send the Write Multi Block command and check the response
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdWriteMultiBlock(SDMMC_TypeDef *SDMMCx, uint32_t WriteAdd)
{
 8007a04:	b580      	push	{r7, lr}
 8007a06:	b088      	sub	sp, #32
 8007a08:	af00      	add	r7, sp, #0
 8007a0a:	6078      	str	r0, [r7, #4]
 8007a0c:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)WriteAdd;
 8007a0e:	683b      	ldr	r3, [r7, #0]
 8007a10:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_WRITE_MULT_BLOCK;
 8007a12:	2319      	movs	r3, #25
 8007a14:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 8007a16:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8007a1a:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 8007a1c:	2300      	movs	r3, #0
 8007a1e:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 8007a20:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8007a24:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 8007a26:	f107 0308 	add.w	r3, r7, #8
 8007a2a:	4619      	mov	r1, r3
 8007a2c:	6878      	ldr	r0, [r7, #4]
 8007a2e:	f7ff fee7 	bl	8007800 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_WRITE_MULT_BLOCK, SDMMC_CMDTIMEOUT);
 8007a32:	f241 3288 	movw	r2, #5000	@ 0x1388
 8007a36:	2119      	movs	r1, #25
 8007a38:	6878      	ldr	r0, [r7, #4]
 8007a3a:	f000 f9d3 	bl	8007de4 <SDMMC_GetCmdResp1>
 8007a3e:	61f8      	str	r0, [r7, #28]

  return errorstate;
 8007a40:	69fb      	ldr	r3, [r7, #28]
}
 8007a42:	4618      	mov	r0, r3
 8007a44:	3720      	adds	r7, #32
 8007a46:	46bd      	mov	sp, r7
 8007a48:	bd80      	pop	{r7, pc}
	...

08007a4c <SDMMC_CmdStopTransfer>:
  * @brief  Send the Stop Transfer command and check the response.
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdStopTransfer(SDMMC_TypeDef *SDMMCx)
{
 8007a4c:	b580      	push	{r7, lr}
 8007a4e:	b088      	sub	sp, #32
 8007a50:	af00      	add	r7, sp, #0
 8007a52:	6078      	str	r0, [r7, #4]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD12 STOP_TRANSMISSION  */
  sdmmc_cmdinit.Argument         = 0U;
 8007a54:	2300      	movs	r3, #0
 8007a56:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_STOP_TRANSMISSION;
 8007a58:	230c      	movs	r3, #12
 8007a5a:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 8007a5c:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8007a60:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 8007a62:	2300      	movs	r3, #0
 8007a64:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 8007a66:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8007a6a:	61bb      	str	r3, [r7, #24]

  __SDMMC_CMDSTOP_ENABLE(SDMMCx);
 8007a6c:	687b      	ldr	r3, [r7, #4]
 8007a6e:	68db      	ldr	r3, [r3, #12]
 8007a70:	f043 0280 	orr.w	r2, r3, #128	@ 0x80
 8007a74:	687b      	ldr	r3, [r7, #4]
 8007a76:	60da      	str	r2, [r3, #12]
  __SDMMC_CMDTRANS_DISABLE(SDMMCx);
 8007a78:	687b      	ldr	r3, [r7, #4]
 8007a7a:	68db      	ldr	r3, [r3, #12]
 8007a7c:	f023 0240 	bic.w	r2, r3, #64	@ 0x40
 8007a80:	687b      	ldr	r3, [r7, #4]
 8007a82:	60da      	str	r2, [r3, #12]

  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 8007a84:	f107 0308 	add.w	r3, r7, #8
 8007a88:	4619      	mov	r1, r3
 8007a8a:	6878      	ldr	r0, [r7, #4]
 8007a8c:	f7ff feb8 	bl	8007800 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_STOP_TRANSMISSION, SDMMC_STOPTRANSFERTIMEOUT);
 8007a90:	4a0b      	ldr	r2, [pc, #44]	@ (8007ac0 <SDMMC_CmdStopTransfer+0x74>)
 8007a92:	210c      	movs	r1, #12
 8007a94:	6878      	ldr	r0, [r7, #4]
 8007a96:	f000 f9a5 	bl	8007de4 <SDMMC_GetCmdResp1>
 8007a9a:	61f8      	str	r0, [r7, #28]

  __SDMMC_CMDSTOP_DISABLE(SDMMCx);
 8007a9c:	687b      	ldr	r3, [r7, #4]
 8007a9e:	68db      	ldr	r3, [r3, #12]
 8007aa0:	f023 0280 	bic.w	r2, r3, #128	@ 0x80
 8007aa4:	687b      	ldr	r3, [r7, #4]
 8007aa6:	60da      	str	r2, [r3, #12]

  /* Ignore Address Out Of Range Error, Not relevant at end of memory */
  if (errorstate == SDMMC_ERROR_ADDR_OUT_OF_RANGE)
 8007aa8:	69fb      	ldr	r3, [r7, #28]
 8007aaa:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 8007aae:	d101      	bne.n	8007ab4 <SDMMC_CmdStopTransfer+0x68>
  {
    errorstate = SDMMC_ERROR_NONE;
 8007ab0:	2300      	movs	r3, #0
 8007ab2:	61fb      	str	r3, [r7, #28]
  }

  return errorstate;
 8007ab4:	69fb      	ldr	r3, [r7, #28]
}
 8007ab6:	4618      	mov	r0, r3
 8007ab8:	3720      	adds	r7, #32
 8007aba:	46bd      	mov	sp, r7
 8007abc:	bd80      	pop	{r7, pc}
 8007abe:	bf00      	nop
 8007ac0:	05f5e100 	.word	0x05f5e100

08007ac4 <SDMMC_CmdSelDesel>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @param  addr: Address of the card to be selected
  * @retval HAL status
  */
uint32_t SDMMC_CmdSelDesel(SDMMC_TypeDef *SDMMCx, uint32_t Addr)
{
 8007ac4:	b580      	push	{r7, lr}
 8007ac6:	b088      	sub	sp, #32
 8007ac8:	af00      	add	r7, sp, #0
 8007aca:	6078      	str	r0, [r7, #4]
 8007acc:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD7 SDMMC_SEL_DESEL_CARD */
  sdmmc_cmdinit.Argument         = (uint32_t)Addr;
 8007ace:	683b      	ldr	r3, [r7, #0]
 8007ad0:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEL_DESEL_CARD;
 8007ad2:	2307      	movs	r3, #7
 8007ad4:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 8007ad6:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8007ada:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 8007adc:	2300      	movs	r3, #0
 8007ade:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 8007ae0:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8007ae4:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 8007ae6:	f107 0308 	add.w	r3, r7, #8
 8007aea:	4619      	mov	r1, r3
 8007aec:	6878      	ldr	r0, [r7, #4]
 8007aee:	f7ff fe87 	bl	8007800 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SEL_DESEL_CARD, SDMMC_CMDTIMEOUT);
 8007af2:	f241 3288 	movw	r2, #5000	@ 0x1388
 8007af6:	2107      	movs	r1, #7
 8007af8:	6878      	ldr	r0, [r7, #4]
 8007afa:	f000 f973 	bl	8007de4 <SDMMC_GetCmdResp1>
 8007afe:	61f8      	str	r0, [r7, #28]

  return errorstate;
 8007b00:	69fb      	ldr	r3, [r7, #28]
}
 8007b02:	4618      	mov	r0, r3
 8007b04:	3720      	adds	r7, #32
 8007b06:	46bd      	mov	sp, r7
 8007b08:	bd80      	pop	{r7, pc}

08007b0a <SDMMC_CmdGoIdleState>:
  * @brief  Send the Go Idle State command and check the response.
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdGoIdleState(SDMMC_TypeDef *SDMMCx)
{
 8007b0a:	b580      	push	{r7, lr}
 8007b0c:	b088      	sub	sp, #32
 8007b0e:	af00      	add	r7, sp, #0
 8007b10:	6078      	str	r0, [r7, #4]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = 0U;
 8007b12:	2300      	movs	r3, #0
 8007b14:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_GO_IDLE_STATE;
 8007b16:	2300      	movs	r3, #0
 8007b18:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_NO;
 8007b1a:	2300      	movs	r3, #0
 8007b1c:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 8007b1e:	2300      	movs	r3, #0
 8007b20:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 8007b22:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8007b26:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 8007b28:	f107 0308 	add.w	r3, r7, #8
 8007b2c:	4619      	mov	r1, r3
 8007b2e:	6878      	ldr	r0, [r7, #4]
 8007b30:	f7ff fe66 	bl	8007800 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdError(SDMMCx);
 8007b34:	6878      	ldr	r0, [r7, #4]
 8007b36:	f000 fb97 	bl	8008268 <SDMMC_GetCmdError>
 8007b3a:	61f8      	str	r0, [r7, #28]

  return errorstate;
 8007b3c:	69fb      	ldr	r3, [r7, #28]
}
 8007b3e:	4618      	mov	r0, r3
 8007b40:	3720      	adds	r7, #32
 8007b42:	46bd      	mov	sp, r7
 8007b44:	bd80      	pop	{r7, pc}

08007b46 <SDMMC_CmdOperCond>:
  * @brief  Send the Operating Condition command and check the response.
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdOperCond(SDMMC_TypeDef *SDMMCx)
{
 8007b46:	b580      	push	{r7, lr}
 8007b48:	b088      	sub	sp, #32
 8007b4a:	af00      	add	r7, sp, #0
 8007b4c:	6078      	str	r0, [r7, #4]
  /* Send CMD8 to verify SD card interface operating condition */
  /* Argument: - [31:12]: Reserved (shall be set to '0')
  - [11:8]: Supply Voltage (VHS) 0x1 (Range: 2.7-3.6 V)
  - [7:0]: Check Pattern (recommended 0xAA) */
  /* CMD Response: R7 */
  sdmmc_cmdinit.Argument         = SDMMC_CHECK_PATTERN;
 8007b4e:	f44f 73d5 	mov.w	r3, #426	@ 0x1aa
 8007b52:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_HS_SEND_EXT_CSD;
 8007b54:	2308      	movs	r3, #8
 8007b56:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 8007b58:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8007b5c:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 8007b5e:	2300      	movs	r3, #0
 8007b60:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 8007b62:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8007b66:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 8007b68:	f107 0308 	add.w	r3, r7, #8
 8007b6c:	4619      	mov	r1, r3
 8007b6e:	6878      	ldr	r0, [r7, #4]
 8007b70:	f7ff fe46 	bl	8007800 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp7(SDMMCx);
 8007b74:	6878      	ldr	r0, [r7, #4]
 8007b76:	f000 fb29 	bl	80081cc <SDMMC_GetCmdResp7>
 8007b7a:	61f8      	str	r0, [r7, #28]

  return errorstate;
 8007b7c:	69fb      	ldr	r3, [r7, #28]
}
 8007b7e:	4618      	mov	r0, r3
 8007b80:	3720      	adds	r7, #32
 8007b82:	46bd      	mov	sp, r7
 8007b84:	bd80      	pop	{r7, pc}

08007b86 <SDMMC_CmdAppCommand>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @param  Argument: Command Argument
  * @retval HAL status
  */
uint32_t SDMMC_CmdAppCommand(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
 8007b86:	b580      	push	{r7, lr}
 8007b88:	b088      	sub	sp, #32
 8007b8a:	af00      	add	r7, sp, #0
 8007b8c:	6078      	str	r0, [r7, #4]
 8007b8e:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = (uint32_t)Argument;
 8007b90:	683b      	ldr	r3, [r7, #0]
 8007b92:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_APP_CMD;
 8007b94:	2337      	movs	r3, #55	@ 0x37
 8007b96:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 8007b98:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8007b9c:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 8007b9e:	2300      	movs	r3, #0
 8007ba0:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 8007ba2:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8007ba6:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 8007ba8:	f107 0308 	add.w	r3, r7, #8
 8007bac:	4619      	mov	r1, r3
 8007bae:	6878      	ldr	r0, [r7, #4]
 8007bb0:	f7ff fe26 	bl	8007800 <SDMMC_SendCommand>

  /* Check for error conditions */
  /* If there is a HAL_ERROR, it is a MMC card, else
  it is a SD card: SD card 2.0 (voltage range mismatch)
     or SD card 1.x */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_APP_CMD, SDMMC_CMDTIMEOUT);
 8007bb4:	f241 3288 	movw	r2, #5000	@ 0x1388
 8007bb8:	2137      	movs	r1, #55	@ 0x37
 8007bba:	6878      	ldr	r0, [r7, #4]
 8007bbc:	f000 f912 	bl	8007de4 <SDMMC_GetCmdResp1>
 8007bc0:	61f8      	str	r0, [r7, #28]

  return errorstate;
 8007bc2:	69fb      	ldr	r3, [r7, #28]
}
 8007bc4:	4618      	mov	r0, r3
 8007bc6:	3720      	adds	r7, #32
 8007bc8:	46bd      	mov	sp, r7
 8007bca:	bd80      	pop	{r7, pc}

08007bcc <SDMMC_CmdAppOperCommand>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @param  Argument: Command Argument
  * @retval HAL status
  */
uint32_t SDMMC_CmdAppOperCommand(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
 8007bcc:	b580      	push	{r7, lr}
 8007bce:	b088      	sub	sp, #32
 8007bd0:	af00      	add	r7, sp, #0
 8007bd2:	6078      	str	r0, [r7, #4]
 8007bd4:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = Argument;
 8007bd6:	683b      	ldr	r3, [r7, #0]
 8007bd8:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_OP_COND;
 8007bda:	2329      	movs	r3, #41	@ 0x29
 8007bdc:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 8007bde:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8007be2:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 8007be4:	2300      	movs	r3, #0
 8007be6:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 8007be8:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8007bec:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 8007bee:	f107 0308 	add.w	r3, r7, #8
 8007bf2:	4619      	mov	r1, r3
 8007bf4:	6878      	ldr	r0, [r7, #4]
 8007bf6:	f7ff fe03 	bl	8007800 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp3(SDMMCx);
 8007bfa:	6878      	ldr	r0, [r7, #4]
 8007bfc:	f000 fa2e 	bl	800805c <SDMMC_GetCmdResp3>
 8007c00:	61f8      	str	r0, [r7, #28]

  return errorstate;
 8007c02:	69fb      	ldr	r3, [r7, #28]
}
 8007c04:	4618      	mov	r0, r3
 8007c06:	3720      	adds	r7, #32
 8007c08:	46bd      	mov	sp, r7
 8007c0a:	bd80      	pop	{r7, pc}

08007c0c <SDMMC_CmdBusWidth>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @param  BusWidth: BusWidth
  * @retval HAL status
  */
uint32_t SDMMC_CmdBusWidth(SDMMC_TypeDef *SDMMCx, uint32_t BusWidth)
{
 8007c0c:	b580      	push	{r7, lr}
 8007c0e:	b088      	sub	sp, #32
 8007c10:	af00      	add	r7, sp, #0
 8007c12:	6078      	str	r0, [r7, #4]
 8007c14:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = (uint32_t)BusWidth;
 8007c16:	683b      	ldr	r3, [r7, #0]
 8007c18:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_APP_SD_SET_BUSWIDTH;
 8007c1a:	2306      	movs	r3, #6
 8007c1c:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 8007c1e:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8007c22:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 8007c24:	2300      	movs	r3, #0
 8007c26:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 8007c28:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8007c2c:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 8007c2e:	f107 0308 	add.w	r3, r7, #8
 8007c32:	4619      	mov	r1, r3
 8007c34:	6878      	ldr	r0, [r7, #4]
 8007c36:	f7ff fde3 	bl	8007800 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_APP_SD_SET_BUSWIDTH, SDMMC_CMDTIMEOUT);
 8007c3a:	f241 3288 	movw	r2, #5000	@ 0x1388
 8007c3e:	2106      	movs	r1, #6
 8007c40:	6878      	ldr	r0, [r7, #4]
 8007c42:	f000 f8cf 	bl	8007de4 <SDMMC_GetCmdResp1>
 8007c46:	61f8      	str	r0, [r7, #28]

  return errorstate;
 8007c48:	69fb      	ldr	r3, [r7, #28]
}
 8007c4a:	4618      	mov	r0, r3
 8007c4c:	3720      	adds	r7, #32
 8007c4e:	46bd      	mov	sp, r7
 8007c50:	bd80      	pop	{r7, pc}

08007c52 <SDMMC_CmdSendSCR>:
  * @brief  Send the Send SCR command and check the response.
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendSCR(SDMMC_TypeDef *SDMMCx)
{
 8007c52:	b580      	push	{r7, lr}
 8007c54:	b088      	sub	sp, #32
 8007c56:	af00      	add	r7, sp, #0
 8007c58:	6078      	str	r0, [r7, #4]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD51 SD_APP_SEND_SCR */
  sdmmc_cmdinit.Argument         = 0U;
 8007c5a:	2300      	movs	r3, #0
 8007c5c:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_SEND_SCR;
 8007c5e:	2333      	movs	r3, #51	@ 0x33
 8007c60:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 8007c62:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8007c66:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 8007c68:	2300      	movs	r3, #0
 8007c6a:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 8007c6c:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8007c70:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 8007c72:	f107 0308 	add.w	r3, r7, #8
 8007c76:	4619      	mov	r1, r3
 8007c78:	6878      	ldr	r0, [r7, #4]
 8007c7a:	f7ff fdc1 	bl	8007800 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SD_APP_SEND_SCR, SDMMC_CMDTIMEOUT);
 8007c7e:	f241 3288 	movw	r2, #5000	@ 0x1388
 8007c82:	2133      	movs	r1, #51	@ 0x33
 8007c84:	6878      	ldr	r0, [r7, #4]
 8007c86:	f000 f8ad 	bl	8007de4 <SDMMC_GetCmdResp1>
 8007c8a:	61f8      	str	r0, [r7, #28]

  return errorstate;
 8007c8c:	69fb      	ldr	r3, [r7, #28]
}
 8007c8e:	4618      	mov	r0, r3
 8007c90:	3720      	adds	r7, #32
 8007c92:	46bd      	mov	sp, r7
 8007c94:	bd80      	pop	{r7, pc}

08007c96 <SDMMC_CmdSendCID>:
  * @brief  Send the Send CID command and check the response.
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendCID(SDMMC_TypeDef *SDMMCx)
{
 8007c96:	b580      	push	{r7, lr}
 8007c98:	b088      	sub	sp, #32
 8007c9a:	af00      	add	r7, sp, #0
 8007c9c:	6078      	str	r0, [r7, #4]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD2 ALL_SEND_CID */
  sdmmc_cmdinit.Argument         = 0U;
 8007c9e:	2300      	movs	r3, #0
 8007ca0:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ALL_SEND_CID;
 8007ca2:	2302      	movs	r3, #2
 8007ca4:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_LONG;
 8007ca6:	f44f 7340 	mov.w	r3, #768	@ 0x300
 8007caa:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 8007cac:	2300      	movs	r3, #0
 8007cae:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 8007cb0:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8007cb4:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 8007cb6:	f107 0308 	add.w	r3, r7, #8
 8007cba:	4619      	mov	r1, r3
 8007cbc:	6878      	ldr	r0, [r7, #4]
 8007cbe:	f7ff fd9f 	bl	8007800 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp2(SDMMCx);
 8007cc2:	6878      	ldr	r0, [r7, #4]
 8007cc4:	f000 f980 	bl	8007fc8 <SDMMC_GetCmdResp2>
 8007cc8:	61f8      	str	r0, [r7, #28]

  return errorstate;
 8007cca:	69fb      	ldr	r3, [r7, #28]
}
 8007ccc:	4618      	mov	r0, r3
 8007cce:	3720      	adds	r7, #32
 8007cd0:	46bd      	mov	sp, r7
 8007cd2:	bd80      	pop	{r7, pc}

08007cd4 <SDMMC_CmdSendCSD>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @param  Argument: Command Argument
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendCSD(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
 8007cd4:	b580      	push	{r7, lr}
 8007cd6:	b088      	sub	sp, #32
 8007cd8:	af00      	add	r7, sp, #0
 8007cda:	6078      	str	r0, [r7, #4]
 8007cdc:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD9 SEND_CSD */
  sdmmc_cmdinit.Argument         = Argument;
 8007cde:	683b      	ldr	r3, [r7, #0]
 8007ce0:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_CSD;
 8007ce2:	2309      	movs	r3, #9
 8007ce4:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_LONG;
 8007ce6:	f44f 7340 	mov.w	r3, #768	@ 0x300
 8007cea:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 8007cec:	2300      	movs	r3, #0
 8007cee:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 8007cf0:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8007cf4:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 8007cf6:	f107 0308 	add.w	r3, r7, #8
 8007cfa:	4619      	mov	r1, r3
 8007cfc:	6878      	ldr	r0, [r7, #4]
 8007cfe:	f7ff fd7f 	bl	8007800 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp2(SDMMCx);
 8007d02:	6878      	ldr	r0, [r7, #4]
 8007d04:	f000 f960 	bl	8007fc8 <SDMMC_GetCmdResp2>
 8007d08:	61f8      	str	r0, [r7, #28]

  return errorstate;
 8007d0a:	69fb      	ldr	r3, [r7, #28]
}
 8007d0c:	4618      	mov	r0, r3
 8007d0e:	3720      	adds	r7, #32
 8007d10:	46bd      	mov	sp, r7
 8007d12:	bd80      	pop	{r7, pc}

08007d14 <SDMMC_CmdSetRelAdd>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @param  pRCA: Card RCA
  * @retval HAL status
  */
uint32_t SDMMC_CmdSetRelAdd(SDMMC_TypeDef *SDMMCx, uint16_t *pRCA)
{
 8007d14:	b580      	push	{r7, lr}
 8007d16:	b088      	sub	sp, #32
 8007d18:	af00      	add	r7, sp, #0
 8007d1a:	6078      	str	r0, [r7, #4]
 8007d1c:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD3 SD_CMD_SET_REL_ADDR */
  sdmmc_cmdinit.Argument         = 0U;
 8007d1e:	2300      	movs	r3, #0
 8007d20:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_REL_ADDR;
 8007d22:	2303      	movs	r3, #3
 8007d24:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 8007d26:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8007d2a:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 8007d2c:	2300      	movs	r3, #0
 8007d2e:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 8007d30:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8007d34:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 8007d36:	f107 0308 	add.w	r3, r7, #8
 8007d3a:	4619      	mov	r1, r3
 8007d3c:	6878      	ldr	r0, [r7, #4]
 8007d3e:	f7ff fd5f 	bl	8007800 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp6(SDMMCx, SDMMC_CMD_SET_REL_ADDR, pRCA);
 8007d42:	683a      	ldr	r2, [r7, #0]
 8007d44:	2103      	movs	r1, #3
 8007d46:	6878      	ldr	r0, [r7, #4]
 8007d48:	f000 f9c8 	bl	80080dc <SDMMC_GetCmdResp6>
 8007d4c:	61f8      	str	r0, [r7, #28]

  return errorstate;
 8007d4e:	69fb      	ldr	r3, [r7, #28]
}
 8007d50:	4618      	mov	r0, r3
 8007d52:	3720      	adds	r7, #32
 8007d54:	46bd      	mov	sp, r7
 8007d56:	bd80      	pop	{r7, pc}

08007d58 <SDMMC_CmdSendStatus>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @param  Argument: Command Argument
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendStatus(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
 8007d58:	b580      	push	{r7, lr}
 8007d5a:	b088      	sub	sp, #32
 8007d5c:	af00      	add	r7, sp, #0
 8007d5e:	6078      	str	r0, [r7, #4]
 8007d60:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = Argument;
 8007d62:	683b      	ldr	r3, [r7, #0]
 8007d64:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_STATUS;
 8007d66:	230d      	movs	r3, #13
 8007d68:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 8007d6a:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8007d6e:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 8007d70:	2300      	movs	r3, #0
 8007d72:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 8007d74:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8007d78:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 8007d7a:	f107 0308 	add.w	r3, r7, #8
 8007d7e:	4619      	mov	r1, r3
 8007d80:	6878      	ldr	r0, [r7, #4]
 8007d82:	f7ff fd3d 	bl	8007800 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SEND_STATUS, SDMMC_CMDTIMEOUT);
 8007d86:	f241 3288 	movw	r2, #5000	@ 0x1388
 8007d8a:	210d      	movs	r1, #13
 8007d8c:	6878      	ldr	r0, [r7, #4]
 8007d8e:	f000 f829 	bl	8007de4 <SDMMC_GetCmdResp1>
 8007d92:	61f8      	str	r0, [r7, #28]

  return errorstate;
 8007d94:	69fb      	ldr	r3, [r7, #28]
}
 8007d96:	4618      	mov	r0, r3
 8007d98:	3720      	adds	r7, #32
 8007d9a:	46bd      	mov	sp, r7
 8007d9c:	bd80      	pop	{r7, pc}

08007d9e <SDMMC_CmdStatusRegister>:
  * @brief  Send the Status register command and check the response.
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdStatusRegister(SDMMC_TypeDef *SDMMCx)
{
 8007d9e:	b580      	push	{r7, lr}
 8007da0:	b088      	sub	sp, #32
 8007da2:	af00      	add	r7, sp, #0
 8007da4:	6078      	str	r0, [r7, #4]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = 0U;
 8007da6:	2300      	movs	r3, #0
 8007da8:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_STATUS;
 8007daa:	230d      	movs	r3, #13
 8007dac:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 8007dae:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8007db2:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 8007db4:	2300      	movs	r3, #0
 8007db6:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 8007db8:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8007dbc:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 8007dbe:	f107 0308 	add.w	r3, r7, #8
 8007dc2:	4619      	mov	r1, r3
 8007dc4:	6878      	ldr	r0, [r7, #4]
 8007dc6:	f7ff fd1b 	bl	8007800 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SD_APP_STATUS, SDMMC_CMDTIMEOUT);
 8007dca:	f241 3288 	movw	r2, #5000	@ 0x1388
 8007dce:	210d      	movs	r1, #13
 8007dd0:	6878      	ldr	r0, [r7, #4]
 8007dd2:	f000 f807 	bl	8007de4 <SDMMC_GetCmdResp1>
 8007dd6:	61f8      	str	r0, [r7, #28]

  return errorstate;
 8007dd8:	69fb      	ldr	r3, [r7, #28]
}
 8007dda:	4618      	mov	r0, r3
 8007ddc:	3720      	adds	r7, #32
 8007dde:	46bd      	mov	sp, r7
 8007de0:	bd80      	pop	{r7, pc}
	...

08007de4 <SDMMC_GetCmdResp1>:
  * @param  hsd: SD handle
  * @param  SD_CMD: The sent command index
  * @retval SD Card error state
  */
uint32_t SDMMC_GetCmdResp1(SDMMC_TypeDef *SDMMCx, uint8_t SD_CMD, uint32_t Timeout)
{
 8007de4:	b580      	push	{r7, lr}
 8007de6:	b088      	sub	sp, #32
 8007de8:	af00      	add	r7, sp, #0
 8007dea:	60f8      	str	r0, [r7, #12]
 8007dec:	460b      	mov	r3, r1
 8007dee:	607a      	str	r2, [r7, #4]
 8007df0:	72fb      	strb	r3, [r7, #11]
  uint32_t response_r1;
  uint32_t sta_reg;

  /* 8 is the number of required instructions cycles for the below loop statement.
  The Timeout is expressed in ms */
  uint32_t count = Timeout * (SystemCoreClock / 8U / 1000U);
 8007df2:	4b70      	ldr	r3, [pc, #448]	@ (8007fb4 <SDMMC_GetCmdResp1+0x1d0>)
 8007df4:	681b      	ldr	r3, [r3, #0]
 8007df6:	4a70      	ldr	r2, [pc, #448]	@ (8007fb8 <SDMMC_GetCmdResp1+0x1d4>)
 8007df8:	fba2 2303 	umull	r2, r3, r2, r3
 8007dfc:	0a5a      	lsrs	r2, r3, #9
 8007dfe:	687b      	ldr	r3, [r7, #4]
 8007e00:	fb02 f303 	mul.w	r3, r2, r3
 8007e04:	61fb      	str	r3, [r7, #28]

  do
  {
    if (count-- == 0U)
 8007e06:	69fb      	ldr	r3, [r7, #28]
 8007e08:	1e5a      	subs	r2, r3, #1
 8007e0a:	61fa      	str	r2, [r7, #28]
 8007e0c:	2b00      	cmp	r3, #0
 8007e0e:	d102      	bne.n	8007e16 <SDMMC_GetCmdResp1+0x32>
    {
      return SDMMC_ERROR_TIMEOUT;
 8007e10:	f04f 4300 	mov.w	r3, #2147483648	@ 0x80000000
 8007e14:	e0c9      	b.n	8007faa <SDMMC_GetCmdResp1+0x1c6>
    }
    sta_reg = SDMMCx->STA;
 8007e16:	68fb      	ldr	r3, [r7, #12]
 8007e18:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8007e1a:	61bb      	str	r3, [r7, #24]
  } while (((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT |
 8007e1c:	69ba      	ldr	r2, [r7, #24]
 8007e1e:	4b67      	ldr	r3, [pc, #412]	@ (8007fbc <SDMMC_GetCmdResp1+0x1d8>)
 8007e20:	4013      	ands	r3, r2
                        SDMMC_FLAG_BUSYD0END)) == 0U) || ((sta_reg & SDMMC_FLAG_CMDACT) != 0U));
 8007e22:	2b00      	cmp	r3, #0
 8007e24:	d0ef      	beq.n	8007e06 <SDMMC_GetCmdResp1+0x22>
 8007e26:	69bb      	ldr	r3, [r7, #24]
 8007e28:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 8007e2c:	2b00      	cmp	r3, #0
 8007e2e:	d1ea      	bne.n	8007e06 <SDMMC_GetCmdResp1+0x22>

  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 8007e30:	68fb      	ldr	r3, [r7, #12]
 8007e32:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8007e34:	f003 0304 	and.w	r3, r3, #4
 8007e38:	2b00      	cmp	r3, #0
 8007e3a:	d004      	beq.n	8007e46 <SDMMC_GetCmdResp1+0x62>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 8007e3c:	68fb      	ldr	r3, [r7, #12]
 8007e3e:	2204      	movs	r2, #4
 8007e40:	639a      	str	r2, [r3, #56]	@ 0x38

    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 8007e42:	2304      	movs	r3, #4
 8007e44:	e0b1      	b.n	8007faa <SDMMC_GetCmdResp1+0x1c6>
  }
  else if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 8007e46:	68fb      	ldr	r3, [r7, #12]
 8007e48:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8007e4a:	f003 0301 	and.w	r3, r3, #1
 8007e4e:	2b00      	cmp	r3, #0
 8007e50:	d004      	beq.n	8007e5c <SDMMC_GetCmdResp1+0x78>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 8007e52:	68fb      	ldr	r3, [r7, #12]
 8007e54:	2201      	movs	r2, #1
 8007e56:	639a      	str	r2, [r3, #56]	@ 0x38

    return SDMMC_ERROR_CMD_CRC_FAIL;
 8007e58:	2301      	movs	r3, #1
 8007e5a:	e0a6      	b.n	8007faa <SDMMC_GetCmdResp1+0x1c6>
  {
    /* Nothing to do */
  }

  /* Clear all the static flags */
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 8007e5c:	68fb      	ldr	r3, [r7, #12]
 8007e5e:	4a58      	ldr	r2, [pc, #352]	@ (8007fc0 <SDMMC_GetCmdResp1+0x1dc>)
 8007e60:	639a      	str	r2, [r3, #56]	@ 0x38

  /* Check response received is of desired command */
  if (SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 8007e62:	68f8      	ldr	r0, [r7, #12]
 8007e64:	f7ff fcf6 	bl	8007854 <SDMMC_GetCommandResponse>
 8007e68:	4603      	mov	r3, r0
 8007e6a:	461a      	mov	r2, r3
 8007e6c:	7afb      	ldrb	r3, [r7, #11]
 8007e6e:	4293      	cmp	r3, r2
 8007e70:	d001      	beq.n	8007e76 <SDMMC_GetCmdResp1+0x92>
  {
    return SDMMC_ERROR_CMD_CRC_FAIL;
 8007e72:	2301      	movs	r3, #1
 8007e74:	e099      	b.n	8007faa <SDMMC_GetCmdResp1+0x1c6>
  }

  /* We have received response, retrieve it for analysis  */
  response_r1 = SDMMC_GetResponse(SDMMCx, SDMMC_RESP1);
 8007e76:	2100      	movs	r1, #0
 8007e78:	68f8      	ldr	r0, [r7, #12]
 8007e7a:	f7ff fcf8 	bl	800786e <SDMMC_GetResponse>
 8007e7e:	6178      	str	r0, [r7, #20]

  if ((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 8007e80:	697a      	ldr	r2, [r7, #20]
 8007e82:	4b50      	ldr	r3, [pc, #320]	@ (8007fc4 <SDMMC_GetCmdResp1+0x1e0>)
 8007e84:	4013      	ands	r3, r2
 8007e86:	2b00      	cmp	r3, #0
 8007e88:	d101      	bne.n	8007e8e <SDMMC_GetCmdResp1+0xaa>
  {
    return SDMMC_ERROR_NONE;
 8007e8a:	2300      	movs	r3, #0
 8007e8c:	e08d      	b.n	8007faa <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
 8007e8e:	697b      	ldr	r3, [r7, #20]
 8007e90:	2b00      	cmp	r3, #0
 8007e92:	da02      	bge.n	8007e9a <SDMMC_GetCmdResp1+0xb6>
  {
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
 8007e94:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
 8007e98:	e087      	b.n	8007faa <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
 8007e9a:	697b      	ldr	r3, [r7, #20]
 8007e9c:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
 8007ea0:	2b00      	cmp	r3, #0
 8007ea2:	d001      	beq.n	8007ea8 <SDMMC_GetCmdResp1+0xc4>
  {
    return SDMMC_ERROR_ADDR_MISALIGNED;
 8007ea4:	2340      	movs	r3, #64	@ 0x40
 8007ea6:	e080      	b.n	8007faa <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
 8007ea8:	697b      	ldr	r3, [r7, #20]
 8007eaa:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 8007eae:	2b00      	cmp	r3, #0
 8007eb0:	d001      	beq.n	8007eb6 <SDMMC_GetCmdResp1+0xd2>
  {
    return SDMMC_ERROR_BLOCK_LEN_ERR;
 8007eb2:	2380      	movs	r3, #128	@ 0x80
 8007eb4:	e079      	b.n	8007faa <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
 8007eb6:	697b      	ldr	r3, [r7, #20]
 8007eb8:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 8007ebc:	2b00      	cmp	r3, #0
 8007ebe:	d002      	beq.n	8007ec6 <SDMMC_GetCmdResp1+0xe2>
  {
    return SDMMC_ERROR_ERASE_SEQ_ERR;
 8007ec0:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8007ec4:	e071      	b.n	8007faa <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
 8007ec6:	697b      	ldr	r3, [r7, #20]
 8007ec8:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8007ecc:	2b00      	cmp	r3, #0
 8007ece:	d002      	beq.n	8007ed6 <SDMMC_GetCmdResp1+0xf2>
  {
    return SDMMC_ERROR_BAD_ERASE_PARAM;
 8007ed0:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8007ed4:	e069      	b.n	8007faa <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
 8007ed6:	697b      	ldr	r3, [r7, #20]
 8007ed8:	f003 6380 	and.w	r3, r3, #67108864	@ 0x4000000
 8007edc:	2b00      	cmp	r3, #0
 8007ede:	d002      	beq.n	8007ee6 <SDMMC_GetCmdResp1+0x102>
  {
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
 8007ee0:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 8007ee4:	e061      	b.n	8007faa <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
 8007ee6:	697b      	ldr	r3, [r7, #20]
 8007ee8:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
 8007eec:	2b00      	cmp	r3, #0
 8007eee:	d002      	beq.n	8007ef6 <SDMMC_GetCmdResp1+0x112>
  {
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
 8007ef0:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8007ef4:	e059      	b.n	8007faa <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
 8007ef6:	697b      	ldr	r3, [r7, #20]
 8007ef8:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 8007efc:	2b00      	cmp	r3, #0
 8007efe:	d002      	beq.n	8007f06 <SDMMC_GetCmdResp1+0x122>
  {
    return SDMMC_ERROR_COM_CRC_FAILED;
 8007f00:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8007f04:	e051      	b.n	8007faa <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
 8007f06:	697b      	ldr	r3, [r7, #20]
 8007f08:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 8007f0c:	2b00      	cmp	r3, #0
 8007f0e:	d002      	beq.n	8007f16 <SDMMC_GetCmdResp1+0x132>
  {
    return SDMMC_ERROR_ILLEGAL_CMD;
 8007f10:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
 8007f14:	e049      	b.n	8007faa <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
 8007f16:	697b      	ldr	r3, [r7, #20]
 8007f18:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 8007f1c:	2b00      	cmp	r3, #0
 8007f1e:	d002      	beq.n	8007f26 <SDMMC_GetCmdResp1+0x142>
  {
    return SDMMC_ERROR_CARD_ECC_FAILED;
 8007f20:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
 8007f24:	e041      	b.n	8007faa <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
 8007f26:	697b      	ldr	r3, [r7, #20]
 8007f28:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
 8007f2c:	2b00      	cmp	r3, #0
 8007f2e:	d002      	beq.n	8007f36 <SDMMC_GetCmdResp1+0x152>
  {
    return SDMMC_ERROR_CC_ERR;
 8007f30:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 8007f34:	e039      	b.n	8007faa <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
 8007f36:	697b      	ldr	r3, [r7, #20]
 8007f38:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
 8007f3c:	2b00      	cmp	r3, #0
 8007f3e:	d002      	beq.n	8007f46 <SDMMC_GetCmdResp1+0x162>
  {
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
 8007f40:	f44f 3300 	mov.w	r3, #131072	@ 0x20000
 8007f44:	e031      	b.n	8007faa <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
 8007f46:	697b      	ldr	r3, [r7, #20]
 8007f48:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8007f4c:	2b00      	cmp	r3, #0
 8007f4e:	d002      	beq.n	8007f56 <SDMMC_GetCmdResp1+0x172>
  {
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
 8007f50:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
 8007f54:	e029      	b.n	8007faa <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
 8007f56:	697b      	ldr	r3, [r7, #20]
 8007f58:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 8007f5c:	2b00      	cmp	r3, #0
 8007f5e:	d002      	beq.n	8007f66 <SDMMC_GetCmdResp1+0x182>
  {
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
 8007f60:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
 8007f64:	e021      	b.n	8007faa <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
 8007f66:	697b      	ldr	r3, [r7, #20]
 8007f68:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 8007f6c:	2b00      	cmp	r3, #0
 8007f6e:	d002      	beq.n	8007f76 <SDMMC_GetCmdResp1+0x192>
  {
    return SDMMC_ERROR_WP_ERASE_SKIP;
 8007f70:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
 8007f74:	e019      	b.n	8007faa <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
 8007f76:	697b      	ldr	r3, [r7, #20]
 8007f78:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 8007f7c:	2b00      	cmp	r3, #0
 8007f7e:	d002      	beq.n	8007f86 <SDMMC_GetCmdResp1+0x1a2>
  {
    return SDMMC_ERROR_CARD_ECC_DISABLED;
 8007f80:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
 8007f84:	e011      	b.n	8007faa <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
 8007f86:	697b      	ldr	r3, [r7, #20]
 8007f88:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 8007f8c:	2b00      	cmp	r3, #0
 8007f8e:	d002      	beq.n	8007f96 <SDMMC_GetCmdResp1+0x1b2>
  {
    return SDMMC_ERROR_ERASE_RESET;
 8007f90:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
 8007f94:	e009      	b.n	8007faa <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_AKE_SEQ_ERROR) == SDMMC_OCR_AKE_SEQ_ERROR)
 8007f96:	697b      	ldr	r3, [r7, #20]
 8007f98:	f003 0308 	and.w	r3, r3, #8
 8007f9c:	2b00      	cmp	r3, #0
 8007f9e:	d002      	beq.n	8007fa6 <SDMMC_GetCmdResp1+0x1c2>
  {
    return SDMMC_ERROR_AKE_SEQ_ERR;
 8007fa0:	f44f 0300 	mov.w	r3, #8388608	@ 0x800000
 8007fa4:	e001      	b.n	8007faa <SDMMC_GetCmdResp1+0x1c6>
  }
  else
  {
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
 8007fa6:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
  }
}
 8007faa:	4618      	mov	r0, r3
 8007fac:	3720      	adds	r7, #32
 8007fae:	46bd      	mov	sp, r7
 8007fb0:	bd80      	pop	{r7, pc}
 8007fb2:	bf00      	nop
 8007fb4:	20000000 	.word	0x20000000
 8007fb8:	10624dd3 	.word	0x10624dd3
 8007fbc:	00200045 	.word	0x00200045
 8007fc0:	002000c5 	.word	0x002000c5
 8007fc4:	fdffe008 	.word	0xfdffe008

08007fc8 <SDMMC_GetCmdResp2>:
  * @brief  Checks for error conditions for R2 (CID or CSD) response.
  * @param  hsd: SD handle
  * @retval SD Card error state
  */
uint32_t SDMMC_GetCmdResp2(SDMMC_TypeDef *SDMMCx)
{
 8007fc8:	b480      	push	{r7}
 8007fca:	b085      	sub	sp, #20
 8007fcc:	af00      	add	r7, sp, #0
 8007fce:	6078      	str	r0, [r7, #4]
  uint32_t sta_reg;
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U / 1000U);
 8007fd0:	4b1f      	ldr	r3, [pc, #124]	@ (8008050 <SDMMC_GetCmdResp2+0x88>)
 8007fd2:	681b      	ldr	r3, [r3, #0]
 8007fd4:	4a1f      	ldr	r2, [pc, #124]	@ (8008054 <SDMMC_GetCmdResp2+0x8c>)
 8007fd6:	fba2 2303 	umull	r2, r3, r2, r3
 8007fda:	0a5b      	lsrs	r3, r3, #9
 8007fdc:	f241 3288 	movw	r2, #5000	@ 0x1388
 8007fe0:	fb02 f303 	mul.w	r3, r2, r3
 8007fe4:	60fb      	str	r3, [r7, #12]

  do
  {
    if (count-- == 0U)
 8007fe6:	68fb      	ldr	r3, [r7, #12]
 8007fe8:	1e5a      	subs	r2, r3, #1
 8007fea:	60fa      	str	r2, [r7, #12]
 8007fec:	2b00      	cmp	r3, #0
 8007fee:	d102      	bne.n	8007ff6 <SDMMC_GetCmdResp2+0x2e>
    {
      return SDMMC_ERROR_TIMEOUT;
 8007ff0:	f04f 4300 	mov.w	r3, #2147483648	@ 0x80000000
 8007ff4:	e026      	b.n	8008044 <SDMMC_GetCmdResp2+0x7c>
    }
    sta_reg = SDMMCx->STA;
 8007ff6:	687b      	ldr	r3, [r7, #4]
 8007ff8:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8007ffa:	60bb      	str	r3, [r7, #8]
  } while (((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 8007ffc:	68bb      	ldr	r3, [r7, #8]
 8007ffe:	f003 0345 	and.w	r3, r3, #69	@ 0x45
 8008002:	2b00      	cmp	r3, #0
 8008004:	d0ef      	beq.n	8007fe6 <SDMMC_GetCmdResp2+0x1e>
           ((sta_reg & SDMMC_FLAG_CMDACT) != 0U));
 8008006:	68bb      	ldr	r3, [r7, #8]
 8008008:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
  } while (((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 800800c:	2b00      	cmp	r3, #0
 800800e:	d1ea      	bne.n	8007fe6 <SDMMC_GetCmdResp2+0x1e>

  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 8008010:	687b      	ldr	r3, [r7, #4]
 8008012:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8008014:	f003 0304 	and.w	r3, r3, #4
 8008018:	2b00      	cmp	r3, #0
 800801a:	d004      	beq.n	8008026 <SDMMC_GetCmdResp2+0x5e>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800801c:	687b      	ldr	r3, [r7, #4]
 800801e:	2204      	movs	r2, #4
 8008020:	639a      	str	r2, [r3, #56]	@ 0x38

    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 8008022:	2304      	movs	r3, #4
 8008024:	e00e      	b.n	8008044 <SDMMC_GetCmdResp2+0x7c>
  }
  else if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 8008026:	687b      	ldr	r3, [r7, #4]
 8008028:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800802a:	f003 0301 	and.w	r3, r3, #1
 800802e:	2b00      	cmp	r3, #0
 8008030:	d004      	beq.n	800803c <SDMMC_GetCmdResp2+0x74>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 8008032:	687b      	ldr	r3, [r7, #4]
 8008034:	2201      	movs	r2, #1
 8008036:	639a      	str	r2, [r3, #56]	@ 0x38

    return SDMMC_ERROR_CMD_CRC_FAIL;
 8008038:	2301      	movs	r3, #1
 800803a:	e003      	b.n	8008044 <SDMMC_GetCmdResp2+0x7c>
  }
  else
  {
    /* No error flag set */
    /* Clear all the static flags */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800803c:	687b      	ldr	r3, [r7, #4]
 800803e:	4a06      	ldr	r2, [pc, #24]	@ (8008058 <SDMMC_GetCmdResp2+0x90>)
 8008040:	639a      	str	r2, [r3, #56]	@ 0x38
  }

  return SDMMC_ERROR_NONE;
 8008042:	2300      	movs	r3, #0
}
 8008044:	4618      	mov	r0, r3
 8008046:	3714      	adds	r7, #20
 8008048:	46bd      	mov	sp, r7
 800804a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800804e:	4770      	bx	lr
 8008050:	20000000 	.word	0x20000000
 8008054:	10624dd3 	.word	0x10624dd3
 8008058:	002000c5 	.word	0x002000c5

0800805c <SDMMC_GetCmdResp3>:
  * @brief  Checks for error conditions for R3 (OCR) response.
  * @param  hsd: SD handle
  * @retval SD Card error state
  */
uint32_t SDMMC_GetCmdResp3(SDMMC_TypeDef *SDMMCx)
{
 800805c:	b480      	push	{r7}
 800805e:	b085      	sub	sp, #20
 8008060:	af00      	add	r7, sp, #0
 8008062:	6078      	str	r0, [r7, #4]
  uint32_t sta_reg;
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U / 1000U);
 8008064:	4b1a      	ldr	r3, [pc, #104]	@ (80080d0 <SDMMC_GetCmdResp3+0x74>)
 8008066:	681b      	ldr	r3, [r3, #0]
 8008068:	4a1a      	ldr	r2, [pc, #104]	@ (80080d4 <SDMMC_GetCmdResp3+0x78>)
 800806a:	fba2 2303 	umull	r2, r3, r2, r3
 800806e:	0a5b      	lsrs	r3, r3, #9
 8008070:	f241 3288 	movw	r2, #5000	@ 0x1388
 8008074:	fb02 f303 	mul.w	r3, r2, r3
 8008078:	60fb      	str	r3, [r7, #12]

  do
  {
    if (count-- == 0U)
 800807a:	68fb      	ldr	r3, [r7, #12]
 800807c:	1e5a      	subs	r2, r3, #1
 800807e:	60fa      	str	r2, [r7, #12]
 8008080:	2b00      	cmp	r3, #0
 8008082:	d102      	bne.n	800808a <SDMMC_GetCmdResp3+0x2e>
    {
      return SDMMC_ERROR_TIMEOUT;
 8008084:	f04f 4300 	mov.w	r3, #2147483648	@ 0x80000000
 8008088:	e01b      	b.n	80080c2 <SDMMC_GetCmdResp3+0x66>
    }
    sta_reg = SDMMCx->STA;
 800808a:	687b      	ldr	r3, [r7, #4]
 800808c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800808e:	60bb      	str	r3, [r7, #8]
  } while (((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 8008090:	68bb      	ldr	r3, [r7, #8]
 8008092:	f003 0345 	and.w	r3, r3, #69	@ 0x45
 8008096:	2b00      	cmp	r3, #0
 8008098:	d0ef      	beq.n	800807a <SDMMC_GetCmdResp3+0x1e>
           ((sta_reg & SDMMC_FLAG_CMDACT) != 0U));
 800809a:	68bb      	ldr	r3, [r7, #8]
 800809c:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
  } while (((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 80080a0:	2b00      	cmp	r3, #0
 80080a2:	d1ea      	bne.n	800807a <SDMMC_GetCmdResp3+0x1e>

  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 80080a4:	687b      	ldr	r3, [r7, #4]
 80080a6:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80080a8:	f003 0304 	and.w	r3, r3, #4
 80080ac:	2b00      	cmp	r3, #0
 80080ae:	d004      	beq.n	80080ba <SDMMC_GetCmdResp3+0x5e>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 80080b0:	687b      	ldr	r3, [r7, #4]
 80080b2:	2204      	movs	r2, #4
 80080b4:	639a      	str	r2, [r3, #56]	@ 0x38

    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 80080b6:	2304      	movs	r3, #4
 80080b8:	e003      	b.n	80080c2 <SDMMC_GetCmdResp3+0x66>
  }
  else
  {
    /* Clear all the static flags */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 80080ba:	687b      	ldr	r3, [r7, #4]
 80080bc:	4a06      	ldr	r2, [pc, #24]	@ (80080d8 <SDMMC_GetCmdResp3+0x7c>)
 80080be:	639a      	str	r2, [r3, #56]	@ 0x38
  }

  return SDMMC_ERROR_NONE;
 80080c0:	2300      	movs	r3, #0
}
 80080c2:	4618      	mov	r0, r3
 80080c4:	3714      	adds	r7, #20
 80080c6:	46bd      	mov	sp, r7
 80080c8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80080cc:	4770      	bx	lr
 80080ce:	bf00      	nop
 80080d0:	20000000 	.word	0x20000000
 80080d4:	10624dd3 	.word	0x10624dd3
 80080d8:	002000c5 	.word	0x002000c5

080080dc <SDMMC_GetCmdResp6>:
  * @param  pRCA: Pointer to the variable that will contain the SD card relative
  *         address RCA
  * @retval SD Card error state
  */
uint32_t SDMMC_GetCmdResp6(SDMMC_TypeDef *SDMMCx, uint8_t SD_CMD, uint16_t *pRCA)
{
 80080dc:	b580      	push	{r7, lr}
 80080de:	b088      	sub	sp, #32
 80080e0:	af00      	add	r7, sp, #0
 80080e2:	60f8      	str	r0, [r7, #12]
 80080e4:	460b      	mov	r3, r1
 80080e6:	607a      	str	r2, [r7, #4]
 80080e8:	72fb      	strb	r3, [r7, #11]
  uint32_t response_r1;
  uint32_t sta_reg;

  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U / 1000U);
 80080ea:	4b35      	ldr	r3, [pc, #212]	@ (80081c0 <SDMMC_GetCmdResp6+0xe4>)
 80080ec:	681b      	ldr	r3, [r3, #0]
 80080ee:	4a35      	ldr	r2, [pc, #212]	@ (80081c4 <SDMMC_GetCmdResp6+0xe8>)
 80080f0:	fba2 2303 	umull	r2, r3, r2, r3
 80080f4:	0a5b      	lsrs	r3, r3, #9
 80080f6:	f241 3288 	movw	r2, #5000	@ 0x1388
 80080fa:	fb02 f303 	mul.w	r3, r2, r3
 80080fe:	61fb      	str	r3, [r7, #28]

  do
  {
    if (count-- == 0U)
 8008100:	69fb      	ldr	r3, [r7, #28]
 8008102:	1e5a      	subs	r2, r3, #1
 8008104:	61fa      	str	r2, [r7, #28]
 8008106:	2b00      	cmp	r3, #0
 8008108:	d102      	bne.n	8008110 <SDMMC_GetCmdResp6+0x34>
    {
      return SDMMC_ERROR_TIMEOUT;
 800810a:	f04f 4300 	mov.w	r3, #2147483648	@ 0x80000000
 800810e:	e052      	b.n	80081b6 <SDMMC_GetCmdResp6+0xda>
    }
    sta_reg = SDMMCx->STA;
 8008110:	68fb      	ldr	r3, [r7, #12]
 8008112:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8008114:	61bb      	str	r3, [r7, #24]
  } while (((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 8008116:	69bb      	ldr	r3, [r7, #24]
 8008118:	f003 0345 	and.w	r3, r3, #69	@ 0x45
 800811c:	2b00      	cmp	r3, #0
 800811e:	d0ef      	beq.n	8008100 <SDMMC_GetCmdResp6+0x24>
           ((sta_reg & SDMMC_FLAG_CMDACT) != 0U));
 8008120:	69bb      	ldr	r3, [r7, #24]
 8008122:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
  } while (((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 8008126:	2b00      	cmp	r3, #0
 8008128:	d1ea      	bne.n	8008100 <SDMMC_GetCmdResp6+0x24>

  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800812a:	68fb      	ldr	r3, [r7, #12]
 800812c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800812e:	f003 0304 	and.w	r3, r3, #4
 8008132:	2b00      	cmp	r3, #0
 8008134:	d004      	beq.n	8008140 <SDMMC_GetCmdResp6+0x64>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 8008136:	68fb      	ldr	r3, [r7, #12]
 8008138:	2204      	movs	r2, #4
 800813a:	639a      	str	r2, [r3, #56]	@ 0x38

    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 800813c:	2304      	movs	r3, #4
 800813e:	e03a      	b.n	80081b6 <SDMMC_GetCmdResp6+0xda>
  }
  else if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 8008140:	68fb      	ldr	r3, [r7, #12]
 8008142:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8008144:	f003 0301 	and.w	r3, r3, #1
 8008148:	2b00      	cmp	r3, #0
 800814a:	d004      	beq.n	8008156 <SDMMC_GetCmdResp6+0x7a>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800814c:	68fb      	ldr	r3, [r7, #12]
 800814e:	2201      	movs	r2, #1
 8008150:	639a      	str	r2, [r3, #56]	@ 0x38

    return SDMMC_ERROR_CMD_CRC_FAIL;
 8008152:	2301      	movs	r3, #1
 8008154:	e02f      	b.n	80081b6 <SDMMC_GetCmdResp6+0xda>
  {
    /* Nothing to do */
  }

  /* Check response received is of desired command */
  if (SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 8008156:	68f8      	ldr	r0, [r7, #12]
 8008158:	f7ff fb7c 	bl	8007854 <SDMMC_GetCommandResponse>
 800815c:	4603      	mov	r3, r0
 800815e:	461a      	mov	r2, r3
 8008160:	7afb      	ldrb	r3, [r7, #11]
 8008162:	4293      	cmp	r3, r2
 8008164:	d001      	beq.n	800816a <SDMMC_GetCmdResp6+0x8e>
  {
    return SDMMC_ERROR_CMD_CRC_FAIL;
 8008166:	2301      	movs	r3, #1
 8008168:	e025      	b.n	80081b6 <SDMMC_GetCmdResp6+0xda>
  }

  /* Clear all the static flags */
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800816a:	68fb      	ldr	r3, [r7, #12]
 800816c:	4a16      	ldr	r2, [pc, #88]	@ (80081c8 <SDMMC_GetCmdResp6+0xec>)
 800816e:	639a      	str	r2, [r3, #56]	@ 0x38

  /* We have received response, retrieve it.  */
  response_r1 = SDMMC_GetResponse(SDMMCx, SDMMC_RESP1);
 8008170:	2100      	movs	r1, #0
 8008172:	68f8      	ldr	r0, [r7, #12]
 8008174:	f7ff fb7b 	bl	800786e <SDMMC_GetResponse>
 8008178:	6178      	str	r0, [r7, #20]

  if ((response_r1 & (SDMMC_R6_GENERAL_UNKNOWN_ERROR | SDMMC_R6_ILLEGAL_CMD |
 800817a:	697b      	ldr	r3, [r7, #20]
 800817c:	f403 4360 	and.w	r3, r3, #57344	@ 0xe000
 8008180:	2b00      	cmp	r3, #0
 8008182:	d106      	bne.n	8008192 <SDMMC_GetCmdResp6+0xb6>
                      SDMMC_R6_COM_CRC_FAILED)) == SDMMC_ALLZERO)
  {
    *pRCA = (uint16_t)(response_r1 >> 16);
 8008184:	697b      	ldr	r3, [r7, #20]
 8008186:	0c1b      	lsrs	r3, r3, #16
 8008188:	b29a      	uxth	r2, r3
 800818a:	687b      	ldr	r3, [r7, #4]
 800818c:	801a      	strh	r2, [r3, #0]

    return SDMMC_ERROR_NONE;
 800818e:	2300      	movs	r3, #0
 8008190:	e011      	b.n	80081b6 <SDMMC_GetCmdResp6+0xda>
  }
  else if ((response_r1 & SDMMC_R6_ILLEGAL_CMD) == SDMMC_R6_ILLEGAL_CMD)
 8008192:	697b      	ldr	r3, [r7, #20]
 8008194:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 8008198:	2b00      	cmp	r3, #0
 800819a:	d002      	beq.n	80081a2 <SDMMC_GetCmdResp6+0xc6>
  {
    return SDMMC_ERROR_ILLEGAL_CMD;
 800819c:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
 80081a0:	e009      	b.n	80081b6 <SDMMC_GetCmdResp6+0xda>
  }
  else if ((response_r1 & SDMMC_R6_COM_CRC_FAILED) == SDMMC_R6_COM_CRC_FAILED)
 80081a2:	697b      	ldr	r3, [r7, #20]
 80081a4:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 80081a8:	2b00      	cmp	r3, #0
 80081aa:	d002      	beq.n	80081b2 <SDMMC_GetCmdResp6+0xd6>
  {
    return SDMMC_ERROR_COM_CRC_FAILED;
 80081ac:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 80081b0:	e001      	b.n	80081b6 <SDMMC_GetCmdResp6+0xda>
  }
  else
  {
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
 80081b2:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
  }
}
 80081b6:	4618      	mov	r0, r3
 80081b8:	3720      	adds	r7, #32
 80081ba:	46bd      	mov	sp, r7
 80081bc:	bd80      	pop	{r7, pc}
 80081be:	bf00      	nop
 80081c0:	20000000 	.word	0x20000000
 80081c4:	10624dd3 	.word	0x10624dd3
 80081c8:	002000c5 	.word	0x002000c5

080081cc <SDMMC_GetCmdResp7>:
  * @brief  Checks for error conditions for R7 response.
  * @param  hsd: SD handle
  * @retval SD Card error state
  */
uint32_t SDMMC_GetCmdResp7(SDMMC_TypeDef *SDMMCx)
{
 80081cc:	b480      	push	{r7}
 80081ce:	b085      	sub	sp, #20
 80081d0:	af00      	add	r7, sp, #0
 80081d2:	6078      	str	r0, [r7, #4]
  uint32_t sta_reg;
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U / 1000U);
 80081d4:	4b22      	ldr	r3, [pc, #136]	@ (8008260 <SDMMC_GetCmdResp7+0x94>)
 80081d6:	681b      	ldr	r3, [r3, #0]
 80081d8:	4a22      	ldr	r2, [pc, #136]	@ (8008264 <SDMMC_GetCmdResp7+0x98>)
 80081da:	fba2 2303 	umull	r2, r3, r2, r3
 80081de:	0a5b      	lsrs	r3, r3, #9
 80081e0:	f241 3288 	movw	r2, #5000	@ 0x1388
 80081e4:	fb02 f303 	mul.w	r3, r2, r3
 80081e8:	60fb      	str	r3, [r7, #12]

  do
  {
    if (count-- == 0U)
 80081ea:	68fb      	ldr	r3, [r7, #12]
 80081ec:	1e5a      	subs	r2, r3, #1
 80081ee:	60fa      	str	r2, [r7, #12]
 80081f0:	2b00      	cmp	r3, #0
 80081f2:	d102      	bne.n	80081fa <SDMMC_GetCmdResp7+0x2e>
    {
      return SDMMC_ERROR_TIMEOUT;
 80081f4:	f04f 4300 	mov.w	r3, #2147483648	@ 0x80000000
 80081f8:	e02c      	b.n	8008254 <SDMMC_GetCmdResp7+0x88>
    }
    sta_reg = SDMMCx->STA;
 80081fa:	687b      	ldr	r3, [r7, #4]
 80081fc:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80081fe:	60bb      	str	r3, [r7, #8]
  } while (((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 8008200:	68bb      	ldr	r3, [r7, #8]
 8008202:	f003 0345 	and.w	r3, r3, #69	@ 0x45
 8008206:	2b00      	cmp	r3, #0
 8008208:	d0ef      	beq.n	80081ea <SDMMC_GetCmdResp7+0x1e>
           ((sta_reg & SDMMC_FLAG_CMDACT) != 0U));
 800820a:	68bb      	ldr	r3, [r7, #8]
 800820c:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
  } while (((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 8008210:	2b00      	cmp	r3, #0
 8008212:	d1ea      	bne.n	80081ea <SDMMC_GetCmdResp7+0x1e>

  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 8008214:	687b      	ldr	r3, [r7, #4]
 8008216:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8008218:	f003 0304 	and.w	r3, r3, #4
 800821c:	2b00      	cmp	r3, #0
 800821e:	d004      	beq.n	800822a <SDMMC_GetCmdResp7+0x5e>
  {
    /* Card is not SD V2.0 compliant */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 8008220:	687b      	ldr	r3, [r7, #4]
 8008222:	2204      	movs	r2, #4
 8008224:	639a      	str	r2, [r3, #56]	@ 0x38

    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 8008226:	2304      	movs	r3, #4
 8008228:	e014      	b.n	8008254 <SDMMC_GetCmdResp7+0x88>
  }

  else if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800822a:	687b      	ldr	r3, [r7, #4]
 800822c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800822e:	f003 0301 	and.w	r3, r3, #1
 8008232:	2b00      	cmp	r3, #0
 8008234:	d004      	beq.n	8008240 <SDMMC_GetCmdResp7+0x74>
  {
    /* Card is not SD V2.0 compliant */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 8008236:	687b      	ldr	r3, [r7, #4]
 8008238:	2201      	movs	r2, #1
 800823a:	639a      	str	r2, [r3, #56]	@ 0x38

    return SDMMC_ERROR_CMD_CRC_FAIL;
 800823c:	2301      	movs	r3, #1
 800823e:	e009      	b.n	8008254 <SDMMC_GetCmdResp7+0x88>
  else
  {
    /* Nothing to do */
  }

  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CMDREND))
 8008240:	687b      	ldr	r3, [r7, #4]
 8008242:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8008244:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8008248:	2b00      	cmp	r3, #0
 800824a:	d002      	beq.n	8008252 <SDMMC_GetCmdResp7+0x86>
  {
    /* Card is SD V2.0 compliant */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CMDREND);
 800824c:	687b      	ldr	r3, [r7, #4]
 800824e:	2240      	movs	r2, #64	@ 0x40
 8008250:	639a      	str	r2, [r3, #56]	@ 0x38
  }

  return SDMMC_ERROR_NONE;
 8008252:	2300      	movs	r3, #0

}
 8008254:	4618      	mov	r0, r3
 8008256:	3714      	adds	r7, #20
 8008258:	46bd      	mov	sp, r7
 800825a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800825e:	4770      	bx	lr
 8008260:	20000000 	.word	0x20000000
 8008264:	10624dd3 	.word	0x10624dd3

08008268 <SDMMC_GetCmdError>:
  * @brief  Checks for error conditions for CMD0.
  * @param  hsd: SD handle
  * @retval SD Card error state
  */
static uint32_t SDMMC_GetCmdError(SDMMC_TypeDef *SDMMCx)
{
 8008268:	b480      	push	{r7}
 800826a:	b085      	sub	sp, #20
 800826c:	af00      	add	r7, sp, #0
 800826e:	6078      	str	r0, [r7, #4]
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U / 1000U);
 8008270:	4b11      	ldr	r3, [pc, #68]	@ (80082b8 <SDMMC_GetCmdError+0x50>)
 8008272:	681b      	ldr	r3, [r3, #0]
 8008274:	4a11      	ldr	r2, [pc, #68]	@ (80082bc <SDMMC_GetCmdError+0x54>)
 8008276:	fba2 2303 	umull	r2, r3, r2, r3
 800827a:	0a5b      	lsrs	r3, r3, #9
 800827c:	f241 3288 	movw	r2, #5000	@ 0x1388
 8008280:	fb02 f303 	mul.w	r3, r2, r3
 8008284:	60fb      	str	r3, [r7, #12]

  do
  {
    if (count-- == 0U)
 8008286:	68fb      	ldr	r3, [r7, #12]
 8008288:	1e5a      	subs	r2, r3, #1
 800828a:	60fa      	str	r2, [r7, #12]
 800828c:	2b00      	cmp	r3, #0
 800828e:	d102      	bne.n	8008296 <SDMMC_GetCmdError+0x2e>
    {
      return SDMMC_ERROR_TIMEOUT;
 8008290:	f04f 4300 	mov.w	r3, #2147483648	@ 0x80000000
 8008294:	e009      	b.n	80082aa <SDMMC_GetCmdError+0x42>
    }

  } while (!__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CMDSENT));
 8008296:	687b      	ldr	r3, [r7, #4]
 8008298:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800829a:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 800829e:	2b00      	cmp	r3, #0
 80082a0:	d0f1      	beq.n	8008286 <SDMMC_GetCmdError+0x1e>

  /* Clear all the static flags */
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 80082a2:	687b      	ldr	r3, [r7, #4]
 80082a4:	4a06      	ldr	r2, [pc, #24]	@ (80082c0 <SDMMC_GetCmdError+0x58>)
 80082a6:	639a      	str	r2, [r3, #56]	@ 0x38

  return SDMMC_ERROR_NONE;
 80082a8:	2300      	movs	r3, #0
}
 80082aa:	4618      	mov	r0, r3
 80082ac:	3714      	adds	r7, #20
 80082ae:	46bd      	mov	sp, r7
 80082b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80082b4:	4770      	bx	lr
 80082b6:	bf00      	nop
 80082b8:	20000000 	.word	0x20000000
 80082bc:	10624dd3 	.word	0x10624dd3
 80082c0:	002000c5 	.word	0x002000c5

080082c4 <MX_FileX_Init>:
  * @brief  Application FileX Initialization.
  * @param  None
  * @retval int
  */
UINT MX_FileX_Init(void)
{
 80082c4:	b580      	push	{r7, lr}
 80082c6:	b086      	sub	sp, #24
 80082c8:	af04      	add	r7, sp, #16
  UINT ret = FX_SUCCESS;
 80082ca:	2300      	movs	r3, #0
 80082cc:	607b      	str	r3, [r7, #4]
  /* USER CODE BEGIN MX_FileX_Init */
  UINT status;
  /* USER CODE END MX_FileX_Init */

  /* Initialize FileX.  */
  fx_system_initialize();
 80082ce:	f006 fa97 	bl	800e800 <_fx_system_initialize>

  /* USER CODE BEGIN MX_FileX_Init 1*/
  /* Start application */
  /* Open the sdio_disk driver. */
  status =  fx_media_open(&sdio_disk, "STM32_SDIO_DISK", fx_stm32_sd_driver, 0, (VOID *) media_memory, sizeof(media_memory));
 80082d2:	f242 4388 	movw	r3, #9352	@ 0x2488
 80082d6:	9302      	str	r3, [sp, #8]
 80082d8:	f44f 7300 	mov.w	r3, #512	@ 0x200
 80082dc:	9301      	str	r3, [sp, #4]
 80082de:	4b09      	ldr	r3, [pc, #36]	@ (8008304 <MX_FileX_Init+0x40>)
 80082e0:	9300      	str	r3, [sp, #0]
 80082e2:	2300      	movs	r3, #0
 80082e4:	4a08      	ldr	r2, [pc, #32]	@ (8008308 <MX_FileX_Init+0x44>)
 80082e6:	4909      	ldr	r1, [pc, #36]	@ (800830c <MX_FileX_Init+0x48>)
 80082e8:	4809      	ldr	r0, [pc, #36]	@ (8008310 <MX_FileX_Init+0x4c>)
 80082ea:	f008 fc51 	bl	8010b90 <_fxe_media_open>
 80082ee:	6038      	str	r0, [r7, #0]

  /* Check the media open status. */
  if (status != FX_SUCCESS)
 80082f0:	683b      	ldr	r3, [r7, #0]
 80082f2:	2b00      	cmp	r3, #0
 80082f4:	d001      	beq.n	80082fa <MX_FileX_Init+0x36>
  {
    Error_Handler();
 80082f6:	f7f8 fa61 	bl	80007bc <Error_Handler>
  }
  /* USER CODE END MX_FileX_Init 1*/

  return ret;
 80082fa:	687b      	ldr	r3, [r7, #4]
}
 80082fc:	4618      	mov	r0, r3
 80082fe:	3708      	adds	r7, #8
 8008300:	46bd      	mov	sp, r7
 8008302:	bd80      	pop	{r7, pc}
 8008304:	20002880 	.word	0x20002880
 8008308:	080085a1 	.word	0x080085a1
 800830c:	080115ec 	.word	0x080115ec
 8008310:	20000218 	.word	0x20000218

08008314 <MX_FileX_Process>:

/* USER CODE BEGIN 1 */
VOID MX_FileX_Process(void)
{
 8008314:	b5b0      	push	{r4, r5, r7, lr}
 8008316:	b094      	sub	sp, #80	@ 0x50
 8008318:	af02      	add	r7, sp, #8
  UINT status;
  ULONG bytes_read;
  CHAR read_buffer[32];
  CHAR data[] = "This is FileX working on STM32";
 800831a:	4b4f      	ldr	r3, [pc, #316]	@ (8008458 <MX_FileX_Process+0x144>)
 800831c:	463c      	mov	r4, r7
 800831e:	461d      	mov	r5, r3
 8008320:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8008322:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8008324:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 8008328:	c407      	stmia	r4!, {r0, r1, r2}
 800832a:	8023      	strh	r3, [r4, #0]
 800832c:	3402      	adds	r4, #2
 800832e:	0c1b      	lsrs	r3, r3, #16
 8008330:	7023      	strb	r3, [r4, #0]

  /* Start application */
  printf("FileX SD Standalone Application Start.\n");
 8008332:	484a      	ldr	r0, [pc, #296]	@ (800845c <MX_FileX_Process+0x148>)
 8008334:	f008 fdae 	bl	8010e94 <puts>

  /* Create a file called STM32.TXT in the root directory.  */
  status =  fx_file_create(&sdio_disk, "STM32.TXT");
 8008338:	4949      	ldr	r1, [pc, #292]	@ (8008460 <MX_FileX_Process+0x14c>)
 800833a:	484a      	ldr	r0, [pc, #296]	@ (8008464 <MX_FileX_Process+0x150>)
 800833c:	f008 fb5b 	bl	80109f6 <_fxe_file_create>
 8008340:	6478      	str	r0, [r7, #68]	@ 0x44

  /* Check the create status.  */
  if (status != FX_SUCCESS)
 8008342:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8008344:	2b00      	cmp	r3, #0
 8008346:	d004      	beq.n	8008352 <MX_FileX_Process+0x3e>
  {
    /* Check for an already created status. This is expected on the
    second pass of this loop!  */
    if (status != FX_ALREADY_CREATED)
 8008348:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800834a:	2b0b      	cmp	r3, #11
 800834c:	d001      	beq.n	8008352 <MX_FileX_Process+0x3e>
    {
      /* Create error, call error handler.  */
      Error_Handler();
 800834e:	f7f8 fa35 	bl	80007bc <Error_Handler>
    }
  }

  /* Open the test file.  */
  status =  fx_file_open(&sdio_disk, &fx_file, "STM32.TXT", FX_OPEN_FOR_WRITE);
 8008352:	f44f 73f0 	mov.w	r3, #480	@ 0x1e0
 8008356:	9300      	str	r3, [sp, #0]
 8008358:	2301      	movs	r3, #1
 800835a:	4a41      	ldr	r2, [pc, #260]	@ (8008460 <MX_FileX_Process+0x14c>)
 800835c:	4942      	ldr	r1, [pc, #264]	@ (8008468 <MX_FileX_Process+0x154>)
 800835e:	4841      	ldr	r0, [pc, #260]	@ (8008464 <MX_FileX_Process+0x150>)
 8008360:	f008 fb5e 	bl	8010a20 <_fxe_file_open>
 8008364:	6478      	str	r0, [r7, #68]	@ 0x44

  /* Check the file open status.  */
  if (status != FX_SUCCESS)
 8008366:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8008368:	2b00      	cmp	r3, #0
 800836a:	d001      	beq.n	8008370 <MX_FileX_Process+0x5c>
  {
    /* Error opening file, call error handler.  */
    Error_Handler();
 800836c:	f7f8 fa26 	bl	80007bc <Error_Handler>
  }

  /* Seek to the beginning of the test file.  */
  status =  fx_file_seek(&fx_file, 0);
 8008370:	2100      	movs	r1, #0
 8008372:	483d      	ldr	r0, [pc, #244]	@ (8008468 <MX_FileX_Process+0x154>)
 8008374:	f008 fbba 	bl	8010aec <_fxe_file_seek>
 8008378:	6478      	str	r0, [r7, #68]	@ 0x44

  /* Check the file seek status.  */
  if (status != FX_SUCCESS)
 800837a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800837c:	2b00      	cmp	r3, #0
 800837e:	d001      	beq.n	8008384 <MX_FileX_Process+0x70>
  {
    /* Error performing file seek, call error handler.  */
    Error_Handler();
 8008380:	f7f8 fa1c 	bl	80007bc <Error_Handler>
  }

  /* Write data into the file */
  printf("Writing data into the file. \n");
 8008384:	4839      	ldr	r0, [pc, #228]	@ (800846c <MX_FileX_Process+0x158>)
 8008386:	f008 fd85 	bl	8010e94 <puts>

  /* Write a string to the test file.  */
  status =  fx_file_write(&fx_file, data, sizeof(data));
 800838a:	463b      	mov	r3, r7
 800838c:	221f      	movs	r2, #31
 800838e:	4619      	mov	r1, r3
 8008390:	4835      	ldr	r0, [pc, #212]	@ (8008468 <MX_FileX_Process+0x154>)
 8008392:	f008 fbbf 	bl	8010b14 <_fxe_file_write>
 8008396:	6478      	str	r0, [r7, #68]	@ 0x44

  /* Check the file write status.  */
  if (status != FX_SUCCESS)
 8008398:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800839a:	2b00      	cmp	r3, #0
 800839c:	d001      	beq.n	80083a2 <MX_FileX_Process+0x8e>
  {
    /* Error writing to a file, call error handler.  */
    Error_Handler();
 800839e:	f7f8 fa0d 	bl	80007bc <Error_Handler>
  }

  /* Close the test file.  */
  status =  fx_file_close(&fx_file);
 80083a2:	4831      	ldr	r0, [pc, #196]	@ (8008468 <MX_FileX_Process+0x154>)
 80083a4:	f008 fb15 	bl	80109d2 <_fxe_file_close>
 80083a8:	6478      	str	r0, [r7, #68]	@ 0x44

  /* Check the file close status.  */
  if (status != FX_SUCCESS)
 80083aa:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80083ac:	2b00      	cmp	r3, #0
 80083ae:	d001      	beq.n	80083b4 <MX_FileX_Process+0xa0>
  {
    /* Error closing the file, call error handler.  */
    Error_Handler();
 80083b0:	f7f8 fa04 	bl	80007bc <Error_Handler>
  }

  status = fx_media_flush(&sdio_disk);
 80083b4:	482b      	ldr	r0, [pc, #172]	@ (8008464 <MX_FileX_Process+0x150>)
 80083b6:	f008 fbd8 	bl	8010b6a <_fxe_media_flush>
 80083ba:	6478      	str	r0, [r7, #68]	@ 0x44

  /* Check the media flush  status.  */
  if (status != FX_SUCCESS)
 80083bc:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80083be:	2b00      	cmp	r3, #0
 80083c0:	d001      	beq.n	80083c6 <MX_FileX_Process+0xb2>
  {
    /* Error closing the file, call error handler.  */
    Error_Handler();
 80083c2:	f7f8 f9fb 	bl	80007bc <Error_Handler>
  }

  /* Open the test file.  */
  status =  fx_file_open(&sdio_disk, &fx_file, "STM32.TXT", FX_OPEN_FOR_READ);
 80083c6:	f44f 73f0 	mov.w	r3, #480	@ 0x1e0
 80083ca:	9300      	str	r3, [sp, #0]
 80083cc:	2300      	movs	r3, #0
 80083ce:	4a24      	ldr	r2, [pc, #144]	@ (8008460 <MX_FileX_Process+0x14c>)
 80083d0:	4925      	ldr	r1, [pc, #148]	@ (8008468 <MX_FileX_Process+0x154>)
 80083d2:	4824      	ldr	r0, [pc, #144]	@ (8008464 <MX_FileX_Process+0x150>)
 80083d4:	f008 fb24 	bl	8010a20 <_fxe_file_open>
 80083d8:	6478      	str	r0, [r7, #68]	@ 0x44

  /* Check the file open status.  */
  if (status != FX_SUCCESS)
 80083da:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80083dc:	2b00      	cmp	r3, #0
 80083de:	d001      	beq.n	80083e4 <MX_FileX_Process+0xd0>
  {
    /* Error opening file, call error handler.  */
    Error_Handler();
 80083e0:	f7f8 f9ec 	bl	80007bc <Error_Handler>
  }

  /* Seek to the beginning of the test file.  */
  status =  fx_file_seek(&fx_file, 0);
 80083e4:	2100      	movs	r1, #0
 80083e6:	4820      	ldr	r0, [pc, #128]	@ (8008468 <MX_FileX_Process+0x154>)
 80083e8:	f008 fb80 	bl	8010aec <_fxe_file_seek>
 80083ec:	6478      	str	r0, [r7, #68]	@ 0x44

  /* Check the file seek status.  */
  if (status != FX_SUCCESS)
 80083ee:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80083f0:	2b00      	cmp	r3, #0
 80083f2:	d001      	beq.n	80083f8 <MX_FileX_Process+0xe4>
  {
    /* Error performing file seek, call error handler.  */
    Error_Handler();
 80083f4:	f7f8 f9e2 	bl	80007bc <Error_Handler>
  }

  /* Read the first 28 bytes of the test file.  */
  status =  fx_file_read(&fx_file, read_buffer, sizeof(data), &bytes_read);
 80083f8:	f107 0340 	add.w	r3, r7, #64	@ 0x40
 80083fc:	f107 0120 	add.w	r1, r7, #32
 8008400:	221f      	movs	r2, #31
 8008402:	4819      	ldr	r0, [pc, #100]	@ (8008468 <MX_FileX_Process+0x154>)
 8008404:	f008 fb54 	bl	8010ab0 <_fxe_file_read>
 8008408:	6478      	str	r0, [r7, #68]	@ 0x44

  /* Check the file read status.  */
  if ((status != FX_SUCCESS) || (bytes_read != sizeof(data)))
 800840a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800840c:	2b00      	cmp	r3, #0
 800840e:	d102      	bne.n	8008416 <MX_FileX_Process+0x102>
 8008410:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8008412:	2b1f      	cmp	r3, #31
 8008414:	d001      	beq.n	800841a <MX_FileX_Process+0x106>
  {
    /* Error reading file, call error handler.  */
    Error_Handler();
 8008416:	f7f8 f9d1 	bl	80007bc <Error_Handler>
  }

  /* Close the test file.  */
  status =  fx_file_close(&fx_file);
 800841a:	4813      	ldr	r0, [pc, #76]	@ (8008468 <MX_FileX_Process+0x154>)
 800841c:	f008 fad9 	bl	80109d2 <_fxe_file_close>
 8008420:	6478      	str	r0, [r7, #68]	@ 0x44

  /* Check the file close status. */
  if (status != FX_SUCCESS)
 8008422:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8008424:	2b00      	cmp	r3, #0
 8008426:	d001      	beq.n	800842c <MX_FileX_Process+0x118>
  {
    /* Error closing the file, call error handler. */
    Error_Handler();
 8008428:	f7f8 f9c8 	bl	80007bc <Error_Handler>
  }

  /* Close the media.  */
  status =  fx_media_close(&sdio_disk);
 800842c:	480d      	ldr	r0, [pc, #52]	@ (8008464 <MX_FileX_Process+0x150>)
 800842e:	f008 fb8a 	bl	8010b46 <_fxe_media_close>
 8008432:	6478      	str	r0, [r7, #68]	@ 0x44

  /* Check the media close status.  */
  if (status != FX_SUCCESS)
 8008434:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8008436:	2b00      	cmp	r3, #0
 8008438:	d001      	beq.n	800843e <MX_FileX_Process+0x12a>
  {
    /* Error closing the media, call error handler.  */
    Error_Handler();
 800843a:	f7f8 f9bf 	bl	80007bc <Error_Handler>
  }

  /* Data successfully written */
  printf("Data successfully written.\n");
 800843e:	480c      	ldr	r0, [pc, #48]	@ (8008470 <MX_FileX_Process+0x15c>)
 8008440:	f008 fd28 	bl	8010e94 <puts>

  /* Infinite loop */
  while (1)
  {
    HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5);
 8008444:	2120      	movs	r1, #32
 8008446:	480b      	ldr	r0, [pc, #44]	@ (8008474 <MX_FileX_Process+0x160>)
 8008448:	f7f9 f934 	bl	80016b4 <HAL_GPIO_TogglePin>
    HAL_Delay(500);
 800844c:	f44f 70fa 	mov.w	r0, #500	@ 0x1f4
 8008450:	f7f8 fda0 	bl	8000f94 <HAL_Delay>
    HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5);
 8008454:	bf00      	nop
 8008456:	e7f5      	b.n	8008444 <MX_FileX_Process+0x130>
 8008458:	0801166c 	.word	0x0801166c
 800845c:	080115fc 	.word	0x080115fc
 8008460:	08011624 	.word	0x08011624
 8008464:	20000218 	.word	0x20000218
 8008468:	200026a0 	.word	0x200026a0
 800846c:	08011630 	.word	0x08011630
 8008470:	08011650 	.word	0x08011650
 8008474:	42020000 	.word	0x42020000

08008478 <fx_stm32_sd_get_status>:
* @brief Check the SD IP status.
* @param UINT instance SD instance to check
* @retval 0 when ready 1 when busy
*/
INT fx_stm32_sd_get_status(UINT instance)
{
 8008478:	b580      	push	{r7, lr}
 800847a:	b084      	sub	sp, #16
 800847c:	af00      	add	r7, sp, #0
 800847e:	6078      	str	r0, [r7, #4]
  INT ret = 0;
 8008480:	2300      	movs	r3, #0
 8008482:	60fb      	str	r3, [r7, #12]

  /* USER CODE BEGIN PRE_GET_STATUS */
  UNUSED(instance);
  /* USER CODE END PRE_GET_STATUS */

  if(HAL_SD_GetCardState(&hsd1) != HAL_SD_CARD_TRANSFER)
 8008484:	4806      	ldr	r0, [pc, #24]	@ (80084a0 <fx_stm32_sd_get_status+0x28>)
 8008486:	f7fe f835 	bl	80064f4 <HAL_SD_GetCardState>
 800848a:	4603      	mov	r3, r0
 800848c:	2b04      	cmp	r3, #4
 800848e:	d001      	beq.n	8008494 <fx_stm32_sd_get_status+0x1c>
  {
    ret = 1;
 8008490:	2301      	movs	r3, #1
 8008492:	60fb      	str	r3, [r7, #12]

  /* USER CODE BEGIN POST_GET_STATUS */

  /* USER CODE END POST_GET_STATUS */

  return ret;
 8008494:	68fb      	ldr	r3, [r7, #12]
}
 8008496:	4618      	mov	r0, r3
 8008498:	3710      	adds	r7, #16
 800849a:	46bd      	mov	sp, r7
 800849c:	bd80      	pop	{r7, pc}
 800849e:	bf00      	nop
 80084a0:	200000fc 	.word	0x200000fc

080084a4 <fx_stm32_sd_read_blocks>:
* @param UINT start_block the first block to start reading from.
* @param UINT total_blocks total number of blocks to read.
* @retval 0 on success error code otherwise
*/
INT fx_stm32_sd_read_blocks(UINT instance, UINT *buffer, UINT start_block, UINT total_blocks)
{
 80084a4:	b580      	push	{r7, lr}
 80084a6:	b086      	sub	sp, #24
 80084a8:	af00      	add	r7, sp, #0
 80084aa:	60f8      	str	r0, [r7, #12]
 80084ac:	60b9      	str	r1, [r7, #8]
 80084ae:	607a      	str	r2, [r7, #4]
 80084b0:	603b      	str	r3, [r7, #0]
  INT ret = 0;
 80084b2:	2300      	movs	r3, #0
 80084b4:	617b      	str	r3, [r7, #20]

  /* USER CODE BEGIN PRE_READ_BLOCKS */
  /* USER CODE END PRE_READ_BLOCKS */

  sd_rx_cplt = 0;
 80084b6:	4b09      	ldr	r3, [pc, #36]	@ (80084dc <fx_stm32_sd_read_blocks+0x38>)
 80084b8:	2200      	movs	r2, #0
 80084ba:	601a      	str	r2, [r3, #0]

  if(HAL_SD_ReadBlocks_DMA(&hsd1, (uint8_t *)buffer, start_block, total_blocks) != HAL_OK)
 80084bc:	683b      	ldr	r3, [r7, #0]
 80084be:	687a      	ldr	r2, [r7, #4]
 80084c0:	68b9      	ldr	r1, [r7, #8]
 80084c2:	4807      	ldr	r0, [pc, #28]	@ (80084e0 <fx_stm32_sd_read_blocks+0x3c>)
 80084c4:	f7fd f9a6 	bl	8005814 <HAL_SD_ReadBlocks_DMA>
 80084c8:	4603      	mov	r3, r0
 80084ca:	2b00      	cmp	r3, #0
 80084cc:	d001      	beq.n	80084d2 <fx_stm32_sd_read_blocks+0x2e>
  {
    ret = 1;
 80084ce:	2301      	movs	r3, #1
 80084d0:	617b      	str	r3, [r7, #20]

  /* USER CODE BEGIN POST_READ_BLOCKS */

  /* USER CODE END POST_READ_BLOCKS */

  return ret;
 80084d2:	697b      	ldr	r3, [r7, #20]
}
 80084d4:	4618      	mov	r0, r3
 80084d6:	3718      	adds	r7, #24
 80084d8:	46bd      	mov	sp, r7
 80084da:	bd80      	pop	{r7, pc}
 80084dc:	20002a80 	.word	0x20002a80
 80084e0:	200000fc 	.word	0x200000fc

080084e4 <fx_stm32_sd_write_blocks>:
* @param UINT start_block the first block to start writing into.
* @param UINT total_blocks total number of blocks to write.
* @retval 0 on success error code otherwise
*/
INT fx_stm32_sd_write_blocks(UINT instance, UINT *buffer, UINT start_block, UINT total_blocks)
{
 80084e4:	b580      	push	{r7, lr}
 80084e6:	b086      	sub	sp, #24
 80084e8:	af00      	add	r7, sp, #0
 80084ea:	60f8      	str	r0, [r7, #12]
 80084ec:	60b9      	str	r1, [r7, #8]
 80084ee:	607a      	str	r2, [r7, #4]
 80084f0:	603b      	str	r3, [r7, #0]
  INT ret = 0;
 80084f2:	2300      	movs	r3, #0
 80084f4:	617b      	str	r3, [r7, #20]

  /* USER CODE BEGIN PRE_WRITE_BLOCKS */
  /* USER CODE END PRE_WRITE_BLOCKS */

  sd_tx_cplt = 0;
 80084f6:	4b09      	ldr	r3, [pc, #36]	@ (800851c <fx_stm32_sd_write_blocks+0x38>)
 80084f8:	2200      	movs	r2, #0
 80084fa:	601a      	str	r2, [r3, #0]

  if(HAL_SD_WriteBlocks_DMA(&hsd1, (uint8_t *)buffer, start_block, total_blocks) != HAL_OK)
 80084fc:	683b      	ldr	r3, [r7, #0]
 80084fe:	687a      	ldr	r2, [r7, #4]
 8008500:	68b9      	ldr	r1, [r7, #8]
 8008502:	4807      	ldr	r0, [pc, #28]	@ (8008520 <fx_stm32_sd_write_blocks+0x3c>)
 8008504:	f7fd fa2e 	bl	8005964 <HAL_SD_WriteBlocks_DMA>
 8008508:	4603      	mov	r3, r0
 800850a:	2b00      	cmp	r3, #0
 800850c:	d001      	beq.n	8008512 <fx_stm32_sd_write_blocks+0x2e>
  {
    ret = 1;
 800850e:	2301      	movs	r3, #1
 8008510:	617b      	str	r3, [r7, #20]

  /* USER CODE BEGIN POST_WRITE_BLOCKS */

  /* USER CODE END POST_WRITE_BLOCKS */

  return ret;
 8008512:	697b      	ldr	r3, [r7, #20]
}
 8008514:	4618      	mov	r0, r3
 8008516:	3718      	adds	r7, #24
 8008518:	46bd      	mov	sp, r7
 800851a:	bd80      	pop	{r7, pc}
 800851c:	20002a84 	.word	0x20002a84
 8008520:	200000fc 	.word	0x200000fc

08008524 <HAL_SD_TxCpltCallback>:
* @brief SD DMA Tx Transfer completed callbacks
* @param SD_HandleTypeDef *hsd the SD_HandleTypeDef handle
* @retval None
*/
void HAL_SD_TxCpltCallback(SD_HandleTypeDef *hsd)
{
 8008524:	b480      	push	{r7}
 8008526:	b083      	sub	sp, #12
 8008528:	af00      	add	r7, sp, #0
 800852a:	6078      	str	r0, [r7, #4]
/* USER CODE BEGIN TX_COMPLETED_0 */

/* USER CODE END TX_COMPLETED_0 */

  sd_tx_cplt = 1;
 800852c:	4b04      	ldr	r3, [pc, #16]	@ (8008540 <HAL_SD_TxCpltCallback+0x1c>)
 800852e:	2201      	movs	r2, #1
 8008530:	601a      	str	r2, [r3, #0]

/* USER CODE BEGIN TX_COMPLETED_1 */

/* USER CODE END TX_COMPLETED_1 */

}
 8008532:	bf00      	nop
 8008534:	370c      	adds	r7, #12
 8008536:	46bd      	mov	sp, r7
 8008538:	f85d 7b04 	ldr.w	r7, [sp], #4
 800853c:	4770      	bx	lr
 800853e:	bf00      	nop
 8008540:	20002a84 	.word	0x20002a84

08008544 <HAL_SD_RxCpltCallback>:
* @brief SD DMA Rx Transfer completed callbacks
* @param SD_HandleTypeDef *hsd the SD_HandleTypeDef handle
* @retval None
*/
void HAL_SD_RxCpltCallback(SD_HandleTypeDef *hsd)
{
 8008544:	b480      	push	{r7}
 8008546:	b083      	sub	sp, #12
 8008548:	af00      	add	r7, sp, #0
 800854a:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN RX_COMPLETED_0 */

/* USER CODE END RX_COMPLETED_0 */
  sd_rx_cplt = 1;
 800854c:	4b04      	ldr	r3, [pc, #16]	@ (8008560 <HAL_SD_RxCpltCallback+0x1c>)
 800854e:	2201      	movs	r2, #1
 8008550:	601a      	str	r2, [r3, #0]

/* USER CODE BEGIN RX_COMPLETED_1 */

/* USER CODE END RX_COMPLETED_1 */

}
 8008552:	bf00      	nop
 8008554:	370c      	adds	r7, #12
 8008556:	46bd      	mov	sp, r7
 8008558:	f85d 7b04 	ldr.w	r7, [sp], #4
 800855c:	4770      	bx	lr
 800855e:	bf00      	nop
 8008560:	20002a80 	.word	0x20002a80

08008564 <check_sd_status>:

static UINT is_initialized = 0;


static INT check_sd_status(uint32_t instance)
{
 8008564:	b580      	push	{r7, lr}
 8008566:	b084      	sub	sp, #16
 8008568:	af00      	add	r7, sp, #0
 800856a:	6078      	str	r0, [r7, #4]
  uint32_t start = FX_STM32_SD_CURRENT_TIME();
 800856c:	f7f8 fd06 	bl	8000f7c <HAL_GetTick>
 8008570:	60f8      	str	r0, [r7, #12]

  while (FX_STM32_SD_CURRENT_TIME() - start < FX_STM32_SD_DEFAULT_TIMEOUT)
 8008572:	e007      	b.n	8008584 <check_sd_status+0x20>
  {
    if (fx_stm32_sd_get_status(instance) == 0)
 8008574:	6878      	ldr	r0, [r7, #4]
 8008576:	f7ff ff7f 	bl	8008478 <fx_stm32_sd_get_status>
 800857a:	4603      	mov	r3, r0
 800857c:	2b00      	cmp	r3, #0
 800857e:	d101      	bne.n	8008584 <check_sd_status+0x20>
    {
      return 0;
 8008580:	2300      	movs	r3, #0
 8008582:	e009      	b.n	8008598 <check_sd_status+0x34>
  while (FX_STM32_SD_CURRENT_TIME() - start < FX_STM32_SD_DEFAULT_TIMEOUT)
 8008584:	f7f8 fcfa 	bl	8000f7c <HAL_GetTick>
 8008588:	4602      	mov	r2, r0
 800858a:	68fb      	ldr	r3, [r7, #12]
 800858c:	1ad3      	subs	r3, r2, r3
 800858e:	f242 720f 	movw	r2, #9999	@ 0x270f
 8008592:	4293      	cmp	r3, r2
 8008594:	d9ee      	bls.n	8008574 <check_sd_status+0x10>
    }
  }

  return 1;
 8008596:	2301      	movs	r3, #1
}
 8008598:	4618      	mov	r0, r3
 800859a:	3710      	adds	r7, #16
 800859c:	46bd      	mov	sp, r7
 800859e:	bd80      	pop	{r7, pc}

080085a0 <fx_stm32_sd_driver>:
* It relies on the STM32 peripheral library from ST.
* @param media_ptr: FileX's Media Config Block
* @retval None
*/
VOID  fx_stm32_sd_driver(FX_MEDIA *media_ptr)
{
 80085a0:	b580      	push	{r7, lr}
 80085a2:	b086      	sub	sp, #24
 80085a4:	af00      	add	r7, sp, #0
 80085a6:	6078      	str	r0, [r7, #4]
  ULONG partition_start;
  ULONG partition_size;

#if (FX_STM32_SD_INIT == 0)
 /* the SD was initialized by the application */
  is_initialized = 1;
 80085a8:	4b6e      	ldr	r3, [pc, #440]	@ (8008764 <fx_stm32_sd_driver+0x1c4>)
 80085aa:	2201      	movs	r2, #1
 80085ac:	601a      	str	r2, [r3, #0]
#endif
  /* before performing any operation, check the status of the SD IP */
  if (is_initialized == 1)
 80085ae:	4b6d      	ldr	r3, [pc, #436]	@ (8008764 <fx_stm32_sd_driver+0x1c4>)
 80085b0:	681b      	ldr	r3, [r3, #0]
 80085b2:	2b01      	cmp	r3, #1
 80085b4:	d10a      	bne.n	80085cc <fx_stm32_sd_driver+0x2c>
  {
    if (check_sd_status(FX_STM32_SD_INSTANCE) != 0)
 80085b6:	2000      	movs	r0, #0
 80085b8:	f7ff ffd4 	bl	8008564 <check_sd_status>
 80085bc:	4603      	mov	r3, r0
 80085be:	2b00      	cmp	r3, #0
 80085c0:	d004      	beq.n	80085cc <fx_stm32_sd_driver+0x2c>
    {
      media_ptr->fx_media_driver_status =  FX_IO_ERROR;
 80085c2:	687b      	ldr	r3, [r7, #4]
 80085c4:	2290      	movs	r2, #144	@ 0x90
 80085c6:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
 80085ca:	e0c8      	b.n	800875e <fx_stm32_sd_driver+0x1be>
    }
  }

#if (FX_STM32_SD_DMA_API == 1)
  /* the SD DMA requires a 4-byte aligned buffers */
  unaligned_buffer = (UINT)(media_ptr->fx_media_driver_buffer) & 0x3;
 80085cc:	687b      	ldr	r3, [r7, #4]
 80085ce:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 80085d2:	f003 0303 	and.w	r3, r3, #3
 80085d6:	617b      	str	r3, [r7, #20]
#else
  /* if the DMA is not used there isn't any constraint on buffer alignment */
  unaligned_buffer = 0;
#endif
  /* Process the driver request specified in the media control block.  */
  switch(media_ptr->fx_media_driver_request)
 80085d8:	687b      	ldr	r3, [r7, #4]
 80085da:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 80085de:	2b08      	cmp	r3, #8
 80085e0:	f200 80b5 	bhi.w	800874e <fx_stm32_sd_driver+0x1ae>
 80085e4:	a201      	add	r2, pc, #4	@ (adr r2, 80085ec <fx_stm32_sd_driver+0x4c>)
 80085e6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80085ea:	bf00      	nop
 80085ec:	08008625 	.word	0x08008625
 80085f0:	08008659 	.word	0x08008659
 80085f4:	0800868b 	.word	0x0800868b
 80085f8:	08008695 	.word	0x08008695
 80085fc:	08008611 	.word	0x08008611
 8008600:	0800869f 	.word	0x0800869f
 8008604:	0800874f 	.word	0x0800874f
 8008608:	08008733 	.word	0x08008733
 800860c:	0800861b 	.word	0x0800861b
  {
  case FX_DRIVER_INIT:
    {
      media_ptr->fx_media_driver_status = FX_SUCCESS;
 8008610:	687b      	ldr	r3, [r7, #4]
 8008612:	2200      	movs	r2, #0
 8008614:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
        }
      }
#endif
      /* call post init user macro */
      FX_STM32_SD_POST_INIT(media_ptr);
      break;
 8008618:	e0a1      	b.n	800875e <fx_stm32_sd_driver+0x1be>
    }

  case FX_DRIVER_UNINIT:
    {
      media_ptr->fx_media_driver_status = FX_SUCCESS;
 800861a:	687b      	ldr	r3, [r7, #4]
 800861c:	2200      	movs	r2, #0
 800861e:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
      }
#endif
      /* call post deinit processing  */
      FX_STM32_SD_POST_DEINIT(media_ptr);

      break;
 8008622:	e09c      	b.n	800875e <fx_stm32_sd_driver+0x1be>
    }

  case FX_DRIVER_READ:
    {
      media_ptr->fx_media_driver_status = FX_IO_ERROR;
 8008624:	687b      	ldr	r3, [r7, #4]
 8008626:	2290      	movs	r2, #144	@ 0x90
 8008628:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c

      if (sd_read_data(media_ptr, media_ptr->fx_media_driver_logical_sector + media_ptr->fx_media_hidden_sectors,
 800862c:	687b      	ldr	r3, [r7, #4]
 800862e:	f8d3 2094 	ldr.w	r2, [r3, #148]	@ 0x94
 8008632:	687b      	ldr	r3, [r7, #4]
 8008634:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8008636:	18d1      	adds	r1, r2, r3
                       media_ptr->fx_media_driver_sectors, unaligned_buffer) == FX_SUCCESS)
 8008638:	687b      	ldr	r3, [r7, #4]
 800863a:	f8d3 2098 	ldr.w	r2, [r3, #152]	@ 0x98
      if (sd_read_data(media_ptr, media_ptr->fx_media_driver_logical_sector + media_ptr->fx_media_hidden_sectors,
 800863e:	697b      	ldr	r3, [r7, #20]
 8008640:	6878      	ldr	r0, [r7, #4]
 8008642:	f000 f891 	bl	8008768 <sd_read_data>
 8008646:	4603      	mov	r3, r0
 8008648:	2b00      	cmp	r3, #0
 800864a:	f040 8085 	bne.w	8008758 <fx_stm32_sd_driver+0x1b8>
      {
        media_ptr->fx_media_driver_status = FX_SUCCESS;
 800864e:	687b      	ldr	r3, [r7, #4]
 8008650:	2200      	movs	r2, #0
 8008652:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
      }

      break;
 8008656:	e07f      	b.n	8008758 <fx_stm32_sd_driver+0x1b8>
    }

  case FX_DRIVER_WRITE:
    {
      media_ptr->fx_media_driver_status = FX_IO_ERROR;
 8008658:	687b      	ldr	r3, [r7, #4]
 800865a:	2290      	movs	r2, #144	@ 0x90
 800865c:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c

      if (sd_write_data(media_ptr, media_ptr->fx_media_driver_logical_sector + media_ptr->fx_media_hidden_sectors,
 8008660:	687b      	ldr	r3, [r7, #4]
 8008662:	f8d3 2094 	ldr.w	r2, [r3, #148]	@ 0x94
 8008666:	687b      	ldr	r3, [r7, #4]
 8008668:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 800866a:	18d1      	adds	r1, r2, r3
                        media_ptr->fx_media_driver_sectors, unaligned_buffer) == FX_SUCCESS)
 800866c:	687b      	ldr	r3, [r7, #4]
 800866e:	f8d3 2098 	ldr.w	r2, [r3, #152]	@ 0x98
      if (sd_write_data(media_ptr, media_ptr->fx_media_driver_logical_sector + media_ptr->fx_media_hidden_sectors,
 8008672:	697b      	ldr	r3, [r7, #20]
 8008674:	6878      	ldr	r0, [r7, #4]
 8008676:	f000 f8fd 	bl	8008874 <sd_write_data>
 800867a:	4603      	mov	r3, r0
 800867c:	2b00      	cmp	r3, #0
 800867e:	d16d      	bne.n	800875c <fx_stm32_sd_driver+0x1bc>
      {
        media_ptr->fx_media_driver_status = FX_SUCCESS;
 8008680:	687b      	ldr	r3, [r7, #4]
 8008682:	2200      	movs	r2, #0
 8008684:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
      }

      break;
 8008688:	e068      	b.n	800875c <fx_stm32_sd_driver+0x1bc>
    }

  case FX_DRIVER_FLUSH:
    {
      /* Return driver success.  */
      media_ptr->fx_media_driver_status =  FX_SUCCESS;
 800868a:	687b      	ldr	r3, [r7, #4]
 800868c:	2200      	movs	r2, #0
 800868e:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
      break;
 8008692:	e064      	b.n	800875e <fx_stm32_sd_driver+0x1be>
    }

  case FX_DRIVER_ABORT:
    {
      /* Return driver success.  */
      media_ptr->fx_media_driver_status =  FX_SUCCESS;
 8008694:	687b      	ldr	r3, [r7, #4]
 8008696:	2200      	movs	r2, #0
 8008698:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c

      FX_STM32_SD_POST_ABORT(media_ptr);
      break;
 800869c:	e05f      	b.n	800875e <fx_stm32_sd_driver+0x1be>
    }

  case FX_DRIVER_BOOT_READ:
    {
      /* the boot sector is the sector zero */
      status = sd_read_data(media_ptr, 0, media_ptr->fx_media_driver_sectors, unaligned_buffer);
 800869e:	687b      	ldr	r3, [r7, #4]
 80086a0:	f8d3 2098 	ldr.w	r2, [r3, #152]	@ 0x98
 80086a4:	697b      	ldr	r3, [r7, #20]
 80086a6:	2100      	movs	r1, #0
 80086a8:	6878      	ldr	r0, [r7, #4]
 80086aa:	f000 f85d 	bl	8008768 <sd_read_data>
 80086ae:	6138      	str	r0, [r7, #16]

      if (status != FX_SUCCESS)
 80086b0:	693b      	ldr	r3, [r7, #16]
 80086b2:	2b00      	cmp	r3, #0
 80086b4:	d004      	beq.n	80086c0 <fx_stm32_sd_driver+0x120>
      {
        media_ptr->fx_media_driver_status = status;
 80086b6:	687b      	ldr	r3, [r7, #4]
 80086b8:	693a      	ldr	r2, [r7, #16]
 80086ba:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
        break;
 80086be:	e04e      	b.n	800875e <fx_stm32_sd_driver+0x1be>

      /* Check if the sector 0 is the actual boot sector, otherwise calculate the offset into it.
      Please note that this should belong to higher level of MW to do this check and it is here
      as a temporary work solution */

      partition_start =  0;
 80086c0:	2300      	movs	r3, #0
 80086c2:	60fb      	str	r3, [r7, #12]

      status =  _fx_partition_offset_calculate(media_ptr -> fx_media_driver_buffer, 0,
 80086c4:	687b      	ldr	r3, [r7, #4]
 80086c6:	f8d3 0090 	ldr.w	r0, [r3, #144]	@ 0x90
 80086ca:	f107 0308 	add.w	r3, r7, #8
 80086ce:	f107 020c 	add.w	r2, r7, #12
 80086d2:	2100      	movs	r1, #0
 80086d4:	f005 ff42 	bl	800e55c <_fx_partition_offset_calculate>
 80086d8:	6138      	str	r0, [r7, #16]
                                               &partition_start, &partition_size);

      /* Check partition read error.  */
      if (status)
 80086da:	693b      	ldr	r3, [r7, #16]
 80086dc:	2b00      	cmp	r3, #0
 80086de:	d004      	beq.n	80086ea <fx_stm32_sd_driver+0x14a>
      {
        /* Unsuccessful driver request.  */
        media_ptr -> fx_media_driver_status =  FX_IO_ERROR;
 80086e0:	687b      	ldr	r3, [r7, #4]
 80086e2:	2290      	movs	r2, #144	@ 0x90
 80086e4:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
        break;
 80086e8:	e039      	b.n	800875e <fx_stm32_sd_driver+0x1be>
      }

      /* Now determine if there is a partition...   */
      if (partition_start)
 80086ea:	68fb      	ldr	r3, [r7, #12]
 80086ec:	2b00      	cmp	r3, #0
 80086ee:	d01b      	beq.n	8008728 <fx_stm32_sd_driver+0x188>
      {

        if (check_sd_status(FX_STM32_SD_INSTANCE) != 0)
 80086f0:	2000      	movs	r0, #0
 80086f2:	f7ff ff37 	bl	8008564 <check_sd_status>
 80086f6:	4603      	mov	r3, r0
 80086f8:	2b00      	cmp	r3, #0
 80086fa:	d004      	beq.n	8008706 <fx_stm32_sd_driver+0x166>
        {
          media_ptr->fx_media_driver_status =  FX_IO_ERROR;
 80086fc:	687b      	ldr	r3, [r7, #4]
 80086fe:	2290      	movs	r2, #144	@ 0x90
 8008700:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
          break;
 8008704:	e02b      	b.n	800875e <fx_stm32_sd_driver+0x1be>
        }

        /* Yes, now lets read the actual boot record.  */
        status = sd_read_data(media_ptr, partition_start, media_ptr->fx_media_driver_sectors, unaligned_buffer);
 8008706:	68f9      	ldr	r1, [r7, #12]
 8008708:	687b      	ldr	r3, [r7, #4]
 800870a:	f8d3 2098 	ldr.w	r2, [r3, #152]	@ 0x98
 800870e:	697b      	ldr	r3, [r7, #20]
 8008710:	6878      	ldr	r0, [r7, #4]
 8008712:	f000 f829 	bl	8008768 <sd_read_data>
 8008716:	6138      	str	r0, [r7, #16]

        if (status != FX_SUCCESS)
 8008718:	693b      	ldr	r3, [r7, #16]
 800871a:	2b00      	cmp	r3, #0
 800871c:	d004      	beq.n	8008728 <fx_stm32_sd_driver+0x188>
        {
          media_ptr->fx_media_driver_status = status;
 800871e:	687b      	ldr	r3, [r7, #4]
 8008720:	693a      	ldr	r2, [r7, #16]
 8008722:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
          break;
 8008726:	e01a      	b.n	800875e <fx_stm32_sd_driver+0x1be>
        }
      }

      /* Successful driver request.  */
      media_ptr -> fx_media_driver_status =  FX_SUCCESS;
 8008728:	687b      	ldr	r3, [r7, #4]
 800872a:	2200      	movs	r2, #0
 800872c:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
      break;
 8008730:	e015      	b.n	800875e <fx_stm32_sd_driver+0x1be>
    }

  case FX_DRIVER_BOOT_WRITE:
    {
      status = sd_write_data(media_ptr, 0, media_ptr->fx_media_driver_sectors, unaligned_buffer);
 8008732:	687b      	ldr	r3, [r7, #4]
 8008734:	f8d3 2098 	ldr.w	r2, [r3, #152]	@ 0x98
 8008738:	697b      	ldr	r3, [r7, #20]
 800873a:	2100      	movs	r1, #0
 800873c:	6878      	ldr	r0, [r7, #4]
 800873e:	f000 f899 	bl	8008874 <sd_write_data>
 8008742:	6138      	str	r0, [r7, #16]

      media_ptr->fx_media_driver_status = status;
 8008744:	687b      	ldr	r3, [r7, #4]
 8008746:	693a      	ldr	r2, [r7, #16]
 8008748:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c

      break;
 800874c:	e007      	b.n	800875e <fx_stm32_sd_driver+0x1be>
    }

  default:
    {
      media_ptr->fx_media_driver_status =  FX_IO_ERROR;
 800874e:	687b      	ldr	r3, [r7, #4]
 8008750:	2290      	movs	r2, #144	@ 0x90
 8008752:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
      break;
 8008756:	e002      	b.n	800875e <fx_stm32_sd_driver+0x1be>
      break;
 8008758:	bf00      	nop
 800875a:	e000      	b.n	800875e <fx_stm32_sd_driver+0x1be>
      break;
 800875c:	bf00      	nop
    }
  }
}
 800875e:	3718      	adds	r7, #24
 8008760:	46bd      	mov	sp, r7
 8008762:	bd80      	pop	{r7, pc}
 8008764:	20002c88 	.word	0x20002c88

08008768 <sd_read_data>:
* @param UINT use_scratch_buffer to enable scratch buffer usage or not.
* @retval FX_SUCCESS on success FX_BUFFER_ERROR / FX_ACCESS_ERROR / FX_IO_ERROR otherwise
*/

static UINT sd_read_data(FX_MEDIA *media_ptr, ULONG start_sector, UINT num_sectors, UINT use_scratch_buffer)
{
 8008768:	b580      	push	{r7, lr}
 800876a:	b08a      	sub	sp, #40	@ 0x28
 800876c:	af00      	add	r7, sp, #0
 800876e:	60f8      	str	r0, [r7, #12]
 8008770:	60b9      	str	r1, [r7, #8]
 8008772:	607a      	str	r2, [r7, #4]
 8008774:	603b      	str	r3, [r7, #0]
  INT i = 0;
 8008776:	2300      	movs	r3, #0
 8008778:	627b      	str	r3, [r7, #36]	@ 0x24
  UCHAR *read_addr;

 /* perform the Pre read operations */
  FX_STM32_SD_PRE_READ_TRANSFER(media_ptr);

  if (use_scratch_buffer)
 800877a:	683b      	ldr	r3, [r7, #0]
 800877c:	2b00      	cmp	r3, #0
 800877e:	d047      	beq.n	8008810 <sd_read_data+0xa8>
  {
    read_addr = media_ptr->fx_media_driver_buffer;
 8008780:	68fb      	ldr	r3, [r7, #12]
 8008782:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 8008786:	61fb      	str	r3, [r7, #28]

    for (i = 0; i < num_sectors; i++)
 8008788:	2300      	movs	r3, #0
 800878a:	627b      	str	r3, [r7, #36]	@ 0x24
 800878c:	e032      	b.n	80087f4 <sd_read_data+0x8c>
    {
      /* Start reading into the scratch buffer */
      status = fx_stm32_sd_read_blocks(FX_STM32_SD_INSTANCE, (UINT *)scratch, (UINT)start_sector++, 1);
 800878e:	68ba      	ldr	r2, [r7, #8]
 8008790:	1c53      	adds	r3, r2, #1
 8008792:	60bb      	str	r3, [r7, #8]
 8008794:	2301      	movs	r3, #1
 8008796:	4935      	ldr	r1, [pc, #212]	@ (800886c <sd_read_data+0x104>)
 8008798:	2000      	movs	r0, #0
 800879a:	f7ff fe83 	bl	80084a4 <fx_stm32_sd_read_blocks>
 800879e:	4603      	mov	r3, r0
 80087a0:	623b      	str	r3, [r7, #32]

      if (status != 0)
 80087a2:	6a3b      	ldr	r3, [r7, #32]
 80087a4:	2b00      	cmp	r3, #0
 80087a6:	d001      	beq.n	80087ac <sd_read_data+0x44>
      {
        /* read error occurred, call the error handler code then return immediately */
        FX_STM32_SD_READ_TRANSFER_ERROR(status);
        return FX_IO_ERROR;
 80087a8:	2390      	movs	r3, #144	@ 0x90
 80087aa:	e05a      	b.n	8008862 <sd_read_data+0xfa>
      }

    /* wait for read transfer notification */
       FX_STM32_SD_READ_CPLT_NOTIFY();
 80087ac:	f7f8 fbe6 	bl	8000f7c <HAL_GetTick>
 80087b0:	6178      	str	r0, [r7, #20]
 80087b2:	e003      	b.n	80087bc <sd_read_data+0x54>
 80087b4:	4b2e      	ldr	r3, [pc, #184]	@ (8008870 <sd_read_data+0x108>)
 80087b6:	681b      	ldr	r3, [r3, #0]
 80087b8:	2b01      	cmp	r3, #1
 80087ba:	d008      	beq.n	80087ce <sd_read_data+0x66>
 80087bc:	f7f8 fbde 	bl	8000f7c <HAL_GetTick>
 80087c0:	4602      	mov	r2, r0
 80087c2:	697b      	ldr	r3, [r7, #20]
 80087c4:	1ad3      	subs	r3, r2, r3
 80087c6:	f242 720f 	movw	r2, #9999	@ 0x270f
 80087ca:	4293      	cmp	r3, r2
 80087cc:	d9f2      	bls.n	80087b4 <sd_read_data+0x4c>
 80087ce:	4b28      	ldr	r3, [pc, #160]	@ (8008870 <sd_read_data+0x108>)
 80087d0:	681b      	ldr	r3, [r3, #0]
 80087d2:	2b00      	cmp	r3, #0
 80087d4:	d101      	bne.n	80087da <sd_read_data+0x72>
 80087d6:	2390      	movs	r3, #144	@ 0x90
 80087d8:	e043      	b.n	8008862 <sd_read_data+0xfa>

#if (FX_STM32_SD_CACHE_MAINTENANCE == 1)
      invalidate_cache_by_addr((uint32_t*)scratch, FX_STM32_SD_DEFAULT_SECTOR_SIZE);
#endif

      _fx_utility_memory_copy(scratch, read_addr, FX_STM32_SD_DEFAULT_SECTOR_SIZE);
 80087da:	f44f 7200 	mov.w	r2, #512	@ 0x200
 80087de:	69f9      	ldr	r1, [r7, #28]
 80087e0:	4822      	ldr	r0, [pc, #136]	@ (800886c <sd_read_data+0x104>)
 80087e2:	f008 f8e7 	bl	80109b4 <_fx_utility_memory_copy>
      read_addr += FX_STM32_SD_DEFAULT_SECTOR_SIZE;
 80087e6:	69fb      	ldr	r3, [r7, #28]
 80087e8:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80087ec:	61fb      	str	r3, [r7, #28]
    for (i = 0; i < num_sectors; i++)
 80087ee:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80087f0:	3301      	adds	r3, #1
 80087f2:	627b      	str	r3, [r7, #36]	@ 0x24
 80087f4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80087f6:	687a      	ldr	r2, [r7, #4]
 80087f8:	429a      	cmp	r2, r3
 80087fa:	d8c8      	bhi.n	800878e <sd_read_data+0x26>
    }

    /* Check if all sectors were read */
    if (i == num_sectors)
 80087fc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80087fe:	687a      	ldr	r2, [r7, #4]
 8008800:	429a      	cmp	r2, r3
 8008802:	d102      	bne.n	800880a <sd_read_data+0xa2>
    {
      status = FX_SUCCESS;
 8008804:	2300      	movs	r3, #0
 8008806:	623b      	str	r3, [r7, #32]
 8008808:	e02a      	b.n	8008860 <sd_read_data+0xf8>
    }
    else
    {
      status = FX_BUFFER_ERROR;
 800880a:	2321      	movs	r3, #33	@ 0x21
 800880c:	623b      	str	r3, [r7, #32]
 800880e:	e027      	b.n	8008860 <sd_read_data+0xf8>
    }
  }
  else
  {

    status = fx_stm32_sd_read_blocks(FX_STM32_SD_INSTANCE, (UINT *)media_ptr->fx_media_driver_buffer, (UINT)start_sector, num_sectors);
 8008810:	68fb      	ldr	r3, [r7, #12]
 8008812:	f8d3 1090 	ldr.w	r1, [r3, #144]	@ 0x90
 8008816:	687b      	ldr	r3, [r7, #4]
 8008818:	68ba      	ldr	r2, [r7, #8]
 800881a:	2000      	movs	r0, #0
 800881c:	f7ff fe42 	bl	80084a4 <fx_stm32_sd_read_blocks>
 8008820:	4603      	mov	r3, r0
 8008822:	623b      	str	r3, [r7, #32]

    if (status != 0)
 8008824:	6a3b      	ldr	r3, [r7, #32]
 8008826:	2b00      	cmp	r3, #0
 8008828:	d001      	beq.n	800882e <sd_read_data+0xc6>
    {
      /* read error occurred, call the error handler code then return immediately */
      FX_STM32_SD_READ_TRANSFER_ERROR(status);

      return FX_IO_ERROR;
 800882a:	2390      	movs	r3, #144	@ 0x90
 800882c:	e019      	b.n	8008862 <sd_read_data+0xfa>
    }

    /* wait for read transfer notification */
       FX_STM32_SD_READ_CPLT_NOTIFY();
 800882e:	f7f8 fba5 	bl	8000f7c <HAL_GetTick>
 8008832:	61b8      	str	r0, [r7, #24]
 8008834:	e003      	b.n	800883e <sd_read_data+0xd6>
 8008836:	4b0e      	ldr	r3, [pc, #56]	@ (8008870 <sd_read_data+0x108>)
 8008838:	681b      	ldr	r3, [r3, #0]
 800883a:	2b01      	cmp	r3, #1
 800883c:	d008      	beq.n	8008850 <sd_read_data+0xe8>
 800883e:	f7f8 fb9d 	bl	8000f7c <HAL_GetTick>
 8008842:	4602      	mov	r2, r0
 8008844:	69bb      	ldr	r3, [r7, #24]
 8008846:	1ad3      	subs	r3, r2, r3
 8008848:	f242 720f 	movw	r2, #9999	@ 0x270f
 800884c:	4293      	cmp	r3, r2
 800884e:	d9f2      	bls.n	8008836 <sd_read_data+0xce>
 8008850:	4b07      	ldr	r3, [pc, #28]	@ (8008870 <sd_read_data+0x108>)
 8008852:	681b      	ldr	r3, [r3, #0]
 8008854:	2b00      	cmp	r3, #0
 8008856:	d101      	bne.n	800885c <sd_read_data+0xf4>
 8008858:	2390      	movs	r3, #144	@ 0x90
 800885a:	e002      	b.n	8008862 <sd_read_data+0xfa>

#if (FX_STM32_SD_CACHE_MAINTENANCE == 1)
    invalidate_cache_by_addr((uint32_t*)media_ptr->fx_media_driver_buffer, num_sectors * FX_STM32_SD_DEFAULT_SECTOR_SIZE);
#endif

    status = FX_SUCCESS;
 800885c:	2300      	movs	r3, #0
 800885e:	623b      	str	r3, [r7, #32]
  }

  /* Operation finished, call the post read macro if defined */

  FX_STM32_SD_POST_READ_TRANSFER(media_ptr);
  return status;
 8008860:	6a3b      	ldr	r3, [r7, #32]
}
 8008862:	4618      	mov	r0, r3
 8008864:	3728      	adds	r7, #40	@ 0x28
 8008866:	46bd      	mov	sp, r7
 8008868:	bd80      	pop	{r7, pc}
 800886a:	bf00      	nop
 800886c:	20002a88 	.word	0x20002a88
 8008870:	20002a80 	.word	0x20002a80

08008874 <sd_write_data>:
* @param UINT use_scratch_buffer to enable scratch buffer usage or not.
* @retval FX_SUCCESS on success FX_BUFFER_ERROR / FX_ACCESS_ERROR / FX_IO_ERROR otherwise
*/

static UINT sd_write_data(FX_MEDIA *media_ptr, ULONG start_sector, UINT num_sectors, UINT use_scratch_buffer)
{
 8008874:	b580      	push	{r7, lr}
 8008876:	b08a      	sub	sp, #40	@ 0x28
 8008878:	af00      	add	r7, sp, #0
 800887a:	60f8      	str	r0, [r7, #12]
 800887c:	60b9      	str	r1, [r7, #8]
 800887e:	607a      	str	r2, [r7, #4]
 8008880:	603b      	str	r3, [r7, #0]
  INT i = 0;
 8008882:	2300      	movs	r3, #0
 8008884:	627b      	str	r3, [r7, #36]	@ 0x24
  UCHAR *write_addr;

  /* call Pre write operation macro */
  FX_STM32_SD_PRE_WRITE_TRANSFER(media_ptr);

  if (use_scratch_buffer)
 8008886:	683b      	ldr	r3, [r7, #0]
 8008888:	2b00      	cmp	r3, #0
 800888a:	d047      	beq.n	800891c <sd_write_data+0xa8>
  {
    write_addr = media_ptr->fx_media_driver_buffer;
 800888c:	68fb      	ldr	r3, [r7, #12]
 800888e:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 8008892:	61fb      	str	r3, [r7, #28]

    for (i = 0; i < num_sectors; i++)
 8008894:	2300      	movs	r3, #0
 8008896:	627b      	str	r3, [r7, #36]	@ 0x24
 8008898:	e032      	b.n	8008900 <sd_write_data+0x8c>
    {
      _fx_utility_memory_copy(write_addr, scratch, FX_STM32_SD_DEFAULT_SECTOR_SIZE);
 800889a:	f44f 7200 	mov.w	r2, #512	@ 0x200
 800889e:	4936      	ldr	r1, [pc, #216]	@ (8008978 <sd_write_data+0x104>)
 80088a0:	69f8      	ldr	r0, [r7, #28]
 80088a2:	f008 f887 	bl	80109b4 <_fx_utility_memory_copy>
      write_addr += FX_STM32_SD_DEFAULT_SECTOR_SIZE;
 80088a6:	69fb      	ldr	r3, [r7, #28]
 80088a8:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 80088ac:	61fb      	str	r3, [r7, #28]
#if (FX_STM32_SD_CACHE_MAINTENANCE == 1)
      /* Clean the DCache to make the SD DMA see the actual content of the scratch buffer */
      clean_cache_by_addr((uint32_t*)scratch, FX_STM32_SD_DEFAULT_SECTOR_SIZE);
#endif

      status = fx_stm32_sd_write_blocks(FX_STM32_SD_INSTANCE, (UINT *)scratch, (UINT)start_sector++, 1);
 80088ae:	68ba      	ldr	r2, [r7, #8]
 80088b0:	1c53      	adds	r3, r2, #1
 80088b2:	60bb      	str	r3, [r7, #8]
 80088b4:	2301      	movs	r3, #1
 80088b6:	4930      	ldr	r1, [pc, #192]	@ (8008978 <sd_write_data+0x104>)
 80088b8:	2000      	movs	r0, #0
 80088ba:	f7ff fe13 	bl	80084e4 <fx_stm32_sd_write_blocks>
 80088be:	4603      	mov	r3, r0
 80088c0:	623b      	str	r3, [r7, #32]

      if (status != 0)
 80088c2:	6a3b      	ldr	r3, [r7, #32]
 80088c4:	2b00      	cmp	r3, #0
 80088c6:	d001      	beq.n	80088cc <sd_write_data+0x58>
      {
        /* in case of error call the error handling macro */
        FX_STM32_SD_WRITE_TRANSFER_ERROR(status);
        return FX_IO_ERROR;
 80088c8:	2390      	movs	r3, #144	@ 0x90
 80088ca:	e050      	b.n	800896e <sd_write_data+0xfa>
      }

      /*  */
       FX_STM32_SD_WRITE_CPLT_NOTIFY();
 80088cc:	f7f8 fb56 	bl	8000f7c <HAL_GetTick>
 80088d0:	6178      	str	r0, [r7, #20]
 80088d2:	e003      	b.n	80088dc <sd_write_data+0x68>
 80088d4:	4b29      	ldr	r3, [pc, #164]	@ (800897c <sd_write_data+0x108>)
 80088d6:	681b      	ldr	r3, [r3, #0]
 80088d8:	2b01      	cmp	r3, #1
 80088da:	d008      	beq.n	80088ee <sd_write_data+0x7a>
 80088dc:	f7f8 fb4e 	bl	8000f7c <HAL_GetTick>
 80088e0:	4602      	mov	r2, r0
 80088e2:	697b      	ldr	r3, [r7, #20]
 80088e4:	1ad3      	subs	r3, r2, r3
 80088e6:	f242 720f 	movw	r2, #9999	@ 0x270f
 80088ea:	4293      	cmp	r3, r2
 80088ec:	d9f2      	bls.n	80088d4 <sd_write_data+0x60>
 80088ee:	4b23      	ldr	r3, [pc, #140]	@ (800897c <sd_write_data+0x108>)
 80088f0:	681b      	ldr	r3, [r3, #0]
 80088f2:	2b00      	cmp	r3, #0
 80088f4:	d101      	bne.n	80088fa <sd_write_data+0x86>
 80088f6:	2390      	movs	r3, #144	@ 0x90
 80088f8:	e039      	b.n	800896e <sd_write_data+0xfa>
    for (i = 0; i < num_sectors; i++)
 80088fa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80088fc:	3301      	adds	r3, #1
 80088fe:	627b      	str	r3, [r7, #36]	@ 0x24
 8008900:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8008902:	687a      	ldr	r2, [r7, #4]
 8008904:	429a      	cmp	r2, r3
 8008906:	d8c8      	bhi.n	800889a <sd_write_data+0x26>
    }

    if (i == num_sectors)
 8008908:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800890a:	687a      	ldr	r2, [r7, #4]
 800890c:	429a      	cmp	r2, r3
 800890e:	d102      	bne.n	8008916 <sd_write_data+0xa2>
    {
      status = FX_SUCCESS;
 8008910:	2300      	movs	r3, #0
 8008912:	623b      	str	r3, [r7, #32]
 8008914:	e02a      	b.n	800896c <sd_write_data+0xf8>
    }
    else
    {
      status = FX_BUFFER_ERROR;
 8008916:	2321      	movs	r3, #33	@ 0x21
 8008918:	623b      	str	r3, [r7, #32]
 800891a:	e027      	b.n	800896c <sd_write_data+0xf8>
  else
  {
#if (FX_STM32_SD_CACHE_MAINTENANCE == 1)
    clean_cache_by_addr((uint32_t*)media_ptr->fx_media_driver_buffer, num_sectors * FX_STM32_SD_DEFAULT_SECTOR_SIZE);
#endif
    status = fx_stm32_sd_write_blocks(FX_STM32_SD_INSTANCE, (UINT *)media_ptr->fx_media_driver_buffer, (UINT)start_sector, num_sectors);
 800891c:	68fb      	ldr	r3, [r7, #12]
 800891e:	f8d3 1090 	ldr.w	r1, [r3, #144]	@ 0x90
 8008922:	687b      	ldr	r3, [r7, #4]
 8008924:	68ba      	ldr	r2, [r7, #8]
 8008926:	2000      	movs	r0, #0
 8008928:	f7ff fddc 	bl	80084e4 <fx_stm32_sd_write_blocks>
 800892c:	4603      	mov	r3, r0
 800892e:	623b      	str	r3, [r7, #32]

    if (status != 0)
 8008930:	6a3b      	ldr	r3, [r7, #32]
 8008932:	2b00      	cmp	r3, #0
 8008934:	d001      	beq.n	800893a <sd_write_data+0xc6>
    {
      FX_STM32_SD_WRITE_TRANSFER_ERROR(status);
      return FX_IO_ERROR;
 8008936:	2390      	movs	r3, #144	@ 0x90
 8008938:	e019      	b.n	800896e <sd_write_data+0xfa>
    }

    /* when defined, wait for the write notification */
     FX_STM32_SD_WRITE_CPLT_NOTIFY();
 800893a:	f7f8 fb1f 	bl	8000f7c <HAL_GetTick>
 800893e:	61b8      	str	r0, [r7, #24]
 8008940:	e003      	b.n	800894a <sd_write_data+0xd6>
 8008942:	4b0e      	ldr	r3, [pc, #56]	@ (800897c <sd_write_data+0x108>)
 8008944:	681b      	ldr	r3, [r3, #0]
 8008946:	2b01      	cmp	r3, #1
 8008948:	d008      	beq.n	800895c <sd_write_data+0xe8>
 800894a:	f7f8 fb17 	bl	8000f7c <HAL_GetTick>
 800894e:	4602      	mov	r2, r0
 8008950:	69bb      	ldr	r3, [r7, #24]
 8008952:	1ad3      	subs	r3, r2, r3
 8008954:	f242 720f 	movw	r2, #9999	@ 0x270f
 8008958:	4293      	cmp	r3, r2
 800895a:	d9f2      	bls.n	8008942 <sd_write_data+0xce>
 800895c:	4b07      	ldr	r3, [pc, #28]	@ (800897c <sd_write_data+0x108>)
 800895e:	681b      	ldr	r3, [r3, #0]
 8008960:	2b00      	cmp	r3, #0
 8008962:	d101      	bne.n	8008968 <sd_write_data+0xf4>
 8008964:	2390      	movs	r3, #144	@ 0x90
 8008966:	e002      	b.n	800896e <sd_write_data+0xfa>

    status = FX_SUCCESS;
 8008968:	2300      	movs	r3, #0
 800896a:	623b      	str	r3, [r7, #32]

  /* perform post write operations */
  FX_STM32_SD_POST_WRITE_TRANSFER(media_ptr);


  return status;
 800896c:	6a3b      	ldr	r3, [r7, #32]
}
 800896e:	4618      	mov	r0, r3
 8008970:	3728      	adds	r7, #40	@ 0x28
 8008972:	46bd      	mov	sp, r7
 8008974:	bd80      	pop	{r7, pc}
 8008976:	bf00      	nop
 8008978:	20002a88 	.word	0x20002a88
 800897c:	20002a84 	.word	0x20002a84

08008980 <_fx_directory_entry_read>:
                                   ULONG *entry_ptr, FX_DIR_ENTRY *destination_ptr)
#else
UINT  _fx_directory_entry_read(FX_MEDIA *media_ptr, FX_DIR_ENTRY *source_dir,
                               ULONG *entry_ptr, FX_DIR_ENTRY *destination_ptr)
#endif /* FX_ENABLE_EXFAT */
{
 8008980:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8008984:	b09e      	sub	sp, #120	@ 0x78
 8008986:	af04      	add	r7, sp, #16
 8008988:	61f8      	str	r0, [r7, #28]
 800898a:	61b9      	str	r1, [r7, #24]
 800898c:	617a      	str	r2, [r7, #20]
 800898e:	613b      	str	r3, [r7, #16]

UINT   i, j, card, dotflag, get_short_name;
UINT   number_of_lfns;
UINT   status;
ULONG  cluster, next_cluster = 0;
 8008990:	2300      	movs	r3, #0
 8008992:	627b      	str	r3, [r7, #36]	@ 0x24
ULONG  logical_sector;
ULONG  byte_offset;
ULONG  bytes_per_cluster;
UCHAR *read_ptr;
CHAR  *short_name_ptr;
ULONG  entry = *entry_ptr;
 8008994:	697b      	ldr	r3, [r7, #20]
 8008996:	681b      	ldr	r3, [r3, #0]
 8008998:	63bb      	str	r3, [r7, #56]	@ 0x38


#ifndef FX_MEDIA_STATISTICS_DISABLE

    /* Increment the number of directory entry read requests.  */
    media_ptr -> fx_media_directory_entry_reads++;
 800899a:	69fb      	ldr	r3, [r7, #28]
 800899c:	f8d3 3168 	ldr.w	r3, [r3, #360]	@ 0x168
 80089a0:	1c5a      	adds	r2, r3, #1
 80089a2:	69fb      	ldr	r3, [r7, #28]
 80089a4:	f8c3 2168 	str.w	r2, [r3, #360]	@ 0x168

    /* If trace is enabled, insert this event into the trace buffer.  */
    FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_DIR_ENTRY_READ, media_ptr, 0, 0, 0, FX_TRACE_INTERNAL_EVENTS, 0, 0)

    /* Calculate the byte offset of this directory entry.  */
    byte_offset =  entry * FX_DIR_ENTRY_SIZE;
 80089a8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80089aa:	015b      	lsls	r3, r3, #5
 80089ac:	647b      	str	r3, [r7, #68]	@ 0x44

    /* Determine if a sub-directory or FAT32 root directory is specified.  */
#ifdef FX_ENABLE_EXFAT
    if ((source_dir) || (media_ptr -> fx_media_FAT_type == FX_FAT32))
#else
    if ((source_dir) || (media_ptr -> fx_media_32_bit_FAT))
 80089ae:	69bb      	ldr	r3, [r7, #24]
 80089b0:	2b00      	cmp	r3, #0
 80089b2:	d104      	bne.n	80089be <_fx_directory_entry_read+0x3e>
 80089b4:	69fb      	ldr	r3, [r7, #28]
 80089b6:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 80089b8:	2b00      	cmp	r3, #0
 80089ba:	f000 80a1 	beq.w	8008b00 <_fx_directory_entry_read+0x180>
    {

        /* Yes, a sub-directory is present.  */

        /* Calculate the number of bytes per cluster.  */
        bytes_per_cluster =  ((ULONG)media_ptr -> fx_media_bytes_per_sector) *
 80089be:	69fb      	ldr	r3, [r7, #28]
 80089c0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
            ((ULONG)media_ptr -> fx_media_sectors_per_cluster);
 80089c2:	69fa      	ldr	r2, [r7, #28]
 80089c4:	6d52      	ldr	r2, [r2, #84]	@ 0x54
        bytes_per_cluster =  ((ULONG)media_ptr -> fx_media_bytes_per_sector) *
 80089c6:	fb02 f303 	mul.w	r3, r2, r3
 80089ca:	633b      	str	r3, [r7, #48]	@ 0x30

        /* Check for invalid value.  */
        if (bytes_per_cluster == 0)
 80089cc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80089ce:	2b00      	cmp	r3, #0
 80089d0:	d101      	bne.n	80089d6 <_fx_directory_entry_read+0x56>
        {

            /* Invalid media, return error.  */
            return(FX_MEDIA_INVALID);
 80089d2:	2302      	movs	r3, #2
 80089d4:	e355      	b.n	8009082 <_fx_directory_entry_read+0x702>
        }

        /* Now determine the relative cluster in the sub-directory file.  */
        relative_cluster =   (UINT)(byte_offset / bytes_per_cluster);
 80089d6:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 80089d8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80089da:	fbb2 f3f3 	udiv	r3, r2, r3
 80089de:	653b      	str	r3, [r7, #80]	@ 0x50

        /* Calculate the byte offset within the cluster.  */
        byte_offset =  byte_offset % bytes_per_cluster;
 80089e0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80089e2:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80089e4:	fbb3 f2f2 	udiv	r2, r3, r2
 80089e8:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 80089ea:	fb01 f202 	mul.w	r2, r1, r2
 80089ee:	1a9b      	subs	r3, r3, r2
 80089f0:	647b      	str	r3, [r7, #68]	@ 0x44

        /* Now figure out the relative sector within the cluster.  */
        relative_sector =    (UINT)(byte_offset / ((ULONG)media_ptr -> fx_media_bytes_per_sector));
 80089f2:	69fb      	ldr	r3, [r7, #28]
 80089f4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80089f6:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 80089f8:	fbb2 f3f3 	udiv	r3, r2, r3
 80089fc:	64fb      	str	r3, [r7, #76]	@ 0x4c

        /* Read the directory sector into the internal memory buffer.  */

        /* Determine if there is a sub-directory.  */
        if (source_dir)
 80089fe:	69bb      	ldr	r3, [r7, #24]
 8008a00:	2b00      	cmp	r3, #0
 8008a02:	d028      	beq.n	8008a56 <_fx_directory_entry_read+0xd6>
        {

            /* Determine if this source directory has valid information from the previous call.  */
            if ((source_dir -> fx_dir_entry_last_search_cluster) &&
 8008a04:	69bb      	ldr	r3, [r7, #24]
 8008a06:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8008a08:	2b00      	cmp	r3, #0
 8008a0a:	d01e      	beq.n	8008a4a <_fx_directory_entry_read+0xca>
                (source_dir -> fx_dir_entry_last_search_relative_cluster <= relative_cluster) &&
 8008a0c:	69bb      	ldr	r3, [r7, #24]
 8008a0e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
            if ((source_dir -> fx_dir_entry_last_search_cluster) &&
 8008a10:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 8008a12:	429a      	cmp	r2, r3
 8008a14:	d319      	bcc.n	8008a4a <_fx_directory_entry_read+0xca>
                (source_dir -> fx_dir_entry_last_search_log_sector == source_dir -> fx_dir_entry_log_sector) &&
 8008a16:	69bb      	ldr	r3, [r7, #24]
 8008a18:	e9d3 0116 	ldrd	r0, r1, [r3, #88]	@ 0x58
 8008a1c:	69bb      	ldr	r3, [r7, #24]
 8008a1e:	e9d3 2310 	ldrd	r2, r3, [r3, #64]	@ 0x40
                (source_dir -> fx_dir_entry_last_search_relative_cluster <= relative_cluster) &&
 8008a22:	4299      	cmp	r1, r3
 8008a24:	bf08      	it	eq
 8008a26:	4290      	cmpeq	r0, r2
 8008a28:	d10f      	bne.n	8008a4a <_fx_directory_entry_read+0xca>
                (source_dir -> fx_dir_entry_last_search_byte_offset == source_dir -> fx_dir_entry_byte_offset))
 8008a2a:	69bb      	ldr	r3, [r7, #24]
 8008a2c:	6e1a      	ldr	r2, [r3, #96]	@ 0x60
 8008a2e:	69bb      	ldr	r3, [r7, #24]
 8008a30:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
                (source_dir -> fx_dir_entry_last_search_log_sector == source_dir -> fx_dir_entry_log_sector) &&
 8008a32:	429a      	cmp	r2, r3
 8008a34:	d109      	bne.n	8008a4a <_fx_directory_entry_read+0xca>
            {

                /* Use the previous information to start the search.  */
                cluster =  source_dir -> fx_dir_entry_last_search_cluster;
 8008a36:	69bb      	ldr	r3, [r7, #24]
 8008a38:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8008a3a:	657b      	str	r3, [r7, #84]	@ 0x54

                /* Setup the relative cluster index to the saved relative cluster.  */
                i =  source_dir -> fx_dir_entry_last_search_relative_cluster;
 8008a3c:	69bb      	ldr	r3, [r7, #24]
 8008a3e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8008a40:	667b      	str	r3, [r7, #100]	@ 0x64

                /* Clear the search cluster.  It will be updated prior to successful return.  */
                source_dir -> fx_dir_entry_last_search_cluster =  0;
 8008a42:	69bb      	ldr	r3, [r7, #24]
 8008a44:	2200      	movs	r2, #0
 8008a46:	651a      	str	r2, [r3, #80]	@ 0x50
 8008a48:	e00a      	b.n	8008a60 <_fx_directory_entry_read+0xe0>
            else
            {

                /* Nothing from the previous directory read, just setup the starting cluster to the
                   beginning of the sub-directory.  */
                cluster =  source_dir -> fx_dir_entry_cluster;
 8008a4a:	69bb      	ldr	r3, [r7, #24]
 8008a4c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8008a4e:	657b      	str	r3, [r7, #84]	@ 0x54

                /* Setup the relative cluster index to zero.  */
                i =  0;
 8008a50:	2300      	movs	r3, #0
 8008a52:	667b      	str	r3, [r7, #100]	@ 0x64
 8008a54:	e024      	b.n	8008aa0 <_fx_directory_entry_read+0x120>
        }
        else
        {

            /* No, setup the starting cluster to the FAT32 root cluster.  */
            cluster =  media_ptr -> fx_media_root_cluster_32;
 8008a56:	69fb      	ldr	r3, [r7, #28]
 8008a58:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 8008a5a:	657b      	str	r3, [r7, #84]	@ 0x54

            /* Setup the relative cluster index to zero.  */
            i =  0;
 8008a5c:	2300      	movs	r3, #0
 8008a5e:	667b      	str	r3, [r7, #100]	@ 0x64
        }

        /* Loop to position to the appropriate cluster.  */
        while (i < relative_cluster)
 8008a60:	e01e      	b.n	8008aa0 <_fx_directory_entry_read+0x120>
        {

            /* Check the value of the new cluster - it must be a valid cluster number
               or something is really wrong!  */
            if ((cluster < FX_FAT_ENTRY_START) || (cluster >= media_ptr -> fx_media_fat_reserved))
 8008a62:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8008a64:	2b01      	cmp	r3, #1
 8008a66:	d907      	bls.n	8008a78 <_fx_directory_entry_read+0xf8>
 8008a68:	69fb      	ldr	r3, [r7, #28]
 8008a6a:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 8008a6e:	f8d3 3478 	ldr.w	r3, [r3, #1144]	@ 0x478
 8008a72:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8008a74:	429a      	cmp	r2, r3
 8008a76:	d301      	bcc.n	8008a7c <_fx_directory_entry_read+0xfc>
            {

                /* Send error message back to caller.  */
                return(FX_FILE_CORRUPT);
 8008a78:	2308      	movs	r3, #8
 8008a7a:	e302      	b.n	8009082 <_fx_directory_entry_read+0x702>
            }

            /* Read the next cluster.  */
            status =  _fx_utility_FAT_entry_read(media_ptr, cluster, &next_cluster);
 8008a7c:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 8008a80:	461a      	mov	r2, r3
 8008a82:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 8008a84:	69f8      	ldr	r0, [r7, #28]
 8008a86:	f005 ff8b 	bl	800e9a0 <_fx_utility_FAT_entry_read>
 8008a8a:	6378      	str	r0, [r7, #52]	@ 0x34

            /* There is a potential for loop, but hardly anything can be done */

            /* Check for I/O error.  */
            if (status != FX_SUCCESS)
 8008a8c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8008a8e:	2b00      	cmp	r3, #0
 8008a90:	d001      	beq.n	8008a96 <_fx_directory_entry_read+0x116>
            {

                /* Return error code.  */
                return(status);
 8008a92:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8008a94:	e2f5      	b.n	8009082 <_fx_directory_entry_read+0x702>
            }

            /* Setup the actual cluster.  */
            cluster = next_cluster;
 8008a96:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8008a98:	657b      	str	r3, [r7, #84]	@ 0x54

            /* Increment the relative cluster number.  */
            i++;
 8008a9a:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8008a9c:	3301      	adds	r3, #1
 8008a9e:	667b      	str	r3, [r7, #100]	@ 0x64
        while (i < relative_cluster)
 8008aa0:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 8008aa2:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8008aa4:	429a      	cmp	r2, r3
 8008aa6:	d3dc      	bcc.n	8008a62 <_fx_directory_entry_read+0xe2>
        }

        /* At this point, the directory data sector needs to be read.  */
        logical_sector =    ((ULONG)media_ptr -> fx_media_data_sector_start) +
 8008aa8:	69fb      	ldr	r3, [r7, #28]
 8008aaa:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
            (((ULONG)cluster - FX_FAT_ENTRY_START) *
 8008aac:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8008aae:	3b02      	subs	r3, #2
             ((ULONG)media_ptr -> fx_media_sectors_per_cluster)) +
 8008ab0:	69f9      	ldr	r1, [r7, #28]
 8008ab2:	6d49      	ldr	r1, [r1, #84]	@ 0x54
            (((ULONG)cluster - FX_FAT_ENTRY_START) *
 8008ab4:	fb01 f303 	mul.w	r3, r1, r3
        logical_sector =    ((ULONG)media_ptr -> fx_media_data_sector_start) +
 8008ab8:	4413      	add	r3, r2
 8008aba:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8008abc:	4413      	add	r3, r2
 8008abe:	64bb      	str	r3, [r7, #72]	@ 0x48
            relative_sector;

        /* Read the logical directory sector.  */
        status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) logical_sector,
 8008ac0:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8008ac2:	2200      	movs	r2, #0
 8008ac4:	60bb      	str	r3, [r7, #8]
 8008ac6:	60fa      	str	r2, [r7, #12]
                                                  media_ptr -> fx_media_memory_buffer, ((ULONG) 1), FX_DIRECTORY_SECTOR);
 8008ac8:	69fb      	ldr	r3, [r7, #28]
 8008aca:	689b      	ldr	r3, [r3, #8]
        status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) logical_sector,
 8008acc:	2203      	movs	r2, #3
 8008ace:	9202      	str	r2, [sp, #8]
 8008ad0:	2201      	movs	r2, #1
 8008ad2:	9201      	str	r2, [sp, #4]
 8008ad4:	9300      	str	r3, [sp, #0]
 8008ad6:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 8008ada:	69f8      	ldr	r0, [r7, #28]
 8008adc:	f007 fb6e 	bl	80101bc <_fx_utility_logical_sector_read>
 8008ae0:	6378      	str	r0, [r7, #52]	@ 0x34

        /* Determine if an error occurred.  */
        if (status != FX_SUCCESS)
 8008ae2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8008ae4:	2b00      	cmp	r3, #0
 8008ae6:	d001      	beq.n	8008aec <_fx_directory_entry_read+0x16c>
        {

            /* Return error code.  */
            return(status);
 8008ae8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8008aea:	e2ca      	b.n	8009082 <_fx_directory_entry_read+0x702>
        }

        /* Calculate the byte offset within this sector.  */
        byte_offset =  byte_offset % media_ptr -> fx_media_bytes_per_sector;
 8008aec:	69fb      	ldr	r3, [r7, #28]
 8008aee:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 8008af0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8008af2:	fbb3 f1f2 	udiv	r1, r3, r2
 8008af6:	fb01 f202 	mul.w	r2, r1, r2
 8008afa:	1a9b      	subs	r3, r3, r2
 8008afc:	647b      	str	r3, [r7, #68]	@ 0x44
 8008afe:	e02f      	b.n	8008b60 <_fx_directory_entry_read+0x1e0>
    {

        /* Read the entry from the root directory.  */

        /* Determine which sector the requested root directory entry is in.  */
        logical_sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 8008b00:	69fb      	ldr	r3, [r7, #28]
 8008b02:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8008b04:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8008b06:	fbb2 f2f3 	udiv	r2, r2, r3
            (ULONG)media_ptr -> fx_media_root_sector_start;
 8008b0a:	69fb      	ldr	r3, [r7, #28]
 8008b0c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
        logical_sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 8008b0e:	4413      	add	r3, r2
 8008b10:	64bb      	str	r3, [r7, #72]	@ 0x48

        /* Read the logical directory sector.  */
        status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) logical_sector,
 8008b12:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8008b14:	2200      	movs	r2, #0
 8008b16:	603b      	str	r3, [r7, #0]
 8008b18:	607a      	str	r2, [r7, #4]
                                                  media_ptr -> fx_media_memory_buffer, ((ULONG) 1), FX_DIRECTORY_SECTOR);
 8008b1a:	69fb      	ldr	r3, [r7, #28]
 8008b1c:	689b      	ldr	r3, [r3, #8]
        status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) logical_sector,
 8008b1e:	2203      	movs	r2, #3
 8008b20:	9202      	str	r2, [sp, #8]
 8008b22:	2201      	movs	r2, #1
 8008b24:	9201      	str	r2, [sp, #4]
 8008b26:	9300      	str	r3, [sp, #0]
 8008b28:	e9d7 2300 	ldrd	r2, r3, [r7]
 8008b2c:	69f8      	ldr	r0, [r7, #28]
 8008b2e:	f007 fb45 	bl	80101bc <_fx_utility_logical_sector_read>
 8008b32:	6378      	str	r0, [r7, #52]	@ 0x34

        /* Determine if an error occurred.  */
        if (status != FX_SUCCESS)
 8008b34:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8008b36:	2b00      	cmp	r3, #0
 8008b38:	d001      	beq.n	8008b3e <_fx_directory_entry_read+0x1be>
        {

            /* Return error code.  */
            return(status);
 8008b3a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8008b3c:	e2a1      	b.n	8009082 <_fx_directory_entry_read+0x702>
        }

        /* Set the cluster and relative variables (not used in this case) to avoid any compiler
           warnings.  */
        relative_cluster =  relative_sector =  cluster =  0;
 8008b3e:	2300      	movs	r3, #0
 8008b40:	657b      	str	r3, [r7, #84]	@ 0x54
 8008b42:	2300      	movs	r3, #0
 8008b44:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8008b46:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8008b48:	653b      	str	r3, [r7, #80]	@ 0x50

        /* Now calculate the byte offset into this sector.  */
        byte_offset =  byte_offset -
            ((logical_sector - (ULONG)media_ptr -> fx_media_root_sector_start) *
 8008b4a:	69fb      	ldr	r3, [r7, #28]
 8008b4c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8008b4e:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8008b50:	1ad3      	subs	r3, r2, r3
             media_ptr -> fx_media_bytes_per_sector);
 8008b52:	69fa      	ldr	r2, [r7, #28]
 8008b54:	6a92      	ldr	r2, [r2, #40]	@ 0x28
            ((logical_sector - (ULONG)media_ptr -> fx_media_root_sector_start) *
 8008b56:	fb02 f303 	mul.w	r3, r2, r3
        byte_offset =  byte_offset -
 8008b5a:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8008b5c:	1ad3      	subs	r3, r2, r3
 8008b5e:	647b      	str	r3, [r7, #68]	@ 0x44
    }

    /* Setup a pointer into the buffer.  */
    read_ptr =  (UCHAR *)media_ptr -> fx_media_memory_buffer + (UINT)byte_offset;
 8008b60:	69fb      	ldr	r3, [r7, #28]
 8008b62:	689a      	ldr	r2, [r3, #8]
 8008b64:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8008b66:	4413      	add	r3, r2
 8008b68:	643b      	str	r3, [r7, #64]	@ 0x40

    /* Save the logical sector and byte offset in the returned directory entry.  */
    destination_ptr -> fx_dir_entry_log_sector =       logical_sector;
 8008b6a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8008b6c:	2200      	movs	r2, #0
 8008b6e:	4698      	mov	r8, r3
 8008b70:	4691      	mov	r9, r2
 8008b72:	693b      	ldr	r3, [r7, #16]
 8008b74:	e9c3 8910 	strd	r8, r9, [r3, #64]	@ 0x40
    destination_ptr -> fx_dir_entry_byte_offset =      byte_offset;
 8008b78:	693b      	ldr	r3, [r7, #16]
 8008b7a:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8008b7c:	649a      	str	r2, [r3, #72]	@ 0x48

    /* Clear the short file name information.  */
    destination_ptr -> fx_dir_entry_long_name_shorted =  0;
 8008b7e:	693b      	ldr	r3, [r7, #16]
 8008b80:	2200      	movs	r2, #0
 8008b82:	619a      	str	r2, [r3, #24]
    destination_ptr -> fx_dir_entry_short_name[0]     =  0;
 8008b84:	693b      	ldr	r3, [r7, #16]
 8008b86:	2200      	movs	r2, #0
 8008b88:	711a      	strb	r2, [r3, #4]

    /* Setup short name pointer.  */
    short_name_ptr =  destination_ptr -> fx_dir_entry_name;
 8008b8a:	693b      	ldr	r3, [r7, #16]
 8008b8c:	681b      	ldr	r3, [r3, #0]
 8008b8e:	63fb      	str	r3, [r7, #60]	@ 0x3c

    /* Check if long file name exists.  */
    get_short_name =  0;
 8008b90:	2300      	movs	r3, #0
 8008b92:	65bb      	str	r3, [r7, #88]	@ 0x58
    if ((*(read_ptr + 11) == (UCHAR)FX_LONG_NAME) && (*read_ptr != (UCHAR)FX_DIR_ENTRY_FREE))
 8008b94:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8008b96:	330b      	adds	r3, #11
 8008b98:	781b      	ldrb	r3, [r3, #0]
 8008b9a:	2b0f      	cmp	r3, #15
 8008b9c:	f040 8129 	bne.w	8008df2 <_fx_directory_entry_read+0x472>
 8008ba0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8008ba2:	781b      	ldrb	r3, [r3, #0]
 8008ba4:	2be5      	cmp	r3, #229	@ 0xe5
 8008ba6:	f000 8124 	beq.w	8008df2 <_fx_directory_entry_read+0x472>
    {

        /* Collate the long name. */

        /* Pickup the file name length.  */
        i = (((UINT)(*read_ptr & (UCHAR)0x1f) - 1) * FX_LONG_NAME_ENTRY_LEN) & 0xFFFFFFFF;
 8008baa:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8008bac:	781b      	ldrb	r3, [r3, #0]
 8008bae:	f003 021f 	and.w	r2, r3, #31
 8008bb2:	4613      	mov	r3, r2
 8008bb4:	005b      	lsls	r3, r3, #1
 8008bb6:	4413      	add	r3, r2
 8008bb8:	009b      	lsls	r3, r3, #2
 8008bba:	4413      	add	r3, r2
 8008bbc:	3b0d      	subs	r3, #13
 8008bbe:	667b      	str	r3, [r7, #100]	@ 0x64

        /* Save the number of LFN entries.  */
        number_of_lfns =  (UINT)(*read_ptr & (UCHAR)0x1f);
 8008bc0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8008bc2:	781b      	ldrb	r3, [r3, #0]
 8008bc4:	f003 031f 	and.w	r3, r3, #31
 8008bc8:	62fb      	str	r3, [r7, #44]	@ 0x2c

        /* Check the file name size.  */
        if (i >= (FX_MAX_LONG_NAME_LEN - 1))
 8008bca:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8008bcc:	2bfe      	cmp	r3, #254	@ 0xfe
 8008bce:	d908      	bls.n	8008be2 <_fx_directory_entry_read+0x262>
        {

            /* Name is too big, shorten it.  */
            get_short_name = 1;
 8008bd0:	2301      	movs	r3, #1
 8008bd2:	65bb      	str	r3, [r7, #88]	@ 0x58
            destination_ptr -> fx_dir_entry_long_name_shorted =  (UINT)(*read_ptr & (UCHAR)0x1f);
 8008bd4:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8008bd6:	781b      	ldrb	r3, [r3, #0]
 8008bd8:	f003 021f 	and.w	r2, r3, #31
 8008bdc:	693b      	ldr	r3, [r7, #16]
 8008bde:	619a      	str	r2, [r3, #24]
 8008be0:	e015      	b.n	8008c0e <_fx_directory_entry_read+0x28e>
        }
        else
        {

            /* Size of name is fine, save pointer to short file name.  */
            short_name_ptr = destination_ptr -> fx_dir_entry_short_name;
 8008be2:	693b      	ldr	r3, [r7, #16]
 8008be4:	3304      	adds	r3, #4
 8008be6:	63fb      	str	r3, [r7, #60]	@ 0x3c

            /* Loop to make sure the long file name is NULL terminated.  */
            j = i + FX_LONG_NAME_ENTRY_LEN + 1;
 8008be8:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8008bea:	330e      	adds	r3, #14
 8008bec:	663b      	str	r3, [r7, #96]	@ 0x60
            do
            {
                /* Place a NULL in the long name.  */
                destination_ptr -> fx_dir_entry_name[i] =  0;
 8008bee:	693b      	ldr	r3, [r7, #16]
 8008bf0:	681a      	ldr	r2, [r3, #0]
 8008bf2:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8008bf4:	4413      	add	r3, r2
 8008bf6:	2200      	movs	r2, #0
 8008bf8:	701a      	strb	r2, [r3, #0]

                /* Position to the next entry.  */
                i++;
 8008bfa:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8008bfc:	3301      	adds	r3, #1
 8008bfe:	667b      	str	r3, [r7, #100]	@ 0x64
            } while ((i < j) && (i < FX_MAX_LONG_NAME_LEN));
 8008c00:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 8008c02:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8008c04:	429a      	cmp	r2, r3
 8008c06:	d202      	bcs.n	8008c0e <_fx_directory_entry_read+0x28e>
 8008c08:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8008c0a:	2bff      	cmp	r3, #255	@ 0xff
 8008c0c:	d9ef      	bls.n	8008bee <_fx_directory_entry_read+0x26e>
        /* Loop to pickup the rest of the name.  */
        do
        {

            /* Get the lower 5 bit containing the cardinality.  */
            card = (UINT)(*read_ptr & (UCHAR)0x1f) - 1;
 8008c0e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8008c10:	781b      	ldrb	r3, [r3, #0]
 8008c12:	f003 031f 	and.w	r3, r3, #31
 8008c16:	3b01      	subs	r3, #1
 8008c18:	62bb      	str	r3, [r7, #40]	@ 0x28

            /* For simplicity no checksum or cardinality checking is done */
            if (get_short_name == 0)
 8008c1a:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8008c1c:	2b00      	cmp	r3, #0
 8008c1e:	d168      	bne.n	8008cf2 <_fx_directory_entry_read+0x372>
            {

                /* Loop to pickup name.  */
                for (i = 1, j = 0; i < FX_DIR_ENTRY_SIZE; i += 2)
 8008c20:	2301      	movs	r3, #1
 8008c22:	667b      	str	r3, [r7, #100]	@ 0x64
 8008c24:	2300      	movs	r3, #0
 8008c26:	663b      	str	r3, [r7, #96]	@ 0x60
 8008c28:	e060      	b.n	8008cec <_fx_directory_entry_read+0x36c>
                {

                    if ((i == 11) || (i == 26))
 8008c2a:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8008c2c:	2b0b      	cmp	r3, #11
 8008c2e:	d057      	beq.n	8008ce0 <_fx_directory_entry_read+0x360>
 8008c30:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8008c32:	2b1a      	cmp	r3, #26
 8008c34:	d054      	beq.n	8008ce0 <_fx_directory_entry_read+0x360>
                    {
                        continue;
                    }

                    /* i = 12, 27 is not generated due to +=2 */
                    if (i == 13)
 8008c36:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8008c38:	2b0d      	cmp	r3, #13
 8008c3a:	d102      	bne.n	8008c42 <_fx_directory_entry_read+0x2c2>
                    {
                        i = 12;
 8008c3c:	230c      	movs	r3, #12
 8008c3e:	667b      	str	r3, [r7, #100]	@ 0x64
                        continue; /* this time next unicode is byte offset 14*/
 8008c40:	e051      	b.n	8008ce6 <_fx_directory_entry_read+0x366>
                    }

                    /* Determine if there is an actual unicode character present.  */
                    if (read_ptr[i + 1])
 8008c42:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8008c44:	3301      	adds	r3, #1
 8008c46:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8008c48:	4413      	add	r3, r2
 8008c4a:	781b      	ldrb	r3, [r3, #0]
 8008c4c:	2b00      	cmp	r3, #0
 8008c4e:	d014      	beq.n	8008c7a <_fx_directory_entry_read+0x2fa>
                    {

                        /* Extended byte is non-zero, make sure both bytes of the unicode entry are not
                           all ones, since this is a normal case.  */
                        if ((read_ptr[i + 1] != (UCHAR)0xFF) || (read_ptr[i] != (UCHAR)0xFF))
 8008c50:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8008c52:	3301      	adds	r3, #1
 8008c54:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8008c56:	4413      	add	r3, r2
 8008c58:	781b      	ldrb	r3, [r3, #0]
 8008c5a:	2bff      	cmp	r3, #255	@ 0xff
 8008c5c:	d105      	bne.n	8008c6a <_fx_directory_entry_read+0x2ea>
 8008c5e:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8008c60:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8008c62:	4413      	add	r3, r2
 8008c64:	781b      	ldrb	r3, [r3, #0]
 8008c66:	2bff      	cmp	r3, #255	@ 0xff
 8008c68:	d007      	beq.n	8008c7a <_fx_directory_entry_read+0x2fa>
                        {

                            /* Name is an actual unicode name, shorten it.  */
                            get_short_name = 1;
 8008c6a:	2301      	movs	r3, #1
 8008c6c:	65bb      	str	r3, [r7, #88]	@ 0x58

                            /* Save the number of directory entries the LFN has.  This will be
                               used later when updating the 8.3 portion of the LFN.  */
                            destination_ptr -> fx_dir_entry_long_name_shorted =  number_of_lfns;
 8008c6e:	693b      	ldr	r3, [r7, #16]
 8008c70:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8008c72:	619a      	str	r2, [r3, #24]

                            /* Setup short name pointer.  */
                            short_name_ptr =  destination_ptr -> fx_dir_entry_name;
 8008c74:	693b      	ldr	r3, [r7, #16]
 8008c76:	681b      	ldr	r3, [r3, #0]
 8008c78:	63fb      	str	r3, [r7, #60]	@ 0x3c
                        }
                    }

                    /* Determine if the character is NULL.  */
                    if ((read_ptr[i] == FX_NULL) || (read_ptr[i] == (UCHAR)0xFF))
 8008c7a:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8008c7c:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8008c7e:	4413      	add	r3, r2
 8008c80:	781b      	ldrb	r3, [r3, #0]
 8008c82:	2b00      	cmp	r3, #0
 8008c84:	d02e      	beq.n	8008ce4 <_fx_directory_entry_read+0x364>
 8008c86:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8008c88:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8008c8a:	4413      	add	r3, r2
 8008c8c:	781b      	ldrb	r3, [r3, #0]
 8008c8e:	2bff      	cmp	r3, #255	@ 0xff
 8008c90:	d028      	beq.n	8008ce4 <_fx_directory_entry_read+0x364>
                    {
                        continue;
                    }

                    /* Determine if the name is too big.  */
                    if ((card * 13 + j) >= (FX_MAX_LONG_NAME_LEN - 1))
 8008c92:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8008c94:	4613      	mov	r3, r2
 8008c96:	005b      	lsls	r3, r3, #1
 8008c98:	4413      	add	r3, r2
 8008c9a:	009b      	lsls	r3, r3, #2
 8008c9c:	441a      	add	r2, r3
 8008c9e:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8008ca0:	4413      	add	r3, r2
 8008ca2:	2bfe      	cmp	r3, #254	@ 0xfe
 8008ca4:	d908      	bls.n	8008cb8 <_fx_directory_entry_read+0x338>
                    {

                        /* Name is actually too big, shorten it.  */
                        get_short_name =  1;
 8008ca6:	2301      	movs	r3, #1
 8008ca8:	65bb      	str	r3, [r7, #88]	@ 0x58

                        /* Save the number of directory entries the LFN has.  This will be
                           used later when updating the 8.3 portion of the LFN.  */
                        destination_ptr -> fx_dir_entry_long_name_shorted =  number_of_lfns;
 8008caa:	693b      	ldr	r3, [r7, #16]
 8008cac:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8008cae:	619a      	str	r2, [r3, #24]

                        /* Also reposition the short name pointer.  */
                        short_name_ptr =  destination_ptr -> fx_dir_entry_name;
 8008cb0:	693b      	ldr	r3, [r7, #16]
 8008cb2:	681b      	ldr	r3, [r3, #0]
 8008cb4:	63fb      	str	r3, [r7, #60]	@ 0x3c

                        break;
 8008cb6:	e01c      	b.n	8008cf2 <_fx_directory_entry_read+0x372>
                    }

                    /* Each entry contains 13 unicode and first byte ASCII, second byte is extended. */
                    destination_ptr -> fx_dir_entry_name[13 * card + j] = (CHAR)read_ptr[i];
 8008cb8:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8008cba:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8008cbc:	18d1      	adds	r1, r2, r3
 8008cbe:	693b      	ldr	r3, [r7, #16]
 8008cc0:	6818      	ldr	r0, [r3, #0]
 8008cc2:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8008cc4:	4613      	mov	r3, r2
 8008cc6:	005b      	lsls	r3, r3, #1
 8008cc8:	4413      	add	r3, r2
 8008cca:	009b      	lsls	r3, r3, #2
 8008ccc:	441a      	add	r2, r3
 8008cce:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8008cd0:	4413      	add	r3, r2
 8008cd2:	4403      	add	r3, r0
 8008cd4:	780a      	ldrb	r2, [r1, #0]
 8008cd6:	701a      	strb	r2, [r3, #0]

                    j++;
 8008cd8:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8008cda:	3301      	adds	r3, #1
 8008cdc:	663b      	str	r3, [r7, #96]	@ 0x60
 8008cde:	e002      	b.n	8008ce6 <_fx_directory_entry_read+0x366>
                        continue;
 8008ce0:	bf00      	nop
 8008ce2:	e000      	b.n	8008ce6 <_fx_directory_entry_read+0x366>
                        continue;
 8008ce4:	bf00      	nop
                for (i = 1, j = 0; i < FX_DIR_ENTRY_SIZE; i += 2)
 8008ce6:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8008ce8:	3302      	adds	r3, #2
 8008cea:	667b      	str	r3, [r7, #100]	@ 0x64
 8008cec:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8008cee:	2b1f      	cmp	r3, #31
 8008cf0:	d99b      	bls.n	8008c2a <_fx_directory_entry_read+0x2aa>
                }
            }

            /* Determine if a new sector needs to be read.  */
            if (byte_offset + FX_DIR_ENTRY_SIZE >= media_ptr -> fx_media_bytes_per_sector)
 8008cf2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8008cf4:	f103 0220 	add.w	r2, r3, #32
 8008cf8:	69fb      	ldr	r3, [r7, #28]
 8008cfa:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8008cfc:	429a      	cmp	r2, r3
 8008cfe:	d365      	bcc.n	8008dcc <_fx_directory_entry_read+0x44c>
            {

                /* Determine if a sub-directory or FAT32 root directory is specified.  */
                if ((source_dir) || (media_ptr -> fx_media_32_bit_FAT))
 8008d00:	69bb      	ldr	r3, [r7, #24]
 8008d02:	2b00      	cmp	r3, #0
 8008d04:	d103      	bne.n	8008d0e <_fx_directory_entry_read+0x38e>
 8008d06:	69fb      	ldr	r3, [r7, #28]
 8008d08:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8008d0a:	2b00      	cmp	r3, #0
 8008d0c:	d038      	beq.n	8008d80 <_fx_directory_entry_read+0x400>
                {

                    /* Determine the next sector of the directory entry.  */
                    if (relative_sector < (media_ptr -> fx_media_sectors_per_cluster - 1))
 8008d0e:	69fb      	ldr	r3, [r7, #28]
 8008d10:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8008d12:	3b01      	subs	r3, #1
 8008d14:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8008d16:	429a      	cmp	r2, r3
 8008d18:	d206      	bcs.n	8008d28 <_fx_directory_entry_read+0x3a8>
                    {

                        /* More sectors in this cluster.  */

                        /* Simply increment the logical sector.  */
                        logical_sector++;
 8008d1a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8008d1c:	3301      	adds	r3, #1
 8008d1e:	64bb      	str	r3, [r7, #72]	@ 0x48

                        /* Increment the relative sector.  */
                        relative_sector++;
 8008d20:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8008d22:	3301      	adds	r3, #1
 8008d24:	64fb      	str	r3, [r7, #76]	@ 0x4c
                    if (relative_sector < (media_ptr -> fx_media_sectors_per_cluster - 1))
 8008d26:	e038      	b.n	8008d9a <_fx_directory_entry_read+0x41a>
                    {

                        /* We need to move to the next cluster.  */

                        /* Pickup the next cluster.  */
                        status =  _fx_utility_FAT_entry_read(media_ptr, cluster, &next_cluster);
 8008d28:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 8008d2c:	461a      	mov	r2, r3
 8008d2e:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 8008d30:	69f8      	ldr	r0, [r7, #28]
 8008d32:	f005 fe35 	bl	800e9a0 <_fx_utility_FAT_entry_read>
 8008d36:	6378      	str	r0, [r7, #52]	@ 0x34

                        /* Check for I/O error.  */
                        if (status != FX_SUCCESS)
 8008d38:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8008d3a:	2b00      	cmp	r3, #0
 8008d3c:	d001      	beq.n	8008d42 <_fx_directory_entry_read+0x3c2>
                        {

                            /* Return error code.  */
                            return(status);
 8008d3e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8008d40:	e19f      	b.n	8009082 <_fx_directory_entry_read+0x702>
                        }

                        /* Copy next cluster to the current cluster.  */
                        cluster =  next_cluster;
 8008d42:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8008d44:	657b      	str	r3, [r7, #84]	@ 0x54

                        /* Check the value of the new cluster - it must be a valid cluster number
                           or something is really wrong!  */
                        if ((cluster < FX_FAT_ENTRY_START) || (cluster >= media_ptr -> fx_media_fat_reserved))
 8008d46:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8008d48:	2b01      	cmp	r3, #1
 8008d4a:	d907      	bls.n	8008d5c <_fx_directory_entry_read+0x3dc>
 8008d4c:	69fb      	ldr	r3, [r7, #28]
 8008d4e:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 8008d52:	f8d3 3478 	ldr.w	r3, [r3, #1144]	@ 0x478
 8008d56:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8008d58:	429a      	cmp	r2, r3
 8008d5a:	d301      	bcc.n	8008d60 <_fx_directory_entry_read+0x3e0>
                        {

                            /* Send error message back to caller.  */
                            return(FX_FILE_CORRUPT);
 8008d5c:	2308      	movs	r3, #8
 8008d5e:	e190      	b.n	8009082 <_fx_directory_entry_read+0x702>
                        }

                        /* Now increment the relative cluster.  */
                        relative_cluster++;
 8008d60:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8008d62:	3301      	adds	r3, #1
 8008d64:	653b      	str	r3, [r7, #80]	@ 0x50

                        /* Setup the relative sector (this is zero for subsequent cluster.  */
                        relative_sector =  0;
 8008d66:	2300      	movs	r3, #0
 8008d68:	64fb      	str	r3, [r7, #76]	@ 0x4c

                        /* Calculate the next logical sector.  */
                        logical_sector =   ((ULONG)media_ptr -> fx_media_data_sector_start) +
 8008d6a:	69fb      	ldr	r3, [r7, #28]
 8008d6c:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
                            (((ULONG)cluster - FX_FAT_ENTRY_START) *
 8008d6e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8008d70:	3b02      	subs	r3, #2
                             ((ULONG)media_ptr -> fx_media_sectors_per_cluster));
 8008d72:	69f9      	ldr	r1, [r7, #28]
 8008d74:	6d49      	ldr	r1, [r1, #84]	@ 0x54
                            (((ULONG)cluster - FX_FAT_ENTRY_START) *
 8008d76:	fb01 f303 	mul.w	r3, r1, r3
                        logical_sector =   ((ULONG)media_ptr -> fx_media_data_sector_start) +
 8008d7a:	4413      	add	r3, r2
 8008d7c:	64bb      	str	r3, [r7, #72]	@ 0x48
                    if (relative_sector < (media_ptr -> fx_media_sectors_per_cluster - 1))
 8008d7e:	e00c      	b.n	8008d9a <_fx_directory_entry_read+0x41a>
                {

                    /* Non-FAT 32 root directory.  */

                    /* Advance to the next sector.  */
                    logical_sector++;
 8008d80:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8008d82:	3301      	adds	r3, #1
 8008d84:	64bb      	str	r3, [r7, #72]	@ 0x48

                    /* Determine if the logical sector is valid.  */
                    if (logical_sector >= (ULONG)(media_ptr -> fx_media_root_sector_start + media_ptr -> fx_media_root_sectors))
 8008d86:	69fb      	ldr	r3, [r7, #28]
 8008d88:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
 8008d8a:	69fb      	ldr	r3, [r7, #28]
 8008d8c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8008d8e:	4413      	add	r3, r2
 8008d90:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8008d92:	429a      	cmp	r2, r3
 8008d94:	d301      	bcc.n	8008d9a <_fx_directory_entry_read+0x41a>
                    {

                        /* Trying to read past root directory - send error message back to caller.  */
                        return(FX_FILE_CORRUPT);
 8008d96:	2308      	movs	r3, #8
 8008d98:	e173      	b.n	8009082 <_fx_directory_entry_read+0x702>
                    }
                }

                /* Read the new sector.  */
                status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) logical_sector,
 8008d9a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8008d9c:	2200      	movs	r2, #0
 8008d9e:	469a      	mov	sl, r3
 8008da0:	4693      	mov	fp, r2
                                                          media_ptr -> fx_media_memory_buffer, ((ULONG) 1), FX_DIRECTORY_SECTOR);
 8008da2:	69fb      	ldr	r3, [r7, #28]
 8008da4:	689b      	ldr	r3, [r3, #8]
                status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) logical_sector,
 8008da6:	2203      	movs	r2, #3
 8008da8:	9202      	str	r2, [sp, #8]
 8008daa:	2201      	movs	r2, #1
 8008dac:	9201      	str	r2, [sp, #4]
 8008dae:	9300      	str	r3, [sp, #0]
 8008db0:	4652      	mov	r2, sl
 8008db2:	465b      	mov	r3, fp
 8008db4:	69f8      	ldr	r0, [r7, #28]
 8008db6:	f007 fa01 	bl	80101bc <_fx_utility_logical_sector_read>
 8008dba:	6378      	str	r0, [r7, #52]	@ 0x34

                /* Check I/O status.  */
                if (status != FX_SUCCESS)
 8008dbc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8008dbe:	2b00      	cmp	r3, #0
 8008dc0:	d001      	beq.n	8008dc6 <_fx_directory_entry_read+0x446>
                {
                    return(status);
 8008dc2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8008dc4:	e15d      	b.n	8009082 <_fx_directory_entry_read+0x702>
                }

                /* Set the byte offset to 0 for new sector.  */
                byte_offset = 0;
 8008dc6:	2300      	movs	r3, #0
 8008dc8:	647b      	str	r3, [r7, #68]	@ 0x44
 8008dca:	e002      	b.n	8008dd2 <_fx_directory_entry_read+0x452>
            }
            else
            {

                /* Calculate the new byte offset.  */
                byte_offset += FX_DIR_ENTRY_SIZE;
 8008dcc:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8008dce:	3320      	adds	r3, #32
 8008dd0:	647b      	str	r3, [r7, #68]	@ 0x44
            }

            /* Calculate the next read pointer.  */
            read_ptr =  (UCHAR *)media_ptr -> fx_media_memory_buffer + (UINT) byte_offset;
 8008dd2:	69fb      	ldr	r3, [r7, #28]
 8008dd4:	689a      	ldr	r2, [r3, #8]
 8008dd6:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8008dd8:	4413      	add	r3, r2
 8008dda:	643b      	str	r3, [r7, #64]	@ 0x40

            /* Move to the next entry.  */
            entry++;
 8008ddc:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8008dde:	3301      	adds	r3, #1
 8008de0:	63bb      	str	r3, [r7, #56]	@ 0x38
        } while (card > 0);
 8008de2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8008de4:	2b00      	cmp	r3, #0
 8008de6:	f47f af12 	bne.w	8008c0e <_fx_directory_entry_read+0x28e>

        /* Set flag indicating long file name is present.  */
        destination_ptr -> fx_dir_entry_long_name_present = 1;
 8008dea:	693b      	ldr	r3, [r7, #16]
 8008dec:	2201      	movs	r2, #1
 8008dee:	615a      	str	r2, [r3, #20]
 8008df0:	e001      	b.n	8008df6 <_fx_directory_entry_read+0x476>
    }
    else
    {
        /* No long file name is present.  */
        get_short_name = 1;
 8008df2:	2301      	movs	r3, #1
 8008df4:	65bb      	str	r3, [r7, #88]	@ 0x58
    }

    /* Determine if we need to clear the long name flag.  */
    if (get_short_name == 1)
 8008df6:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8008df8:	2b01      	cmp	r3, #1
 8008dfa:	d102      	bne.n	8008e02 <_fx_directory_entry_read+0x482>
    {

        /* Clear the long name flag.  */
        destination_ptr -> fx_dir_entry_long_name_present =  0;
 8008dfc:	693b      	ldr	r3, [r7, #16]
 8008dfe:	2200      	movs	r2, #0
 8008e00:	615a      	str	r2, [r3, #20]
    }

    /* Pickup the short file name.  */
    short_name_ptr[0] =  0;
 8008e02:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8008e04:	2200      	movs	r2, #0
 8008e06:	701a      	strb	r2, [r3, #0]
    dotflag =  0;
 8008e08:	2300      	movs	r3, #0
 8008e0a:	65fb      	str	r3, [r7, #92]	@ 0x5c
    for (i = 0, j = 0; i < (FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE); i++)
 8008e0c:	2300      	movs	r3, #0
 8008e0e:	667b      	str	r3, [r7, #100]	@ 0x64
 8008e10:	2300      	movs	r3, #0
 8008e12:	663b      	str	r3, [r7, #96]	@ 0x60
 8008e14:	e03d      	b.n	8008e92 <_fx_directory_entry_read+0x512>
    {

        /* Check for a NULL.  */
        if ((CHAR)read_ptr[i] == 0)
 8008e16:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8008e18:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8008e1a:	4413      	add	r3, r2
 8008e1c:	781b      	ldrb	r3, [r3, #0]
 8008e1e:	2b00      	cmp	r3, #0
 8008e20:	d03b      	beq.n	8008e9a <_fx_directory_entry_read+0x51a>
            break;
        }

        /* Check for a dot.  This happens for the first two directory entries, no
           extra dot is needed.  */
        if ((CHAR)read_ptr[i] == '.')
 8008e22:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8008e24:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8008e26:	4413      	add	r3, r2
 8008e28:	781b      	ldrb	r3, [r3, #0]
 8008e2a:	2b2e      	cmp	r3, #46	@ 0x2e
 8008e2c:	d101      	bne.n	8008e32 <_fx_directory_entry_read+0x4b2>
        {
            dotflag =  2;
 8008e2e:	2302      	movs	r3, #2
 8008e30:	65fb      	str	r3, [r7, #92]	@ 0x5c
        }

        /* Check for a space.  */
        if ((CHAR)read_ptr[i] == ' ')
 8008e32:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8008e34:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8008e36:	4413      	add	r3, r2
 8008e38:	781b      	ldrb	r3, [r3, #0]
 8008e3a:	2b20      	cmp	r3, #32
 8008e3c:	d105      	bne.n	8008e4a <_fx_directory_entry_read+0x4ca>
        {
            /* Put a dot if a character comes after space.  */
            if (dotflag == 0)
 8008e3e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8008e40:	2b00      	cmp	r3, #0
 8008e42:	d122      	bne.n	8008e8a <_fx_directory_entry_read+0x50a>
            {
                dotflag =  1;
 8008e44:	2301      	movs	r3, #1
 8008e46:	65fb      	str	r3, [r7, #92]	@ 0x5c
            }
            continue;
 8008e48:	e01f      	b.n	8008e8a <_fx_directory_entry_read+0x50a>
        }

        /* Check for the main short file name size.  */
        if (i == FX_DIR_NAME_SIZE)
 8008e4a:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8008e4c:	2b08      	cmp	r3, #8
 8008e4e:	d104      	bne.n	8008e5a <_fx_directory_entry_read+0x4da>
        {
            /* Check to see if we need to insert a dot.  */
            if (dotflag == 0)
 8008e50:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8008e52:	2b00      	cmp	r3, #0
 8008e54:	d101      	bne.n	8008e5a <_fx_directory_entry_read+0x4da>
            {
                dotflag =  1;
 8008e56:	2301      	movs	r3, #1
 8008e58:	65fb      	str	r3, [r7, #92]	@ 0x5c
            }
        }

        /* Check to see if we need to add a dot.  */
        if (dotflag == 1)
 8008e5a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8008e5c:	2b01      	cmp	r3, #1
 8008e5e:	d108      	bne.n	8008e72 <_fx_directory_entry_read+0x4f2>
        {
            /* Add dot to short file name.  */
            short_name_ptr[j++] =  '.';
 8008e60:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8008e62:	1c5a      	adds	r2, r3, #1
 8008e64:	663a      	str	r2, [r7, #96]	@ 0x60
 8008e66:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8008e68:	4413      	add	r3, r2
 8008e6a:	222e      	movs	r2, #46	@ 0x2e
 8008e6c:	701a      	strb	r2, [r3, #0]
            dotflag =  2;    /* no more dot for spaces */
 8008e6e:	2302      	movs	r3, #2
 8008e70:	65fb      	str	r3, [r7, #92]	@ 0x5c
        }

        /* Copy a character.  */
        short_name_ptr[j] =  (CHAR)read_ptr[i];
 8008e72:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8008e74:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8008e76:	441a      	add	r2, r3
 8008e78:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 8008e7a:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8008e7c:	440b      	add	r3, r1
 8008e7e:	7812      	ldrb	r2, [r2, #0]
 8008e80:	701a      	strb	r2, [r3, #0]

        /* Increment size.  */
        j++;
 8008e82:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8008e84:	3301      	adds	r3, #1
 8008e86:	663b      	str	r3, [r7, #96]	@ 0x60
 8008e88:	e000      	b.n	8008e8c <_fx_directory_entry_read+0x50c>
            continue;
 8008e8a:	bf00      	nop
    for (i = 0, j = 0; i < (FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE); i++)
 8008e8c:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8008e8e:	3301      	adds	r3, #1
 8008e90:	667b      	str	r3, [r7, #100]	@ 0x64
 8008e92:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8008e94:	2b0a      	cmp	r3, #10
 8008e96:	d9be      	bls.n	8008e16 <_fx_directory_entry_read+0x496>
 8008e98:	e000      	b.n	8008e9c <_fx_directory_entry_read+0x51c>
            break;
 8008e9a:	bf00      	nop
    }

    /* Determine if a long file name is present and its associated short file
       name is actually free.  */
    if ((destination_ptr -> fx_dir_entry_long_name_present) && (((UCHAR)short_name_ptr[0]) == (UCHAR)FX_DIR_ENTRY_FREE))
 8008e9c:	693b      	ldr	r3, [r7, #16]
 8008e9e:	695b      	ldr	r3, [r3, #20]
 8008ea0:	2b00      	cmp	r3, #0
 8008ea2:	d00a      	beq.n	8008eba <_fx_directory_entry_read+0x53a>
 8008ea4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8008ea6:	781b      	ldrb	r3, [r3, #0]
 8008ea8:	2be5      	cmp	r3, #229	@ 0xe5
 8008eaa:	d106      	bne.n	8008eba <_fx_directory_entry_read+0x53a>
    {

        /* Yes, the short file name is really free even though long file name entries directly precede it.
           In this case, simply place the free directory marker at the front of the long file name.  */
        destination_ptr -> fx_dir_entry_name[0] =  (CHAR)FX_DIR_ENTRY_FREE;
 8008eac:	693b      	ldr	r3, [r7, #16]
 8008eae:	681b      	ldr	r3, [r3, #0]
 8008eb0:	22e5      	movs	r2, #229	@ 0xe5
 8008eb2:	701a      	strb	r2, [r3, #0]
        short_name_ptr[0] =  (CHAR)0;
 8008eb4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8008eb6:	2200      	movs	r2, #0
 8008eb8:	701a      	strb	r2, [r3, #0]
    }

    /* Determine if the short name pointer is NULL while the read pointer is
       non-NULL.  */
    if ((short_name_ptr[0] == 0) && (read_ptr[0] == ' '))
 8008eba:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8008ebc:	781b      	ldrb	r3, [r3, #0]
 8008ebe:	2b00      	cmp	r3, #0
 8008ec0:	d114      	bne.n	8008eec <_fx_directory_entry_read+0x56c>
 8008ec2:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8008ec4:	781b      	ldrb	r3, [r3, #0]
 8008ec6:	2b20      	cmp	r3, #32
 8008ec8:	d110      	bne.n	8008eec <_fx_directory_entry_read+0x56c>
    {

        /* This condition can occur with an all blank volume name.  Simply
           copy the volume name to the short name in this case.  */
        for (j = 0; j < (FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE); j++)
 8008eca:	2300      	movs	r3, #0
 8008ecc:	663b      	str	r3, [r7, #96]	@ 0x60
 8008ece:	e00a      	b.n	8008ee6 <_fx_directory_entry_read+0x566>
        {

            /* Copy a byte of the volume name.  */
            short_name_ptr[j] =  (CHAR)read_ptr[j];
 8008ed0:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8008ed2:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8008ed4:	441a      	add	r2, r3
 8008ed6:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 8008ed8:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8008eda:	440b      	add	r3, r1
 8008edc:	7812      	ldrb	r2, [r2, #0]
 8008ede:	701a      	strb	r2, [r3, #0]
        for (j = 0; j < (FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE); j++)
 8008ee0:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8008ee2:	3301      	adds	r3, #1
 8008ee4:	663b      	str	r3, [r7, #96]	@ 0x60
 8008ee6:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8008ee8:	2b0a      	cmp	r3, #10
 8008eea:	d9f1      	bls.n	8008ed0 <_fx_directory_entry_read+0x550>
        }
    }

    /* Set end of string to null.  */
    short_name_ptr[j] = 0;
 8008eec:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8008eee:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8008ef0:	4413      	add	r3, r2
 8008ef2:	2200      	movs	r2, #0
 8008ef4:	701a      	strb	r2, [r3, #0]

    /* Load up the destination directory entry.  */
    read_ptr += (FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE);
 8008ef6:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8008ef8:	330b      	adds	r3, #11
 8008efa:	643b      	str	r3, [r7, #64]	@ 0x40

    /* Copy the attribute into the destination.  */
    destination_ptr -> fx_dir_entry_attributes =  *read_ptr++;
 8008efc:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8008efe:	1c5a      	adds	r2, r3, #1
 8008f00:	643a      	str	r2, [r7, #64]	@ 0x40
 8008f02:	781a      	ldrb	r2, [r3, #0]
 8008f04:	693b      	ldr	r3, [r7, #16]
 8008f06:	771a      	strb	r2, [r3, #28]

    /* Pickup the reserved byte.  */
    destination_ptr -> fx_dir_entry_reserved =  *read_ptr++;
 8008f08:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8008f0a:	1c5a      	adds	r2, r3, #1
 8008f0c:	643a      	str	r2, [r7, #64]	@ 0x40
 8008f0e:	781a      	ldrb	r2, [r3, #0]
 8008f10:	693b      	ldr	r3, [r7, #16]
 8008f12:	775a      	strb	r2, [r3, #29]
         BIT3 - set if 8.3 is all in lower case and no extended filename.
         BIT4 - set for file, clear for directory entry if no extended filename.

       This is true for all NT systems. Prior to NT follows MSDOS FAT documentation and
       is set to 0x00, all bits cleared. Therefore if BIT3 is set force lowercase.  */
    if ((get_short_name) && (destination_ptr -> fx_dir_entry_reserved & 0x08))
 8008f14:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8008f16:	2b00      	cmp	r3, #0
 8008f18:	d02a      	beq.n	8008f70 <_fx_directory_entry_read+0x5f0>
 8008f1a:	693b      	ldr	r3, [r7, #16]
 8008f1c:	7f5b      	ldrb	r3, [r3, #29]
 8008f1e:	f003 0308 	and.w	r3, r3, #8
 8008f22:	2b00      	cmp	r3, #0
 8008f24:	d024      	beq.n	8008f70 <_fx_directory_entry_read+0x5f0>
    {

        /* Microsoft undocumented NT file name feature... convert short name to lower
           case.  */
        for (j = 0; j <= (FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE) && (short_name_ptr[j] != 0x00); j++)
 8008f26:	2300      	movs	r3, #0
 8008f28:	663b      	str	r3, [r7, #96]	@ 0x60
 8008f2a:	e018      	b.n	8008f5e <_fx_directory_entry_read+0x5de>
        {

            /* Determine if an upper case character is present.  */
            if ((short_name_ptr[j] >= 'A') && (short_name_ptr[j] <= 'Z'))
 8008f2c:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8008f2e:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8008f30:	4413      	add	r3, r2
 8008f32:	781b      	ldrb	r3, [r3, #0]
 8008f34:	2b40      	cmp	r3, #64	@ 0x40
 8008f36:	d90f      	bls.n	8008f58 <_fx_directory_entry_read+0x5d8>
 8008f38:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8008f3a:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8008f3c:	4413      	add	r3, r2
 8008f3e:	781b      	ldrb	r3, [r3, #0]
 8008f40:	2b5a      	cmp	r3, #90	@ 0x5a
 8008f42:	d809      	bhi.n	8008f58 <_fx_directory_entry_read+0x5d8>
            {

                /* Yes, an upper case character is present. Force it to lower case.  */
                short_name_ptr[j] =  (CHAR)(short_name_ptr[j] + 32);
 8008f44:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8008f46:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8008f48:	4413      	add	r3, r2
 8008f4a:	781a      	ldrb	r2, [r3, #0]
 8008f4c:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 8008f4e:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8008f50:	440b      	add	r3, r1
 8008f52:	3220      	adds	r2, #32
 8008f54:	b2d2      	uxtb	r2, r2
 8008f56:	701a      	strb	r2, [r3, #0]
        for (j = 0; j <= (FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE) && (short_name_ptr[j] != 0x00); j++)
 8008f58:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8008f5a:	3301      	adds	r3, #1
 8008f5c:	663b      	str	r3, [r7, #96]	@ 0x60
 8008f5e:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8008f60:	2b0b      	cmp	r3, #11
 8008f62:	d805      	bhi.n	8008f70 <_fx_directory_entry_read+0x5f0>
 8008f64:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8008f66:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8008f68:	4413      	add	r3, r2
 8008f6a:	781b      	ldrb	r3, [r3, #0]
 8008f6c:	2b00      	cmp	r3, #0
 8008f6e:	d1dd      	bne.n	8008f2c <_fx_directory_entry_read+0x5ac>
            }
        }
    }

    /* Pickup the created time in milliseconds.  */
    destination_ptr -> fx_dir_entry_created_time_ms =  *read_ptr++;
 8008f70:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8008f72:	1c5a      	adds	r2, r3, #1
 8008f74:	643a      	str	r2, [r7, #64]	@ 0x40
 8008f76:	781a      	ldrb	r2, [r3, #0]
 8008f78:	693b      	ldr	r3, [r7, #16]
 8008f7a:	779a      	strb	r2, [r3, #30]

    /* Pickup the created time.  */
    destination_ptr -> fx_dir_entry_created_time =  _fx_utility_16_unsigned_read(read_ptr);
 8008f7c:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 8008f7e:	f005 fca9 	bl	800e8d4 <_fx_utility_16_unsigned_read>
 8008f82:	4602      	mov	r2, r0
 8008f84:	693b      	ldr	r3, [r7, #16]
 8008f86:	621a      	str	r2, [r3, #32]
    read_ptr =  read_ptr + 2;  /* Always 2 bytes */
 8008f88:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8008f8a:	3302      	adds	r3, #2
 8008f8c:	643b      	str	r3, [r7, #64]	@ 0x40

    /* Pickup the created date.  */
    destination_ptr -> fx_dir_entry_created_date =  _fx_utility_16_unsigned_read(read_ptr);
 8008f8e:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 8008f90:	f005 fca0 	bl	800e8d4 <_fx_utility_16_unsigned_read>
 8008f94:	4602      	mov	r2, r0
 8008f96:	693b      	ldr	r3, [r7, #16]
 8008f98:	625a      	str	r2, [r3, #36]	@ 0x24
    read_ptr =  read_ptr + 2;  /* Always 2 bytes */
 8008f9a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8008f9c:	3302      	adds	r3, #2
 8008f9e:	643b      	str	r3, [r7, #64]	@ 0x40

    /* Pickup the last accessed date.  */
    destination_ptr -> fx_dir_entry_last_accessed_date =  _fx_utility_16_unsigned_read(read_ptr);
 8008fa0:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 8008fa2:	f005 fc97 	bl	800e8d4 <_fx_utility_16_unsigned_read>
 8008fa6:	4602      	mov	r2, r0
 8008fa8:	693b      	ldr	r3, [r7, #16]
 8008faa:	629a      	str	r2, [r3, #40]	@ 0x28
    read_ptr =  read_ptr + 2;  /* Always 2 bytes */
 8008fac:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8008fae:	3302      	adds	r3, #2
 8008fb0:	643b      	str	r3, [r7, #64]	@ 0x40

    /* read the upper 2 bytes of starting cluster - required only for 32 bit FAT */
    if (media_ptr -> fx_media_32_bit_FAT)
 8008fb2:	69fb      	ldr	r3, [r7, #28]
 8008fb4:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8008fb6:	2b00      	cmp	r3, #0
 8008fb8:	d00b      	beq.n	8008fd2 <_fx_directory_entry_read+0x652>
    {

        /* FAT32 only.  */
        destination_ptr -> fx_dir_entry_cluster =  _fx_utility_16_unsigned_read(read_ptr);
 8008fba:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 8008fbc:	f005 fc8a 	bl	800e8d4 <_fx_utility_16_unsigned_read>
 8008fc0:	4602      	mov	r2, r0
 8008fc2:	693b      	ldr	r3, [r7, #16]
 8008fc4:	635a      	str	r2, [r3, #52]	@ 0x34
        destination_ptr -> fx_dir_entry_cluster <<= 16;
 8008fc6:	693b      	ldr	r3, [r7, #16]
 8008fc8:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8008fca:	041a      	lsls	r2, r3, #16
 8008fcc:	693b      	ldr	r3, [r7, #16]
 8008fce:	635a      	str	r2, [r3, #52]	@ 0x34
 8008fd0:	e002      	b.n	8008fd8 <_fx_directory_entry_read+0x658>
    }
    else
    {
        /* Not required for non FAT32.  */
        destination_ptr -> fx_dir_entry_cluster =  0;
 8008fd2:	693b      	ldr	r3, [r7, #16]
 8008fd4:	2200      	movs	r2, #0
 8008fd6:	635a      	str	r2, [r3, #52]	@ 0x34
    }

    /* Advance the read pointer.  */
    read_ptr =  read_ptr + 2;  /* Always 2 bytes */
 8008fd8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8008fda:	3302      	adds	r3, #2
 8008fdc:	643b      	str	r3, [r7, #64]	@ 0x40

    /* Copy the time into the destination.  */
    destination_ptr -> fx_dir_entry_time =  _fx_utility_16_unsigned_read(read_ptr);
 8008fde:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 8008fe0:	f005 fc78 	bl	800e8d4 <_fx_utility_16_unsigned_read>
 8008fe4:	4602      	mov	r2, r0
 8008fe6:	693b      	ldr	r3, [r7, #16]
 8008fe8:	62da      	str	r2, [r3, #44]	@ 0x2c
    read_ptr =  read_ptr + 2;  /* Always 2 bytes */
 8008fea:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8008fec:	3302      	adds	r3, #2
 8008fee:	643b      	str	r3, [r7, #64]	@ 0x40

    /* Copy the date into the destination.  */
    destination_ptr -> fx_dir_entry_date =  _fx_utility_16_unsigned_read(read_ptr);
 8008ff0:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 8008ff2:	f005 fc6f 	bl	800e8d4 <_fx_utility_16_unsigned_read>
 8008ff6:	4602      	mov	r2, r0
 8008ff8:	693b      	ldr	r3, [r7, #16]
 8008ffa:	631a      	str	r2, [r3, #48]	@ 0x30
    read_ptr =  read_ptr + 2;  /* Always 2 bytes */
 8008ffc:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8008ffe:	3302      	adds	r3, #2
 8009000:	643b      	str	r3, [r7, #64]	@ 0x40

    /* Copy the starting cluster into the destination.  */
    destination_ptr -> fx_dir_entry_cluster +=  _fx_utility_16_unsigned_read(read_ptr);
 8009002:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 8009004:	f005 fc66 	bl	800e8d4 <_fx_utility_16_unsigned_read>
 8009008:	4602      	mov	r2, r0
 800900a:	693b      	ldr	r3, [r7, #16]
 800900c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800900e:	441a      	add	r2, r3
 8009010:	693b      	ldr	r3, [r7, #16]
 8009012:	635a      	str	r2, [r3, #52]	@ 0x34
    read_ptr =  read_ptr + 2;  /* Always 2 bytes */
 8009014:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8009016:	3302      	adds	r3, #2
 8009018:	643b      	str	r3, [r7, #64]	@ 0x40

    /* Copy the file size into the destination.  */
    destination_ptr -> fx_dir_entry_file_size =  _fx_utility_32_unsigned_read(read_ptr);
 800901a:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 800901c:	f005 fc82 	bl	800e924 <_fx_utility_32_unsigned_read>
 8009020:	4603      	mov	r3, r0
 8009022:	2200      	movs	r2, #0
 8009024:	461c      	mov	r4, r3
 8009026:	4615      	mov	r5, r2
 8009028:	693b      	ldr	r3, [r7, #16]
 800902a:	e9c3 450e 	strd	r4, r5, [r3, #56]	@ 0x38

    /* Clear the destination search specific fields.  */
    destination_ptr -> fx_dir_entry_last_search_cluster =           0;
 800902e:	693b      	ldr	r3, [r7, #16]
 8009030:	2200      	movs	r2, #0
 8009032:	651a      	str	r2, [r3, #80]	@ 0x50
    destination_ptr -> fx_dir_entry_last_search_relative_cluster =  0;
 8009034:	693b      	ldr	r3, [r7, #16]
 8009036:	2200      	movs	r2, #0
 8009038:	655a      	str	r2, [r3, #84]	@ 0x54
    destination_ptr -> fx_dir_entry_last_search_log_sector =        0;
 800903a:	6939      	ldr	r1, [r7, #16]
 800903c:	f04f 0200 	mov.w	r2, #0
 8009040:	f04f 0300 	mov.w	r3, #0
 8009044:	e9c1 2316 	strd	r2, r3, [r1, #88]	@ 0x58
    destination_ptr -> fx_dir_entry_last_search_byte_offset =       0;
 8009048:	693b      	ldr	r3, [r7, #16]
 800904a:	2200      	movs	r2, #0
 800904c:	661a      	str	r2, [r3, #96]	@ 0x60

    /* Remember the entry number.  */
    destination_ptr -> fx_dir_entry_number =  entry;
 800904e:	693b      	ldr	r3, [r7, #16]
 8009050:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8009052:	64da      	str	r2, [r3, #76]	@ 0x4c

    /* Return entry number.  */
    *entry_ptr =  entry;
 8009054:	697b      	ldr	r3, [r7, #20]
 8009056:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8009058:	601a      	str	r2, [r3, #0]

    /* Determine if we should remember the last cluster and relative cluster.  */
    if (source_dir)
 800905a:	69bb      	ldr	r3, [r7, #24]
 800905c:	2b00      	cmp	r3, #0
 800905e:	d00f      	beq.n	8009080 <_fx_directory_entry_read+0x700>
    {

        /* Yes, remember the last cluster and relative cluster for a subsequent call
           to read a directory entry.  */
        source_dir -> fx_dir_entry_last_search_cluster =           cluster;
 8009060:	69bb      	ldr	r3, [r7, #24]
 8009062:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8009064:	651a      	str	r2, [r3, #80]	@ 0x50
        source_dir -> fx_dir_entry_last_search_relative_cluster =  relative_cluster;
 8009066:	69bb      	ldr	r3, [r7, #24]
 8009068:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 800906a:	655a      	str	r2, [r3, #84]	@ 0x54

        /* Also remember several other items that are unique to the directory... just to verify that the
           search information can be used.  */
        source_dir -> fx_dir_entry_last_search_log_sector =        source_dir -> fx_dir_entry_log_sector;
 800906c:	69bb      	ldr	r3, [r7, #24]
 800906e:	e9d3 2310 	ldrd	r2, r3, [r3, #64]	@ 0x40
 8009072:	69b9      	ldr	r1, [r7, #24]
 8009074:	e9c1 2316 	strd	r2, r3, [r1, #88]	@ 0x58
        source_dir -> fx_dir_entry_last_search_byte_offset =       source_dir -> fx_dir_entry_byte_offset;
 8009078:	69bb      	ldr	r3, [r7, #24]
 800907a:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
 800907c:	69bb      	ldr	r3, [r7, #24]
 800907e:	661a      	str	r2, [r3, #96]	@ 0x60
        destination_ptr -> fx_dir_entry_type = FX_EXFAT_DIR_ENTRY_TYPE_FILE_DIRECTORY;
    }
#endif /* FX_ENABLE_EXFAT */

    /* Return success to the caller.  */
    return(FX_SUCCESS);
 8009080:	2300      	movs	r3, #0
}
 8009082:	4618      	mov	r0, r3
 8009084:	3768      	adds	r7, #104	@ 0x68
 8009086:	46bd      	mov	sp, r7
 8009088:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

0800908c <_fx_directory_entry_write>:
/*  03-02-2021     William E. Lamie         Modified comment(s),          */
/*                                            resulting in version 6.1.5  */
/*                                                                        */
/**************************************************************************/
UINT  _fx_directory_entry_write(FX_MEDIA *media_ptr, FX_DIR_ENTRY *entry_ptr)
{
 800908c:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8009090:	b0a2      	sub	sp, #136	@ 0x88
 8009092:	af04      	add	r7, sp, #16
 8009094:	6178      	str	r0, [r7, #20]
 8009096:	6139      	str	r1, [r7, #16]


#ifndef FX_MEDIA_STATISTICS_DISABLE

    /* Increment the number of directory entry write requests.  */
    media_ptr -> fx_media_directory_entry_writes++;
 8009098:	697b      	ldr	r3, [r7, #20]
 800909a:	f8d3 316c 	ldr.w	r3, [r3, #364]	@ 0x16c
 800909e:	1c5a      	adds	r2, r3, #1
 80090a0:	697b      	ldr	r3, [r7, #20]
 80090a2:	f8c3 216c 	str.w	r2, [r3, #364]	@ 0x16c

    /* If trace is enabled, insert this event into the trace buffer.  */
    FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_DIR_ENTRY_WRITE, media_ptr, 0, 0, 0, FX_TRACE_INTERNAL_EVENTS, 0, 0)

    /* Determine if this is entry is being deleted.  */
    if (((UCHAR)entry_ptr -> fx_dir_entry_name[0] == (UCHAR)FX_DIR_ENTRY_FREE) &&
 80090a6:	693b      	ldr	r3, [r7, #16]
 80090a8:	681b      	ldr	r3, [r3, #0]
 80090aa:	781b      	ldrb	r3, [r3, #0]
 80090ac:	2be5      	cmp	r3, #229	@ 0xe5
 80090ae:	d109      	bne.n	80090c4 <_fx_directory_entry_write+0x38>
        ((UCHAR)entry_ptr -> fx_dir_entry_short_name[0] == (UCHAR)FX_DIR_ENTRY_FREE))
 80090b0:	693b      	ldr	r3, [r7, #16]
 80090b2:	791b      	ldrb	r3, [r3, #4]
    if (((UCHAR)entry_ptr -> fx_dir_entry_name[0] == (UCHAR)FX_DIR_ENTRY_FREE) &&
 80090b4:	2be5      	cmp	r3, #229	@ 0xe5
 80090b6:	d105      	bne.n	80090c4 <_fx_directory_entry_write+0x38>
    {

        /* Yes, this is a request to delete the entry. Set the flag to remember this.  */
        delete_flag =  FX_TRUE;
 80090b8:	2301      	movs	r3, #1
 80090ba:	66bb      	str	r3, [r7, #104]	@ 0x68

        /* Null the short file name.  */
        entry_ptr -> fx_dir_entry_short_name[0] =  0;
 80090bc:	693b      	ldr	r3, [r7, #16]
 80090be:	2200      	movs	r2, #0
 80090c0:	711a      	strb	r2, [r3, #4]
 80090c2:	e001      	b.n	80090c8 <_fx_directory_entry_write+0x3c>
    }
    else
    {

        /* Not a deleted entry. Set the flag to false.  */
        delete_flag =  FX_FALSE;
 80090c4:	2300      	movs	r3, #0
 80090c6:	66bb      	str	r3, [r7, #104]	@ 0x68
    }

    /* Pickup the byte offset of the entry.  */
    byte_offset = entry_ptr -> fx_dir_entry_byte_offset;
 80090c8:	693b      	ldr	r3, [r7, #16]
 80090ca:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 80090cc:	637b      	str	r3, [r7, #52]	@ 0x34

    /* Pickup the logical sector of the entry.  */
    logical_sector = (ULONG)entry_ptr -> fx_dir_entry_log_sector;
 80090ce:	693b      	ldr	r3, [r7, #16]
 80090d0:	e9d3 2310 	ldrd	r2, r3, [r3, #64]	@ 0x40
 80090d4:	4613      	mov	r3, r2
 80090d6:	63fb      	str	r3, [r7, #60]	@ 0x3c

    /* Figure out where what cluster we are in.  */
    if (logical_sector >= (ULONG)(media_ptr -> fx_media_data_sector_start))
 80090d8:	697b      	ldr	r3, [r7, #20]
 80090da:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 80090dc:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 80090de:	429a      	cmp	r2, r3
 80090e0:	d316      	bcc.n	8009110 <_fx_directory_entry_write+0x84>
    {

        /* Calculate the cluster that this logical sector is in.  */
        cluster =  (logical_sector - media_ptr -> fx_media_data_sector_start) / (media_ptr -> fx_media_sectors_per_cluster) + FX_FAT_ENTRY_START;
 80090e2:	697b      	ldr	r3, [r7, #20]
 80090e4:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 80090e6:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 80090e8:	1ad2      	subs	r2, r2, r3
 80090ea:	697b      	ldr	r3, [r7, #20]
 80090ec:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 80090ee:	fbb2 f3f3 	udiv	r3, r2, r3
 80090f2:	3302      	adds	r3, #2
 80090f4:	633b      	str	r3, [r7, #48]	@ 0x30

        /* Calculate the relative cluster.  */
        relative_sector =  logical_sector -  (((ULONG)media_ptr -> fx_media_data_sector_start) +
 80090f6:	697b      	ldr	r3, [r7, #20]
 80090f8:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
                                              (((ULONG)cluster - FX_FAT_ENTRY_START) *
 80090fa:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80090fc:	3b02      	subs	r3, #2
                                               ((ULONG)media_ptr -> fx_media_sectors_per_cluster)));
 80090fe:	6979      	ldr	r1, [r7, #20]
 8009100:	6d49      	ldr	r1, [r1, #84]	@ 0x54
                                              (((ULONG)cluster - FX_FAT_ENTRY_START) *
 8009102:	fb01 f303 	mul.w	r3, r1, r3
        relative_sector =  logical_sector -  (((ULONG)media_ptr -> fx_media_data_sector_start) +
 8009106:	4413      	add	r3, r2
 8009108:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 800910a:	1ad3      	subs	r3, r2, r3
 800910c:	63bb      	str	r3, [r7, #56]	@ 0x38
 800910e:	e003      	b.n	8009118 <_fx_directory_entry_write+0x8c>
    }
    else
    {

        /* Clear the cluster and the relative sector.  */
        cluster =  0;
 8009110:	2300      	movs	r3, #0
 8009112:	633b      	str	r3, [r7, #48]	@ 0x30
        relative_sector =  0;
 8009114:	2300      	movs	r3, #0
 8009116:	63bb      	str	r3, [r7, #56]	@ 0x38
    }

    /* Read the logical directory sector.  */
    status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) entry_ptr -> fx_dir_entry_log_sector,
 8009118:	693b      	ldr	r3, [r7, #16]
 800911a:	e9d3 0110 	ldrd	r0, r1, [r3, #64]	@ 0x40
                                              media_ptr -> fx_media_memory_buffer, ((ULONG) 1), FX_DIRECTORY_SECTOR);
 800911e:	697b      	ldr	r3, [r7, #20]
 8009120:	689a      	ldr	r2, [r3, #8]
    status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) entry_ptr -> fx_dir_entry_log_sector,
 8009122:	2303      	movs	r3, #3
 8009124:	9302      	str	r3, [sp, #8]
 8009126:	2301      	movs	r3, #1
 8009128:	9301      	str	r3, [sp, #4]
 800912a:	9200      	str	r2, [sp, #0]
 800912c:	4602      	mov	r2, r0
 800912e:	460b      	mov	r3, r1
 8009130:	6978      	ldr	r0, [r7, #20]
 8009132:	f007 f843 	bl	80101bc <_fx_utility_logical_sector_read>
 8009136:	62f8      	str	r0, [r7, #44]	@ 0x2c

    /* Determine if an error occurred.  */
    if (status != FX_SUCCESS)
 8009138:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800913a:	2b00      	cmp	r3, #0
 800913c:	d002      	beq.n	8009144 <_fx_directory_entry_write+0xb8>
    {

        /* Return the error status.  */
        return(status);
 800913e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8009140:	f000 bdda 	b.w	8009cf8 <_fx_directory_entry_write+0xc6c>
    }

    /* Setup a pointer into the buffer.  */
    sector_base_ptr = (UCHAR *)media_ptr -> fx_media_memory_buffer;
 8009144:	697b      	ldr	r3, [r7, #20]
 8009146:	689b      	ldr	r3, [r3, #8]
 8009148:	673b      	str	r3, [r7, #112]	@ 0x70
    work_ptr =  sector_base_ptr + (UINT)entry_ptr -> fx_dir_entry_byte_offset;
 800914a:	693b      	ldr	r3, [r7, #16]
 800914c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 800914e:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 8009150:	4413      	add	r3, r2
 8009152:	677b      	str	r3, [r7, #116]	@ 0x74
    changed_size = 0;
    changed_offset = entry_ptr -> fx_dir_entry_byte_offset;
#endif /* FX_ENABLE_FAULT_TOLERANT */

    /* Determine if a long file name is present.  */
    if (entry_ptr -> fx_dir_entry_long_name_present)
 8009154:	693b      	ldr	r3, [r7, #16]
 8009156:	695b      	ldr	r3, [r3, #20]
 8009158:	2b00      	cmp	r3, #0
 800915a:	f000 83cc 	beq.w	80098f6 <_fx_directory_entry_write+0x86a>
    {

        /* Yes, long name is present - prepare short name and write out this name.  */
        for (len = 0, i = 0, dotpos = 0, dotfound = 0; entry_ptr -> fx_dir_entry_name[len]; len++)
 800915e:	2300      	movs	r3, #0
 8009160:	653b      	str	r3, [r7, #80]	@ 0x50
 8009162:	2300      	movs	r3, #0
 8009164:	667b      	str	r3, [r7, #100]	@ 0x64
 8009166:	2300      	movs	r3, #0
 8009168:	64bb      	str	r3, [r7, #72]	@ 0x48
 800916a:	2300      	movs	r3, #0
 800916c:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800916e:	e02c      	b.n	80091ca <_fx_directory_entry_write+0x13e>
        {

            /* Check for a dot.  */
            if (entry_ptr -> fx_dir_entry_name[len] == '.')
 8009170:	693b      	ldr	r3, [r7, #16]
 8009172:	681a      	ldr	r2, [r3, #0]
 8009174:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8009176:	4413      	add	r3, r2
 8009178:	781b      	ldrb	r3, [r3, #0]
 800917a:	2b2e      	cmp	r3, #46	@ 0x2e
 800917c:	d108      	bne.n	8009190 <_fx_directory_entry_write+0x104>
            {

                /* Check for leading dot. */
                if (len == 0)
 800917e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8009180:	2b00      	cmp	r3, #0
 8009182:	d01e      	beq.n	80091c2 <_fx_directory_entry_write+0x136>
                    continue;
                }

                /* Yes, a dot is present.  From this position the extension will
                   be written.  */
                dotfound = i;
 8009184:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8009186:	64fb      	str	r3, [r7, #76]	@ 0x4c
                dotpos   = len + 1;
 8009188:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800918a:	3301      	adds	r3, #1
 800918c:	64bb      	str	r3, [r7, #72]	@ 0x48
                continue;
 800918e:	e019      	b.n	80091c4 <_fx_directory_entry_write+0x138>
            }

            /* Check for non-space and within the short file name length.  */
            if ((entry_ptr -> fx_dir_entry_name[len] != ' ') && (i < 8))
 8009190:	693b      	ldr	r3, [r7, #16]
 8009192:	681a      	ldr	r2, [r3, #0]
 8009194:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8009196:	4413      	add	r3, r2
 8009198:	781b      	ldrb	r3, [r3, #0]
 800919a:	2b20      	cmp	r3, #32
 800919c:	d012      	beq.n	80091c4 <_fx_directory_entry_write+0x138>
 800919e:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80091a0:	2b07      	cmp	r3, #7
 80091a2:	d80f      	bhi.n	80091c4 <_fx_directory_entry_write+0x138>
            {

                /* Copy characters into the short file name area.  */
                shortname[i] = entry_ptr -> fx_dir_entry_name[len];
 80091a4:	693b      	ldr	r3, [r7, #16]
 80091a6:	681a      	ldr	r2, [r3, #0]
 80091a8:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80091aa:	4413      	add	r3, r2
 80091ac:	7819      	ldrb	r1, [r3, #0]
 80091ae:	f107 021c 	add.w	r2, r7, #28
 80091b2:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80091b4:	4413      	add	r3, r2
 80091b6:	460a      	mov	r2, r1
 80091b8:	701a      	strb	r2, [r3, #0]
                i++;
 80091ba:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80091bc:	3301      	adds	r3, #1
 80091be:	667b      	str	r3, [r7, #100]	@ 0x64
 80091c0:	e000      	b.n	80091c4 <_fx_directory_entry_write+0x138>
                    continue;
 80091c2:	bf00      	nop
        for (len = 0, i = 0, dotpos = 0, dotfound = 0; entry_ptr -> fx_dir_entry_name[len]; len++)
 80091c4:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80091c6:	3301      	adds	r3, #1
 80091c8:	653b      	str	r3, [r7, #80]	@ 0x50
 80091ca:	693b      	ldr	r3, [r7, #16]
 80091cc:	681a      	ldr	r2, [r3, #0]
 80091ce:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80091d0:	4413      	add	r3, r2
 80091d2:	781b      	ldrb	r3, [r3, #0]
 80091d4:	2b00      	cmp	r3, #0
 80091d6:	d1cb      	bne.n	8009170 <_fx_directory_entry_write+0xe4>
            }
        }

        /* Fill remaining short file name with spaces.  */
        for (j = i; j < FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE; j++)
 80091d8:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80091da:	663b      	str	r3, [r7, #96]	@ 0x60
 80091dc:	e008      	b.n	80091f0 <_fx_directory_entry_write+0x164>
        {
            shortname[j] =  ' ';
 80091de:	f107 021c 	add.w	r2, r7, #28
 80091e2:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80091e4:	4413      	add	r3, r2
 80091e6:	2220      	movs	r2, #32
 80091e8:	701a      	strb	r2, [r3, #0]
        for (j = i; j < FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE; j++)
 80091ea:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80091ec:	3301      	adds	r3, #1
 80091ee:	663b      	str	r3, [r7, #96]	@ 0x60
 80091f0:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80091f2:	2b0a      	cmp	r3, #10
 80091f4:	d9f3      	bls.n	80091de <_fx_directory_entry_write+0x152>
        }

        /* Determine if a dot was encountered.  */
        if (dotpos)
 80091f6:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80091f8:	2b00      	cmp	r3, #0
 80091fa:	d03e      	beq.n	800927a <_fx_directory_entry_write+0x1ee>
        {

            /* Process relative to the dot position.  */
            if (entry_ptr -> fx_dir_entry_name[dotpos])
 80091fc:	693b      	ldr	r3, [r7, #16]
 80091fe:	681a      	ldr	r2, [r3, #0]
 8009200:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8009202:	4413      	add	r3, r2
 8009204:	781b      	ldrb	r3, [r3, #0]
 8009206:	2b00      	cmp	r3, #0
 8009208:	d008      	beq.n	800921c <_fx_directory_entry_write+0x190>
            {
                shortname[8] = entry_ptr -> fx_dir_entry_name[dotpos++];
 800920a:	693b      	ldr	r3, [r7, #16]
 800920c:	681a      	ldr	r2, [r3, #0]
 800920e:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8009210:	1c59      	adds	r1, r3, #1
 8009212:	64b9      	str	r1, [r7, #72]	@ 0x48
 8009214:	4413      	add	r3, r2
 8009216:	781b      	ldrb	r3, [r3, #0]
 8009218:	f887 3024 	strb.w	r3, [r7, #36]	@ 0x24
            }
            if (entry_ptr -> fx_dir_entry_name[dotpos])
 800921c:	693b      	ldr	r3, [r7, #16]
 800921e:	681a      	ldr	r2, [r3, #0]
 8009220:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8009222:	4413      	add	r3, r2
 8009224:	781b      	ldrb	r3, [r3, #0]
 8009226:	2b00      	cmp	r3, #0
 8009228:	d008      	beq.n	800923c <_fx_directory_entry_write+0x1b0>
            {
                shortname[9] = entry_ptr -> fx_dir_entry_name[dotpos++];
 800922a:	693b      	ldr	r3, [r7, #16]
 800922c:	681a      	ldr	r2, [r3, #0]
 800922e:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8009230:	1c59      	adds	r1, r3, #1
 8009232:	64b9      	str	r1, [r7, #72]	@ 0x48
 8009234:	4413      	add	r3, r2
 8009236:	781b      	ldrb	r3, [r3, #0]
 8009238:	f887 3025 	strb.w	r3, [r7, #37]	@ 0x25
            }
            if (entry_ptr -> fx_dir_entry_name[dotpos])
 800923c:	693b      	ldr	r3, [r7, #16]
 800923e:	681a      	ldr	r2, [r3, #0]
 8009240:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8009242:	4413      	add	r3, r2
 8009244:	781b      	ldrb	r3, [r3, #0]
 8009246:	2b00      	cmp	r3, #0
 8009248:	d008      	beq.n	800925c <_fx_directory_entry_write+0x1d0>
            {
                shortname[10] = entry_ptr -> fx_dir_entry_name[dotpos++];
 800924a:	693b      	ldr	r3, [r7, #16]
 800924c:	681a      	ldr	r2, [r3, #0]
 800924e:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8009250:	1c59      	adds	r1, r3, #1
 8009252:	64b9      	str	r1, [r7, #72]	@ 0x48
 8009254:	4413      	add	r3, r2
 8009256:	781b      	ldrb	r3, [r3, #0]
 8009258:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
            }

            /* Determine if additional spaces are needed.  */
            i = dotfound;
 800925c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800925e:	667b      	str	r3, [r7, #100]	@ 0x64

            for (; dotfound <= 7; dotfound++)
 8009260:	e008      	b.n	8009274 <_fx_directory_entry_write+0x1e8>
            {
                /* Add space...  */
                shortname[dotfound] = ' ';
 8009262:	f107 021c 	add.w	r2, r7, #28
 8009266:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8009268:	4413      	add	r3, r2
 800926a:	2220      	movs	r2, #32
 800926c:	701a      	strb	r2, [r3, #0]
            for (; dotfound <= 7; dotfound++)
 800926e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8009270:	3301      	adds	r3, #1
 8009272:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8009274:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8009276:	2b07      	cmp	r3, #7
 8009278:	d9f3      	bls.n	8009262 <_fx_directory_entry_write+0x1d6>
            }
        }

        /* Each entry contains 13 unicode entries.  Calculate the remainder.  */
        if (len % 13 == 0)
 800927a:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 800927c:	4b8e      	ldr	r3, [pc, #568]	@ (80094b8 <_fx_directory_entry_write+0x42c>)
 800927e:	fba3 2301 	umull	r2, r3, r3, r1
 8009282:	089a      	lsrs	r2, r3, #2
 8009284:	4613      	mov	r3, r2
 8009286:	005b      	lsls	r3, r3, #1
 8009288:	4413      	add	r3, r2
 800928a:	009b      	lsls	r3, r3, #2
 800928c:	4413      	add	r3, r2
 800928e:	1aca      	subs	r2, r1, r3
 8009290:	2a00      	cmp	r2, #0
 8009292:	d106      	bne.n	80092a2 <_fx_directory_entry_write+0x216>
        {
            card =  len / 13;
 8009294:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8009296:	4a88      	ldr	r2, [pc, #544]	@ (80094b8 <_fx_directory_entry_write+0x42c>)
 8009298:	fba2 2303 	umull	r2, r3, r2, r3
 800929c:	089b      	lsrs	r3, r3, #2
 800929e:	657b      	str	r3, [r7, #84]	@ 0x54
 80092a0:	e006      	b.n	80092b0 <_fx_directory_entry_write+0x224>
        }
        else
        {
            card =  len / 13 + 1;
 80092a2:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80092a4:	4a84      	ldr	r2, [pc, #528]	@ (80094b8 <_fx_directory_entry_write+0x42c>)
 80092a6:	fba2 2303 	umull	r2, r3, r2, r3
 80092aa:	089b      	lsrs	r3, r3, #2
 80092ac:	3301      	adds	r3, #1
 80092ae:	657b      	str	r3, [r7, #84]	@ 0x54
        }

        /* Default the name match to true.  */
        match =  FX_TRUE;
 80092b0:	2301      	movs	r3, #1
 80092b2:	647b      	str	r3, [r7, #68]	@ 0x44

        /* Loop through the newly derived short name and the original name and look
           for a non-matching character.  */
        l =  0;
 80092b4:	2300      	movs	r3, #0
 80092b6:	65bb      	str	r3, [r7, #88]	@ 0x58
        k =  0;
 80092b8:	2300      	movs	r3, #0
 80092ba:	65fb      	str	r3, [r7, #92]	@ 0x5c
        while (k < FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE)
 80092bc:	e03f      	b.n	800933e <_fx_directory_entry_write+0x2b2>
        {

            /* Determine if a space is detected in the short name. If so,
               advance to the extension index.  */
            if (shortname[k] == ' ')
 80092be:	f107 021c 	add.w	r2, r7, #28
 80092c2:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80092c4:	4413      	add	r3, r2
 80092c6:	781b      	ldrb	r3, [r3, #0]
 80092c8:	2b20      	cmp	r3, #32
 80092ca:	d116      	bne.n	80092fa <_fx_directory_entry_write+0x26e>
            {

                /* The first pad space was detected. First, check for a name
                   without an extension.  */
                if (entry_ptr -> fx_dir_entry_name[l] == FX_NULL)
 80092cc:	693b      	ldr	r3, [r7, #16]
 80092ce:	681a      	ldr	r2, [r3, #0]
 80092d0:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80092d2:	4413      	add	r3, r2
 80092d4:	781b      	ldrb	r3, [r3, #0]
 80092d6:	2b00      	cmp	r3, #0
 80092d8:	d035      	beq.n	8009346 <_fx_directory_entry_write+0x2ba>
                    /* All is okay, get out of the loop!  */
                    break;
                }

                /* Now check for a period in the long name... if not, there is a non-match!  */
                if (entry_ptr -> fx_dir_entry_name[l] != '.')
 80092da:	693b      	ldr	r3, [r7, #16]
 80092dc:	681a      	ldr	r2, [r3, #0]
 80092de:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80092e0:	4413      	add	r3, r2
 80092e2:	781b      	ldrb	r3, [r3, #0]
 80092e4:	2b2e      	cmp	r3, #46	@ 0x2e
 80092e6:	d002      	beq.n	80092ee <_fx_directory_entry_write+0x262>
                {

                    /* Set the match flag to false and exit the loop.  */
                    match =  FX_FALSE;
 80092e8:	2300      	movs	r3, #0
 80092ea:	647b      	str	r3, [r7, #68]	@ 0x44
                    break;
 80092ec:	e02c      	b.n	8009348 <_fx_directory_entry_write+0x2bc>
                }

                /* Otherwise move short file name index to the extension area and
                   increment the long file name index.  */
                k =  8;
 80092ee:	2308      	movs	r3, #8
 80092f0:	65fb      	str	r3, [r7, #92]	@ 0x5c
                l++;
 80092f2:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80092f4:	3301      	adds	r3, #1
 80092f6:	65bb      	str	r3, [r7, #88]	@ 0x58

                /* Restart the loop at the top.  */
                continue;
 80092f8:	e021      	b.n	800933e <_fx_directory_entry_write+0x2b2>
            }

            /* Check for the dot for the 8.3 match... it is no longer in the
               shortname but possibly still present in the long name.  */
            if ((k == 8) && (entry_ptr -> fx_dir_entry_name[l] == '.'))
 80092fa:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80092fc:	2b08      	cmp	r3, #8
 80092fe:	d109      	bne.n	8009314 <_fx_directory_entry_write+0x288>
 8009300:	693b      	ldr	r3, [r7, #16]
 8009302:	681a      	ldr	r2, [r3, #0]
 8009304:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8009306:	4413      	add	r3, r2
 8009308:	781b      	ldrb	r3, [r3, #0]
 800930a:	2b2e      	cmp	r3, #46	@ 0x2e
 800930c:	d102      	bne.n	8009314 <_fx_directory_entry_write+0x288>
            {

                /* Yes, handle the implicit dot in the shortname by
                   positioning past it in the long name.  */
                l++;
 800930e:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8009310:	3301      	adds	r3, #1
 8009312:	65bb      	str	r3, [r7, #88]	@ 0x58
            }

            /* Do the names match?  */
            if (shortname[k] != entry_ptr -> fx_dir_entry_name[l])
 8009314:	f107 021c 	add.w	r2, r7, #28
 8009318:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 800931a:	4413      	add	r3, r2
 800931c:	781a      	ldrb	r2, [r3, #0]
 800931e:	693b      	ldr	r3, [r7, #16]
 8009320:	6819      	ldr	r1, [r3, #0]
 8009322:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8009324:	440b      	add	r3, r1
 8009326:	781b      	ldrb	r3, [r3, #0]
 8009328:	429a      	cmp	r2, r3
 800932a:	d002      	beq.n	8009332 <_fx_directory_entry_write+0x2a6>
            {

                /* No, the names do not match, set the match flag to false and
                   exit the loop.  */
                match =  FX_FALSE;
 800932c:	2300      	movs	r3, #0
 800932e:	647b      	str	r3, [r7, #68]	@ 0x44
                break;
 8009330:	e00a      	b.n	8009348 <_fx_directory_entry_write+0x2bc>
            }

            /* Move the indices forward.  */
            k++;
 8009332:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8009334:	3301      	adds	r3, #1
 8009336:	65fb      	str	r3, [r7, #92]	@ 0x5c
            l++;
 8009338:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 800933a:	3301      	adds	r3, #1
 800933c:	65bb      	str	r3, [r7, #88]	@ 0x58
        while (k < FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE)
 800933e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8009340:	2b0a      	cmp	r3, #10
 8009342:	d9bc      	bls.n	80092be <_fx_directory_entry_write+0x232>
 8009344:	e000      	b.n	8009348 <_fx_directory_entry_write+0x2bc>
                    break;
 8009346:	bf00      	nop
        }

        /* Check if there is a dot in the name, but no extension in the short name.  In this case, 
           we should create a mangled short name.  */
        if ((dotpos) && (shortname[8] == ' '))
 8009348:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800934a:	2b00      	cmp	r3, #0
 800934c:	d005      	beq.n	800935a <_fx_directory_entry_write+0x2ce>
 800934e:	f897 3024 	ldrb.w	r3, [r7, #36]	@ 0x24
 8009352:	2b20      	cmp	r3, #32
 8009354:	d101      	bne.n	800935a <_fx_directory_entry_write+0x2ce>
        {
        
            /* Something left.. the names do not match!  */
            match =  FX_FALSE;
 8009356:	2300      	movs	r3, #0
 8009358:	647b      	str	r3, [r7, #68]	@ 0x44
        }

        /* One final check to make sure there is nothing left on the long file name.  */
        if (entry_ptr -> fx_dir_entry_name[l])
 800935a:	693b      	ldr	r3, [r7, #16]
 800935c:	681a      	ldr	r2, [r3, #0]
 800935e:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8009360:	4413      	add	r3, r2
 8009362:	781b      	ldrb	r3, [r3, #0]
 8009364:	2b00      	cmp	r3, #0
 8009366:	d001      	beq.n	800936c <_fx_directory_entry_write+0x2e0>
        {

            /* Something left.. the names do not match!  */
            match =  FX_FALSE;
 8009368:	2300      	movs	r3, #0
 800936a:	647b      	str	r3, [r7, #68]	@ 0x44
        }

        /* Determine if the derived short name matches exactly the long file name. If so
           we don't need to mangle the name with a numeric value based on its entry.  */
        if (match == FX_FALSE)
 800936c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800936e:	2b00      	cmp	r3, #0
 8009370:	d15a      	bne.n	8009428 <_fx_directory_entry_write+0x39c>
        {

            /* Name does not match, create a mangled name.  */

            /* Generate short file name from LFN.  */
            entry = entry_ptr -> fx_dir_entry_number;
 8009372:	693b      	ldr	r3, [r7, #16]
 8009374:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8009376:	62bb      	str	r3, [r7, #40]	@ 0x28

            /* Name suffice is between 000 and FFFF in hex, calculate this short file
               name's numeric component.  */
            entry = entry % 0x10000;
 8009378:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800937a:	b29b      	uxth	r3, r3
 800937c:	62bb      	str	r3, [r7, #40]	@ 0x28

            /* Build short name of the format xxx~NNNN.ext.  */
            if (i > 3)
 800937e:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8009380:	2b03      	cmp	r3, #3
 8009382:	d901      	bls.n	8009388 <_fx_directory_entry_write+0x2fc>
            {
                i = 3;
 8009384:	2303      	movs	r3, #3
 8009386:	667b      	str	r3, [r7, #100]	@ 0x64
            }
            shortname[i++] = '~';
 8009388:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 800938a:	1c5a      	adds	r2, r3, #1
 800938c:	667a      	str	r2, [r7, #100]	@ 0x64
 800938e:	3368      	adds	r3, #104	@ 0x68
 8009390:	f107 0210 	add.w	r2, r7, #16
 8009394:	4413      	add	r3, r2
 8009396:	227e      	movs	r2, #126	@ 0x7e
 8009398:	f803 2c5c 	strb.w	r2, [r3, #-92]

            /* Loop to build the numeric part of the name.  */
            for (l = 0; l < 4; l++)
 800939c:	2300      	movs	r3, #0
 800939e:	65bb      	str	r3, [r7, #88]	@ 0x58
 80093a0:	e03f      	b.n	8009422 <_fx_directory_entry_write+0x396>
            {
                
                /* Shift down the entry number based on the numeric position.  */
                if (l == 0)
 80093a2:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80093a4:	2b00      	cmp	r3, #0
 80093a6:	d105      	bne.n	80093b4 <_fx_directory_entry_write+0x328>
                {
                    temp =  ((entry >> 12) & 0xf);
 80093a8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80093aa:	0b1b      	lsrs	r3, r3, #12
 80093ac:	f003 030f 	and.w	r3, r3, #15
 80093b0:	66fb      	str	r3, [r7, #108]	@ 0x6c
 80093b2:	e015      	b.n	80093e0 <_fx_directory_entry_write+0x354>
                }
                else if (l == 1)
 80093b4:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80093b6:	2b01      	cmp	r3, #1
 80093b8:	d105      	bne.n	80093c6 <_fx_directory_entry_write+0x33a>
                {
                     temp = ((entry >> 8) & 0xf);
 80093ba:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80093bc:	0a1b      	lsrs	r3, r3, #8
 80093be:	f003 030f 	and.w	r3, r3, #15
 80093c2:	66fb      	str	r3, [r7, #108]	@ 0x6c
 80093c4:	e00c      	b.n	80093e0 <_fx_directory_entry_write+0x354>
                }
                else if (l == 2)
 80093c6:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80093c8:	2b02      	cmp	r3, #2
 80093ca:	d105      	bne.n	80093d8 <_fx_directory_entry_write+0x34c>
                {
                     temp = ((entry >> 4) & 0xf);
 80093cc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80093ce:	091b      	lsrs	r3, r3, #4
 80093d0:	f003 030f 	and.w	r3, r3, #15
 80093d4:	66fb      	str	r3, [r7, #108]	@ 0x6c
 80093d6:	e003      	b.n	80093e0 <_fx_directory_entry_write+0x354>
                }
                else
                {
                     temp = ((entry) & 0xf);
 80093d8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80093da:	f003 030f 	and.w	r3, r3, #15
 80093de:	66fb      	str	r3, [r7, #108]	@ 0x6c
                }
                
                /* Now build hex value.  */
                if (temp > 9)
 80093e0:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80093e2:	2b09      	cmp	r3, #9
 80093e4:	d90d      	bls.n	8009402 <_fx_directory_entry_write+0x376>
                    shortname[i++] =  (CHAR)('A' + (temp - 10));
 80093e6:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80093e8:	b2da      	uxtb	r2, r3
 80093ea:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80093ec:	1c59      	adds	r1, r3, #1
 80093ee:	6679      	str	r1, [r7, #100]	@ 0x64
 80093f0:	3237      	adds	r2, #55	@ 0x37
 80093f2:	b2d2      	uxtb	r2, r2
 80093f4:	3368      	adds	r3, #104	@ 0x68
 80093f6:	f107 0110 	add.w	r1, r7, #16
 80093fa:	440b      	add	r3, r1
 80093fc:	f803 2c5c 	strb.w	r2, [r3, #-92]
 8009400:	e00c      	b.n	800941c <_fx_directory_entry_write+0x390>
                else
                    shortname[i++] =  (CHAR)('0' + temp);
 8009402:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8009404:	b2da      	uxtb	r2, r3
 8009406:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8009408:	1c59      	adds	r1, r3, #1
 800940a:	6679      	str	r1, [r7, #100]	@ 0x64
 800940c:	3230      	adds	r2, #48	@ 0x30
 800940e:	b2d2      	uxtb	r2, r2
 8009410:	3368      	adds	r3, #104	@ 0x68
 8009412:	f107 0110 	add.w	r1, r7, #16
 8009416:	440b      	add	r3, r1
 8009418:	f803 2c5c 	strb.w	r2, [r3, #-92]
            for (l = 0; l < 4; l++)
 800941c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 800941e:	3301      	adds	r3, #1
 8009420:	65bb      	str	r3, [r7, #88]	@ 0x58
 8009422:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8009424:	2b03      	cmp	r3, #3
 8009426:	d9bc      	bls.n	80093a2 <_fx_directory_entry_write+0x316>
            }
        }

        /* Set end of short string to NULL.   */
        shortname[11] = 0;
 8009428:	2300      	movs	r3, #0
 800942a:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27

        /* Determine if the first character of the short file name is the directory free
           value. If so, it must be changed.  */
        if (((UCHAR)shortname[0] == (UCHAR)FX_DIR_ENTRY_FREE) && (delete_flag == FX_FALSE))
 800942e:	7f3b      	ldrb	r3, [r7, #28]
 8009430:	2be5      	cmp	r3, #229	@ 0xe5
 8009432:	d104      	bne.n	800943e <_fx_directory_entry_write+0x3b2>
 8009434:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8009436:	2b00      	cmp	r3, #0
 8009438:	d101      	bne.n	800943e <_fx_directory_entry_write+0x3b2>
        {

            /* Change to 0x8F to be compatible with what DOS does.  */
            shortname[0] =  (CHAR)0x8F;
 800943a:	238f      	movs	r3, #143	@ 0x8f
 800943c:	773b      	strb	r3, [r7, #28]
        }

        /* Loop to convert the new short file name to upper case.  */
        for (i = 0; i < (FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE); i++)
 800943e:	2300      	movs	r3, #0
 8009440:	667b      	str	r3, [r7, #100]	@ 0x64
 8009442:	e01d      	b.n	8009480 <_fx_directory_entry_write+0x3f4>
        {

            /* Pickup shortname character.  */
            alpha = shortname[i];
 8009444:	f107 021c 	add.w	r2, r7, #28
 8009448:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 800944a:	4413      	add	r3, r2
 800944c:	781b      	ldrb	r3, [r3, #0]
 800944e:	f887 3041 	strb.w	r3, [r7, #65]	@ 0x41

            /* Determine if character is lower case.  */
            if ((alpha >= 'a') && (alpha <= 'z'))
 8009452:	f897 3041 	ldrb.w	r3, [r7, #65]	@ 0x41
 8009456:	2b60      	cmp	r3, #96	@ 0x60
 8009458:	d908      	bls.n	800946c <_fx_directory_entry_write+0x3e0>
 800945a:	f897 3041 	ldrb.w	r3, [r7, #65]	@ 0x41
 800945e:	2b7a      	cmp	r3, #122	@ 0x7a
 8009460:	d804      	bhi.n	800946c <_fx_directory_entry_write+0x3e0>
            {

                /* Store the character - converted to upper case.  */
                alpha =  (CHAR)(alpha - ((CHAR)0x20));
 8009462:	f897 3041 	ldrb.w	r3, [r7, #65]	@ 0x41
 8009466:	3b20      	subs	r3, #32
 8009468:	f887 3041 	strb.w	r3, [r7, #65]	@ 0x41
            }

            /* Now store the short name character.  */
            shortname[i] =  alpha;
 800946c:	f107 021c 	add.w	r2, r7, #28
 8009470:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8009472:	4413      	add	r3, r2
 8009474:	f897 2041 	ldrb.w	r2, [r7, #65]	@ 0x41
 8009478:	701a      	strb	r2, [r3, #0]
        for (i = 0; i < (FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE); i++)
 800947a:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 800947c:	3301      	adds	r3, #1
 800947e:	667b      	str	r3, [r7, #100]	@ 0x64
 8009480:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8009482:	2b0a      	cmp	r3, #10
 8009484:	d9de      	bls.n	8009444 <_fx_directory_entry_write+0x3b8>
        }

        /* Determine if there already is a short name and we are not deleting the entry.  */
        if (entry_ptr -> fx_dir_entry_short_name[0] != 0)
 8009486:	693b      	ldr	r3, [r7, #16]
 8009488:	791b      	ldrb	r3, [r3, #4]
 800948a:	2b00      	cmp	r3, #0
 800948c:	f000 8095 	beq.w	80095ba <_fx_directory_entry_write+0x52e>
        {

            /* Yes, override the calculated shortname with the original 8.3 name.  */

            /* Clear the short file name area.  */
            for (i = 0; i < FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE; i++)
 8009490:	2300      	movs	r3, #0
 8009492:	667b      	str	r3, [r7, #100]	@ 0x64
 8009494:	e008      	b.n	80094a8 <_fx_directory_entry_write+0x41c>
            {
                shortname[i] = ' ';
 8009496:	f107 021c 	add.w	r2, r7, #28
 800949a:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 800949c:	4413      	add	r3, r2
 800949e:	2220      	movs	r2, #32
 80094a0:	701a      	strb	r2, [r3, #0]
            for (i = 0; i < FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE; i++)
 80094a2:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80094a4:	3301      	adds	r3, #1
 80094a6:	667b      	str	r3, [r7, #100]	@ 0x64
 80094a8:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80094aa:	2b0a      	cmp	r3, #10
 80094ac:	d9f3      	bls.n	8009496 <_fx_directory_entry_write+0x40a>
            }

            /* Loop to copy the original short file name.  */
            for (i = 0, j = 0; j < FX_DIR_NAME_SIZE; i++, j++)
 80094ae:	2300      	movs	r3, #0
 80094b0:	667b      	str	r3, [r7, #100]	@ 0x64
 80094b2:	2300      	movs	r3, #0
 80094b4:	663b      	str	r3, [r7, #96]	@ 0x60
 80094b6:	e023      	b.n	8009500 <_fx_directory_entry_write+0x474>
 80094b8:	4ec4ec4f 	.word	0x4ec4ec4f
            {

                /* Check for end of copy conditions.  */
                if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] == '.')
 80094bc:	693a      	ldr	r2, [r7, #16]
 80094be:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80094c0:	4413      	add	r3, r2
 80094c2:	3304      	adds	r3, #4
 80094c4:	781b      	ldrb	r3, [r3, #0]
 80094c6:	2b2e      	cmp	r3, #46	@ 0x2e
 80094c8:	d01e      	beq.n	8009508 <_fx_directory_entry_write+0x47c>
                {
                    break;
                }
                if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] == 0)
 80094ca:	693a      	ldr	r2, [r7, #16]
 80094cc:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80094ce:	4413      	add	r3, r2
 80094d0:	3304      	adds	r3, #4
 80094d2:	781b      	ldrb	r3, [r3, #0]
 80094d4:	2b00      	cmp	r3, #0
 80094d6:	d019      	beq.n	800950c <_fx_directory_entry_write+0x480>
                {
                    break;
                }

                /* Pickup the character.  */
                alpha =  entry_ptr -> fx_dir_entry_short_name[i];
 80094d8:	693a      	ldr	r2, [r7, #16]
 80094da:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80094dc:	4413      	add	r3, r2
 80094de:	3304      	adds	r3, #4
 80094e0:	781b      	ldrb	r3, [r3, #0]
 80094e2:	f887 3041 	strb.w	r3, [r7, #65]	@ 0x41

                /* Copy file name character.  */
                shortname[j] =  alpha;
 80094e6:	f107 021c 	add.w	r2, r7, #28
 80094ea:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80094ec:	4413      	add	r3, r2
 80094ee:	f897 2041 	ldrb.w	r2, [r7, #65]	@ 0x41
 80094f2:	701a      	strb	r2, [r3, #0]
            for (i = 0, j = 0; j < FX_DIR_NAME_SIZE; i++, j++)
 80094f4:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80094f6:	3301      	adds	r3, #1
 80094f8:	667b      	str	r3, [r7, #100]	@ 0x64
 80094fa:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80094fc:	3301      	adds	r3, #1
 80094fe:	663b      	str	r3, [r7, #96]	@ 0x60
 8009500:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8009502:	2b07      	cmp	r3, #7
 8009504:	d9da      	bls.n	80094bc <_fx_directory_entry_write+0x430>
 8009506:	e002      	b.n	800950e <_fx_directory_entry_write+0x482>
                    break;
 8009508:	bf00      	nop
 800950a:	e000      	b.n	800950e <_fx_directory_entry_write+0x482>
                    break;
 800950c:	bf00      	nop
            }

            /* Determine if there is anything left in the short file name.  */
            if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] != 0)
 800950e:	693a      	ldr	r2, [r7, #16]
 8009510:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8009512:	4413      	add	r3, r2
 8009514:	3304      	adds	r3, #4
 8009516:	781b      	ldrb	r3, [r3, #0]
 8009518:	2b00      	cmp	r3, #0
 800951a:	d025      	beq.n	8009568 <_fx_directory_entry_write+0x4dc>
            {

                /* Pickup remaining characters.  */
                for (i++, j = FX_DIR_NAME_SIZE; j < FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE; i++, j++)
 800951c:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 800951e:	3301      	adds	r3, #1
 8009520:	667b      	str	r3, [r7, #100]	@ 0x64
 8009522:	2308      	movs	r3, #8
 8009524:	663b      	str	r3, [r7, #96]	@ 0x60
 8009526:	e01a      	b.n	800955e <_fx_directory_entry_write+0x4d2>
                {

                    /* If NULL is encountered, stop the copying.  */
                    if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] == 0)
 8009528:	693a      	ldr	r2, [r7, #16]
 800952a:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 800952c:	4413      	add	r3, r2
 800952e:	3304      	adds	r3, #4
 8009530:	781b      	ldrb	r3, [r3, #0]
 8009532:	2b00      	cmp	r3, #0
 8009534:	d017      	beq.n	8009566 <_fx_directory_entry_write+0x4da>
                    {
                        break;
                    }

                    /* Pickup the character.  */
                    alpha =  entry_ptr -> fx_dir_entry_short_name[i];
 8009536:	693a      	ldr	r2, [r7, #16]
 8009538:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 800953a:	4413      	add	r3, r2
 800953c:	3304      	adds	r3, #4
 800953e:	781b      	ldrb	r3, [r3, #0]
 8009540:	f887 3041 	strb.w	r3, [r7, #65]	@ 0x41

                    /* Copy file name character.  */
                    shortname[j] =  alpha;
 8009544:	f107 021c 	add.w	r2, r7, #28
 8009548:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 800954a:	4413      	add	r3, r2
 800954c:	f897 2041 	ldrb.w	r2, [r7, #65]	@ 0x41
 8009550:	701a      	strb	r2, [r3, #0]
                for (i++, j = FX_DIR_NAME_SIZE; j < FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE; i++, j++)
 8009552:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8009554:	3301      	adds	r3, #1
 8009556:	667b      	str	r3, [r7, #100]	@ 0x64
 8009558:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 800955a:	3301      	adds	r3, #1
 800955c:	663b      	str	r3, [r7, #96]	@ 0x60
 800955e:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8009560:	2b0a      	cmp	r3, #10
 8009562:	d9e1      	bls.n	8009528 <_fx_directory_entry_write+0x49c>
 8009564:	e000      	b.n	8009568 <_fx_directory_entry_write+0x4dc>
                        break;
 8009566:	bf00      	nop
                }
            }

            /* Loop to make sure the short name is upper case.  */
            for (j = 0; j < (FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE); j++)
 8009568:	2300      	movs	r3, #0
 800956a:	663b      	str	r3, [r7, #96]	@ 0x60
 800956c:	e01d      	b.n	80095aa <_fx_directory_entry_write+0x51e>
            {

                /* Pickup the character.  */
                alpha =  shortname[j];
 800956e:	f107 021c 	add.w	r2, r7, #28
 8009572:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8009574:	4413      	add	r3, r2
 8009576:	781b      	ldrb	r3, [r3, #0]
 8009578:	f887 3041 	strb.w	r3, [r7, #65]	@ 0x41

                /* Determine if character is lower case.  */
                if ((alpha >= 'a') && (alpha <= 'z'))
 800957c:	f897 3041 	ldrb.w	r3, [r7, #65]	@ 0x41
 8009580:	2b60      	cmp	r3, #96	@ 0x60
 8009582:	d908      	bls.n	8009596 <_fx_directory_entry_write+0x50a>
 8009584:	f897 3041 	ldrb.w	r3, [r7, #65]	@ 0x41
 8009588:	2b7a      	cmp	r3, #122	@ 0x7a
 800958a:	d804      	bhi.n	8009596 <_fx_directory_entry_write+0x50a>
                {

                    /* Store the character - converted to upper case.  */
                    alpha =  (CHAR)(alpha - ((CHAR)0x20));
 800958c:	f897 3041 	ldrb.w	r3, [r7, #65]	@ 0x41
 8009590:	3b20      	subs	r3, #32
 8009592:	f887 3041 	strb.w	r3, [r7, #65]	@ 0x41
                }

                /* Copy file name character.  */
                shortname[j] =  alpha;
 8009596:	f107 021c 	add.w	r2, r7, #28
 800959a:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 800959c:	4413      	add	r3, r2
 800959e:	f897 2041 	ldrb.w	r2, [r7, #65]	@ 0x41
 80095a2:	701a      	strb	r2, [r3, #0]
            for (j = 0; j < (FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE); j++)
 80095a4:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80095a6:	3301      	adds	r3, #1
 80095a8:	663b      	str	r3, [r7, #96]	@ 0x60
 80095aa:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80095ac:	2b0a      	cmp	r3, #10
 80095ae:	d9de      	bls.n	800956e <_fx_directory_entry_write+0x4e2>
            }

            /* Determine if the first character of the short file name is the directory free
               value. If so, it must be changed.  */
            if (((UCHAR)shortname[0]) == ((UCHAR)FX_DIR_ENTRY_FREE))
 80095b0:	7f3b      	ldrb	r3, [r7, #28]
 80095b2:	2be5      	cmp	r3, #229	@ 0xe5
 80095b4:	d101      	bne.n	80095ba <_fx_directory_entry_write+0x52e>
            {

                /* Change to 0x8F to be compatible with what DOS does.  */
                shortname[0] =  (CHAR)0x8F;
 80095b6:	238f      	movs	r3, #143	@ 0x8f
 80095b8:	773b      	strb	r3, [r7, #28]
            }
        }

        /* Loop to calculate the checksum.  */
        for (i = checksum = 0; i < FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE; i++)
 80095ba:	2300      	movs	r3, #0
 80095bc:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 80095c0:	2300      	movs	r3, #0
 80095c2:	667b      	str	r3, [r7, #100]	@ 0x64
 80095c4:	e016      	b.n	80095f4 <_fx_directory_entry_write+0x568>
        {

            /* Calculate the checksum.  */
            checksum = (UCHAR)((UCHAR)(((checksum & 1) << 7) | ((checksum & (UCHAR)0xfe) >> 1)) + shortname[i]);
 80095c6:	f897 3043 	ldrb.w	r3, [r7, #67]	@ 0x43
 80095ca:	01db      	lsls	r3, r3, #7
 80095cc:	b25a      	sxtb	r2, r3
 80095ce:	f897 3043 	ldrb.w	r3, [r7, #67]	@ 0x43
 80095d2:	085b      	lsrs	r3, r3, #1
 80095d4:	b2db      	uxtb	r3, r3
 80095d6:	b25b      	sxtb	r3, r3
 80095d8:	4313      	orrs	r3, r2
 80095da:	b25b      	sxtb	r3, r3
 80095dc:	b2da      	uxtb	r2, r3
 80095de:	f107 011c 	add.w	r1, r7, #28
 80095e2:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80095e4:	440b      	add	r3, r1
 80095e6:	781b      	ldrb	r3, [r3, #0]
 80095e8:	4413      	add	r3, r2
 80095ea:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
        for (i = checksum = 0; i < FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE; i++)
 80095ee:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80095f0:	3301      	adds	r3, #1
 80095f2:	667b      	str	r3, [r7, #100]	@ 0x64
 80095f4:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80095f6:	2b0a      	cmp	r3, #10
 80095f8:	d9e5      	bls.n	80095c6 <_fx_directory_entry_write+0x53a>
        }

        /* Set the last entry mark.  */
        work_ptr[0] =  (UCHAR)(0x40 | card);
 80095fa:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80095fc:	b2db      	uxtb	r3, r3
 80095fe:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8009602:	b2da      	uxtb	r2, r3
 8009604:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8009606:	701a      	strb	r2, [r3, #0]

        /* Loop to process remainder of long file name entry.  */
        while (card > 0)
 8009608:	e0f3      	b.n	80097f2 <_fx_directory_entry_write+0x766>
        {

            /* Clear eof marker.  */
            eof_marker = 0;
 800960a:	2300      	movs	r3, #0
 800960c:	f887 3042 	strb.w	r3, [r7, #66]	@ 0x42

            /* Determine if the entry is free.  */
            if ((UCHAR)shortname[0] == (UCHAR)FX_DIR_ENTRY_FREE)
 8009610:	7f3b      	ldrb	r3, [r7, #28]
 8009612:	2be5      	cmp	r3, #229	@ 0xe5
 8009614:	d102      	bne.n	800961c <_fx_directory_entry_write+0x590>
            {
                /* Yes, place delete marker.  */
                work_ptr[0] =  (UCHAR)FX_DIR_ENTRY_FREE;
 8009616:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8009618:	22e5      	movs	r2, #229	@ 0xe5
 800961a:	701a      	strb	r2, [r3, #0]
            }

            /* Setup various long file name fields.  */
            work_ptr[11] = FX_LONG_NAME;
 800961c:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 800961e:	330b      	adds	r3, #11
 8009620:	220f      	movs	r2, #15
 8009622:	701a      	strb	r2, [r3, #0]
            work_ptr[12] = 0;
 8009624:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8009626:	330c      	adds	r3, #12
 8009628:	2200      	movs	r2, #0
 800962a:	701a      	strb	r2, [r3, #0]
            work_ptr[13] = checksum;
 800962c:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 800962e:	330d      	adds	r3, #13
 8009630:	f897 2043 	ldrb.w	r2, [r7, #67]	@ 0x43
 8009634:	701a      	strb	r2, [r3, #0]
            work_ptr[26] = 0;
 8009636:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8009638:	331a      	adds	r3, #26
 800963a:	2200      	movs	r2, #0
 800963c:	701a      	strb	r2, [r3, #0]
            work_ptr[27] = 0;
 800963e:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8009640:	331b      	adds	r3, #27
 8009642:	2200      	movs	r2, #0
 8009644:	701a      	strb	r2, [r3, #0]

            /* Loop through file name fields.  */
            for (i = 1, j = 13 * (card - 1); i < FX_DIR_ENTRY_SIZE; i += 2)
 8009646:	2301      	movs	r3, #1
 8009648:	667b      	str	r3, [r7, #100]	@ 0x64
 800964a:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 800964c:	4613      	mov	r3, r2
 800964e:	005b      	lsls	r3, r3, #1
 8009650:	4413      	add	r3, r2
 8009652:	009b      	lsls	r3, r3, #2
 8009654:	4413      	add	r3, r2
 8009656:	3b0d      	subs	r3, #13
 8009658:	663b      	str	r3, [r7, #96]	@ 0x60
 800965a:	e03e      	b.n	80096da <_fx_directory_entry_write+0x64e>
            {

                /* Process relative to specific fields.  */
                if ((i == 11) || (i == 26))
 800965c:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 800965e:	2b0b      	cmp	r3, #11
 8009660:	d037      	beq.n	80096d2 <_fx_directory_entry_write+0x646>
 8009662:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8009664:	2b1a      	cmp	r3, #26
 8009666:	d034      	beq.n	80096d2 <_fx_directory_entry_write+0x646>
                {
                    continue;
                }

                if (i == 13)
 8009668:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 800966a:	2b0d      	cmp	r3, #13
 800966c:	d102      	bne.n	8009674 <_fx_directory_entry_write+0x5e8>
                {
                    i = 12;
 800966e:	230c      	movs	r3, #12
 8009670:	667b      	str	r3, [r7, #100]	@ 0x64
                    continue;
 8009672:	e02f      	b.n	80096d4 <_fx_directory_entry_write+0x648>
                }

                /* Determine if the EOF marker is present.  */
                if (eof_marker)
 8009674:	f897 3042 	ldrb.w	r3, [r7, #66]	@ 0x42
 8009678:	2b00      	cmp	r3, #0
 800967a:	d00d      	beq.n	8009698 <_fx_directory_entry_write+0x60c>
                {

                    work_ptr[i] = eof_marker;
 800967c:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 800967e:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8009680:	4413      	add	r3, r2
 8009682:	f897 2042 	ldrb.w	r2, [r7, #66]	@ 0x42
 8009686:	701a      	strb	r2, [r3, #0]
                    work_ptr[i + 1] = eof_marker;
 8009688:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 800968a:	3301      	adds	r3, #1
 800968c:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 800968e:	4413      	add	r3, r2
 8009690:	f897 2042 	ldrb.w	r2, [r7, #66]	@ 0x42
 8009694:	701a      	strb	r2, [r3, #0]
 8009696:	e00e      	b.n	80096b6 <_fx_directory_entry_write+0x62a>
                }
                else
                {
                    work_ptr[i] = (UCHAR)entry_ptr -> fx_dir_entry_name[j];
 8009698:	693b      	ldr	r3, [r7, #16]
 800969a:	681a      	ldr	r2, [r3, #0]
 800969c:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 800969e:	441a      	add	r2, r3
 80096a0:	6f79      	ldr	r1, [r7, #116]	@ 0x74
 80096a2:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80096a4:	440b      	add	r3, r1
 80096a6:	7812      	ldrb	r2, [r2, #0]
 80096a8:	701a      	strb	r2, [r3, #0]
                    work_ptr[i + 1] = 0;
 80096aa:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80096ac:	3301      	adds	r3, #1
 80096ae:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 80096b0:	4413      	add	r3, r2
 80096b2:	2200      	movs	r2, #0
 80096b4:	701a      	strb	r2, [r3, #0]
                }

                if (entry_ptr -> fx_dir_entry_name[j] == 0)
 80096b6:	693b      	ldr	r3, [r7, #16]
 80096b8:	681a      	ldr	r2, [r3, #0]
 80096ba:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80096bc:	4413      	add	r3, r2
 80096be:	781b      	ldrb	r3, [r3, #0]
 80096c0:	2b00      	cmp	r3, #0
 80096c2:	d102      	bne.n	80096ca <_fx_directory_entry_write+0x63e>
                {

                    /* end of name, pad with 0xff.  */
                    eof_marker =  (UCHAR)0xff;
 80096c4:	23ff      	movs	r3, #255	@ 0xff
 80096c6:	f887 3042 	strb.w	r3, [r7, #66]	@ 0x42
                }

                j++;
 80096ca:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80096cc:	3301      	adds	r3, #1
 80096ce:	663b      	str	r3, [r7, #96]	@ 0x60
 80096d0:	e000      	b.n	80096d4 <_fx_directory_entry_write+0x648>
                    continue;
 80096d2:	bf00      	nop
            for (i = 1, j = 13 * (card - 1); i < FX_DIR_ENTRY_SIZE; i += 2)
 80096d4:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80096d6:	3302      	adds	r3, #2
 80096d8:	667b      	str	r3, [r7, #100]	@ 0x64
 80096da:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80096dc:	2b1f      	cmp	r3, #31
 80096de:	d9bd      	bls.n	800965c <_fx_directory_entry_write+0x5d0>
            }

            /* Move to the next directory entry.  */
            work_ptr += FX_DIR_ENTRY_SIZE;
 80096e0:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 80096e2:	3320      	adds	r3, #32
 80096e4:	677b      	str	r3, [r7, #116]	@ 0x74
            byte_offset += FX_DIR_ENTRY_SIZE;
 80096e6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80096e8:	3320      	adds	r3, #32
 80096ea:	637b      	str	r3, [r7, #52]	@ 0x34
            /* Update changed_size. */
            changed_size += FX_DIR_ENTRY_SIZE;
#endif /* FX_ENABLE_FAULT_TOLERANT */

            /* Determine if the entry overlaps into the next sector.  */
            if (byte_offset >= media_ptr -> fx_media_bytes_per_sector)
 80096ec:	697b      	ldr	r3, [r7, #20]
 80096ee:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80096f0:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 80096f2:	429a      	cmp	r2, r3
 80096f4:	d376      	bcc.n	80097e4 <_fx_directory_entry_write+0x758>
                else
                {
#endif /* FX_ENABLE_FAULT_TOLERANT */

                    /* Write current logical sector out.  */
                    status =  _fx_utility_logical_sector_write(media_ptr, (ULONG64) logical_sector,
 80096f6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80096f8:	2200      	movs	r2, #0
 80096fa:	60bb      	str	r3, [r7, #8]
 80096fc:	60fa      	str	r2, [r7, #12]
 80096fe:	2303      	movs	r3, #3
 8009700:	9302      	str	r3, [sp, #8]
 8009702:	2301      	movs	r3, #1
 8009704:	9301      	str	r3, [sp, #4]
 8009706:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8009708:	9300      	str	r3, [sp, #0]
 800970a:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 800970e:	6978      	ldr	r0, [r7, #20]
 8009710:	f006 ffe8 	bl	80106e4 <_fx_utility_logical_sector_write>
 8009714:	62f8      	str	r0, [r7, #44]	@ 0x2c
#ifdef FX_ENABLE_FAULT_TOLERANT
                }
#endif /* FX_ENABLE_FAULT_TOLERANT */

                /* Determine if an error occurred.  */
                if (status != FX_SUCCESS)
 8009716:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8009718:	2b00      	cmp	r3, #0
 800971a:	d001      	beq.n	8009720 <_fx_directory_entry_write+0x694>
                {

                    /* Return the error status.  */
                    return(status);
 800971c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800971e:	e2eb      	b.n	8009cf8 <_fx_directory_entry_write+0xc6c>
                }

                /* Determine if we are in the root directory.  */
                if (logical_sector >= (ULONG)(media_ptr -> fx_media_data_sector_start))
 8009720:	697b      	ldr	r3, [r7, #20]
 8009722:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8009724:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8009726:	429a      	cmp	r2, r3
 8009728:	d335      	bcc.n	8009796 <_fx_directory_entry_write+0x70a>
                {

                    /* Determine the next sector of the directory entry.  */
                    if (relative_sector < (media_ptr -> fx_media_sectors_per_cluster - 1))
 800972a:	697b      	ldr	r3, [r7, #20]
 800972c:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800972e:	3b01      	subs	r3, #1
 8009730:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8009732:	429a      	cmp	r2, r3
 8009734:	d206      	bcs.n	8009744 <_fx_directory_entry_write+0x6b8>
                    {

                        /* More sectors in this cluster.  */

                        /* Simply increment the logical sector.  */
                        logical_sector++;
 8009736:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8009738:	3301      	adds	r3, #1
 800973a:	63fb      	str	r3, [r7, #60]	@ 0x3c

                        /* Increment the relative sector.  */
                        relative_sector++;
 800973c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800973e:	3301      	adds	r3, #1
 8009740:	63bb      	str	r3, [r7, #56]	@ 0x38
 8009742:	e032      	b.n	80097aa <_fx_directory_entry_write+0x71e>
                    {

                        /* We need to move to the next cluster.  */

                        /* Pickup the next cluster.  */
                        status =  _fx_utility_FAT_entry_read(media_ptr, cluster, &next_cluster);
 8009744:	f107 0318 	add.w	r3, r7, #24
 8009748:	461a      	mov	r2, r3
 800974a:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 800974c:	6978      	ldr	r0, [r7, #20]
 800974e:	f005 f927 	bl	800e9a0 <_fx_utility_FAT_entry_read>
 8009752:	62f8      	str	r0, [r7, #44]	@ 0x2c

                        /* Check for I/O error.  */
                        if (status != FX_SUCCESS)
 8009754:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8009756:	2b00      	cmp	r3, #0
 8009758:	d001      	beq.n	800975e <_fx_directory_entry_write+0x6d2>
                        {

                            /* Return error code.  */
                            return(status);
 800975a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800975c:	e2cc      	b.n	8009cf8 <_fx_directory_entry_write+0xc6c>
                        }

                        /* Copy next cluster to the current cluster.  */
                        cluster =  next_cluster;
 800975e:	69bb      	ldr	r3, [r7, #24]
 8009760:	633b      	str	r3, [r7, #48]	@ 0x30

                        /* Check the value of the new cluster - it must be a valid cluster number
                           or something is really wrong!  */
                        if ((cluster < FX_FAT_ENTRY_START) || (cluster >= media_ptr -> fx_media_fat_reserved))
 8009762:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8009764:	2b01      	cmp	r3, #1
 8009766:	d907      	bls.n	8009778 <_fx_directory_entry_write+0x6ec>
 8009768:	697b      	ldr	r3, [r7, #20]
 800976a:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 800976e:	f8d3 3478 	ldr.w	r3, [r3, #1144]	@ 0x478
 8009772:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8009774:	429a      	cmp	r2, r3
 8009776:	d301      	bcc.n	800977c <_fx_directory_entry_write+0x6f0>
                        {

                            /* Send error message back to caller.  */
                            return(FX_FILE_CORRUPT);
 8009778:	2308      	movs	r3, #8
 800977a:	e2bd      	b.n	8009cf8 <_fx_directory_entry_write+0xc6c>
                        }

                        /* Setup the relative sector (this is zero for subsequent cluster.  */
                        relative_sector =  0;
 800977c:	2300      	movs	r3, #0
 800977e:	63bb      	str	r3, [r7, #56]	@ 0x38

                        /* Calculate the next logical sector.  */
                        logical_sector =   ((ULONG)media_ptr -> fx_media_data_sector_start) +
 8009780:	697b      	ldr	r3, [r7, #20]
 8009782:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
                            (((ULONG)cluster - FX_FAT_ENTRY_START) *
 8009784:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8009786:	3b02      	subs	r3, #2
                             ((ULONG)media_ptr -> fx_media_sectors_per_cluster));
 8009788:	6979      	ldr	r1, [r7, #20]
 800978a:	6d49      	ldr	r1, [r1, #84]	@ 0x54
                            (((ULONG)cluster - FX_FAT_ENTRY_START) *
 800978c:	fb01 f303 	mul.w	r3, r1, r3
                        logical_sector =   ((ULONG)media_ptr -> fx_media_data_sector_start) +
 8009790:	4413      	add	r3, r2
 8009792:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8009794:	e009      	b.n	80097aa <_fx_directory_entry_write+0x71e>
                }
                else
                {

                    /* Increment the logical sector.  */
                    logical_sector++;
 8009796:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8009798:	3301      	adds	r3, #1
 800979a:	63fb      	str	r3, [r7, #60]	@ 0x3c

                    /* Determine if the logical sector is valid.  */
                    if (logical_sector >= (ULONG)(media_ptr -> fx_media_data_sector_start))
 800979c:	697b      	ldr	r3, [r7, #20]
 800979e:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 80097a0:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 80097a2:	429a      	cmp	r2, r3
 80097a4:	d301      	bcc.n	80097aa <_fx_directory_entry_write+0x71e>
                    {

                        /* We have exceeded the root directory.  */

                        /* Send error message back to caller.  */
                        return(FX_FILE_CORRUPT);
 80097a6:	2308      	movs	r3, #8
 80097a8:	e2a6      	b.n	8009cf8 <_fx_directory_entry_write+0xc6c>
                    }
                }

                /* Read the sector.  */
                status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) logical_sector,
 80097aa:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80097ac:	2200      	movs	r2, #0
 80097ae:	603b      	str	r3, [r7, #0]
 80097b0:	607a      	str	r2, [r7, #4]
                                                          media_ptr -> fx_media_memory_buffer, ((ULONG) 1), FX_DIRECTORY_SECTOR);
 80097b2:	697b      	ldr	r3, [r7, #20]
 80097b4:	689b      	ldr	r3, [r3, #8]
                status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) logical_sector,
 80097b6:	2203      	movs	r2, #3
 80097b8:	9202      	str	r2, [sp, #8]
 80097ba:	2201      	movs	r2, #1
 80097bc:	9201      	str	r2, [sp, #4]
 80097be:	9300      	str	r3, [sp, #0]
 80097c0:	e9d7 2300 	ldrd	r2, r3, [r7]
 80097c4:	6978      	ldr	r0, [r7, #20]
 80097c6:	f006 fcf9 	bl	80101bc <_fx_utility_logical_sector_read>
 80097ca:	62f8      	str	r0, [r7, #44]	@ 0x2c

                /* Determine if an error occurred.  */
                if (status != FX_SUCCESS)
 80097cc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80097ce:	2b00      	cmp	r3, #0
 80097d0:	d001      	beq.n	80097d6 <_fx_directory_entry_write+0x74a>
                {

                    /* Return the error status.  */
                    return(status);
 80097d2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80097d4:	e290      	b.n	8009cf8 <_fx_directory_entry_write+0xc6c>
                }

                /* Setup logical sector.  */
                sector_base_ptr = media_ptr -> fx_media_memory_buffer;
 80097d6:	697b      	ldr	r3, [r7, #20]
 80097d8:	689b      	ldr	r3, [r3, #8]
 80097da:	673b      	str	r3, [r7, #112]	@ 0x70

                /* Setup a fresh byte offset.  */
                byte_offset = 0;
 80097dc:	2300      	movs	r3, #0
 80097de:	637b      	str	r3, [r7, #52]	@ 0x34

                /* Setup a new pointer into the buffer.  */
                work_ptr = sector_base_ptr;
 80097e0:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 80097e2:	677b      	str	r3, [r7, #116]	@ 0x74
                changed_offset = 0;
#endif /* FX_ENABLE_FAULT_TOLERANT */
            }

            /* Decrement loop control.  */
            card--;
 80097e4:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80097e6:	3b01      	subs	r3, #1
 80097e8:	657b      	str	r3, [r7, #84]	@ 0x54
            work_ptr[0] = (UCHAR)card;
 80097ea:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80097ec:	b2da      	uxtb	r2, r3
 80097ee:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 80097f0:	701a      	strb	r2, [r3, #0]
        while (card > 0)
 80097f2:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80097f4:	2b00      	cmp	r3, #0
 80097f6:	f47f af08 	bne.w	800960a <_fx_directory_entry_write+0x57e>
        }

        /* Determine if there is a short name.  */
        if (entry_ptr -> fx_dir_entry_short_name[0] == 0)
 80097fa:	693b      	ldr	r3, [r7, #16]
 80097fc:	791b      	ldrb	r3, [r3, #4]
 80097fe:	2b00      	cmp	r3, #0
 8009800:	d116      	bne.n	8009830 <_fx_directory_entry_write+0x7a4>
        {

            /* Loop to copy the new short file name.  */
            for (i = 0; i < (FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE); i++)
 8009802:	2300      	movs	r3, #0
 8009804:	667b      	str	r3, [r7, #100]	@ 0x64
 8009806:	e00f      	b.n	8009828 <_fx_directory_entry_write+0x79c>
            {

                /* Pickup shortname character.  */
                alpha = shortname[i];
 8009808:	f107 021c 	add.w	r2, r7, #28
 800980c:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 800980e:	4413      	add	r3, r2
 8009810:	781b      	ldrb	r3, [r3, #0]
 8009812:	f887 3041 	strb.w	r3, [r7, #65]	@ 0x41

                /* Now store the short name character.  */
                *work_ptr++ =  (UCHAR)alpha;
 8009816:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8009818:	1c5a      	adds	r2, r3, #1
 800981a:	677a      	str	r2, [r7, #116]	@ 0x74
 800981c:	f897 2041 	ldrb.w	r2, [r7, #65]	@ 0x41
 8009820:	701a      	strb	r2, [r3, #0]
            for (i = 0; i < (FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE); i++)
 8009822:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8009824:	3301      	adds	r3, #1
 8009826:	667b      	str	r3, [r7, #100]	@ 0x64
 8009828:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 800982a:	2b0a      	cmp	r3, #10
 800982c:	d9ec      	bls.n	8009808 <_fx_directory_entry_write+0x77c>
 800982e:	e1a5      	b.n	8009b7c <_fx_directory_entry_write+0xaf0>
        }
        else
        {

            /* Clear the short file name area.  */
            for (i = 0; i < FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE; i++)
 8009830:	2300      	movs	r3, #0
 8009832:	667b      	str	r3, [r7, #100]	@ 0x64
 8009834:	e007      	b.n	8009846 <_fx_directory_entry_write+0x7ba>
            {
                work_ptr[i] = ' ';
 8009836:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8009838:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 800983a:	4413      	add	r3, r2
 800983c:	2220      	movs	r2, #32
 800983e:	701a      	strb	r2, [r3, #0]
            for (i = 0; i < FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE; i++)
 8009840:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8009842:	3301      	adds	r3, #1
 8009844:	667b      	str	r3, [r7, #100]	@ 0x64
 8009846:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8009848:	2b0a      	cmp	r3, #10
 800984a:	d9f4      	bls.n	8009836 <_fx_directory_entry_write+0x7aa>
            }

            /* Loop to copy the old short file name.  */
            for (i = 0, j = 0; j < FX_DIR_NAME_SIZE; i++, j++)
 800984c:	2300      	movs	r3, #0
 800984e:	667b      	str	r3, [r7, #100]	@ 0x64
 8009850:	2300      	movs	r3, #0
 8009852:	663b      	str	r3, [r7, #96]	@ 0x60
 8009854:	e01c      	b.n	8009890 <_fx_directory_entry_write+0x804>
            {

                /* Check for end of copy conditions.  */
                if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] == '.')
 8009856:	693a      	ldr	r2, [r7, #16]
 8009858:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 800985a:	4413      	add	r3, r2
 800985c:	3304      	adds	r3, #4
 800985e:	781b      	ldrb	r3, [r3, #0]
 8009860:	2b2e      	cmp	r3, #46	@ 0x2e
 8009862:	d019      	beq.n	8009898 <_fx_directory_entry_write+0x80c>
                {
                    break;
                }
                if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] == 0)
 8009864:	693a      	ldr	r2, [r7, #16]
 8009866:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8009868:	4413      	add	r3, r2
 800986a:	3304      	adds	r3, #4
 800986c:	781b      	ldrb	r3, [r3, #0]
 800986e:	2b00      	cmp	r3, #0
 8009870:	d014      	beq.n	800989c <_fx_directory_entry_write+0x810>
                {
                    break;
                }

                /* Copy file name character.  */
                work_ptr[j] =  (UCHAR)entry_ptr -> fx_dir_entry_short_name[i];
 8009872:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8009874:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8009876:	4413      	add	r3, r2
 8009878:	6939      	ldr	r1, [r7, #16]
 800987a:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 800987c:	440a      	add	r2, r1
 800987e:	3204      	adds	r2, #4
 8009880:	7812      	ldrb	r2, [r2, #0]
 8009882:	701a      	strb	r2, [r3, #0]
            for (i = 0, j = 0; j < FX_DIR_NAME_SIZE; i++, j++)
 8009884:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8009886:	3301      	adds	r3, #1
 8009888:	667b      	str	r3, [r7, #100]	@ 0x64
 800988a:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 800988c:	3301      	adds	r3, #1
 800988e:	663b      	str	r3, [r7, #96]	@ 0x60
 8009890:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8009892:	2b07      	cmp	r3, #7
 8009894:	d9df      	bls.n	8009856 <_fx_directory_entry_write+0x7ca>
 8009896:	e002      	b.n	800989e <_fx_directory_entry_write+0x812>
                    break;
 8009898:	bf00      	nop
 800989a:	e000      	b.n	800989e <_fx_directory_entry_write+0x812>
                    break;
 800989c:	bf00      	nop
            }

            /* Determine if there is anything left in the short file name.  */
            if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] != 0)
 800989e:	693a      	ldr	r2, [r7, #16]
 80098a0:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80098a2:	4413      	add	r3, r2
 80098a4:	3304      	adds	r3, #4
 80098a6:	781b      	ldrb	r3, [r3, #0]
 80098a8:	2b00      	cmp	r3, #0
 80098aa:	d020      	beq.n	80098ee <_fx_directory_entry_write+0x862>
            {

                /* Pickup remaining characters.  */
                for (i++, j = FX_DIR_NAME_SIZE; j < FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE; i++, j++)
 80098ac:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80098ae:	3301      	adds	r3, #1
 80098b0:	667b      	str	r3, [r7, #100]	@ 0x64
 80098b2:	2308      	movs	r3, #8
 80098b4:	663b      	str	r3, [r7, #96]	@ 0x60
 80098b6:	e015      	b.n	80098e4 <_fx_directory_entry_write+0x858>
                {

                    /* If NULL is encountered, stop the copying.  */
                    if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] == 0)
 80098b8:	693a      	ldr	r2, [r7, #16]
 80098ba:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80098bc:	4413      	add	r3, r2
 80098be:	3304      	adds	r3, #4
 80098c0:	781b      	ldrb	r3, [r3, #0]
 80098c2:	2b00      	cmp	r3, #0
 80098c4:	d012      	beq.n	80098ec <_fx_directory_entry_write+0x860>
                    {
                        break;
                    }

                    /* Copy file name character.  */
                    work_ptr[j] =  (UCHAR)entry_ptr -> fx_dir_entry_short_name[i];
 80098c6:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 80098c8:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80098ca:	4413      	add	r3, r2
 80098cc:	6939      	ldr	r1, [r7, #16]
 80098ce:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 80098d0:	440a      	add	r2, r1
 80098d2:	3204      	adds	r2, #4
 80098d4:	7812      	ldrb	r2, [r2, #0]
 80098d6:	701a      	strb	r2, [r3, #0]
                for (i++, j = FX_DIR_NAME_SIZE; j < FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE; i++, j++)
 80098d8:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80098da:	3301      	adds	r3, #1
 80098dc:	667b      	str	r3, [r7, #100]	@ 0x64
 80098de:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80098e0:	3301      	adds	r3, #1
 80098e2:	663b      	str	r3, [r7, #96]	@ 0x60
 80098e4:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80098e6:	2b0a      	cmp	r3, #10
 80098e8:	d9e6      	bls.n	80098b8 <_fx_directory_entry_write+0x82c>
 80098ea:	e000      	b.n	80098ee <_fx_directory_entry_write+0x862>
                        break;
 80098ec:	bf00      	nop
                }
            }

            /* Adjust the work pointer accordingly.  */
            work_ptr += (FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE);
 80098ee:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 80098f0:	330b      	adds	r3, #11
 80098f2:	677b      	str	r3, [r7, #116]	@ 0x74
 80098f4:	e142      	b.n	8009b7c <_fx_directory_entry_write+0xaf0>
    }
    else
    {

        /* Determine if long name was shorted.  */
        if (entry_ptr -> fx_dir_entry_long_name_shorted > 0)
 80098f6:	693b      	ldr	r3, [r7, #16]
 80098f8:	699b      	ldr	r3, [r3, #24]
 80098fa:	2b00      	cmp	r3, #0
 80098fc:	f000 80a1 	beq.w	8009a42 <_fx_directory_entry_write+0x9b6>
        {

            /* Check for a valid short name.  */
            if ((UCHAR)(0x40 | entry_ptr -> fx_dir_entry_long_name_shorted) == (UCHAR)(*work_ptr))
 8009900:	693b      	ldr	r3, [r7, #16]
 8009902:	699b      	ldr	r3, [r3, #24]
 8009904:	b2db      	uxtb	r3, r3
 8009906:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 800990a:	b2da      	uxtb	r2, r3
 800990c:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 800990e:	781b      	ldrb	r3, [r3, #0]
 8009910:	429a      	cmp	r2, r3
 8009912:	f040 8096 	bne.w	8009a42 <_fx_directory_entry_write+0x9b6>
            {

                /* Loop through the file name.  */
                for (j = 0; j < entry_ptr -> fx_dir_entry_long_name_shorted; j++)
 8009916:	2300      	movs	r3, #0
 8009918:	663b      	str	r3, [r7, #96]	@ 0x60
 800991a:	e08c      	b.n	8009a36 <_fx_directory_entry_write+0x9aa>
                {

                    /* Check for a free entry to be written.  */
                    if ((UCHAR)entry_ptr -> fx_dir_entry_name[0] == (UCHAR)FX_DIR_ENTRY_FREE)
 800991c:	693b      	ldr	r3, [r7, #16]
 800991e:	681b      	ldr	r3, [r3, #0]
 8009920:	781b      	ldrb	r3, [r3, #0]
 8009922:	2be5      	cmp	r3, #229	@ 0xe5
 8009924:	d102      	bne.n	800992c <_fx_directory_entry_write+0x8a0>
                    {
                        /* Delete long parts.  */
                        work_ptr[0] =  (UCHAR)FX_DIR_ENTRY_FREE;
 8009926:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8009928:	22e5      	movs	r2, #229	@ 0xe5
 800992a:	701a      	strb	r2, [r3, #0]
                    }

                    /* Setup pointers for the name write.  */
                    work_ptr += FX_DIR_ENTRY_SIZE;
 800992c:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 800992e:	3320      	adds	r3, #32
 8009930:	677b      	str	r3, [r7, #116]	@ 0x74
                    byte_offset += FX_DIR_ENTRY_SIZE;
 8009932:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8009934:	3320      	adds	r3, #32
 8009936:	637b      	str	r3, [r7, #52]	@ 0x34
                    /* Update changed_size. */
                    changed_size += FX_DIR_ENTRY_SIZE;
#endif /* FX_ENABLE_FAULT_TOLERANT */

                    /* Determine if the write is within the current sector.   */
                    if (byte_offset >= media_ptr -> fx_media_bytes_per_sector)
 8009938:	697b      	ldr	r3, [r7, #20]
 800993a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800993c:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 800993e:	429a      	cmp	r2, r3
 8009940:	d376      	bcc.n	8009a30 <_fx_directory_entry_write+0x9a4>
                        else
                        {
#endif /* FX_ENABLE_FAULT_TOLERANT */

                            /* Write the current sector out.  */
                            status =  _fx_utility_logical_sector_write(media_ptr, (ULONG64) logical_sector,
 8009942:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8009944:	2200      	movs	r2, #0
 8009946:	4698      	mov	r8, r3
 8009948:	4691      	mov	r9, r2
 800994a:	2303      	movs	r3, #3
 800994c:	9302      	str	r3, [sp, #8]
 800994e:	2301      	movs	r3, #1
 8009950:	9301      	str	r3, [sp, #4]
 8009952:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8009954:	9300      	str	r3, [sp, #0]
 8009956:	4642      	mov	r2, r8
 8009958:	464b      	mov	r3, r9
 800995a:	6978      	ldr	r0, [r7, #20]
 800995c:	f006 fec2 	bl	80106e4 <_fx_utility_logical_sector_write>
 8009960:	62f8      	str	r0, [r7, #44]	@ 0x2c
#ifdef FX_ENABLE_FAULT_TOLERANT
                        }
#endif /* FX_ENABLE_FAULT_TOLERANT */

                        /* Determine if an error occurred.  */
                        if (status != FX_SUCCESS)
 8009962:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8009964:	2b00      	cmp	r3, #0
 8009966:	d001      	beq.n	800996c <_fx_directory_entry_write+0x8e0>
                        {

                            /* Return the error status.  */
                            return(status);
 8009968:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800996a:	e1c5      	b.n	8009cf8 <_fx_directory_entry_write+0xc6c>
                        }

                        /* Determine if we are in the root directory.  */
                        if (logical_sector >= (ULONG)(media_ptr -> fx_media_data_sector_start))
 800996c:	697b      	ldr	r3, [r7, #20]
 800996e:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8009970:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8009972:	429a      	cmp	r2, r3
 8009974:	d335      	bcc.n	80099e2 <_fx_directory_entry_write+0x956>
                        {

                            /* Determine the next sector of the directory entry.  */
                            if (relative_sector < (media_ptr -> fx_media_sectors_per_cluster - 1))
 8009976:	697b      	ldr	r3, [r7, #20]
 8009978:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800997a:	3b01      	subs	r3, #1
 800997c:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 800997e:	429a      	cmp	r2, r3
 8009980:	d206      	bcs.n	8009990 <_fx_directory_entry_write+0x904>
                            {

                                /* More sectors in this cluster.  */

                                /* Simply increment the logical sector.  */
                                logical_sector++;
 8009982:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8009984:	3301      	adds	r3, #1
 8009986:	63fb      	str	r3, [r7, #60]	@ 0x3c

                                /* Increment the relative sector.  */
                                relative_sector++;
 8009988:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800998a:	3301      	adds	r3, #1
 800998c:	63bb      	str	r3, [r7, #56]	@ 0x38
 800998e:	e032      	b.n	80099f6 <_fx_directory_entry_write+0x96a>
                            {

                                /* We need to move to the next cluster.  */

                                /* Pickup the next cluster.  */
                                status =  _fx_utility_FAT_entry_read(media_ptr, cluster, &next_cluster);
 8009990:	f107 0318 	add.w	r3, r7, #24
 8009994:	461a      	mov	r2, r3
 8009996:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 8009998:	6978      	ldr	r0, [r7, #20]
 800999a:	f005 f801 	bl	800e9a0 <_fx_utility_FAT_entry_read>
 800999e:	62f8      	str	r0, [r7, #44]	@ 0x2c

                                /* Check for I/O error.  */
                                if (status != FX_SUCCESS)
 80099a0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80099a2:	2b00      	cmp	r3, #0
 80099a4:	d001      	beq.n	80099aa <_fx_directory_entry_write+0x91e>
                                {

                                    /* Return error code.  */
                                    return(status);
 80099a6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80099a8:	e1a6      	b.n	8009cf8 <_fx_directory_entry_write+0xc6c>
                                }

                                /* Copy next cluster to the current cluster.  */
                                cluster =  next_cluster;
 80099aa:	69bb      	ldr	r3, [r7, #24]
 80099ac:	633b      	str	r3, [r7, #48]	@ 0x30

                                /* Check the value of the new cluster - it must be a valid cluster number
                                   or something is really wrong!  */
                                if ((cluster < FX_FAT_ENTRY_START) || (cluster >= media_ptr -> fx_media_fat_reserved))
 80099ae:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80099b0:	2b01      	cmp	r3, #1
 80099b2:	d907      	bls.n	80099c4 <_fx_directory_entry_write+0x938>
 80099b4:	697b      	ldr	r3, [r7, #20]
 80099b6:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 80099ba:	f8d3 3478 	ldr.w	r3, [r3, #1144]	@ 0x478
 80099be:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80099c0:	429a      	cmp	r2, r3
 80099c2:	d301      	bcc.n	80099c8 <_fx_directory_entry_write+0x93c>
                                {

                                    /* Send error message back to caller.  */
                                    return(FX_FILE_CORRUPT);
 80099c4:	2308      	movs	r3, #8
 80099c6:	e197      	b.n	8009cf8 <_fx_directory_entry_write+0xc6c>
                                }

                                /* Setup the relative sector (this is zero for subsequent cluster.  */
                                relative_sector =  0;
 80099c8:	2300      	movs	r3, #0
 80099ca:	63bb      	str	r3, [r7, #56]	@ 0x38

                                /* Calculate the next logical sector.  */
                                logical_sector =   ((ULONG)media_ptr -> fx_media_data_sector_start) +
 80099cc:	697b      	ldr	r3, [r7, #20]
 80099ce:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
                                    (((ULONG)cluster - FX_FAT_ENTRY_START) *
 80099d0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80099d2:	3b02      	subs	r3, #2
                                     ((ULONG)media_ptr -> fx_media_sectors_per_cluster));
 80099d4:	6979      	ldr	r1, [r7, #20]
 80099d6:	6d49      	ldr	r1, [r1, #84]	@ 0x54
                                    (((ULONG)cluster - FX_FAT_ENTRY_START) *
 80099d8:	fb01 f303 	mul.w	r3, r1, r3
                                logical_sector =   ((ULONG)media_ptr -> fx_media_data_sector_start) +
 80099dc:	4413      	add	r3, r2
 80099de:	63fb      	str	r3, [r7, #60]	@ 0x3c
 80099e0:	e009      	b.n	80099f6 <_fx_directory_entry_write+0x96a>
                        }
                        else
                        {

                            /* Increment the logical sector.  */
                            logical_sector++;
 80099e2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80099e4:	3301      	adds	r3, #1
 80099e6:	63fb      	str	r3, [r7, #60]	@ 0x3c

                            /* Determine if the logical sector is valid.  */
                            if (logical_sector >= (ULONG)(media_ptr -> fx_media_data_sector_start))
 80099e8:	697b      	ldr	r3, [r7, #20]
 80099ea:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 80099ec:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 80099ee:	429a      	cmp	r2, r3
 80099f0:	d301      	bcc.n	80099f6 <_fx_directory_entry_write+0x96a>
                            {

                                /* We have exceeded the root directory.  */

                                /* Send error message back to caller.  */
                                return(FX_FILE_CORRUPT);
 80099f2:	2308      	movs	r3, #8
 80099f4:	e180      	b.n	8009cf8 <_fx_directory_entry_write+0xc6c>
                            }
                        }

                        /* Read the next logical sector.  */
                        status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) logical_sector,
 80099f6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80099f8:	2200      	movs	r2, #0
 80099fa:	469a      	mov	sl, r3
 80099fc:	4693      	mov	fp, r2
                                                                  media_ptr -> fx_media_memory_buffer, ((ULONG) 1), FX_DIRECTORY_SECTOR);
 80099fe:	697b      	ldr	r3, [r7, #20]
 8009a00:	689b      	ldr	r3, [r3, #8]
                        status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) logical_sector,
 8009a02:	2203      	movs	r2, #3
 8009a04:	9202      	str	r2, [sp, #8]
 8009a06:	2201      	movs	r2, #1
 8009a08:	9201      	str	r2, [sp, #4]
 8009a0a:	9300      	str	r3, [sp, #0]
 8009a0c:	4652      	mov	r2, sl
 8009a0e:	465b      	mov	r3, fp
 8009a10:	6978      	ldr	r0, [r7, #20]
 8009a12:	f006 fbd3 	bl	80101bc <_fx_utility_logical_sector_read>
 8009a16:	62f8      	str	r0, [r7, #44]	@ 0x2c

                        /* Determine if an error occurred.  */
                        if (status != FX_SUCCESS)
 8009a18:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8009a1a:	2b00      	cmp	r3, #0
 8009a1c:	d001      	beq.n	8009a22 <_fx_directory_entry_write+0x996>
                        {

                            /* Return the error status.  */
                            return(status);
 8009a1e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8009a20:	e16a      	b.n	8009cf8 <_fx_directory_entry_write+0xc6c>
                        }

                        /* Move to the next sector buffer.  */
                        sector_base_ptr = media_ptr -> fx_media_memory_buffer;
 8009a22:	697b      	ldr	r3, [r7, #20]
 8009a24:	689b      	ldr	r3, [r3, #8]
 8009a26:	673b      	str	r3, [r7, #112]	@ 0x70

                        /* Setup new buffer pointers.  */
                        byte_offset =  0;
 8009a28:	2300      	movs	r3, #0
 8009a2a:	637b      	str	r3, [r7, #52]	@ 0x34
                        work_ptr = sector_base_ptr;
 8009a2c:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8009a2e:	677b      	str	r3, [r7, #116]	@ 0x74
                for (j = 0; j < entry_ptr -> fx_dir_entry_long_name_shorted; j++)
 8009a30:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8009a32:	3301      	adds	r3, #1
 8009a34:	663b      	str	r3, [r7, #96]	@ 0x60
 8009a36:	693b      	ldr	r3, [r7, #16]
 8009a38:	699b      	ldr	r3, [r3, #24]
 8009a3a:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 8009a3c:	429a      	cmp	r2, r3
 8009a3e:	f4ff af6d 	bcc.w	800991c <_fx_directory_entry_write+0x890>
                }
            }
        }

        /* This is an 8.3 name.  First clear the directory name.  */
        for (j = 0; j < FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE; j++)
 8009a42:	2300      	movs	r3, #0
 8009a44:	663b      	str	r3, [r7, #96]	@ 0x60
 8009a46:	e007      	b.n	8009a58 <_fx_directory_entry_write+0x9cc>
        {
            work_ptr[j] = ' ';
 8009a48:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8009a4a:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8009a4c:	4413      	add	r3, r2
 8009a4e:	2220      	movs	r2, #32
 8009a50:	701a      	strb	r2, [r3, #0]
        for (j = 0; j < FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE; j++)
 8009a52:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8009a54:	3301      	adds	r3, #1
 8009a56:	663b      	str	r3, [r7, #96]	@ 0x60
 8009a58:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8009a5a:	2b0a      	cmp	r3, #10
 8009a5c:	d9f4      	bls.n	8009a48 <_fx_directory_entry_write+0x9bc>
        }

        /* Copy leading dots in case of first two entries of a directory.  */
        for (i = 0; (UCHAR)entry_ptr -> fx_dir_entry_name[i] == '.'; i++)
 8009a5e:	2300      	movs	r3, #0
 8009a60:	667b      	str	r3, [r7, #100]	@ 0x64
 8009a62:	e007      	b.n	8009a74 <_fx_directory_entry_write+0x9e8>
        {
            work_ptr[i] = '.';
 8009a64:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8009a66:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8009a68:	4413      	add	r3, r2
 8009a6a:	222e      	movs	r2, #46	@ 0x2e
 8009a6c:	701a      	strb	r2, [r3, #0]
        for (i = 0; (UCHAR)entry_ptr -> fx_dir_entry_name[i] == '.'; i++)
 8009a6e:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8009a70:	3301      	adds	r3, #1
 8009a72:	667b      	str	r3, [r7, #100]	@ 0x64
 8009a74:	693b      	ldr	r3, [r7, #16]
 8009a76:	681a      	ldr	r2, [r3, #0]
 8009a78:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8009a7a:	4413      	add	r3, r2
 8009a7c:	781b      	ldrb	r3, [r3, #0]
 8009a7e:	2b2e      	cmp	r3, #46	@ 0x2e
 8009a80:	d0f0      	beq.n	8009a64 <_fx_directory_entry_write+0x9d8>
        }

        /* Determine if there are more characters to copy.  */
        if ((UCHAR)entry_ptr -> fx_dir_entry_name[i] != 0)
 8009a82:	693b      	ldr	r3, [r7, #16]
 8009a84:	681a      	ldr	r2, [r3, #0]
 8009a86:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8009a88:	4413      	add	r3, r2
 8009a8a:	781b      	ldrb	r3, [r3, #0]
 8009a8c:	2b00      	cmp	r3, #0
 8009a8e:	d039      	beq.n	8009b04 <_fx_directory_entry_write+0xa78>
        {

            /* Copy directory name.  */
            for (i = 0, j = 0; j < FX_DIR_NAME_SIZE; i++, j++)
 8009a90:	2300      	movs	r3, #0
 8009a92:	667b      	str	r3, [r7, #100]	@ 0x64
 8009a94:	2300      	movs	r3, #0
 8009a96:	663b      	str	r3, [r7, #96]	@ 0x60
 8009a98:	e02d      	b.n	8009af6 <_fx_directory_entry_write+0xa6a>
            {

                /* Check for end of copy conditions.  */
                if ((UCHAR)entry_ptr -> fx_dir_entry_name[i] == '.')
 8009a9a:	693b      	ldr	r3, [r7, #16]
 8009a9c:	681a      	ldr	r2, [r3, #0]
 8009a9e:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8009aa0:	4413      	add	r3, r2
 8009aa2:	781b      	ldrb	r3, [r3, #0]
 8009aa4:	2b2e      	cmp	r3, #46	@ 0x2e
 8009aa6:	d02a      	beq.n	8009afe <_fx_directory_entry_write+0xa72>
                {
                    break;
                }
                if ((UCHAR)entry_ptr -> fx_dir_entry_name[i] == 0)
 8009aa8:	693b      	ldr	r3, [r7, #16]
 8009aaa:	681a      	ldr	r2, [r3, #0]
 8009aac:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8009aae:	4413      	add	r3, r2
 8009ab0:	781b      	ldrb	r3, [r3, #0]
 8009ab2:	2b00      	cmp	r3, #0
 8009ab4:	d025      	beq.n	8009b02 <_fx_directory_entry_write+0xa76>
                {
                    break;
                }

                /* Pickup shortname character.  */
                alpha = entry_ptr -> fx_dir_entry_name[i];
 8009ab6:	693b      	ldr	r3, [r7, #16]
 8009ab8:	681a      	ldr	r2, [r3, #0]
 8009aba:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8009abc:	4413      	add	r3, r2
 8009abe:	781b      	ldrb	r3, [r3, #0]
 8009ac0:	f887 3041 	strb.w	r3, [r7, #65]	@ 0x41

                /* Determine if character is lower case.  */
                if ((alpha >= 'a') && (alpha <= 'z'))
 8009ac4:	f897 3041 	ldrb.w	r3, [r7, #65]	@ 0x41
 8009ac8:	2b60      	cmp	r3, #96	@ 0x60
 8009aca:	d908      	bls.n	8009ade <_fx_directory_entry_write+0xa52>
 8009acc:	f897 3041 	ldrb.w	r3, [r7, #65]	@ 0x41
 8009ad0:	2b7a      	cmp	r3, #122	@ 0x7a
 8009ad2:	d804      	bhi.n	8009ade <_fx_directory_entry_write+0xa52>
                {

                    /* Store the character - converted to upper case.  */
                    alpha =  (CHAR)(alpha - ((CHAR)0x20));
 8009ad4:	f897 3041 	ldrb.w	r3, [r7, #65]	@ 0x41
 8009ad8:	3b20      	subs	r3, #32
 8009ada:	f887 3041 	strb.w	r3, [r7, #65]	@ 0x41
                }

                /* Copy a name character.  */
                work_ptr[j] =  (UCHAR)alpha;
 8009ade:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8009ae0:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8009ae2:	4413      	add	r3, r2
 8009ae4:	f897 2041 	ldrb.w	r2, [r7, #65]	@ 0x41
 8009ae8:	701a      	strb	r2, [r3, #0]
            for (i = 0, j = 0; j < FX_DIR_NAME_SIZE; i++, j++)
 8009aea:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8009aec:	3301      	adds	r3, #1
 8009aee:	667b      	str	r3, [r7, #100]	@ 0x64
 8009af0:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8009af2:	3301      	adds	r3, #1
 8009af4:	663b      	str	r3, [r7, #96]	@ 0x60
 8009af6:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8009af8:	2b07      	cmp	r3, #7
 8009afa:	d9ce      	bls.n	8009a9a <_fx_directory_entry_write+0xa0e>
 8009afc:	e002      	b.n	8009b04 <_fx_directory_entry_write+0xa78>
                    break;
 8009afe:	bf00      	nop
 8009b00:	e000      	b.n	8009b04 <_fx_directory_entry_write+0xa78>
                    break;
 8009b02:	bf00      	nop
            }
        }

        /* Determine if there are more characters in the name.  */
        if ((UCHAR)entry_ptr -> fx_dir_entry_name[i] != 0)
 8009b04:	693b      	ldr	r3, [r7, #16]
 8009b06:	681a      	ldr	r2, [r3, #0]
 8009b08:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8009b0a:	4413      	add	r3, r2
 8009b0c:	781b      	ldrb	r3, [r3, #0]
 8009b0e:	2b00      	cmp	r3, #0
 8009b10:	d031      	beq.n	8009b76 <_fx_directory_entry_write+0xaea>
        {

            /* Loop to copy the remainder of the name.  */
            for (i++, j = FX_DIR_NAME_SIZE; j < FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE; i++, j++)
 8009b12:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8009b14:	3301      	adds	r3, #1
 8009b16:	667b      	str	r3, [r7, #100]	@ 0x64
 8009b18:	2308      	movs	r3, #8
 8009b1a:	663b      	str	r3, [r7, #96]	@ 0x60
 8009b1c:	e026      	b.n	8009b6c <_fx_directory_entry_write+0xae0>
            {

                /* Check for end of copy conditions.  */
                if ((UCHAR)entry_ptr -> fx_dir_entry_name[i] == 0)
 8009b1e:	693b      	ldr	r3, [r7, #16]
 8009b20:	681a      	ldr	r2, [r3, #0]
 8009b22:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8009b24:	4413      	add	r3, r2
 8009b26:	781b      	ldrb	r3, [r3, #0]
 8009b28:	2b00      	cmp	r3, #0
 8009b2a:	d023      	beq.n	8009b74 <_fx_directory_entry_write+0xae8>
                {
                    break;
                }

                /* Pickup shortname character.  */
                alpha = entry_ptr -> fx_dir_entry_name[i];
 8009b2c:	693b      	ldr	r3, [r7, #16]
 8009b2e:	681a      	ldr	r2, [r3, #0]
 8009b30:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8009b32:	4413      	add	r3, r2
 8009b34:	781b      	ldrb	r3, [r3, #0]
 8009b36:	f887 3041 	strb.w	r3, [r7, #65]	@ 0x41

                /* Determine if character is lower case.  */
                if ((alpha >= 'a') && (alpha <= 'z'))
 8009b3a:	f897 3041 	ldrb.w	r3, [r7, #65]	@ 0x41
 8009b3e:	2b60      	cmp	r3, #96	@ 0x60
 8009b40:	d908      	bls.n	8009b54 <_fx_directory_entry_write+0xac8>
 8009b42:	f897 3041 	ldrb.w	r3, [r7, #65]	@ 0x41
 8009b46:	2b7a      	cmp	r3, #122	@ 0x7a
 8009b48:	d804      	bhi.n	8009b54 <_fx_directory_entry_write+0xac8>
                {

                    /* Store the character - converted to upper case.  */
                    alpha =  (CHAR)(alpha - ((CHAR)0x20));
 8009b4a:	f897 3041 	ldrb.w	r3, [r7, #65]	@ 0x41
 8009b4e:	3b20      	subs	r3, #32
 8009b50:	f887 3041 	strb.w	r3, [r7, #65]	@ 0x41
                }

                /* Copy a name character.  */
                work_ptr[j] =  (UCHAR)alpha;
 8009b54:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 8009b56:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8009b58:	4413      	add	r3, r2
 8009b5a:	f897 2041 	ldrb.w	r2, [r7, #65]	@ 0x41
 8009b5e:	701a      	strb	r2, [r3, #0]
            for (i++, j = FX_DIR_NAME_SIZE; j < FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE; i++, j++)
 8009b60:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8009b62:	3301      	adds	r3, #1
 8009b64:	667b      	str	r3, [r7, #100]	@ 0x64
 8009b66:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8009b68:	3301      	adds	r3, #1
 8009b6a:	663b      	str	r3, [r7, #96]	@ 0x60
 8009b6c:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8009b6e:	2b0a      	cmp	r3, #10
 8009b70:	d9d5      	bls.n	8009b1e <_fx_directory_entry_write+0xa92>
 8009b72:	e000      	b.n	8009b76 <_fx_directory_entry_write+0xaea>
                    break;
 8009b74:	bf00      	nop
            }
        }

        /* Move to the next entry.  */
        work_ptr += (FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE);
 8009b76:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8009b78:	330b      	adds	r3, #11
 8009b7a:	677b      	str	r3, [r7, #116]	@ 0x74
    }

    /* Write out the 8.3 part of the name. */

    /* Copy the attribute into the destination.  */
    *work_ptr++ =  entry_ptr -> fx_dir_entry_attributes;
 8009b7c:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8009b7e:	1c5a      	adds	r2, r3, #1
 8009b80:	677a      	str	r2, [r7, #116]	@ 0x74
 8009b82:	693a      	ldr	r2, [r7, #16]
 8009b84:	7f12      	ldrb	r2, [r2, #28]
 8009b86:	701a      	strb	r2, [r3, #0]

    /* Copy the reserved byte.  */
    *work_ptr++ =  entry_ptr -> fx_dir_entry_reserved;
 8009b88:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8009b8a:	1c5a      	adds	r2, r3, #1
 8009b8c:	677a      	str	r2, [r7, #116]	@ 0x74
 8009b8e:	693a      	ldr	r2, [r7, #16]
 8009b90:	7f52      	ldrb	r2, [r2, #29]
 8009b92:	701a      	strb	r2, [r3, #0]

    /* Copy the created time in milliseconds.  */
    *work_ptr++ =  entry_ptr -> fx_dir_entry_created_time_ms;
 8009b94:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8009b96:	1c5a      	adds	r2, r3, #1
 8009b98:	677a      	str	r2, [r7, #116]	@ 0x74
 8009b9a:	693a      	ldr	r2, [r7, #16]
 8009b9c:	7f92      	ldrb	r2, [r2, #30]
 8009b9e:	701a      	strb	r2, [r3, #0]

    /* Copy the created time.  */
    _fx_utility_16_unsigned_write(work_ptr, entry_ptr -> fx_dir_entry_created_time);
 8009ba0:	693b      	ldr	r3, [r7, #16]
 8009ba2:	6a1b      	ldr	r3, [r3, #32]
 8009ba4:	4619      	mov	r1, r3
 8009ba6:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 8009ba8:	f004 fea7 	bl	800e8fa <_fx_utility_16_unsigned_write>
    work_ptr =  work_ptr + 2;  /* Always 2 bytes  */
 8009bac:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8009bae:	3302      	adds	r3, #2
 8009bb0:	677b      	str	r3, [r7, #116]	@ 0x74

    /* Copy the created date.  */
    _fx_utility_16_unsigned_write(work_ptr, entry_ptr -> fx_dir_entry_created_date);
 8009bb2:	693b      	ldr	r3, [r7, #16]
 8009bb4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8009bb6:	4619      	mov	r1, r3
 8009bb8:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 8009bba:	f004 fe9e 	bl	800e8fa <_fx_utility_16_unsigned_write>
    work_ptr =  work_ptr + 2;  /* Always 2 bytes  */
 8009bbe:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8009bc0:	3302      	adds	r3, #2
 8009bc2:	677b      	str	r3, [r7, #116]	@ 0x74

    /* Copy the last accessed date.  */
    _fx_utility_16_unsigned_write(work_ptr, entry_ptr -> fx_dir_entry_last_accessed_date);
 8009bc4:	693b      	ldr	r3, [r7, #16]
 8009bc6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8009bc8:	4619      	mov	r1, r3
 8009bca:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 8009bcc:	f004 fe95 	bl	800e8fa <_fx_utility_16_unsigned_write>
    work_ptr =  work_ptr + 2;  /* Always 2 bytes  */
 8009bd0:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8009bd2:	3302      	adds	r3, #2
 8009bd4:	677b      	str	r3, [r7, #116]	@ 0x74

    /* Determine if a FAT32 entry is present.  */
    if (media_ptr -> fx_media_32_bit_FAT)
 8009bd6:	697b      	ldr	r3, [r7, #20]
 8009bd8:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8009bda:	2b00      	cmp	r3, #0
 8009bdc:	d008      	beq.n	8009bf0 <_fx_directory_entry_write+0xb64>
    {

        /* Yes, FAT32 is present, store upper half of cluster.  */
        temp = (entry_ptr -> fx_dir_entry_cluster >> 16);
 8009bde:	693b      	ldr	r3, [r7, #16]
 8009be0:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8009be2:	0c1b      	lsrs	r3, r3, #16
 8009be4:	66fb      	str	r3, [r7, #108]	@ 0x6c
        _fx_utility_16_unsigned_write(work_ptr, temp);
 8009be6:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 8009be8:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 8009bea:	f004 fe86 	bl	800e8fa <_fx_utility_16_unsigned_write>
 8009bee:	e003      	b.n	8009bf8 <_fx_directory_entry_write+0xb6c>
    else
    {

        /* No, FAT16 or FAT12 is present, just write a 0 for
           the upper half of the cluster.  */
        _fx_utility_16_unsigned_write(work_ptr, 0);
 8009bf0:	2100      	movs	r1, #0
 8009bf2:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 8009bf4:	f004 fe81 	bl	800e8fa <_fx_utility_16_unsigned_write>
    }

    /* Advance the entry pointer.  */
    work_ptr =  work_ptr + 2;  /* Always 2 bytes  */
 8009bf8:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8009bfa:	3302      	adds	r3, #2
 8009bfc:	677b      	str	r3, [r7, #116]	@ 0x74

    /* Copy the time into the destination.  */
    _fx_utility_16_unsigned_write(work_ptr, entry_ptr -> fx_dir_entry_time);
 8009bfe:	693b      	ldr	r3, [r7, #16]
 8009c00:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8009c02:	4619      	mov	r1, r3
 8009c04:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 8009c06:	f004 fe78 	bl	800e8fa <_fx_utility_16_unsigned_write>
    work_ptr =  work_ptr + 2;  /* Always 2 bytes  */
 8009c0a:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8009c0c:	3302      	adds	r3, #2
 8009c0e:	677b      	str	r3, [r7, #116]	@ 0x74

    /* Copy the date into the destination.  */
    _fx_utility_16_unsigned_write(work_ptr, entry_ptr -> fx_dir_entry_date);
 8009c10:	693b      	ldr	r3, [r7, #16]
 8009c12:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8009c14:	4619      	mov	r1, r3
 8009c16:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 8009c18:	f004 fe6f 	bl	800e8fa <_fx_utility_16_unsigned_write>
    work_ptr =  work_ptr + 2;  /* Always 2 bytes  */
 8009c1c:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8009c1e:	3302      	adds	r3, #2
 8009c20:	677b      	str	r3, [r7, #116]	@ 0x74

    /* Copy the starting cluster into the destination.  */
    _fx_utility_16_unsigned_write(work_ptr, (UINT)entry_ptr -> fx_dir_entry_cluster);
 8009c22:	693b      	ldr	r3, [r7, #16]
 8009c24:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8009c26:	4619      	mov	r1, r3
 8009c28:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 8009c2a:	f004 fe66 	bl	800e8fa <_fx_utility_16_unsigned_write>
    work_ptr =  work_ptr + 2;  /* Always 2 bytes  */
 8009c2e:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8009c30:	3302      	adds	r3, #2
 8009c32:	677b      	str	r3, [r7, #116]	@ 0x74

    /* Copy the file size into the destination.  */
    _fx_utility_32_unsigned_write(work_ptr, (ULONG)entry_ptr -> fx_dir_entry_file_size);
 8009c34:	693b      	ldr	r3, [r7, #16]
 8009c36:	e9d3 230e 	ldrd	r2, r3, [r3, #56]	@ 0x38
 8009c3a:	4613      	mov	r3, r2
 8009c3c:	4619      	mov	r1, r3
 8009c3e:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 8009c40:	f004 fe8d 	bl	800e95e <_fx_utility_32_unsigned_write>
    else
    {
#endif /* FX_ENABLE_FAULT_TOLERANT */

        /* Write the directory sector to the media.  */
        status =  _fx_utility_logical_sector_write(media_ptr, (ULONG64) logical_sector,
 8009c44:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8009c46:	2200      	movs	r2, #0
 8009c48:	461c      	mov	r4, r3
 8009c4a:	4615      	mov	r5, r2
 8009c4c:	2303      	movs	r3, #3
 8009c4e:	9302      	str	r3, [sp, #8]
 8009c50:	2301      	movs	r3, #1
 8009c52:	9301      	str	r3, [sp, #4]
 8009c54:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8009c56:	9300      	str	r3, [sp, #0]
 8009c58:	4622      	mov	r2, r4
 8009c5a:	462b      	mov	r3, r5
 8009c5c:	6978      	ldr	r0, [r7, #20]
 8009c5e:	f006 fd41 	bl	80106e4 <_fx_utility_logical_sector_write>
 8009c62:	62f8      	str	r0, [r7, #44]	@ 0x2c
#ifdef FX_ENABLE_FAULT_TOLERANT
    }
#endif /* FX_ENABLE_FAULT_TOLERANT */

    /* Determine if an error occurred.  */
    if (status != FX_SUCCESS)
 8009c64:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8009c66:	2b00      	cmp	r3, #0
 8009c68:	d001      	beq.n	8009c6e <_fx_directory_entry_write+0xbe2>
    {

        /* Return the error status.  */
        return(status);
 8009c6a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8009c6c:	e044      	b.n	8009cf8 <_fx_directory_entry_write+0xc6c>

#ifndef FX_MEDIA_DISABLE_SEARCH_CACHE

    /* Determine if there is a previously found directory entry in the directory
       search cache.  */
    if (media_ptr -> fx_media_last_found_name[0])
 8009c6e:	697b      	ldr	r3, [r7, #20]
 8009c70:	f893 33b0 	ldrb.w	r3, [r3, #944]	@ 0x3b0
 8009c74:	2b00      	cmp	r3, #0
 8009c76:	d03e      	beq.n	8009cf6 <_fx_directory_entry_write+0xc6a>
    {

        /* Determine if the cached search directory entry matches the directory entry being
           written.  */
        if ((entry_ptr -> fx_dir_entry_log_sector == media_ptr -> fx_media_last_found_entry.fx_dir_entry_log_sector) &&
 8009c78:	693b      	ldr	r3, [r7, #16]
 8009c7a:	e9d3 0110 	ldrd	r0, r1, [r3, #64]	@ 0x40
 8009c7e:	697b      	ldr	r3, [r7, #20]
 8009c80:	e9d3 23a0 	ldrd	r2, r3, [r3, #640]	@ 0x280
 8009c84:	4299      	cmp	r1, r3
 8009c86:	bf08      	it	eq
 8009c88:	4290      	cmpeq	r0, r2
 8009c8a:	d134      	bne.n	8009cf6 <_fx_directory_entry_write+0xc6a>
            (entry_ptr -> fx_dir_entry_byte_offset == media_ptr -> fx_media_last_found_entry.fx_dir_entry_byte_offset))
 8009c8c:	693b      	ldr	r3, [r7, #16]
 8009c8e:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
 8009c90:	697b      	ldr	r3, [r7, #20]
 8009c92:	f8d3 3288 	ldr.w	r3, [r3, #648]	@ 0x288
        if ((entry_ptr -> fx_dir_entry_log_sector == media_ptr -> fx_media_last_found_entry.fx_dir_entry_log_sector) &&
 8009c96:	429a      	cmp	r2, r3
 8009c98:	d12d      	bne.n	8009cf6 <_fx_directory_entry_write+0xc6a>
        {

            /* Yes, this entry is the same as the one currently in the directory search cache.
               Update various fields in the directory search cache with the information being
               written now.  */
            media_ptr -> fx_media_last_found_entry.fx_dir_entry_cluster =         entry_ptr -> fx_dir_entry_cluster;
 8009c9a:	693b      	ldr	r3, [r7, #16]
 8009c9c:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8009c9e:	697b      	ldr	r3, [r7, #20]
 8009ca0:	f8c3 2274 	str.w	r2, [r3, #628]	@ 0x274
            media_ptr -> fx_media_last_found_entry.fx_dir_entry_file_size =       entry_ptr -> fx_dir_entry_file_size;
 8009ca4:	693b      	ldr	r3, [r7, #16]
 8009ca6:	e9d3 230e 	ldrd	r2, r3, [r3, #56]	@ 0x38
 8009caa:	6979      	ldr	r1, [r7, #20]
 8009cac:	e9c1 239e 	strd	r2, r3, [r1, #632]	@ 0x278
            media_ptr -> fx_media_last_found_entry.fx_dir_entry_attributes =      entry_ptr -> fx_dir_entry_attributes;
 8009cb0:	693b      	ldr	r3, [r7, #16]
 8009cb2:	7f1a      	ldrb	r2, [r3, #28]
 8009cb4:	697b      	ldr	r3, [r7, #20]
 8009cb6:	f883 225c 	strb.w	r2, [r3, #604]	@ 0x25c
            media_ptr -> fx_media_last_found_entry.fx_dir_entry_time =            entry_ptr -> fx_dir_entry_time;
 8009cba:	693b      	ldr	r3, [r7, #16]
 8009cbc:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8009cbe:	697b      	ldr	r3, [r7, #20]
 8009cc0:	f8c3 226c 	str.w	r2, [r3, #620]	@ 0x26c
            media_ptr -> fx_media_last_found_entry.fx_dir_entry_date =            entry_ptr -> fx_dir_entry_date;
 8009cc4:	693b      	ldr	r3, [r7, #16]
 8009cc6:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8009cc8:	697b      	ldr	r3, [r7, #20]
 8009cca:	f8c3 2270 	str.w	r2, [r3, #624]	@ 0x270
            media_ptr -> fx_media_last_found_entry.fx_dir_entry_reserved =        entry_ptr -> fx_dir_entry_reserved;
 8009cce:	693b      	ldr	r3, [r7, #16]
 8009cd0:	7f5a      	ldrb	r2, [r3, #29]
 8009cd2:	697b      	ldr	r3, [r7, #20]
 8009cd4:	f883 225d 	strb.w	r2, [r3, #605]	@ 0x25d
            media_ptr -> fx_media_last_found_entry.fx_dir_entry_created_time_ms = entry_ptr -> fx_dir_entry_created_time_ms;
 8009cd8:	693b      	ldr	r3, [r7, #16]
 8009cda:	7f9a      	ldrb	r2, [r3, #30]
 8009cdc:	697b      	ldr	r3, [r7, #20]
 8009cde:	f883 225e 	strb.w	r2, [r3, #606]	@ 0x25e
            media_ptr -> fx_media_last_found_entry.fx_dir_entry_created_time =    entry_ptr -> fx_dir_entry_created_time;
 8009ce2:	693b      	ldr	r3, [r7, #16]
 8009ce4:	6a1a      	ldr	r2, [r3, #32]
 8009ce6:	697b      	ldr	r3, [r7, #20]
 8009ce8:	f8c3 2260 	str.w	r2, [r3, #608]	@ 0x260
            media_ptr -> fx_media_last_found_entry.fx_dir_entry_created_date =    entry_ptr -> fx_dir_entry_created_date;
 8009cec:	693b      	ldr	r3, [r7, #16]
 8009cee:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8009cf0:	697b      	ldr	r3, [r7, #20]
 8009cf2:	f8c3 2264 	str.w	r2, [r3, #612]	@ 0x264
        }
    }
#endif

    /* Return success to the caller.  */
    return(FX_SUCCESS);
 8009cf6:	2300      	movs	r3, #0
}
 8009cf8:	4618      	mov	r0, r3
 8009cfa:	3778      	adds	r7, #120	@ 0x78
 8009cfc:	46bd      	mov	sp, r7
 8009cfe:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 8009d02:	bf00      	nop

08009d04 <_fx_directory_free_search>:
/*                                            check for sub directory,    */
/*                                            resulting in version 6.1.12 */
/*                                                                        */
/**************************************************************************/
UINT  _fx_directory_free_search(FX_MEDIA *media_ptr, FX_DIR_ENTRY *directory_ptr, FX_DIR_ENTRY *entry_ptr)
{
 8009d04:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8009d08:	b0a4      	sub	sp, #144	@ 0x90
 8009d0a:	af04      	add	r7, sp, #16
 8009d0c:	6278      	str	r0, [r7, #36]	@ 0x24
 8009d0e:	6239      	str	r1, [r7, #32]
 8009d10:	61fa      	str	r2, [r7, #28]
#endif /* FX_ENABLE_EXFAT */

#ifndef FX_MEDIA_STATISTICS_DISABLE

    /* Increment the number of directory free entry search requests.  */
    media_ptr -> fx_media_directory_free_searches++;
 8009d12:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8009d14:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
 8009d18:	1c5a      	adds	r2, r3, #1
 8009d1a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8009d1c:	f8c3 2174 	str.w	r2, [r3, #372]	@ 0x174
#endif

    /* Initialize the entry sector values.  */
    entry_sector = entry_offset = 0;
 8009d20:	2300      	movs	r3, #0
 8009d22:	66bb      	str	r3, [r7, #104]	@ 0x68
 8009d24:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8009d26:	66fb      	str	r3, [r7, #108]	@ 0x6c

    /* Set the long file name flag to false.  */
    entry_ptr -> fx_dir_entry_long_name_present =  0;
 8009d28:	69fb      	ldr	r3, [r7, #28]
 8009d2a:	2200      	movs	r2, #0
 8009d2c:	615a      	str	r2, [r3, #20]

    /* Are there leading dots?  */
    if (entry_ptr -> fx_dir_entry_name[0] == '.')
 8009d2e:	69fb      	ldr	r3, [r7, #28]
 8009d30:	681b      	ldr	r3, [r3, #0]
 8009d32:	781b      	ldrb	r3, [r3, #0]
 8009d34:	2b2e      	cmp	r3, #46	@ 0x2e
 8009d36:	d107      	bne.n	8009d48 <_fx_directory_free_search+0x44>
    {

        /* Is there more than 1 dot?  */
        if (entry_ptr -> fx_dir_entry_name[1] == '.')
 8009d38:	69fb      	ldr	r3, [r7, #28]
 8009d3a:	681b      	ldr	r3, [r3, #0]
 8009d3c:	3301      	adds	r3, #1
 8009d3e:	781b      	ldrb	r3, [r3, #0]
 8009d40:	2b2e      	cmp	r3, #46	@ 0x2e
 8009d42:	d101      	bne.n	8009d48 <_fx_directory_free_search+0x44>
        {
            /* Yes, consider the name invalid.  */
            return(FX_INVALID_NAME);
 8009d44:	230c      	movs	r3, #12
 8009d46:	e3bf      	b.n	800a4c8 <_fx_directory_free_search+0x7c4>
        }
    }

    /* Determine if a long file name is present.  */
    for (i = 0, j = 0; entry_ptr -> fx_dir_entry_name[i]; i++)
 8009d48:	2300      	movs	r3, #0
 8009d4a:	67fb      	str	r3, [r7, #124]	@ 0x7c
 8009d4c:	2300      	movs	r3, #0
 8009d4e:	67bb      	str	r3, [r7, #120]	@ 0x78
 8009d50:	e115      	b.n	8009f7e <_fx_directory_free_search+0x27a>
    {

        /* Check for upper-case characters.  */
        if ((entry_ptr -> fx_dir_entry_name[i] >= 'A') && (entry_ptr -> fx_dir_entry_name[i] <= 'Z'))
 8009d52:	69fb      	ldr	r3, [r7, #28]
 8009d54:	681a      	ldr	r2, [r3, #0]
 8009d56:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8009d58:	4413      	add	r3, r2
 8009d5a:	781b      	ldrb	r3, [r3, #0]
 8009d5c:	2b40      	cmp	r3, #64	@ 0x40
 8009d5e:	d907      	bls.n	8009d70 <_fx_directory_free_search+0x6c>
 8009d60:	69fb      	ldr	r3, [r7, #28]
 8009d62:	681a      	ldr	r2, [r3, #0]
 8009d64:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8009d66:	4413      	add	r3, r2
 8009d68:	781b      	ldrb	r3, [r3, #0]
 8009d6a:	2b5a      	cmp	r3, #90	@ 0x5a
 8009d6c:	f240 80fd 	bls.w	8009f6a <_fx_directory_free_search+0x266>
        {
            continue;
        }
        /* Check for numeric characters.  */
        else if ((entry_ptr -> fx_dir_entry_name[i] >= '0') && (entry_ptr -> fx_dir_entry_name[i] <= '9'))
 8009d70:	69fb      	ldr	r3, [r7, #28]
 8009d72:	681a      	ldr	r2, [r3, #0]
 8009d74:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8009d76:	4413      	add	r3, r2
 8009d78:	781b      	ldrb	r3, [r3, #0]
 8009d7a:	2b2f      	cmp	r3, #47	@ 0x2f
 8009d7c:	d907      	bls.n	8009d8e <_fx_directory_free_search+0x8a>
 8009d7e:	69fb      	ldr	r3, [r7, #28]
 8009d80:	681a      	ldr	r2, [r3, #0]
 8009d82:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8009d84:	4413      	add	r3, r2
 8009d86:	781b      	ldrb	r3, [r3, #0]
 8009d88:	2b39      	cmp	r3, #57	@ 0x39
 8009d8a:	f240 80f0 	bls.w	8009f6e <_fx_directory_free_search+0x26a>
        {
            continue;
        }
        /* Check for any lower-case characters.  */
        else if ((entry_ptr -> fx_dir_entry_name[i] >= 'a') && (entry_ptr -> fx_dir_entry_name[i] <= 'z'))
 8009d8e:	69fb      	ldr	r3, [r7, #28]
 8009d90:	681a      	ldr	r2, [r3, #0]
 8009d92:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8009d94:	4413      	add	r3, r2
 8009d96:	781b      	ldrb	r3, [r3, #0]
 8009d98:	2b60      	cmp	r3, #96	@ 0x60
 8009d9a:	d90a      	bls.n	8009db2 <_fx_directory_free_search+0xae>
 8009d9c:	69fb      	ldr	r3, [r7, #28]
 8009d9e:	681a      	ldr	r2, [r3, #0]
 8009da0:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8009da2:	4413      	add	r3, r2
 8009da4:	781b      	ldrb	r3, [r3, #0]
 8009da6:	2b7a      	cmp	r3, #122	@ 0x7a
 8009da8:	d803      	bhi.n	8009db2 <_fx_directory_free_search+0xae>
        {
            entry_ptr -> fx_dir_entry_long_name_present =  1;
 8009daa:	69fb      	ldr	r3, [r7, #28]
 8009dac:	2201      	movs	r2, #1
 8009dae:	615a      	str	r2, [r3, #20]
 8009db0:	e0e2      	b.n	8009f78 <_fx_directory_free_search+0x274>
        }
        /* Check for a space in the middle of the name.  */
        else if (entry_ptr -> fx_dir_entry_name[i] == ' ')
 8009db2:	69fb      	ldr	r3, [r7, #28]
 8009db4:	681a      	ldr	r2, [r3, #0]
 8009db6:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8009db8:	4413      	add	r3, r2
 8009dba:	781b      	ldrb	r3, [r3, #0]
 8009dbc:	2b20      	cmp	r3, #32
 8009dbe:	d103      	bne.n	8009dc8 <_fx_directory_free_search+0xc4>
        {
            entry_ptr -> fx_dir_entry_long_name_present = 1;
 8009dc0:	69fb      	ldr	r3, [r7, #28]
 8009dc2:	2201      	movs	r2, #1
 8009dc4:	615a      	str	r2, [r3, #20]
 8009dc6:	e0d7      	b.n	8009f78 <_fx_directory_free_search+0x274>
        }
        /* Check for a dot in the name.  */
        else if (entry_ptr -> fx_dir_entry_name[i] == '.')
 8009dc8:	69fb      	ldr	r3, [r7, #28]
 8009dca:	681a      	ldr	r2, [r3, #0]
 8009dcc:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8009dce:	4413      	add	r3, r2
 8009dd0:	781b      	ldrb	r3, [r3, #0]
 8009dd2:	2b2e      	cmp	r3, #46	@ 0x2e
 8009dd4:	d110      	bne.n	8009df8 <_fx_directory_free_search+0xf4>
        {
            /* Determine if this is the first dot detected.  */
            if (j == 0)
 8009dd6:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8009dd8:	2b00      	cmp	r3, #0
 8009dda:	d109      	bne.n	8009df0 <_fx_directory_free_search+0xec>
            {
                /* First dot, remember where it was.  */
                j = i;
 8009ddc:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8009dde:	67bb      	str	r3, [r7, #120]	@ 0x78

                /* Determine if this is a leading dot.  */
                if (i == 0)
 8009de0:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8009de2:	2b00      	cmp	r3, #0
 8009de4:	f040 80c8 	bne.w	8009f78 <_fx_directory_free_search+0x274>
                {

                    /* Leading dot detected, treat as a long filename.  */
                    entry_ptr -> fx_dir_entry_long_name_present =  1;
 8009de8:	69fb      	ldr	r3, [r7, #28]
 8009dea:	2201      	movs	r2, #1
 8009dec:	615a      	str	r2, [r3, #20]
 8009dee:	e0c3      	b.n	8009f78 <_fx_directory_free_search+0x274>
                }
            }
            else
            {
                /* Second dot detected, must have a long file name.  */
                entry_ptr -> fx_dir_entry_long_name_present = 1;
 8009df0:	69fb      	ldr	r3, [r7, #28]
 8009df2:	2201      	movs	r2, #1
 8009df4:	615a      	str	r2, [r3, #20]
 8009df6:	e0bf      	b.n	8009f78 <_fx_directory_free_search+0x274>
            }
        }
        /* Check for a special 0xE5 character.  */
        else if ((UCHAR)entry_ptr -> fx_dir_entry_name[i] == (UCHAR)0xE5)
 8009df8:	69fb      	ldr	r3, [r7, #28]
 8009dfa:	681a      	ldr	r2, [r3, #0]
 8009dfc:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8009dfe:	4413      	add	r3, r2
 8009e00:	781b      	ldrb	r3, [r3, #0]
 8009e02:	2be5      	cmp	r3, #229	@ 0xe5
 8009e04:	d103      	bne.n	8009e0e <_fx_directory_free_search+0x10a>
        {
            entry_ptr -> fx_dir_entry_long_name_present = 1;
 8009e06:	69fb      	ldr	r3, [r7, #28]
 8009e08:	2201      	movs	r2, #1
 8009e0a:	615a      	str	r2, [r3, #20]
 8009e0c:	e0b4      	b.n	8009f78 <_fx_directory_free_search+0x274>
        }
        /* Check for code point value greater than 127.  */
        else if ((UCHAR)entry_ptr -> fx_dir_entry_name[i] > (UCHAR)127)
 8009e0e:	69fb      	ldr	r3, [r7, #28]
 8009e10:	681a      	ldr	r2, [r3, #0]
 8009e12:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8009e14:	4413      	add	r3, r2
 8009e16:	781b      	ldrb	r3, [r3, #0]
 8009e18:	b25b      	sxtb	r3, r3
 8009e1a:	2b00      	cmp	r3, #0
 8009e1c:	f2c0 80a9 	blt.w	8009f72 <_fx_directory_free_search+0x26e>
        {
            continue;
        }
        /* Check for any special characters.  */
        else if ((entry_ptr -> fx_dir_entry_name[i] == '~') ||
 8009e20:	69fb      	ldr	r3, [r7, #28]
 8009e22:	681a      	ldr	r2, [r3, #0]
 8009e24:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8009e26:	4413      	add	r3, r2
 8009e28:	781b      	ldrb	r3, [r3, #0]
 8009e2a:	2b7e      	cmp	r3, #126	@ 0x7e
 8009e2c:	f000 80a3 	beq.w	8009f76 <_fx_directory_free_search+0x272>
                 (entry_ptr -> fx_dir_entry_name[i] == '-') ||
 8009e30:	69fb      	ldr	r3, [r7, #28]
 8009e32:	681a      	ldr	r2, [r3, #0]
 8009e34:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8009e36:	4413      	add	r3, r2
 8009e38:	781b      	ldrb	r3, [r3, #0]
        else if ((entry_ptr -> fx_dir_entry_name[i] == '~') ||
 8009e3a:	2b2d      	cmp	r3, #45	@ 0x2d
 8009e3c:	f000 809b 	beq.w	8009f76 <_fx_directory_free_search+0x272>
                 (entry_ptr -> fx_dir_entry_name[i] == '_') ||
 8009e40:	69fb      	ldr	r3, [r7, #28]
 8009e42:	681a      	ldr	r2, [r3, #0]
 8009e44:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8009e46:	4413      	add	r3, r2
 8009e48:	781b      	ldrb	r3, [r3, #0]
                 (entry_ptr -> fx_dir_entry_name[i] == '-') ||
 8009e4a:	2b5f      	cmp	r3, #95	@ 0x5f
 8009e4c:	f000 8093 	beq.w	8009f76 <_fx_directory_free_search+0x272>
                 (entry_ptr -> fx_dir_entry_name[i] == '}') ||
 8009e50:	69fb      	ldr	r3, [r7, #28]
 8009e52:	681a      	ldr	r2, [r3, #0]
 8009e54:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8009e56:	4413      	add	r3, r2
 8009e58:	781b      	ldrb	r3, [r3, #0]
                 (entry_ptr -> fx_dir_entry_name[i] == '_') ||
 8009e5a:	2b7d      	cmp	r3, #125	@ 0x7d
 8009e5c:	f000 808b 	beq.w	8009f76 <_fx_directory_free_search+0x272>
                 (entry_ptr -> fx_dir_entry_name[i] == '{') ||
 8009e60:	69fb      	ldr	r3, [r7, #28]
 8009e62:	681a      	ldr	r2, [r3, #0]
 8009e64:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8009e66:	4413      	add	r3, r2
 8009e68:	781b      	ldrb	r3, [r3, #0]
                 (entry_ptr -> fx_dir_entry_name[i] == '}') ||
 8009e6a:	2b7b      	cmp	r3, #123	@ 0x7b
 8009e6c:	f000 8083 	beq.w	8009f76 <_fx_directory_free_search+0x272>
                 (entry_ptr -> fx_dir_entry_name[i] == '(') ||
 8009e70:	69fb      	ldr	r3, [r7, #28]
 8009e72:	681a      	ldr	r2, [r3, #0]
 8009e74:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8009e76:	4413      	add	r3, r2
 8009e78:	781b      	ldrb	r3, [r3, #0]
                 (entry_ptr -> fx_dir_entry_name[i] == '{') ||
 8009e7a:	2b28      	cmp	r3, #40	@ 0x28
 8009e7c:	d07b      	beq.n	8009f76 <_fx_directory_free_search+0x272>
                 (entry_ptr -> fx_dir_entry_name[i] == ')') ||
 8009e7e:	69fb      	ldr	r3, [r7, #28]
 8009e80:	681a      	ldr	r2, [r3, #0]
 8009e82:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8009e84:	4413      	add	r3, r2
 8009e86:	781b      	ldrb	r3, [r3, #0]
                 (entry_ptr -> fx_dir_entry_name[i] == '(') ||
 8009e88:	2b29      	cmp	r3, #41	@ 0x29
 8009e8a:	d074      	beq.n	8009f76 <_fx_directory_free_search+0x272>
                 (entry_ptr -> fx_dir_entry_name[i] == '`') ||
 8009e8c:	69fb      	ldr	r3, [r7, #28]
 8009e8e:	681a      	ldr	r2, [r3, #0]
 8009e90:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8009e92:	4413      	add	r3, r2
 8009e94:	781b      	ldrb	r3, [r3, #0]
                 (entry_ptr -> fx_dir_entry_name[i] == ')') ||
 8009e96:	2b60      	cmp	r3, #96	@ 0x60
 8009e98:	d06d      	beq.n	8009f76 <_fx_directory_free_search+0x272>
                 (entry_ptr -> fx_dir_entry_name[i] == '\'') ||
 8009e9a:	69fb      	ldr	r3, [r7, #28]
 8009e9c:	681a      	ldr	r2, [r3, #0]
 8009e9e:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8009ea0:	4413      	add	r3, r2
 8009ea2:	781b      	ldrb	r3, [r3, #0]
                 (entry_ptr -> fx_dir_entry_name[i] == '`') ||
 8009ea4:	2b27      	cmp	r3, #39	@ 0x27
 8009ea6:	d066      	beq.n	8009f76 <_fx_directory_free_search+0x272>
                 (entry_ptr -> fx_dir_entry_name[i] == '!') ||
 8009ea8:	69fb      	ldr	r3, [r7, #28]
 8009eaa:	681a      	ldr	r2, [r3, #0]
 8009eac:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8009eae:	4413      	add	r3, r2
 8009eb0:	781b      	ldrb	r3, [r3, #0]
                 (entry_ptr -> fx_dir_entry_name[i] == '\'') ||
 8009eb2:	2b21      	cmp	r3, #33	@ 0x21
 8009eb4:	d05f      	beq.n	8009f76 <_fx_directory_free_search+0x272>
                 (entry_ptr -> fx_dir_entry_name[i] == '#') ||
 8009eb6:	69fb      	ldr	r3, [r7, #28]
 8009eb8:	681a      	ldr	r2, [r3, #0]
 8009eba:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8009ebc:	4413      	add	r3, r2
 8009ebe:	781b      	ldrb	r3, [r3, #0]
                 (entry_ptr -> fx_dir_entry_name[i] == '!') ||
 8009ec0:	2b23      	cmp	r3, #35	@ 0x23
 8009ec2:	d058      	beq.n	8009f76 <_fx_directory_free_search+0x272>
                 (entry_ptr -> fx_dir_entry_name[i] == '$') ||
 8009ec4:	69fb      	ldr	r3, [r7, #28]
 8009ec6:	681a      	ldr	r2, [r3, #0]
 8009ec8:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8009eca:	4413      	add	r3, r2
 8009ecc:	781b      	ldrb	r3, [r3, #0]
                 (entry_ptr -> fx_dir_entry_name[i] == '#') ||
 8009ece:	2b24      	cmp	r3, #36	@ 0x24
 8009ed0:	d051      	beq.n	8009f76 <_fx_directory_free_search+0x272>
                 (entry_ptr -> fx_dir_entry_name[i] == '&') ||
 8009ed2:	69fb      	ldr	r3, [r7, #28]
 8009ed4:	681a      	ldr	r2, [r3, #0]
 8009ed6:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8009ed8:	4413      	add	r3, r2
 8009eda:	781b      	ldrb	r3, [r3, #0]
                 (entry_ptr -> fx_dir_entry_name[i] == '$') ||
 8009edc:	2b26      	cmp	r3, #38	@ 0x26
 8009ede:	d04a      	beq.n	8009f76 <_fx_directory_free_search+0x272>
                 (entry_ptr -> fx_dir_entry_name[i] == '@') ||
 8009ee0:	69fb      	ldr	r3, [r7, #28]
 8009ee2:	681a      	ldr	r2, [r3, #0]
 8009ee4:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8009ee6:	4413      	add	r3, r2
 8009ee8:	781b      	ldrb	r3, [r3, #0]
                 (entry_ptr -> fx_dir_entry_name[i] == '&') ||
 8009eea:	2b40      	cmp	r3, #64	@ 0x40
 8009eec:	d043      	beq.n	8009f76 <_fx_directory_free_search+0x272>
                 (entry_ptr -> fx_dir_entry_name[i] == '^') ||
 8009eee:	69fb      	ldr	r3, [r7, #28]
 8009ef0:	681a      	ldr	r2, [r3, #0]
 8009ef2:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8009ef4:	4413      	add	r3, r2
 8009ef6:	781b      	ldrb	r3, [r3, #0]
                 (entry_ptr -> fx_dir_entry_name[i] == '@') ||
 8009ef8:	2b5e      	cmp	r3, #94	@ 0x5e
 8009efa:	d03c      	beq.n	8009f76 <_fx_directory_free_search+0x272>
                 (entry_ptr -> fx_dir_entry_name[i] == '%'))
 8009efc:	69fb      	ldr	r3, [r7, #28]
 8009efe:	681a      	ldr	r2, [r3, #0]
 8009f00:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8009f02:	4413      	add	r3, r2
 8009f04:	781b      	ldrb	r3, [r3, #0]
                 (entry_ptr -> fx_dir_entry_name[i] == '^') ||
 8009f06:	2b25      	cmp	r3, #37	@ 0x25
 8009f08:	d035      	beq.n	8009f76 <_fx_directory_free_search+0x272>
        {
            continue;
        }
        /* Check for long filename special characters.  */
        else if ((entry_ptr -> fx_dir_entry_name[i] == '+') ||
 8009f0a:	69fb      	ldr	r3, [r7, #28]
 8009f0c:	681a      	ldr	r2, [r3, #0]
 8009f0e:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8009f10:	4413      	add	r3, r2
 8009f12:	781b      	ldrb	r3, [r3, #0]
 8009f14:	2b2b      	cmp	r3, #43	@ 0x2b
 8009f16:	d022      	beq.n	8009f5e <_fx_directory_free_search+0x25a>
                 (entry_ptr -> fx_dir_entry_name[i] == ',') ||
 8009f18:	69fb      	ldr	r3, [r7, #28]
 8009f1a:	681a      	ldr	r2, [r3, #0]
 8009f1c:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8009f1e:	4413      	add	r3, r2
 8009f20:	781b      	ldrb	r3, [r3, #0]
        else if ((entry_ptr -> fx_dir_entry_name[i] == '+') ||
 8009f22:	2b2c      	cmp	r3, #44	@ 0x2c
 8009f24:	d01b      	beq.n	8009f5e <_fx_directory_free_search+0x25a>
                 (entry_ptr -> fx_dir_entry_name[i] == ';') ||
 8009f26:	69fb      	ldr	r3, [r7, #28]
 8009f28:	681a      	ldr	r2, [r3, #0]
 8009f2a:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8009f2c:	4413      	add	r3, r2
 8009f2e:	781b      	ldrb	r3, [r3, #0]
                 (entry_ptr -> fx_dir_entry_name[i] == ',') ||
 8009f30:	2b3b      	cmp	r3, #59	@ 0x3b
 8009f32:	d014      	beq.n	8009f5e <_fx_directory_free_search+0x25a>
                 (entry_ptr -> fx_dir_entry_name[i] == '=') ||
 8009f34:	69fb      	ldr	r3, [r7, #28]
 8009f36:	681a      	ldr	r2, [r3, #0]
 8009f38:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8009f3a:	4413      	add	r3, r2
 8009f3c:	781b      	ldrb	r3, [r3, #0]
                 (entry_ptr -> fx_dir_entry_name[i] == ';') ||
 8009f3e:	2b3d      	cmp	r3, #61	@ 0x3d
 8009f40:	d00d      	beq.n	8009f5e <_fx_directory_free_search+0x25a>
                 (entry_ptr -> fx_dir_entry_name[i] == '[') ||
 8009f42:	69fb      	ldr	r3, [r7, #28]
 8009f44:	681a      	ldr	r2, [r3, #0]
 8009f46:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8009f48:	4413      	add	r3, r2
 8009f4a:	781b      	ldrb	r3, [r3, #0]
                 (entry_ptr -> fx_dir_entry_name[i] == '=') ||
 8009f4c:	2b5b      	cmp	r3, #91	@ 0x5b
 8009f4e:	d006      	beq.n	8009f5e <_fx_directory_free_search+0x25a>
                 (entry_ptr -> fx_dir_entry_name[i] == ']'))
 8009f50:	69fb      	ldr	r3, [r7, #28]
 8009f52:	681a      	ldr	r2, [r3, #0]
 8009f54:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8009f56:	4413      	add	r3, r2
 8009f58:	781b      	ldrb	r3, [r3, #0]
                 (entry_ptr -> fx_dir_entry_name[i] == '[') ||
 8009f5a:	2b5d      	cmp	r3, #93	@ 0x5d
 8009f5c:	d103      	bne.n	8009f66 <_fx_directory_free_search+0x262>
        {
            entry_ptr -> fx_dir_entry_long_name_present = 1;
 8009f5e:	69fb      	ldr	r3, [r7, #28]
 8009f60:	2201      	movs	r2, #1
 8009f62:	615a      	str	r2, [r3, #20]
 8009f64:	e008      	b.n	8009f78 <_fx_directory_free_search+0x274>
        }
        /* Something is wrong with the supplied name.  */
        else
        {
            return(FX_INVALID_NAME);
 8009f66:	230c      	movs	r3, #12
 8009f68:	e2ae      	b.n	800a4c8 <_fx_directory_free_search+0x7c4>
            continue;
 8009f6a:	bf00      	nop
 8009f6c:	e004      	b.n	8009f78 <_fx_directory_free_search+0x274>
            continue;
 8009f6e:	bf00      	nop
 8009f70:	e002      	b.n	8009f78 <_fx_directory_free_search+0x274>
            continue;
 8009f72:	bf00      	nop
 8009f74:	e000      	b.n	8009f78 <_fx_directory_free_search+0x274>
            continue;
 8009f76:	bf00      	nop
    for (i = 0, j = 0; entry_ptr -> fx_dir_entry_name[i]; i++)
 8009f78:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8009f7a:	3301      	adds	r3, #1
 8009f7c:	67fb      	str	r3, [r7, #124]	@ 0x7c
 8009f7e:	69fb      	ldr	r3, [r7, #28]
 8009f80:	681a      	ldr	r2, [r3, #0]
 8009f82:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8009f84:	4413      	add	r3, r2
 8009f86:	781b      	ldrb	r3, [r3, #0]
 8009f88:	2b00      	cmp	r3, #0
 8009f8a:	f47f aee2 	bne.w	8009d52 <_fx_directory_free_search+0x4e>
        }
    }

    /* Determine if a dot was found.  */
    if (j != 0)
 8009f8e:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8009f90:	2b00      	cmp	r3, #0
 8009f92:	d007      	beq.n	8009fa4 <_fx_directory_free_search+0x2a0>
    {

        /* Yes, Determine if the extension exceeds a 3 character extension.  */
        if ((i - j) > 4)
 8009f94:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 8009f96:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8009f98:	1ad3      	subs	r3, r2, r3
 8009f9a:	2b04      	cmp	r3, #4
 8009f9c:	d902      	bls.n	8009fa4 <_fx_directory_free_search+0x2a0>
        {

            /* Yes, long file name is present.  */
            entry_ptr -> fx_dir_entry_long_name_present = 1;
 8009f9e:	69fb      	ldr	r3, [r7, #28]
 8009fa0:	2201      	movs	r2, #1
 8009fa2:	615a      	str	r2, [r3, #20]
        }
    }

    /* Calculate the total entries needed.  */
    if ((i <= 12) && (entry_ptr -> fx_dir_entry_long_name_present == 0))
 8009fa4:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8009fa6:	2b0c      	cmp	r3, #12
 8009fa8:	d813      	bhi.n	8009fd2 <_fx_directory_free_search+0x2ce>
 8009faa:	69fb      	ldr	r3, [r7, #28]
 8009fac:	695b      	ldr	r3, [r3, #20]
 8009fae:	2b00      	cmp	r3, #0
 8009fb0:	d10f      	bne.n	8009fd2 <_fx_directory_free_search+0x2ce>
    {

        /* Initialize the total entries to 1.  */
        total_entries = 1;
 8009fb2:	2301      	movs	r3, #1
 8009fb4:	673b      	str	r3, [r7, #112]	@ 0x70

        /* Check for special instance of long file name.  */
        if ((j >= 9) || ((i - j) >= 9))
 8009fb6:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8009fb8:	2b08      	cmp	r3, #8
 8009fba:	d804      	bhi.n	8009fc6 <_fx_directory_free_search+0x2c2>
 8009fbc:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 8009fbe:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8009fc0:	1ad3      	subs	r3, r2, r3
 8009fc2:	2b08      	cmp	r3, #8
 8009fc4:	d922      	bls.n	800a00c <_fx_directory_free_search+0x308>
        {

            /* The dot is after 8 character or there is no dot and the name
               is greater than 8 character. */
            entry_ptr -> fx_dir_entry_long_name_present = 1;
 8009fc6:	69fb      	ldr	r3, [r7, #28]
 8009fc8:	2201      	movs	r2, #1
 8009fca:	615a      	str	r2, [r3, #20]
            total_entries = 2;
 8009fcc:	2302      	movs	r3, #2
 8009fce:	673b      	str	r3, [r7, #112]	@ 0x70
        if ((j >= 9) || ((i - j) >= 9))
 8009fd0:	e01c      	b.n	800a00c <_fx_directory_free_search+0x308>
    else
    {

        /* Long file name is present, calculate how many entries are needed
           to represent it.  */
        if (i % 13 == 0)
 8009fd2:	6ff9      	ldr	r1, [r7, #124]	@ 0x7c
 8009fd4:	4b90      	ldr	r3, [pc, #576]	@ (800a218 <_fx_directory_free_search+0x514>)
 8009fd6:	fba3 2301 	umull	r2, r3, r3, r1
 8009fda:	089a      	lsrs	r2, r3, #2
 8009fdc:	4613      	mov	r3, r2
 8009fde:	005b      	lsls	r3, r3, #1
 8009fe0:	4413      	add	r3, r2
 8009fe2:	009b      	lsls	r3, r3, #2
 8009fe4:	4413      	add	r3, r2
 8009fe6:	1aca      	subs	r2, r1, r3
 8009fe8:	2a00      	cmp	r2, #0
 8009fea:	d107      	bne.n	8009ffc <_fx_directory_free_search+0x2f8>
        {
            /* Exact fit, just add one for the 8.3 short name.  */
            total_entries = i / 13 + 1;
 8009fec:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8009fee:	4a8a      	ldr	r2, [pc, #552]	@ (800a218 <_fx_directory_free_search+0x514>)
 8009ff0:	fba2 2303 	umull	r2, r3, r2, r3
 8009ff4:	089b      	lsrs	r3, r3, #2
 8009ff6:	3301      	adds	r3, #1
 8009ff8:	673b      	str	r3, [r7, #112]	@ 0x70
 8009ffa:	e008      	b.n	800a00e <_fx_directory_free_search+0x30a>
        }
        else
        {
            /* Non-exact fit, add two for 8.3 short name and overlap.  */
            total_entries = i / 13 + 2;
 8009ffc:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8009ffe:	4a86      	ldr	r2, [pc, #536]	@ (800a218 <_fx_directory_free_search+0x514>)
 800a000:	fba2 2303 	umull	r2, r3, r2, r3
 800a004:	089b      	lsrs	r3, r3, #2
 800a006:	3302      	adds	r3, #2
 800a008:	673b      	str	r3, [r7, #112]	@ 0x70
 800a00a:	e000      	b.n	800a00e <_fx_directory_free_search+0x30a>
        if ((j >= 9) || ((i - j) >= 9))
 800a00c:	bf00      	nop
    }

    /* Determine if the search is in the root directory or in a
       sub-directory.  Note: the directory search function clears the
       first character of the name for the root directory.  */
    if (directory_ptr -> fx_dir_entry_name[0])
 800a00e:	6a3b      	ldr	r3, [r7, #32]
 800a010:	681b      	ldr	r3, [r3, #0]
 800a012:	781b      	ldrb	r3, [r3, #0]
 800a014:	2b00      	cmp	r3, #0
 800a016:	d00c      	beq.n	800a032 <_fx_directory_free_search+0x32e>

        /* Search for a free entry in a sub-directory.  */

        /* Pickup the number of entries in this directory.  This was placed
           into the unused file size field.  */
        directory_entries =  (ULONG)directory_ptr -> fx_dir_entry_file_size;
 800a018:	6a3b      	ldr	r3, [r7, #32]
 800a01a:	e9d3 230e 	ldrd	r2, r3, [r3, #56]	@ 0x38
 800a01e:	4613      	mov	r3, r2
 800a020:	64fb      	str	r3, [r7, #76]	@ 0x4c

        /* Point the search directory pointer to this entry.  */
        search_dir_ptr =  directory_ptr;
 800a022:	6a3b      	ldr	r3, [r7, #32]
 800a024:	64bb      	str	r3, [r7, #72]	@ 0x48

        /* Ensure that the search directory's last search cluster is cleared.  */
        search_dir_ptr -> fx_dir_entry_last_search_cluster =  0;
 800a026:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800a028:	2200      	movs	r2, #0
 800a02a:	651a      	str	r2, [r3, #80]	@ 0x50

        /* Set the initial index to 2, since the first two directory entries are
           always allocated.  */
        directory_index =  2;
 800a02c:	2302      	movs	r3, #2
 800a02e:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800a030:	e006      	b.n	800a040 <_fx_directory_free_search+0x33c>
    {

        /* Find a free entry in the root directory.  */

        /* Setup the number of directory entries.  */
        directory_entries =  (ULONG)media_ptr -> fx_media_root_directory_entries;
 800a032:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a034:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 800a036:	64fb      	str	r3, [r7, #76]	@ 0x4c

        /* Set the search pointer to NULL since we are working off of the
           root directory.  */
        search_dir_ptr =  FX_NULL;
 800a038:	2300      	movs	r3, #0
 800a03a:	64bb      	str	r3, [r7, #72]	@ 0x48

        /* Set the initial index to 0, since the first entry of the root directory is valid.  */
        directory_index =  0;
 800a03c:	2300      	movs	r3, #0
 800a03e:	62fb      	str	r3, [r7, #44]	@ 0x2c
    }

    /* Loop through entries in the search directory.  Yes, this is a
       linear search!  */
    free_entry_start = directory_entries;
 800a040:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800a042:	647b      	str	r3, [r7, #68]	@ 0x44
    do
    {

        /* Read an entry from the directory.  */
        status =  _fx_directory_entry_read(media_ptr, search_dir_ptr, &directory_index, entry_ptr);
 800a044:	f107 022c 	add.w	r2, r7, #44	@ 0x2c
 800a048:	69fb      	ldr	r3, [r7, #28]
 800a04a:	6cb9      	ldr	r1, [r7, #72]	@ 0x48
 800a04c:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 800a04e:	f7fe fc97 	bl	8008980 <_fx_directory_entry_read>
 800a052:	63f8      	str	r0, [r7, #60]	@ 0x3c

        /* Check for error status.  */
        if (status != FX_SUCCESS)
 800a054:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800a056:	2b00      	cmp	r3, #0
 800a058:	d001      	beq.n	800a05e <_fx_directory_free_search+0x35a>
        {
            return(status);
 800a05a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800a05c:	e234      	b.n	800a4c8 <_fx_directory_free_search+0x7c4>
        }

        /* Determine if this is an empty entry.  */
        if ((((UCHAR)entry_ptr -> fx_dir_entry_name[0] == (UCHAR)FX_DIR_ENTRY_FREE) && (entry_ptr -> fx_dir_entry_short_name[0] == 0)) ||
 800a05e:	69fb      	ldr	r3, [r7, #28]
 800a060:	681b      	ldr	r3, [r3, #0]
 800a062:	781b      	ldrb	r3, [r3, #0]
 800a064:	2be5      	cmp	r3, #229	@ 0xe5
 800a066:	d103      	bne.n	800a070 <_fx_directory_free_search+0x36c>
 800a068:	69fb      	ldr	r3, [r7, #28]
 800a06a:	791b      	ldrb	r3, [r3, #4]
 800a06c:	2b00      	cmp	r3, #0
 800a06e:	d004      	beq.n	800a07a <_fx_directory_free_search+0x376>
            ((UCHAR)entry_ptr -> fx_dir_entry_name[0] == (UCHAR)FX_DIR_ENTRY_DONE))
 800a070:	69fb      	ldr	r3, [r7, #28]
 800a072:	681b      	ldr	r3, [r3, #0]
 800a074:	781b      	ldrb	r3, [r3, #0]
        if ((((UCHAR)entry_ptr -> fx_dir_entry_name[0] == (UCHAR)FX_DIR_ENTRY_FREE) && (entry_ptr -> fx_dir_entry_short_name[0] == 0)) ||
 800a076:	2b00      	cmp	r3, #0
 800a078:	d15a      	bne.n	800a130 <_fx_directory_free_search+0x42c>
        {

            /* Determine how many entries are needed.  */
            if (total_entries > 1)
 800a07a:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 800a07c:	2b01      	cmp	r3, #1
 800a07e:	d91a      	bls.n	800a0b6 <_fx_directory_free_search+0x3b2>
            {

                /* Multiple entries are needed for long file names.  Mark this
                   entry as free. */
                if (entry_ptr -> fx_dir_entry_name[0] == FX_DIR_ENTRY_DONE)
 800a080:	69fb      	ldr	r3, [r7, #28]
 800a082:	681b      	ldr	r3, [r3, #0]
 800a084:	781b      	ldrb	r3, [r3, #0]
 800a086:	2b00      	cmp	r3, #0
 800a088:	d115      	bne.n	800a0b6 <_fx_directory_free_search+0x3b2>
                {

                    entry_ptr -> fx_dir_entry_long_name_present =  0;
 800a08a:	69fb      	ldr	r3, [r7, #28]
 800a08c:	2200      	movs	r2, #0
 800a08e:	615a      	str	r2, [r3, #20]
                    entry_ptr -> fx_dir_entry_name[0] =      (CHAR)FX_DIR_ENTRY_FREE;
 800a090:	69fb      	ldr	r3, [r7, #28]
 800a092:	681a      	ldr	r2, [r3, #0]
 800a094:	23e5      	movs	r3, #229	@ 0xe5
 800a096:	7013      	strb	r3, [r2, #0]
                    entry_ptr -> fx_dir_entry_name[1] =      (CHAR)0;
 800a098:	69fb      	ldr	r3, [r7, #28]
 800a09a:	681b      	ldr	r3, [r3, #0]
 800a09c:	1c5a      	adds	r2, r3, #1
 800a09e:	2300      	movs	r3, #0
 800a0a0:	7013      	strb	r3, [r2, #0]

                    /* Write out the directory entry.  */
                    status = _fx_directory_entry_write(media_ptr, entry_ptr);
 800a0a2:	69f9      	ldr	r1, [r7, #28]
 800a0a4:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 800a0a6:	f7fe fff1 	bl	800908c <_fx_directory_entry_write>
 800a0aa:	63f8      	str	r0, [r7, #60]	@ 0x3c
                    if(status != FX_SUCCESS)
 800a0ac:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800a0ae:	2b00      	cmp	r3, #0
 800a0b0:	d001      	beq.n	800a0b6 <_fx_directory_free_search+0x3b2>
                    {  
                        return(status);
 800a0b2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800a0b4:	e208      	b.n	800a4c8 <_fx_directory_free_search+0x7c4>
                       i.e. entries must be logically contiguous.  */
                }
            }

            /* Determine if we are at the first free entry.  */
            if (free_entry_start == directory_entries)
 800a0b6:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 800a0b8:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800a0ba:	429a      	cmp	r2, r3
 800a0bc:	d109      	bne.n	800a0d2 <_fx_directory_free_search+0x3ce>
            {

                /* Remember the start of the free entry.  */
                free_entry_start =  directory_index;
 800a0be:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800a0c0:	647b      	str	r3, [r7, #68]	@ 0x44
                entry_sector =      (ULONG)entry_ptr -> fx_dir_entry_log_sector;
 800a0c2:	69fb      	ldr	r3, [r7, #28]
 800a0c4:	e9d3 2310 	ldrd	r2, r3, [r3, #64]	@ 0x40
 800a0c8:	4613      	mov	r3, r2
 800a0ca:	66fb      	str	r3, [r7, #108]	@ 0x6c
                entry_offset  =     entry_ptr -> fx_dir_entry_byte_offset;
 800a0cc:	69fb      	ldr	r3, [r7, #28]
 800a0ce:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 800a0d0:	66bb      	str	r3, [r7, #104]	@ 0x68
            }

            /* Determine if there are enough free entries to satisfy the request.  */
            if ((directory_index - free_entry_start + 1) >= total_entries)
 800a0d2:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800a0d4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800a0d6:	1ad3      	subs	r3, r2, r3
 800a0d8:	3301      	adds	r3, #1
 800a0da:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 800a0dc:	429a      	cmp	r2, r3
 800a0de:	d829      	bhi.n	800a134 <_fx_directory_free_search+0x430>

                /* Found an empty slot.  Most pertinent information is already
                   in the entry structure.  */

                /* Setup the the sector and the offset.  */
                entry_ptr -> fx_dir_entry_log_sector =      entry_sector;
 800a0e0:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800a0e2:	2200      	movs	r2, #0
 800a0e4:	461c      	mov	r4, r3
 800a0e6:	4615      	mov	r5, r2
 800a0e8:	69fb      	ldr	r3, [r7, #28]
 800a0ea:	e9c3 4510 	strd	r4, r5, [r3, #64]	@ 0x40
                entry_ptr -> fx_dir_entry_byte_offset =     entry_offset;
 800a0ee:	69fb      	ldr	r3, [r7, #28]
 800a0f0:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 800a0f2:	649a      	str	r2, [r3, #72]	@ 0x48

                /* Initialize the additional directory entries.  */
                entry_ptr -> fx_dir_entry_reserved =            0;
 800a0f4:	69fb      	ldr	r3, [r7, #28]
 800a0f6:	2200      	movs	r2, #0
 800a0f8:	775a      	strb	r2, [r3, #29]
                entry_ptr -> fx_dir_entry_created_time_ms =     0;
 800a0fa:	69fb      	ldr	r3, [r7, #28]
 800a0fc:	2200      	movs	r2, #0
 800a0fe:	779a      	strb	r2, [r3, #30]

                /* Lockout interrupts for time/date access.  */
                FX_DISABLE_INTS

                entry_ptr -> fx_dir_entry_created_time =        _fx_system_time;
 800a100:	4b46      	ldr	r3, [pc, #280]	@ (800a21c <_fx_directory_free_search+0x518>)
 800a102:	681a      	ldr	r2, [r3, #0]
 800a104:	69fb      	ldr	r3, [r7, #28]
 800a106:	621a      	str	r2, [r3, #32]
                entry_ptr -> fx_dir_entry_created_date =        _fx_system_date;
 800a108:	4b45      	ldr	r3, [pc, #276]	@ (800a220 <_fx_directory_free_search+0x51c>)
 800a10a:	681a      	ldr	r2, [r3, #0]
 800a10c:	69fb      	ldr	r3, [r7, #28]
 800a10e:	625a      	str	r2, [r3, #36]	@ 0x24
                entry_ptr -> fx_dir_entry_last_accessed_date =  _fx_system_date;
 800a110:	4b43      	ldr	r3, [pc, #268]	@ (800a220 <_fx_directory_free_search+0x51c>)
 800a112:	681a      	ldr	r2, [r3, #0]
 800a114:	69fb      	ldr	r3, [r7, #28]
 800a116:	629a      	str	r2, [r3, #40]	@ 0x28

                /* Restore interrupts.  */
                FX_RESTORE_INTS

                /* Determine if a long file name is present.  */
                if (total_entries == 1)
 800a118:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 800a11a:	2b01      	cmp	r3, #1
 800a11c:	d103      	bne.n	800a126 <_fx_directory_free_search+0x422>
                {
                    entry_ptr -> fx_dir_entry_long_name_present =  0;
 800a11e:	69fb      	ldr	r3, [r7, #28]
 800a120:	2200      	movs	r2, #0
 800a122:	615a      	str	r2, [r3, #20]
 800a124:	e002      	b.n	800a12c <_fx_directory_free_search+0x428>
                }
                else
                {
                    entry_ptr -> fx_dir_entry_long_name_present =  1;
 800a126:	69fb      	ldr	r3, [r7, #28]
 800a128:	2201      	movs	r2, #1
 800a12a:	615a      	str	r2, [r3, #20]
                }

                /* Return a successful completion.  */
                return(FX_SUCCESS);
 800a12c:	2300      	movs	r3, #0
 800a12e:	e1cb      	b.n	800a4c8 <_fx_directory_free_search+0x7c4>
        }
        else
        {

            /* Reset the free entry start.  */
            free_entry_start =  directory_entries;
 800a130:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800a132:	647b      	str	r3, [r7, #68]	@ 0x44
        }

        /* Move to the next entry.  */
        directory_index++;
 800a134:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800a136:	3301      	adds	r3, #1
 800a138:	62fb      	str	r3, [r7, #44]	@ 0x2c

        /* Determine if we have exceeded the number of entries in the current directory.  */
        if (directory_index >= directory_entries)
 800a13a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800a13c:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 800a13e:	429a      	cmp	r2, r3
 800a140:	f200 81bc 	bhi.w	800a4bc <_fx_directory_free_search+0x7b8>
        {

            /* Calculate how many sectors we need for the new directory entry.  */
            sectors =  ((total_entries * FX_DIR_ENTRY_SIZE) + (media_ptr -> fx_media_bytes_per_sector - 1))/
 800a144:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 800a146:	015a      	lsls	r2, r3, #5
 800a148:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a14a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800a14c:	4413      	add	r3, r2
 800a14e:	1e5a      	subs	r2, r3, #1
                                                                            media_ptr -> fx_media_bytes_per_sector;
 800a150:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a152:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
            sectors =  ((total_entries * FX_DIR_ENTRY_SIZE) + (media_ptr -> fx_media_bytes_per_sector - 1))/
 800a154:	fbb2 f3f3 	udiv	r3, r2, r3
 800a158:	643b      	str	r3, [r7, #64]	@ 0x40

            /* Now calculate how many clusters we need for the new directory entry.  */
            clusters_needed = (sectors + (media_ptr -> fx_media_sectors_per_cluster - 1)) / media_ptr -> fx_media_sectors_per_cluster;
 800a15a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a15c:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
 800a15e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800a160:	4413      	add	r3, r2
 800a162:	1e5a      	subs	r2, r3, #1
 800a164:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a166:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800a168:	fbb2 f3f3 	udiv	r3, r2, r3
 800a16c:	63bb      	str	r3, [r7, #56]	@ 0x38

            /* Not enough empty entries were found.  If the specified directory is a sub-directory,
               attempt to allocate another cluster to it.  */
            if (((search_dir_ptr) || (media_ptr -> fx_media_32_bit_FAT)) && (media_ptr -> fx_media_available_clusters >= clusters_needed))
 800a16e:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800a170:	2b00      	cmp	r3, #0
 800a172:	d104      	bne.n	800a17e <_fx_directory_free_search+0x47a>
 800a174:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a176:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 800a178:	2b00      	cmp	r3, #0
 800a17a:	f000 819f 	beq.w	800a4bc <_fx_directory_free_search+0x7b8>
 800a17e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a180:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
 800a182:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 800a184:	429a      	cmp	r2, r3
 800a186:	f200 8199 	bhi.w	800a4bc <_fx_directory_free_search+0x7b8>
            {

                /* Search for the additional clusters we need.  */
                first_new_cluster =  0;
 800a18a:	2300      	movs	r3, #0
 800a18c:	65bb      	str	r3, [r7, #88]	@ 0x58
                total_clusters =     media_ptr -> fx_media_total_clusters;
 800a18e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a190:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800a192:	65fb      	str	r3, [r7, #92]	@ 0x5c
                last_cluster =       0;
 800a194:	2300      	movs	r3, #0
 800a196:	657b      	str	r3, [r7, #84]	@ 0x54
                FAT_index    =       media_ptr -> fx_media_cluster_search_start;
 800a198:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a19a:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 800a19e:	667b      	str	r3, [r7, #100]	@ 0x64
                clusters =           clusters_needed;
 800a1a0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800a1a2:	653b      	str	r3, [r7, #80]	@ 0x50

                /* Loop to find the needed clusters.  */
                while (clusters)
 800a1a4:	e103      	b.n	800a3ae <_fx_directory_free_search+0x6aa>
                {

                    /* Decrease the cluster count.  */
                    clusters--;
 800a1a6:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800a1a8:	3b01      	subs	r3, #1
 800a1aa:	653b      	str	r3, [r7, #80]	@ 0x50
                    /* Loop to find the first available cluster.  */
                    do
                    {

                        /* Make sure we stop looking after one pass through the FAT table.  */
                        if (!total_clusters)
 800a1ac:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 800a1ae:	2b00      	cmp	r3, #0
 800a1b0:	d101      	bne.n	800a1b6 <_fx_directory_free_search+0x4b2>
                        {

                            /* Something is wrong with the media - the desired clusters were
                               not found in the FAT table.  */
                            return(FX_NO_MORE_SPACE);
 800a1b2:	230a      	movs	r3, #10
 800a1b4:	e188      	b.n	800a4c8 <_fx_directory_free_search+0x7c4>
                        }

                        /* Read FAT entry.  */
                        status =  _fx_utility_FAT_entry_read(media_ptr, FAT_index, &FAT_value);
 800a1b6:	f107 0330 	add.w	r3, r7, #48	@ 0x30
 800a1ba:	461a      	mov	r2, r3
 800a1bc:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 800a1be:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 800a1c0:	f004 fbee 	bl	800e9a0 <_fx_utility_FAT_entry_read>
 800a1c4:	63f8      	str	r0, [r7, #60]	@ 0x3c

                        /* Check for a bad status.  */
                        if (status != FX_SUCCESS)
 800a1c6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800a1c8:	2b00      	cmp	r3, #0
 800a1ca:	d001      	beq.n	800a1d0 <_fx_directory_free_search+0x4cc>
                        {

                            /* Return the bad status.  */
                            return(status);
 800a1cc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800a1ce:	e17b      	b.n	800a4c8 <_fx_directory_free_search+0x7c4>
                        }

                        /* Decrement the total cluster count.  */
                        total_clusters--;
 800a1d0:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 800a1d2:	3b01      	subs	r3, #1
 800a1d4:	65fb      	str	r3, [r7, #92]	@ 0x5c

                        /* Determine if the FAT entry is free.  */
                        if (FAT_value == FX_FREE_CLUSTER)
 800a1d6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800a1d8:	2b00      	cmp	r3, #0
 800a1da:	d111      	bne.n	800a200 <_fx_directory_free_search+0x4fc>
                        {

                            /* Move cluster search pointer forward.  */
                            media_ptr -> fx_media_cluster_search_start =  FAT_index + 1;
 800a1dc:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 800a1de:	1c5a      	adds	r2, r3, #1
 800a1e0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a1e2:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

                            /* Determine if this needs to be wrapped.  */
                            if (media_ptr -> fx_media_cluster_search_start >= (media_ptr -> fx_media_total_clusters + FX_FAT_ENTRY_START))
 800a1e6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a1e8:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
 800a1ec:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a1ee:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800a1f0:	3302      	adds	r3, #2
 800a1f2:	429a      	cmp	r2, r3
 800a1f4:	d316      	bcc.n	800a224 <_fx_directory_free_search+0x520>
                            {

                                /* Wrap the search to the beginning FAT entry.  */
                                media_ptr -> fx_media_cluster_search_start =  FX_FAT_ENTRY_START;
 800a1f6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a1f8:	2202      	movs	r2, #2
 800a1fa:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
                            }

                            /* Break this loop.  */
                            break;
 800a1fe:	e011      	b.n	800a224 <_fx_directory_free_search+0x520>
                        }
                        else
                        {

                            /* FAT entry is not free... Advance the FAT index.  */
                            FAT_index++;
 800a200:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 800a202:	3301      	adds	r3, #1
 800a204:	667b      	str	r3, [r7, #100]	@ 0x64

                            /* Determine if we need to wrap the FAT index around.  */
                            if (FAT_index >= (media_ptr -> fx_media_total_clusters + FX_FAT_ENTRY_START))
 800a206:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a208:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800a20a:	3302      	adds	r3, #2
 800a20c:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 800a20e:	429a      	cmp	r2, r3
 800a210:	d3cc      	bcc.n	800a1ac <_fx_directory_free_search+0x4a8>
                            {

                                /* Wrap the search to the beginning FAT entry.  */
                                FAT_index =  FX_FAT_ENTRY_START;
 800a212:	2302      	movs	r3, #2
 800a214:	667b      	str	r3, [r7, #100]	@ 0x64
                        if (!total_clusters)
 800a216:	e7c9      	b.n	800a1ac <_fx_directory_free_search+0x4a8>
 800a218:	4ec4ec4f 	.word	0x4ec4ec4f
 800a21c:	20002c98 	.word	0x20002c98
 800a220:	20002c94 	.word	0x20002c94
                            break;
 800a224:	bf00      	nop

                    /* We found an available cluster.  We now need to clear all of entries in
                       each of the cluster's sectors.  */

                    /* Calculate the logical sector of this cluster.  */
                    logical_sector =  ((ULONG) media_ptr -> fx_media_data_sector_start) +
 800a226:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a228:	6d19      	ldr	r1, [r3, #80]	@ 0x50
                                       ((((ULONG) FAT_index) - FX_FAT_ENTRY_START) *
 800a22a:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 800a22c:	1e9a      	subs	r2, r3, #2
                                       ((ULONG) media_ptr -> fx_media_sectors_per_cluster));
 800a22e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a230:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
                                       ((((ULONG) FAT_index) - FX_FAT_ENTRY_START) *
 800a232:	fb02 f303 	mul.w	r3, r2, r3
                    logical_sector =  ((ULONG) media_ptr -> fx_media_data_sector_start) +
 800a236:	440b      	add	r3, r1
 800a238:	637b      	str	r3, [r7, #52]	@ 0x34

                    /* Pickup the number of sectors for the next directory cluster.  */
                    sectors =  media_ptr -> fx_media_sectors_per_cluster;
 800a23a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a23c:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800a23e:	643b      	str	r3, [r7, #64]	@ 0x40

                    /* Read the logical sector just for cache reasons.  */
                    status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) logical_sector,
 800a240:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800a242:	2200      	movs	r2, #0
 800a244:	613b      	str	r3, [r7, #16]
 800a246:	617a      	str	r2, [r7, #20]
                                                              media_ptr -> fx_media_memory_buffer, ((ULONG) 1), FX_DIRECTORY_SECTOR);
 800a248:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a24a:	689a      	ldr	r2, [r3, #8]
                    status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) logical_sector,
 800a24c:	2303      	movs	r3, #3
 800a24e:	9302      	str	r3, [sp, #8]
 800a250:	2301      	movs	r3, #1
 800a252:	9301      	str	r3, [sp, #4]
 800a254:	9200      	str	r2, [sp, #0]
 800a256:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 800a25a:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 800a25c:	f005 ffae 	bl	80101bc <_fx_utility_logical_sector_read>
 800a260:	63f8      	str	r0, [r7, #60]	@ 0x3c

                    /* Check the return value.  */
                    if (status != FX_SUCCESS)
 800a262:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800a264:	2b00      	cmp	r3, #0
 800a266:	d001      	beq.n	800a26c <_fx_directory_free_search+0x568>
                    {

                        /* Return the error status.  */
                        return(status);
 800a268:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800a26a:	e12d      	b.n	800a4c8 <_fx_directory_free_search+0x7c4>
                    }

                    /* Clear the entire first sector of the new sub-directory cluster.  */
                    work_ptr =  (UCHAR *)media_ptr -> fx_media_memory_buffer;
 800a26c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a26e:	689b      	ldr	r3, [r3, #8]
 800a270:	677b      	str	r3, [r7, #116]	@ 0x74
                    i =  0;
 800a272:	2300      	movs	r3, #0
 800a274:	67fb      	str	r3, [r7, #124]	@ 0x7c
                    while (i < media_ptr -> fx_media_bytes_per_sector)
 800a276:	e008      	b.n	800a28a <_fx_directory_free_search+0x586>
                    {

                        /* Clear 4 bytes.  */
                        *((ULONG *)work_ptr) =  (ULONG)0;
 800a278:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 800a27a:	2200      	movs	r2, #0
 800a27c:	601a      	str	r2, [r3, #0]

                        /* Increment pointer.  */
                        work_ptr =  work_ptr + sizeof(ULONG);
 800a27e:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 800a280:	3304      	adds	r3, #4
 800a282:	677b      	str	r3, [r7, #116]	@ 0x74

                        /* Increment counter.  */
                        i =  i + (ULONG)sizeof(ULONG);
 800a284:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 800a286:	3304      	adds	r3, #4
 800a288:	67fb      	str	r3, [r7, #124]	@ 0x7c
                    while (i < media_ptr -> fx_media_bytes_per_sector)
 800a28a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a28c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800a28e:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 800a290:	429a      	cmp	r2, r3
 800a292:	d3f1      	bcc.n	800a278 <_fx_directory_free_search+0x574>
                    }

                    /* Write the logical sector to ensure the zeros are written.  */
                    status =  _fx_utility_logical_sector_write(media_ptr, (ULONG64) logical_sector,
 800a294:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800a296:	2200      	movs	r2, #0
 800a298:	60bb      	str	r3, [r7, #8]
 800a29a:	60fa      	str	r2, [r7, #12]
                                                               media_ptr -> fx_media_memory_buffer, ((ULONG) 1), FX_DIRECTORY_SECTOR);
 800a29c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a29e:	689a      	ldr	r2, [r3, #8]
                    status =  _fx_utility_logical_sector_write(media_ptr, (ULONG64) logical_sector,
 800a2a0:	2303      	movs	r3, #3
 800a2a2:	9302      	str	r3, [sp, #8]
 800a2a4:	2301      	movs	r3, #1
 800a2a6:	9301      	str	r3, [sp, #4]
 800a2a8:	9200      	str	r2, [sp, #0]
 800a2aa:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 800a2ae:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 800a2b0:	f006 fa18 	bl	80106e4 <_fx_utility_logical_sector_write>
 800a2b4:	63f8      	str	r0, [r7, #60]	@ 0x3c

                    /* Determine if the write was successful.  */
                    if (status != FX_SUCCESS)
 800a2b6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800a2b8:	2b00      	cmp	r3, #0
 800a2ba:	d001      	beq.n	800a2c0 <_fx_directory_free_search+0x5bc>
                    {

                        /* Return the error code.  */
                        return(status);
 800a2bc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800a2be:	e103      	b.n	800a4c8 <_fx_directory_free_search+0x7c4>
                    }

                    /* Determine if there are more sectors to clear in the first cluster of the new
                       sub-directory.  */
                    if (sectors > 1)
 800a2c0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800a2c2:	2b01      	cmp	r3, #1
 800a2c4:	d95a      	bls.n	800a37c <_fx_directory_free_search+0x678>

                        /* Yes, invalidate all cached sectors that are contained in the newly allocated first
                           cluster of the directory.  */

                        /* Flush the internal logical sector cache.  */
                        status =  _fx_utility_logical_sector_flush(media_ptr, (ULONG64) (logical_sector + 1), (ULONG64) (sectors - 1), FX_TRUE);
 800a2c6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800a2c8:	3301      	adds	r3, #1
 800a2ca:	2200      	movs	r2, #0
 800a2cc:	603b      	str	r3, [r7, #0]
 800a2ce:	607a      	str	r2, [r7, #4]
 800a2d0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800a2d2:	3b01      	subs	r3, #1
 800a2d4:	2200      	movs	r2, #0
 800a2d6:	4698      	mov	r8, r3
 800a2d8:	4691      	mov	r9, r2
 800a2da:	2301      	movs	r3, #1
 800a2dc:	9302      	str	r3, [sp, #8]
 800a2de:	e9cd 8900 	strd	r8, r9, [sp]
 800a2e2:	e9d7 2300 	ldrd	r2, r3, [r7]
 800a2e6:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 800a2e8:	f005 fd52 	bl	800fd90 <_fx_utility_logical_sector_flush>
 800a2ec:	63f8      	str	r0, [r7, #60]	@ 0x3c

                        /* Determine if the flush was successful.  */
                        if (status != FX_SUCCESS)
 800a2ee:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800a2f0:	2b00      	cmp	r3, #0
 800a2f2:	d001      	beq.n	800a2f8 <_fx_directory_free_search+0x5f4>
                        {

                            /* Return the error code.  */
                            return(status);
 800a2f4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800a2f6:	e0e7      	b.n	800a4c8 <_fx_directory_free_search+0x7c4>
                        }

                        /* Clear all additional sectors of new sub-directory.  */
                        sectors--;
 800a2f8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800a2fa:	3b01      	subs	r3, #1
 800a2fc:	643b      	str	r3, [r7, #64]	@ 0x40
                        while (sectors)
 800a2fe:	e03a      	b.n	800a376 <_fx_directory_free_search+0x672>
                        {

#ifndef FX_MEDIA_STATISTICS_DISABLE

                            /* Increment the number of driver write sector(s) requests.  */
                            media_ptr -> fx_media_driver_write_requests++;
 800a300:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a302:	f8d3 31b0 	ldr.w	r3, [r3, #432]	@ 0x1b0
 800a306:	1c5a      	adds	r2, r3, #1
 800a308:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a30a:	f8c3 21b0 	str.w	r2, [r3, #432]	@ 0x1b0
#endif

                            /* Build Write request to the driver.  */
                            media_ptr -> fx_media_driver_request =          FX_DRIVER_WRITE;
 800a30e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a310:	2201      	movs	r2, #1
 800a312:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
                            media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 800a316:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a318:	2290      	movs	r2, #144	@ 0x90
 800a31a:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
                            media_ptr -> fx_media_driver_buffer =           media_ptr -> fx_media_memory_buffer;
 800a31e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a320:	689a      	ldr	r2, [r3, #8]
 800a322:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a324:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
                            media_ptr -> fx_media_driver_logical_sector =   (ULONG)logical_sector + ((ULONG)sectors);
 800a328:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 800a32a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800a32c:	441a      	add	r2, r3
 800a32e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a330:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
                            media_ptr -> fx_media_driver_sectors =          1;
 800a334:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a336:	2201      	movs	r2, #1
 800a338:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98
                            media_ptr -> fx_media_driver_sector_type =      FX_DIRECTORY_SECTOR;
 800a33c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a33e:	2203      	movs	r2, #3
 800a340:	f8c3 20b8 	str.w	r2, [r3, #184]	@ 0xb8

                            /* Set the system write flag since we are writing a directory sector.  */
                            media_ptr -> fx_media_driver_system_write =  FX_TRUE;
 800a344:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a346:	2201      	movs	r2, #1
 800a348:	f8c3 20b0 	str.w	r2, [r3, #176]	@ 0xb0

                            /* If trace is enabled, insert this event into the trace buffer.  */
                            FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_WRITE, media_ptr, ((ULONG)logical_sector) + ((ULONG)sectors), 1, media_ptr -> fx_media_memory_buffer, FX_TRACE_INTERNAL_EVENTS, 0, 0)

                            /* Invoke the driver to write the sector.  */
                            (media_ptr -> fx_media_driver_entry) (media_ptr);
 800a34c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a34e:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
 800a352:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 800a354:	4798      	blx	r3

                            /* Clear the system write flag.  */
                            media_ptr -> fx_media_driver_system_write =  FX_FALSE;
 800a356:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a358:	2200      	movs	r2, #0
 800a35a:	f8c3 20b0 	str.w	r2, [r3, #176]	@ 0xb0

                            /* Determine if an error occurred.  */
                            if (media_ptr -> fx_media_driver_status != FX_SUCCESS)
 800a35e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a360:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800a364:	2b00      	cmp	r3, #0
 800a366:	d003      	beq.n	800a370 <_fx_directory_free_search+0x66c>
                            {

                                /* Return error code.  */
                                return(media_ptr -> fx_media_driver_status);
 800a368:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a36a:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800a36e:	e0ab      	b.n	800a4c8 <_fx_directory_free_search+0x7c4>
                            }

                            /* Decrease the number of sectors to clear.  */
                            sectors--;
 800a370:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800a372:	3b01      	subs	r3, #1
 800a374:	643b      	str	r3, [r7, #64]	@ 0x40
                        while (sectors)
 800a376:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800a378:	2b00      	cmp	r3, #0
 800a37a:	d1c1      	bne.n	800a300 <_fx_directory_free_search+0x5fc>
                        }
                    }

                    /* Determine if we have found the first new cluster yet.  */
                    if (first_new_cluster == 0)
 800a37c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 800a37e:	2b00      	cmp	r3, #0
 800a380:	d101      	bne.n	800a386 <_fx_directory_free_search+0x682>
                    {

                        /* Remember the first new cluster. */
                        first_new_cluster =  FAT_index;
 800a382:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 800a384:	65bb      	str	r3, [r7, #88]	@ 0x58
                    }

                    /* Check for a valid last cluster to link.  */
                    if (last_cluster)
 800a386:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 800a388:	2b00      	cmp	r3, #0
 800a38a:	d00a      	beq.n	800a3a2 <_fx_directory_free_search+0x69e>
                    {

                        /* Normal condition - link the last cluster with the new
                           found cluster.  */
                        status = _fx_utility_FAT_entry_write(media_ptr, last_cluster, FAT_index);
 800a38c:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 800a38e:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 800a390:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 800a392:	f004 fd2e 	bl	800edf2 <_fx_utility_FAT_entry_write>
 800a396:	63f8      	str	r0, [r7, #60]	@ 0x3c

                        /* Check for a bad FAT write status.  */
                        if (status !=  FX_SUCCESS)
 800a398:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800a39a:	2b00      	cmp	r3, #0
 800a39c:	d001      	beq.n	800a3a2 <_fx_directory_free_search+0x69e>
                        {

                            /* Return the bad status.  */
                            return(status);
 800a39e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800a3a0:	e092      	b.n	800a4c8 <_fx_directory_free_search+0x7c4>
                        }
                    }

                    /* Otherwise, remember the new FAT index as the last.  */
                    last_cluster =  FAT_index;
 800a3a2:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 800a3a4:	657b      	str	r3, [r7, #84]	@ 0x54

                    /* Move to the next FAT entry.  */
                    FAT_index =  media_ptr -> fx_media_cluster_search_start;
 800a3a6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a3a8:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 800a3ac:	667b      	str	r3, [r7, #100]	@ 0x64
                while (clusters)
 800a3ae:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800a3b0:	2b00      	cmp	r3, #0
 800a3b2:	f47f aef8 	bne.w	800a1a6 <_fx_directory_free_search+0x4a2>
                }

                /* Place an end-of-file marker on the last cluster.  */
                status = _fx_utility_FAT_entry_write(media_ptr, last_cluster, media_ptr -> fx_media_fat_last);
 800a3b6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a3b8:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 800a3bc:	f8d3 347c 	ldr.w	r3, [r3, #1148]	@ 0x47c
 800a3c0:	461a      	mov	r2, r3
 800a3c2:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 800a3c4:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 800a3c6:	f004 fd14 	bl	800edf2 <_fx_utility_FAT_entry_write>
 800a3ca:	63f8      	str	r0, [r7, #60]	@ 0x3c

                /* Check for a bad FAT write status.  */
                if (status !=  FX_SUCCESS)
 800a3cc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800a3ce:	2b00      	cmp	r3, #0
 800a3d0:	d001      	beq.n	800a3d6 <_fx_directory_free_search+0x6d2>
                {

                    /* Return the bad status.  */
                    return(status);
 800a3d2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800a3d4:	e078      	b.n	800a4c8 <_fx_directory_free_search+0x7c4>
                /* Flush the cached individual FAT entries */
                _fx_utility_FAT_flush(media_ptr);
#endif

                /* Now the new cluster needs to be linked to the sub-directory.  */
                if (search_dir_ptr)
 800a3d6:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800a3d8:	2b00      	cmp	r3, #0
 800a3da:	d003      	beq.n	800a3e4 <_fx_directory_free_search+0x6e0>
                {
                    cluster = search_dir_ptr -> fx_dir_entry_cluster;
 800a3dc:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800a3de:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800a3e0:	663b      	str	r3, [r7, #96]	@ 0x60
 800a3e2:	e002      	b.n	800a3ea <_fx_directory_free_search+0x6e6>
                }
                else
                {
                    cluster = media_ptr -> fx_media_root_cluster_32;
 800a3e4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a3e6:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 800a3e8:	663b      	str	r3, [r7, #96]	@ 0x60
                }

                /* Initialize loop variables.  */
                last_cluster =  0;
 800a3ea:	2300      	movs	r3, #0
 800a3ec:	657b      	str	r3, [r7, #84]	@ 0x54
                i =  0;
 800a3ee:	2300      	movs	r3, #0
 800a3f0:	67fb      	str	r3, [r7, #124]	@ 0x7c

                /* Follow the link of FAT entries.  */
                while (cluster < media_ptr -> fx_media_fat_reserved)
 800a3f2:	e021      	b.n	800a438 <_fx_directory_free_search+0x734>
                {

                    /* Read the current cluster entry from the FAT.  */
                    status =  _fx_utility_FAT_entry_read(media_ptr, cluster, &FAT_value);
 800a3f4:	f107 0330 	add.w	r3, r7, #48	@ 0x30
 800a3f8:	461a      	mov	r2, r3
 800a3fa:	6e39      	ldr	r1, [r7, #96]	@ 0x60
 800a3fc:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 800a3fe:	f004 facf 	bl	800e9a0 <_fx_utility_FAT_entry_read>
 800a402:	63f8      	str	r0, [r7, #60]	@ 0x3c
                    i++;
 800a404:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 800a406:	3301      	adds	r3, #1
 800a408:	67fb      	str	r3, [r7, #124]	@ 0x7c

                    /* Check the return value.  */
                    if (status != FX_SUCCESS)
 800a40a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800a40c:	2b00      	cmp	r3, #0
 800a40e:	d001      	beq.n	800a414 <_fx_directory_free_search+0x710>
                    {

                        /* Return the error status.  */
                        return(status);
 800a410:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800a412:	e059      	b.n	800a4c8 <_fx_directory_free_search+0x7c4>
                    }

                    /* Determine if the FAT read was invalid.  */
                    if ((cluster < FX_FAT_ENTRY_START) || (cluster == FAT_value) || (i > media_ptr -> fx_media_total_clusters))
 800a414:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 800a416:	2b01      	cmp	r3, #1
 800a418:	d908      	bls.n	800a42c <_fx_directory_free_search+0x728>
 800a41a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800a41c:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 800a41e:	429a      	cmp	r2, r3
 800a420:	d004      	beq.n	800a42c <_fx_directory_free_search+0x728>
 800a422:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a424:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800a426:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 800a428:	429a      	cmp	r2, r3
 800a42a:	d901      	bls.n	800a430 <_fx_directory_free_search+0x72c>
                    {

                        /* Return the bad status.  */
                        return(FX_FAT_READ_ERROR);
 800a42c:	2303      	movs	r3, #3
 800a42e:	e04b      	b.n	800a4c8 <_fx_directory_free_search+0x7c4>
                    }

                    /* Save the last valid cluster.  */
                    last_cluster =  cluster;
 800a430:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 800a432:	657b      	str	r3, [r7, #84]	@ 0x54

                    /* Setup for the next cluster.  */
                    cluster =  FAT_value;
 800a434:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800a436:	663b      	str	r3, [r7, #96]	@ 0x60
                while (cluster < media_ptr -> fx_media_fat_reserved)
 800a438:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a43a:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 800a43e:	f8d3 3478 	ldr.w	r3, [r3, #1144]	@ 0x478
 800a442:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 800a444:	429a      	cmp	r2, r3
 800a446:	d3d5      	bcc.n	800a3f4 <_fx_directory_free_search+0x6f0>
                }

                /* Decrease the available clusters in the media.  */
                media_ptr -> fx_media_available_clusters =  media_ptr -> fx_media_available_clusters - clusters_needed;
 800a448:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a44a:	6fda      	ldr	r2, [r3, #124]	@ 0x7c
 800a44c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800a44e:	1ad2      	subs	r2, r2, r3
 800a450:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a452:	67da      	str	r2, [r3, #124]	@ 0x7c

                /* Increase the number of directory entries.  */
                directory_entries =  directory_entries + ((clusters_needed * media_ptr -> fx_media_sectors_per_cluster) * media_ptr -> fx_media_bytes_per_sector) / FX_DIR_ENTRY_SIZE;
 800a454:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a456:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800a458:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 800a45a:	fb03 f202 	mul.w	r2, r3, r2
 800a45e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a460:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800a462:	fb02 f303 	mul.w	r3, r2, r3
 800a466:	095b      	lsrs	r3, r3, #5
 800a468:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 800a46a:	4413      	add	r3, r2
 800a46c:	64fb      	str	r3, [r7, #76]	@ 0x4c

                /* Determine if we need to reset the free entry start since we changed the
                   number of directory entries.  If the last entry was not free, then we
                   should definitely reset the free entry start.  */
                if (!(((UCHAR)entry_ptr -> fx_dir_entry_name[0] == (UCHAR) FX_DIR_ENTRY_FREE) && (entry_ptr -> fx_dir_entry_short_name[0] == 0)))
 800a46e:	69fb      	ldr	r3, [r7, #28]
 800a470:	681b      	ldr	r3, [r3, #0]
 800a472:	781b      	ldrb	r3, [r3, #0]
 800a474:	2be5      	cmp	r3, #229	@ 0xe5
 800a476:	d103      	bne.n	800a480 <_fx_directory_free_search+0x77c>
 800a478:	69fb      	ldr	r3, [r7, #28]
 800a47a:	791b      	ldrb	r3, [r3, #4]
 800a47c:	2b00      	cmp	r3, #0
 800a47e:	d001      	beq.n	800a484 <_fx_directory_free_search+0x780>
                {

                    /* Reset the free entry start to indicate we haven't found a starting free entry yet.  */
                    free_entry_start =  directory_entries;
 800a480:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800a482:	647b      	str	r3, [r7, #68]	@ 0x44
                }

                /* Update the directory size field.  */
                directory_ptr -> fx_dir_entry_file_size =  directory_entries;
 800a484:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800a486:	2200      	movs	r2, #0
 800a488:	469a      	mov	sl, r3
 800a48a:	4693      	mov	fp, r2
 800a48c:	6a3b      	ldr	r3, [r7, #32]
 800a48e:	e9c3 ab0e 	strd	sl, fp, [r3, #56]	@ 0x38

                /* Defer the update of the FAT entry and the last cluster of the current
                   directory entry until after the new cluster is initialized and written out.  */

                /* Determine if a FAT32 is present.  */
                if ((media_ptr -> fx_media_32_bit_FAT) && (search_dir_ptr == FX_NULL))
 800a492:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a494:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 800a496:	2b00      	cmp	r3, #0
 800a498:	d005      	beq.n	800a4a6 <_fx_directory_free_search+0x7a2>
 800a49a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800a49c:	2b00      	cmp	r3, #0
 800a49e:	d102      	bne.n	800a4a6 <_fx_directory_free_search+0x7a2>
                {

                    /* Change root directory entry count - FAT32 has a variable sized root directory.  */
                    media_ptr -> fx_media_root_directory_entries =  directory_entries;
 800a4a0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a4a2:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 800a4a4:	679a      	str	r2, [r3, #120]	@ 0x78
                }

                /* At this point, link up the last cluster with the new cluster.  */
                status =  _fx_utility_FAT_entry_write(media_ptr, last_cluster, first_new_cluster);
 800a4a6:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 800a4a8:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 800a4aa:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 800a4ac:	f004 fca1 	bl	800edf2 <_fx_utility_FAT_entry_write>
 800a4b0:	63f8      	str	r0, [r7, #60]	@ 0x3c

                /* Check the return value.  */
                if (status != FX_SUCCESS)
 800a4b2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800a4b4:	2b00      	cmp	r3, #0
 800a4b6:	d001      	beq.n	800a4bc <_fx_directory_free_search+0x7b8>
                {

                    /* Return the error status.  */
                    return(status);
 800a4b8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800a4ba:	e005      	b.n	800a4c8 <_fx_directory_free_search+0x7c4>
                /* Flush the cached individual FAT entries */
                _fx_utility_FAT_flush(media_ptr);
#endif
            }
        }
    } while (directory_index < directory_entries);
 800a4bc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800a4be:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 800a4c0:	429a      	cmp	r2, r3
 800a4c2:	f63f adbf 	bhi.w	800a044 <_fx_directory_free_search+0x340>

    /* Return FX_NO_MORE_SPACE status to the caller.  */
    return(FX_NO_MORE_SPACE);
 800a4c6:	230a      	movs	r3, #10
}
 800a4c8:	4618      	mov	r0, r3
 800a4ca:	3780      	adds	r7, #128	@ 0x80
 800a4cc:	46bd      	mov	sp, r7
 800a4ce:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 800a4d2:	bf00      	nop

0800a4d4 <_fx_directory_name_extract>:
/*  09-30-2020     William E. Lamie         Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
CHAR  *_fx_directory_name_extract(CHAR *source_ptr, CHAR *dest_ptr)
{
 800a4d4:	b480      	push	{r7}
 800a4d6:	b085      	sub	sp, #20
 800a4d8:	af00      	add	r7, sp, #0
 800a4da:	6078      	str	r0, [r7, #4]
 800a4dc:	6039      	str	r1, [r7, #0]

UINT i;


    /* Set the destination string to NULL.  */
    dest_ptr[0] = 0;
 800a4de:	683b      	ldr	r3, [r7, #0]
 800a4e0:	2200      	movs	r2, #0
 800a4e2:	701a      	strb	r2, [r3, #0]

    /* Is a backslash present?  */
    if ((*source_ptr == '\\') || (*source_ptr == '/'))
 800a4e4:	687b      	ldr	r3, [r7, #4]
 800a4e6:	781b      	ldrb	r3, [r3, #0]
 800a4e8:	2b5c      	cmp	r3, #92	@ 0x5c
 800a4ea:	d003      	beq.n	800a4f4 <_fx_directory_name_extract+0x20>
 800a4ec:	687b      	ldr	r3, [r7, #4]
 800a4ee:	781b      	ldrb	r3, [r3, #0]
 800a4f0:	2b2f      	cmp	r3, #47	@ 0x2f
 800a4f2:	d106      	bne.n	800a502 <_fx_directory_name_extract+0x2e>
    {

        /* Advance the string pointer.  */
        source_ptr++;
 800a4f4:	687b      	ldr	r3, [r7, #4]
 800a4f6:	3301      	adds	r3, #1
 800a4f8:	607b      	str	r3, [r7, #4]
    }

    /* Loop to remove any leading spaces.  */
    while (*source_ptr == ' ')
 800a4fa:	e002      	b.n	800a502 <_fx_directory_name_extract+0x2e>
    {

        /* Position past leading space.  */
        source_ptr++;
 800a4fc:	687b      	ldr	r3, [r7, #4]
 800a4fe:	3301      	adds	r3, #1
 800a500:	607b      	str	r3, [r7, #4]
    while (*source_ptr == ' ')
 800a502:	687b      	ldr	r3, [r7, #4]
 800a504:	781b      	ldrb	r3, [r3, #0]
 800a506:	2b20      	cmp	r3, #32
 800a508:	d0f8      	beq.n	800a4fc <_fx_directory_name_extract+0x28>
    }

    /* Loop to extract the name.  */
    i = 0;
 800a50a:	2300      	movs	r3, #0
 800a50c:	60fb      	str	r3, [r7, #12]
    while (*source_ptr)
 800a50e:	e015      	b.n	800a53c <_fx_directory_name_extract+0x68>
    {

        /* If another backslash is present, break the loop.  */
        if ((*source_ptr == '\\') || (*source_ptr == '/'))
 800a510:	687b      	ldr	r3, [r7, #4]
 800a512:	781b      	ldrb	r3, [r3, #0]
 800a514:	2b5c      	cmp	r3, #92	@ 0x5c
 800a516:	d017      	beq.n	800a548 <_fx_directory_name_extract+0x74>
 800a518:	687b      	ldr	r3, [r7, #4]
 800a51a:	781b      	ldrb	r3, [r3, #0]
 800a51c:	2b2f      	cmp	r3, #47	@ 0x2f
 800a51e:	d013      	beq.n	800a548 <_fx_directory_name_extract+0x74>
            break;
        }

        /* Long name can be at most 255 characters, but are further limited by the
           FX_MAX_LONG_NAME_LEN define.  */
        if (i == FX_MAX_LONG_NAME_LEN - 1)
 800a520:	68fb      	ldr	r3, [r7, #12]
 800a522:	2bff      	cmp	r3, #255	@ 0xff
 800a524:	d00f      	beq.n	800a546 <_fx_directory_name_extract+0x72>
        {
            break;
        }

        /* Store the character.  */
        dest_ptr[i] =  *source_ptr++;
 800a526:	687b      	ldr	r3, [r7, #4]
 800a528:	1c5a      	adds	r2, r3, #1
 800a52a:	607a      	str	r2, [r7, #4]
 800a52c:	6839      	ldr	r1, [r7, #0]
 800a52e:	68fa      	ldr	r2, [r7, #12]
 800a530:	440a      	add	r2, r1
 800a532:	781b      	ldrb	r3, [r3, #0]
 800a534:	7013      	strb	r3, [r2, #0]

        /* Increment the character counter.  */
        i++;
 800a536:	68fb      	ldr	r3, [r7, #12]
 800a538:	3301      	adds	r3, #1
 800a53a:	60fb      	str	r3, [r7, #12]
    while (*source_ptr)
 800a53c:	687b      	ldr	r3, [r7, #4]
 800a53e:	781b      	ldrb	r3, [r3, #0]
 800a540:	2b00      	cmp	r3, #0
 800a542:	d1e5      	bne.n	800a510 <_fx_directory_name_extract+0x3c>
 800a544:	e000      	b.n	800a548 <_fx_directory_name_extract+0x74>
            break;
 800a546:	bf00      	nop
    }

    /* NULL-terminate the string.  */
    dest_ptr[i] =  0;
 800a548:	683a      	ldr	r2, [r7, #0]
 800a54a:	68fb      	ldr	r3, [r7, #12]
 800a54c:	4413      	add	r3, r2
 800a54e:	2200      	movs	r2, #0
 800a550:	701a      	strb	r2, [r3, #0]

    /* Determine if we can backup to the previous character.  */
    if (i)
 800a552:	68fb      	ldr	r3, [r7, #12]
 800a554:	2b00      	cmp	r3, #0
 800a556:	d00b      	beq.n	800a570 <_fx_directory_name_extract+0x9c>
    {

        /* Yes, we can move backwards.  */
        i--;
 800a558:	68fb      	ldr	r3, [r7, #12]
 800a55a:	3b01      	subs	r3, #1
 800a55c:	60fb      	str	r3, [r7, #12]
    }

    /* Get rid of trailing blanks in the destination string.  */
    while (dest_ptr[i] == ' ')
 800a55e:	e007      	b.n	800a570 <_fx_directory_name_extract+0x9c>
    {

        /* Set this entry to NULL.  */
        dest_ptr[i] =  0;
 800a560:	683a      	ldr	r2, [r7, #0]
 800a562:	68fb      	ldr	r3, [r7, #12]
 800a564:	4413      	add	r3, r2
 800a566:	2200      	movs	r2, #0
 800a568:	701a      	strb	r2, [r3, #0]

        /* Backup to the next character. Since leading spaces have been removed,
           we know that the index is always greater than 1.  */
        i--;
 800a56a:	68fb      	ldr	r3, [r7, #12]
 800a56c:	3b01      	subs	r3, #1
 800a56e:	60fb      	str	r3, [r7, #12]
    while (dest_ptr[i] == ' ')
 800a570:	683a      	ldr	r2, [r7, #0]
 800a572:	68fb      	ldr	r3, [r7, #12]
 800a574:	4413      	add	r3, r2
 800a576:	781b      	ldrb	r3, [r3, #0]
 800a578:	2b20      	cmp	r3, #32
 800a57a:	d0f1      	beq.n	800a560 <_fx_directory_name_extract+0x8c>
    }

    /* Determine if the source string is now at the end.  */
    if (*source_ptr == 0)
 800a57c:	687b      	ldr	r3, [r7, #4]
 800a57e:	781b      	ldrb	r3, [r3, #0]
 800a580:	2b00      	cmp	r3, #0
 800a582:	d101      	bne.n	800a588 <_fx_directory_name_extract+0xb4>
    {

        /* Yes, return a NULL pointer.  */
        source_ptr = FX_NULL;
 800a584:	2300      	movs	r3, #0
 800a586:	607b      	str	r3, [r7, #4]
    }

    /* Return the last pointer position in the source.  */
    return(source_ptr);
 800a588:	687b      	ldr	r3, [r7, #4]
}
 800a58a:	4618      	mov	r0, r3
 800a58c:	3714      	adds	r7, #20
 800a58e:	46bd      	mov	sp, r7
 800a590:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a594:	4770      	bx	lr

0800a596 <_fx_directory_search>:
/*                                            resulting in version 6.1.10 */
/*                                                                        */
/**************************************************************************/
UINT  _fx_directory_search(FX_MEDIA *media_ptr, CHAR *name_ptr, FX_DIR_ENTRY *entry_ptr,
                           FX_DIR_ENTRY *last_dir_ptr, CHAR **last_name_ptr)
{
 800a596:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 800a59a:	b0c0      	sub	sp, #256	@ 0x100
 800a59c:	af00      	add	r7, sp, #0
 800a59e:	62f8      	str	r0, [r7, #44]	@ 0x2c
 800a5a0:	62b9      	str	r1, [r7, #40]	@ 0x28
 800a5a2:	627a      	str	r2, [r7, #36]	@ 0x24
 800a5a4:	623b      	str	r3, [r7, #32]
UINT          found;
UINT          status;
#ifndef FX_MEDIA_DISABLE_SEARCH_CACHE
UINT          v, j;
#endif /* FX_MEDIA_DISABLE_SEARCH_CACHE */
ULONG         cluster, next_cluster = 0;
 800a5a6:	2300      	movs	r3, #0
 800a5a8:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
FX_DIR_ENTRY  search_dir;
FX_DIR_ENTRY *search_dir_ptr;
CHAR         *name, alpha, name_alpha;
#ifndef FX_MEDIA_DISABLE_SEARCH_CACHE
UINT          index;
CHAR         *path_ptr =  FX_NULL;
 800a5ac:	2300      	movs	r3, #0
 800a5ae:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
CHAR         *original_name =  name_ptr;
 800a5b2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800a5b4:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
#endif /* FX_ENABLE_EXFAT */

#ifndef FX_MEDIA_STATISTICS_DISABLE

    /* Increment the number of directory search requests.  */
    media_ptr -> fx_media_directory_searches++;
 800a5b8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800a5ba:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
 800a5be:	1c5a      	adds	r2, r3, #1
 800a5c0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800a5c2:	f8c3 2170 	str.w	r2, [r3, #368]	@ 0x170
#endif

    /* Setup pointer to media name buffer.  */
    name =  media_ptr -> fx_media_name_buffer;
 800a5c6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800a5c8:	f603 036c 	addw	r3, r3, #2156	@ 0x86c
 800a5cc:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8

    /* Setup the last directory, if required.  */
    if (last_dir_ptr)
 800a5d0:	6a3b      	ldr	r3, [r7, #32]
 800a5d2:	2b00      	cmp	r3, #0
 800a5d4:	d003      	beq.n	800a5de <_fx_directory_search+0x48>
    {

        /* Set the first character of the directory entry to NULL to
           indicate root or no directory.  */
        last_dir_ptr -> fx_dir_entry_name[0] =  0;
 800a5d6:	6a3b      	ldr	r3, [r7, #32]
 800a5d8:	681a      	ldr	r2, [r3, #0]
 800a5da:	2300      	movs	r3, #0
 800a5dc:	7013      	strb	r3, [r2, #0]
    }

    /* Determine if the file name has a full directory path.  */
    if ((*name_ptr == '\\') || (*name_ptr == '/'))
 800a5de:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800a5e0:	781b      	ldrb	r3, [r3, #0]
 800a5e2:	2b5c      	cmp	r3, #92	@ 0x5c
 800a5e4:	d003      	beq.n	800a5ee <_fx_directory_search+0x58>
 800a5e6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800a5e8:	781b      	ldrb	r3, [r3, #0]
 800a5ea:	2b2f      	cmp	r3, #47	@ 0x2f
 800a5ec:	d103      	bne.n	800a5f6 <_fx_directory_search+0x60>
    {

        /* Directory name has full path, set the search pointer to NULL.  */
        search_dir_ptr =  FX_NULL;
 800a5ee:	2300      	movs	r3, #0
 800a5f0:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
 800a5f4:	e01b      	b.n	800a62e <_fx_directory_search+0x98>
                search_dir_ptr =  FX_NULL;
            }
        }
        else
#endif
        if (media_ptr -> fx_media_default_path.fx_path_directory.fx_dir_entry_name[0])
 800a5f6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800a5f8:	f8d3 34b0 	ldr.w	r3, [r3, #1200]	@ 0x4b0
 800a5fc:	781b      	ldrb	r3, [r3, #0]
 800a5fe:	2b00      	cmp	r3, #0
 800a600:	d012      	beq.n	800a628 <_fx_directory_search+0x92>
        {

            /* Start at the current working directory of the media.  */
            search_dir =  media_ptr -> fx_media_default_path.fx_path_directory;
 800a602:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800a604:	f107 0030 	add.w	r0, r7, #48	@ 0x30
 800a608:	f503 6196 	add.w	r1, r3, #1200	@ 0x4b0
 800a60c:	2370      	movs	r3, #112	@ 0x70
 800a60e:	461a      	mov	r2, r3
 800a610:	f006 fd9b 	bl	801114a <memcpy>

#ifndef FX_MEDIA_DISABLE_SEARCH_CACHE

            /* Setup pointer to the path.  */
            path_ptr =  media_ptr -> fx_media_default_path.fx_path_string;
 800a614:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800a616:	f503 63a4 	add.w	r3, r3, #1312	@ 0x520
 800a61a:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
#endif

            /* Set the internal pointer to the search directory as well.  */
            search_dir_ptr =  &search_dir;
 800a61e:	f107 0330 	add.w	r3, r7, #48	@ 0x30
 800a622:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
 800a626:	e002      	b.n	800a62e <_fx_directory_search+0x98>
        else
        {

            /* The current default directory is the root so just set the
               search directory pointer to NULL.  */
            search_dir_ptr =  FX_NULL;
 800a628:	2300      	movs	r3, #0
 800a62a:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
    }

#ifndef FX_MEDIA_DISABLE_SEARCH_CACHE

    /* Determine if there is a previously found directory entry.  */
    if (media_ptr -> fx_media_last_found_name[0])
 800a62e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800a630:	f893 33b0 	ldrb.w	r3, [r3, #944]	@ 0x3b0
 800a634:	2b00      	cmp	r3, #0
 800a636:	f000 81b7 	beq.w	800a9a8 <_fx_directory_search+0x412>
    CHAR *temp_ptr, beta;

        /* Yes, there is a previously found directory in our cache.  */

        /* Initialize the index.  */
        v =  0;
 800a63a:	2300      	movs	r3, #0
 800a63c:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4

        /* Determine if there is a full path.  */
        if ((*name_ptr == '\\') || (*name_ptr == '/'))
 800a640:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800a642:	781b      	ldrb	r3, [r3, #0]
 800a644:	2b5c      	cmp	r3, #92	@ 0x5c
 800a646:	d02d      	beq.n	800a6a4 <_fx_directory_search+0x10e>
 800a648:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800a64a:	781b      	ldrb	r3, [r3, #0]
 800a64c:	2b2f      	cmp	r3, #47	@ 0x2f
 800a64e:	d14c      	bne.n	800a6ea <_fx_directory_search+0x154>
        {

            /* Yes, the full path is in the name buffer. Simply compare with what is in
               the last search buffer.  */
            while ((v < (FX_MAX_LAST_NAME_LEN - 1)) && (name_ptr[v]))
 800a650:	e028      	b.n	800a6a4 <_fx_directory_search+0x10e>
            {

                /* Pickup the respective name characters.  */
                alpha =  name_ptr[v];
 800a652:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800a654:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800a658:	4413      	add	r3, r2
 800a65a:	781b      	ldrb	r3, [r3, #0]
 800a65c:	f887 30d3 	strb.w	r3, [r7, #211]	@ 0xd3
                beta =   media_ptr -> fx_media_last_found_name[v];
 800a660:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800a662:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800a666:	4413      	add	r3, r2
 800a668:	f503 736c 	add.w	r3, r3, #944	@ 0x3b0
 800a66c:	781b      	ldrb	r3, [r3, #0]
 800a66e:	f887 30c3 	strb.w	r3, [r7, #195]	@ 0xc3

                /* Ensure directory markers are the same.  */
                if (alpha == '\\')
 800a672:	f897 30d3 	ldrb.w	r3, [r7, #211]	@ 0xd3
 800a676:	2b5c      	cmp	r3, #92	@ 0x5c
 800a678:	d102      	bne.n	800a680 <_fx_directory_search+0xea>
                {
                    alpha =  '/';
 800a67a:	232f      	movs	r3, #47	@ 0x2f
 800a67c:	f887 30d3 	strb.w	r3, [r7, #211]	@ 0xd3
                }
                if (beta == '\\')
 800a680:	f897 30c3 	ldrb.w	r3, [r7, #195]	@ 0xc3
 800a684:	2b5c      	cmp	r3, #92	@ 0x5c
 800a686:	d102      	bne.n	800a68e <_fx_directory_search+0xf8>
                {
                    beta =  '/';
 800a688:	232f      	movs	r3, #47	@ 0x2f
 800a68a:	f887 30c3 	strb.w	r3, [r7, #195]	@ 0xc3
                }

                /* Is the name the same?  */
                if (alpha != beta)
 800a68e:	f897 20d3 	ldrb.w	r2, [r7, #211]	@ 0xd3
 800a692:	f897 30c3 	ldrb.w	r3, [r7, #195]	@ 0xc3
 800a696:	429a      	cmp	r2, r3
 800a698:	d110      	bne.n	800a6bc <_fx_directory_search+0x126>
                    /* Break out of loop!  */
                    break;
                }

                /* Move to next character.  */
                v++;
 800a69a:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800a69e:	3301      	adds	r3, #1
 800a6a0:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
            while ((v < (FX_MAX_LAST_NAME_LEN - 1)) && (name_ptr[v]))
 800a6a4:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800a6a8:	2bfe      	cmp	r3, #254	@ 0xfe
 800a6aa:	d808      	bhi.n	800a6be <_fx_directory_search+0x128>
 800a6ac:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800a6ae:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800a6b2:	4413      	add	r3, r2
 800a6b4:	781b      	ldrb	r3, [r3, #0]
 800a6b6:	2b00      	cmp	r3, #0
 800a6b8:	d1cb      	bne.n	800a652 <_fx_directory_search+0xbc>
 800a6ba:	e000      	b.n	800a6be <_fx_directory_search+0x128>
                    break;
 800a6bc:	bf00      	nop
            }

            /* Determine if we have a match.  */
            if (name_ptr[v] != media_ptr -> fx_media_last_found_name[v])
 800a6be:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800a6c0:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800a6c4:	4413      	add	r3, r2
 800a6c6:	7819      	ldrb	r1, [r3, #0]
 800a6c8:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800a6ca:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800a6ce:	4413      	add	r3, r2
 800a6d0:	f503 736c 	add.w	r3, r3, #944	@ 0x3b0
 800a6d4:	781b      	ldrb	r3, [r3, #0]
 800a6d6:	4299      	cmp	r1, r3
 800a6d8:	d003      	beq.n	800a6e2 <_fx_directory_search+0x14c>
            {
                match =  FX_FALSE;
 800a6da:	2300      	movs	r3, #0
 800a6dc:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
            if (name_ptr[v] != media_ptr -> fx_media_last_found_name[v])
 800a6e0:	e0cd      	b.n	800a87e <_fx_directory_search+0x2e8>
            }
            else
            {
                match =  FX_TRUE;
 800a6e2:	2301      	movs	r3, #1
 800a6e4:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
            if (name_ptr[v] != media_ptr -> fx_media_last_found_name[v])
 800a6e8:	e0c9      	b.n	800a87e <_fx_directory_search+0x2e8>
        }
        else
        {

            /* Default to found.  */
            match =  FX_TRUE;
 800a6ea:	2301      	movs	r3, #1
 800a6ec:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4

            /* Determine if there is a default path to compare with.  */
            if (path_ptr)
 800a6f0:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 800a6f4:	2b00      	cmp	r3, #0
 800a6f6:	d043      	beq.n	800a780 <_fx_directory_search+0x1ea>
            {

                /* Yes, compare the current path with what is contained in the last
                   found buffer. Note that the last found name must have at least one
                   path separator as well as room for at least one character for a name. */
                while ((v < (FX_MAX_LAST_NAME_LEN - 1)) && (path_ptr[v]))
 800a6f8:	e029      	b.n	800a74e <_fx_directory_search+0x1b8>
                {

                    /* Pickup the respective name characters.  */
                    alpha =  media_ptr -> fx_media_last_found_name[v];
 800a6fa:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800a6fc:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800a700:	4413      	add	r3, r2
 800a702:	f503 736c 	add.w	r3, r3, #944	@ 0x3b0
 800a706:	781b      	ldrb	r3, [r3, #0]
 800a708:	f887 30d3 	strb.w	r3, [r7, #211]	@ 0xd3
                    beta =   path_ptr[v];
 800a70c:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
 800a710:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800a714:	4413      	add	r3, r2
 800a716:	781b      	ldrb	r3, [r3, #0]
 800a718:	f887 30c3 	strb.w	r3, [r7, #195]	@ 0xc3

                    /* Ensure directory markers are the same.  */
                    if (alpha == '\\')
 800a71c:	f897 30d3 	ldrb.w	r3, [r7, #211]	@ 0xd3
 800a720:	2b5c      	cmp	r3, #92	@ 0x5c
 800a722:	d102      	bne.n	800a72a <_fx_directory_search+0x194>
                    {
                        alpha =  '/';
 800a724:	232f      	movs	r3, #47	@ 0x2f
 800a726:	f887 30d3 	strb.w	r3, [r7, #211]	@ 0xd3
                    }
                    if (beta == '\\')
 800a72a:	f897 30c3 	ldrb.w	r3, [r7, #195]	@ 0xc3
 800a72e:	2b5c      	cmp	r3, #92	@ 0x5c
 800a730:	d102      	bne.n	800a738 <_fx_directory_search+0x1a2>
                    {
                        beta =  '/';
 800a732:	232f      	movs	r3, #47	@ 0x2f
 800a734:	f887 30c3 	strb.w	r3, [r7, #195]	@ 0xc3
                    }

                    /* Is the name the same?  */
                    if (alpha != beta)
 800a738:	f897 20d3 	ldrb.w	r2, [r7, #211]	@ 0xd3
 800a73c:	f897 30c3 	ldrb.w	r3, [r7, #195]	@ 0xc3
 800a740:	429a      	cmp	r2, r3
 800a742:	d111      	bne.n	800a768 <_fx_directory_search+0x1d2>
                        /* Break out of loop!  */
                        break;
                    }

                    /* Move to next character.  */
                    v++;
 800a744:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800a748:	3301      	adds	r3, #1
 800a74a:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
                while ((v < (FX_MAX_LAST_NAME_LEN - 1)) && (path_ptr[v]))
 800a74e:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800a752:	2bfe      	cmp	r3, #254	@ 0xfe
 800a754:	d809      	bhi.n	800a76a <_fx_directory_search+0x1d4>
 800a756:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
 800a75a:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800a75e:	4413      	add	r3, r2
 800a760:	781b      	ldrb	r3, [r3, #0]
 800a762:	2b00      	cmp	r3, #0
 800a764:	d1c9      	bne.n	800a6fa <_fx_directory_search+0x164>
 800a766:	e000      	b.n	800a76a <_fx_directory_search+0x1d4>
                        break;
 800a768:	bf00      	nop
                }

                /* Determine if we don't have a match...  The relative path must be exhausted. */
                if (path_ptr[v])
 800a76a:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
 800a76e:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800a772:	4413      	add	r3, r2
 800a774:	781b      	ldrb	r3, [r3, #0]
 800a776:	2b00      	cmp	r3, #0
 800a778:	d002      	beq.n	800a780 <_fx_directory_search+0x1ea>
                {
                    match =  FX_FALSE;
 800a77a:	2300      	movs	r3, #0
 800a77c:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
                }
            }

            /* Determine if we still have a match.  */
            if (match)
 800a780:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 800a784:	2b00      	cmp	r3, #0
 800a786:	d07a      	beq.n	800a87e <_fx_directory_search+0x2e8>

                /* Now examine the rest of the last name and the newly supplied
                   input name.  */

                /* Determine if a valid directory separator is present.  */
                if ((media_ptr -> fx_media_last_found_name[v] != '\\') &&
 800a788:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800a78a:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800a78e:	4413      	add	r3, r2
 800a790:	f503 736c 	add.w	r3, r3, #944	@ 0x3b0
 800a794:	781b      	ldrb	r3, [r3, #0]
 800a796:	2b5c      	cmp	r3, #92	@ 0x5c
 800a798:	d00c      	beq.n	800a7b4 <_fx_directory_search+0x21e>
                    (media_ptr -> fx_media_last_found_name[v] != '/'))
 800a79a:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800a79c:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800a7a0:	4413      	add	r3, r2
 800a7a2:	f503 736c 	add.w	r3, r3, #944	@ 0x3b0
 800a7a6:	781b      	ldrb	r3, [r3, #0]
                if ((media_ptr -> fx_media_last_found_name[v] != '\\') &&
 800a7a8:	2b2f      	cmp	r3, #47	@ 0x2f
 800a7aa:	d003      	beq.n	800a7b4 <_fx_directory_search+0x21e>
                {

                    /* Set match to false - invalid directory path separator.  */
                    match =  FX_FALSE;
 800a7ac:	2300      	movs	r3, #0
 800a7ae:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
 800a7b2:	e004      	b.n	800a7be <_fx_directory_search+0x228>
                }
                else
                {
                    /* Position past the next directory separator in the
                       last name string.  */
                    v++;
 800a7b4:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800a7b8:	3301      	adds	r3, #1
 800a7ba:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
                }

                /* Yes, the full path is in the name buffer. Simply compare with what is in
                   the last search buffer.  */
                j =  0;
 800a7be:	2300      	movs	r3, #0
 800a7c0:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
                while ((v < (FX_MAX_LAST_NAME_LEN - 1)) && (name_ptr[j]) && (match))
 800a7c4:	e02d      	b.n	800a822 <_fx_directory_search+0x28c>
                {

                    /* Pickup the respective name characters.  */
                    alpha =  name_ptr[j];
 800a7c6:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800a7c8:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 800a7cc:	4413      	add	r3, r2
 800a7ce:	781b      	ldrb	r3, [r3, #0]
 800a7d0:	f887 30d3 	strb.w	r3, [r7, #211]	@ 0xd3
                    beta =   media_ptr -> fx_media_last_found_name[v];
 800a7d4:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800a7d6:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800a7da:	4413      	add	r3, r2
 800a7dc:	f503 736c 	add.w	r3, r3, #944	@ 0x3b0
 800a7e0:	781b      	ldrb	r3, [r3, #0]
 800a7e2:	f887 30c3 	strb.w	r3, [r7, #195]	@ 0xc3

                    /* Ensure directory markers are the same.  */
                    if (alpha == '\\')
 800a7e6:	f897 30d3 	ldrb.w	r3, [r7, #211]	@ 0xd3
 800a7ea:	2b5c      	cmp	r3, #92	@ 0x5c
 800a7ec:	d102      	bne.n	800a7f4 <_fx_directory_search+0x25e>
                    {
                        alpha =  '/';
 800a7ee:	232f      	movs	r3, #47	@ 0x2f
 800a7f0:	f887 30d3 	strb.w	r3, [r7, #211]	@ 0xd3
                    }
                    if (beta == '\\')
 800a7f4:	f897 30c3 	ldrb.w	r3, [r7, #195]	@ 0xc3
 800a7f8:	2b5c      	cmp	r3, #92	@ 0x5c
 800a7fa:	d102      	bne.n	800a802 <_fx_directory_search+0x26c>
                    {
                        beta =  '/';
 800a7fc:	232f      	movs	r3, #47	@ 0x2f
 800a7fe:	f887 30c3 	strb.w	r3, [r7, #195]	@ 0xc3
                    }

                    /* Is the name the same?  */
                    if (alpha != beta)
 800a802:	f897 20d3 	ldrb.w	r2, [r7, #211]	@ 0xd3
 800a806:	f897 30c3 	ldrb.w	r3, [r7, #195]	@ 0xc3
 800a80a:	429a      	cmp	r2, r3
 800a80c:	d119      	bne.n	800a842 <_fx_directory_search+0x2ac>
                        /* Break out of loop!  */
                        break;
                    }

                    /* Move to next character.  */
                    v++;
 800a80e:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800a812:	3301      	adds	r3, #1
 800a814:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
                    j++;
 800a818:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 800a81c:	3301      	adds	r3, #1
 800a81e:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
                while ((v < (FX_MAX_LAST_NAME_LEN - 1)) && (name_ptr[j]) && (match))
 800a822:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800a826:	2bfe      	cmp	r3, #254	@ 0xfe
 800a828:	d80c      	bhi.n	800a844 <_fx_directory_search+0x2ae>
 800a82a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800a82c:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 800a830:	4413      	add	r3, r2
 800a832:	781b      	ldrb	r3, [r3, #0]
 800a834:	2b00      	cmp	r3, #0
 800a836:	d005      	beq.n	800a844 <_fx_directory_search+0x2ae>
 800a838:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 800a83c:	2b00      	cmp	r3, #0
 800a83e:	d1c2      	bne.n	800a7c6 <_fx_directory_search+0x230>
 800a840:	e000      	b.n	800a844 <_fx_directory_search+0x2ae>
                        break;
 800a842:	bf00      	nop
                }

                /* Avoid accessing fx_media_last_found_name out of bounds. */
                if (v >= 256)
 800a844:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800a848:	2bff      	cmp	r3, #255	@ 0xff
 800a84a:	d903      	bls.n	800a854 <_fx_directory_search+0x2be>
                {
                    match = FX_FALSE;
 800a84c:	2300      	movs	r3, #0
 800a84e:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
 800a852:	e014      	b.n	800a87e <_fx_directory_search+0x2e8>
                }
                else if ((match) && (name_ptr[j] != media_ptr -> fx_media_last_found_name[v]))
 800a854:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 800a858:	2b00      	cmp	r3, #0
 800a85a:	d010      	beq.n	800a87e <_fx_directory_search+0x2e8>
 800a85c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800a85e:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 800a862:	4413      	add	r3, r2
 800a864:	7819      	ldrb	r1, [r3, #0]
 800a866:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800a868:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800a86c:	4413      	add	r3, r2
 800a86e:	f503 736c 	add.w	r3, r3, #944	@ 0x3b0
 800a872:	781b      	ldrb	r3, [r3, #0]
 800a874:	4299      	cmp	r1, r3
 800a876:	d002      	beq.n	800a87e <_fx_directory_search+0x2e8>
                {

                    /* We don't have a match.  */
                    match =  FX_FALSE;
 800a878:	2300      	movs	r3, #0
 800a87a:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
                }
            }
        }

        /* Now determine if we actually found a match.  */
        if (match)
 800a87e:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 800a882:	2b00      	cmp	r3, #0
 800a884:	f000 8090 	beq.w	800a9a8 <_fx_directory_search+0x412>
        {

            /* Save the directory entry name pointer.  */
            temp_ptr =  entry_ptr -> fx_dir_entry_name;
 800a888:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a88a:	681b      	ldr	r3, [r3, #0]
 800a88c:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4

            /* Copy the saved directory entry.  */
            *entry_ptr =  media_ptr -> fx_media_last_found_entry;
 800a890:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800a892:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800a894:	4610      	mov	r0, r2
 800a896:	f503 7310 	add.w	r3, r3, #576	@ 0x240
 800a89a:	2270      	movs	r2, #112	@ 0x70
 800a89c:	4619      	mov	r1, r3
 800a89e:	f006 fc54 	bl	801114a <memcpy>

            /* Restore the directory entry name pointer.  */
            entry_ptr -> fx_dir_entry_name =  temp_ptr;
 800a8a2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a8a4:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 800a8a8:	601a      	str	r2, [r3, #0]

            /* Copy the directory name into the destination directory name.  */
            for (index = 0; index < FX_MAX_LONG_NAME_LEN; index++)
 800a8aa:	2300      	movs	r3, #0
 800a8ac:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
 800a8b0:	e01d      	b.n	800a8ee <_fx_directory_search+0x358>
            {

                /* Copy character into the destination.  */
                temp_ptr[index] =  media_ptr -> fx_media_last_found_file_name[index];
 800a8b2:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 800a8b6:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 800a8ba:	4413      	add	r3, r2
 800a8bc:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 800a8be:	f8d7 20cc 	ldr.w	r2, [r7, #204]	@ 0xcc
 800a8c2:	440a      	add	r2, r1
 800a8c4:	f502 722c 	add.w	r2, r2, #688	@ 0x2b0
 800a8c8:	7812      	ldrb	r2, [r2, #0]
 800a8ca:	701a      	strb	r2, [r3, #0]

                /* See if we have copied the NULL termination character.  */
                if (temp_ptr[index] == (CHAR)FX_NULL)
 800a8cc:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 800a8d0:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 800a8d4:	4413      	add	r3, r2
 800a8d6:	781b      	ldrb	r3, [r3, #0]
 800a8d8:	2b00      	cmp	r3, #0
 800a8da:	d103      	bne.n	800a8e4 <_fx_directory_search+0x34e>
                {
                
                    /* Determine if we should break here or at the top of the loop.  */
                    if (index < (FX_MAX_LONG_NAME_LEN - 1))
 800a8dc:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 800a8e0:	2bfe      	cmp	r3, #254	@ 0xfe
 800a8e2:	d909      	bls.n	800a8f8 <_fx_directory_search+0x362>
            for (index = 0; index < FX_MAX_LONG_NAME_LEN; index++)
 800a8e4:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 800a8e8:	3301      	adds	r3, #1
 800a8ea:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
 800a8ee:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 800a8f2:	2bff      	cmp	r3, #255	@ 0xff
 800a8f4:	d9dd      	bls.n	800a8b2 <_fx_directory_search+0x31c>
 800a8f6:	e000      	b.n	800a8fa <_fx_directory_search+0x364>
                    {
                    
                        /* Yes, break out of the loop early.  */
                        break;
 800a8f8:	bf00      	nop
                    }
                }
            }

            /* Determine if there is a search directory to copy.  */
            if ((last_dir_ptr) && (media_ptr -> fx_media_last_found_directory_valid))
 800a8fa:	6a3b      	ldr	r3, [r7, #32]
 800a8fc:	2b00      	cmp	r3, #0
 800a8fe:	d041      	beq.n	800a984 <_fx_directory_search+0x3ee>
 800a900:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800a902:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
 800a906:	2b00      	cmp	r3, #0
 800a908:	d03c      	beq.n	800a984 <_fx_directory_search+0x3ee>

                /* Yes, there was a search directory... and one is requested in this request as well.
                   Simply copy it into the destination.  */

                /* First, save the name pointer from the list directory pointer.  */
                destination_name_ptr =  last_dir_ptr -> fx_dir_entry_name;
 800a90a:	6a3b      	ldr	r3, [r7, #32]
 800a90c:	681b      	ldr	r3, [r3, #0]
 800a90e:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0

                /* Copy the entire directory entry structure.  */
                *last_dir_ptr =  media_ptr -> fx_media_last_found_directory;
 800a912:	6a3a      	ldr	r2, [r7, #32]
 800a914:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800a916:	4610      	mov	r0, r2
 800a918:	f503 73e8 	add.w	r3, r3, #464	@ 0x1d0
 800a91c:	2270      	movs	r2, #112	@ 0x70
 800a91e:	4619      	mov	r1, r3
 800a920:	f006 fc13 	bl	801114a <memcpy>

                /* Restore the original name buffer pointer.  */
                last_dir_ptr -> fx_dir_entry_name =  destination_name_ptr;
 800a924:	6a3b      	ldr	r3, [r7, #32]
 800a926:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 800a92a:	601a      	str	r2, [r3, #0]

                /* Pickup pointer to name to copy.  */
                source_name_ptr =  media_ptr -> fx_media_last_found_directory.fx_dir_entry_name;
 800a92c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800a92e:	f8d3 31d0 	ldr.w	r3, [r3, #464]	@ 0x1d0
 800a932:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac

                /* Loop to copy the name into the last directory name buffer.  */
                for (n = 0; n < FX_MAX_LONG_NAME_LEN; n++)
 800a936:	2300      	movs	r3, #0
 800a938:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
 800a93c:	e01c      	b.n	800a978 <_fx_directory_search+0x3e2>
                {
                
                    /* Copy a character.  */
                    destination_name_ptr[n] =  source_name_ptr[n];
 800a93e:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
 800a942:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 800a946:	441a      	add	r2, r3
 800a948:	f8d7 10b0 	ldr.w	r1, [r7, #176]	@ 0xb0
 800a94c:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 800a950:	440b      	add	r3, r1
 800a952:	7812      	ldrb	r2, [r2, #0]
 800a954:	701a      	strb	r2, [r3, #0]
                
                    /* See if we have copied the NULL termination character.  */
                    if (source_name_ptr[n] == (CHAR)FX_NULL)
 800a956:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
 800a95a:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 800a95e:	4413      	add	r3, r2
 800a960:	781b      	ldrb	r3, [r3, #0]
 800a962:	2b00      	cmp	r3, #0
 800a964:	d103      	bne.n	800a96e <_fx_directory_search+0x3d8>
                    {
                
                        /* Determine if we should break here or at the top of the loop.  */
                        if (n < (FX_MAX_LONG_NAME_LEN - 1))
 800a966:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 800a96a:	2bfe      	cmp	r3, #254	@ 0xfe
 800a96c:	d909      	bls.n	800a982 <_fx_directory_search+0x3ec>
                for (n = 0; n < FX_MAX_LONG_NAME_LEN; n++)
 800a96e:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 800a972:	3301      	adds	r3, #1
 800a974:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
 800a978:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 800a97c:	2bff      	cmp	r3, #255	@ 0xff
 800a97e:	d9de      	bls.n	800a93e <_fx_directory_search+0x3a8>
 800a980:	e000      	b.n	800a984 <_fx_directory_search+0x3ee>
                        {
                    
                            /* Yes, break out of the loop early.  */
                            break;
 800a982:	bf00      	nop
                    }
                }
            }

            /* Return the last name pointer, if required.  */
            if (last_name_ptr)
 800a984:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 800a988:	2b00      	cmp	r3, #0
 800a98a:	d004      	beq.n	800a996 <_fx_directory_search+0x400>
            {

                /* Just set the last name to initial name string.  */
                *last_name_ptr =  temp_ptr;
 800a98c:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 800a990:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 800a994:	601a      	str	r2, [r3, #0]
            }

#ifndef FX_MEDIA_STATISTICS_DISABLE

            /* Increment the number of directory search cache hits.  */
            media_ptr -> fx_media_directory_search_cache_hits++;
 800a996:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800a998:	f8d3 31c4 	ldr.w	r3, [r3, #452]	@ 0x1c4
 800a99c:	1c5a      	adds	r2, r3, #1
 800a99e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800a9a0:	f8c3 21c4 	str.w	r2, [r3, #452]	@ 0x1c4
#endif

            /* Return success.  */
            return(FX_SUCCESS);
 800a9a4:	2300      	movs	r3, #0
 800a9a6:	e2ff      	b.n	800afa8 <_fx_directory_search+0xa12>
        }
    }

    /* Not a sequential search, invalidate the saved information.  */
    media_ptr -> fx_media_last_found_name[0] =  FX_NULL;
 800a9a8:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800a9aa:	2300      	movs	r3, #0
 800a9ac:	f882 33b0 	strb.w	r3, [r2, #944]	@ 0x3b0
    /* Loop to traverse the directory paths to find the specified file.  */
    do
    {

        /* Remember the last name pointer, if required.  */
        if (last_name_ptr)
 800a9b0:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 800a9b4:	2b00      	cmp	r3, #0
 800a9b6:	d003      	beq.n	800a9c0 <_fx_directory_search+0x42a>
        {

            /* Just set the last name to initial name string.  */
            *last_name_ptr =  name_ptr;
 800a9b8:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 800a9bc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800a9be:	6013      	str	r3, [r2, #0]
        }

        /* Extract file name.  */
        name_ptr =  _fx_directory_name_extract(name_ptr, name);
 800a9c0:	f8d7 10b8 	ldr.w	r1, [r7, #184]	@ 0xb8
 800a9c4:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 800a9c6:	f7ff fd85 	bl	800a4d4 <_fx_directory_name_extract>
 800a9ca:	62b8      	str	r0, [r7, #40]	@ 0x28

        /* Calculate the directory size.  */
        if (search_dir_ptr)
 800a9cc:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 800a9d0:	2b00      	cmp	r3, #0
 800a9d2:	f000 80be 	beq.w	800ab52 <_fx_directory_search+0x5bc>
            else
            {
#endif /* FX_ENABLE_EXFAT */

                /* Ensure that the search directory's last search cluster is cleared.  */
                search_dir_ptr -> fx_dir_entry_last_search_cluster =  0;
 800a9d6:	f8d7 20d4 	ldr.w	r2, [r7, #212]	@ 0xd4
 800a9da:	2300      	movs	r3, #0
 800a9dc:	6513      	str	r3, [r2, #80]	@ 0x50

                /* Calculate the directory size by counting the allocated
                clusters for it.  */
                i =        0;
 800a9de:	2300      	movs	r3, #0
 800a9e0:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
                cluster =  search_dir_ptr -> fx_dir_entry_cluster;
 800a9e4:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 800a9e8:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800a9ea:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
                while (cluster < media_ptr -> fx_media_fat_reserved)
 800a9ee:	e02b      	b.n	800aa48 <_fx_directory_search+0x4b2>
                {

                    /* Increment the cluster count.  */
                    i++;
 800a9f0:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 800a9f4:	3301      	adds	r3, #1
 800a9f6:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4

                    /* Read the next FAT entry.  */
                    status =  _fx_utility_FAT_entry_read(media_ptr, cluster, &next_cluster);
 800a9fa:	f107 03a0 	add.w	r3, r7, #160	@ 0xa0
 800a9fe:	461a      	mov	r2, r3
 800aa00:	f8d7 10ec 	ldr.w	r1, [r7, #236]	@ 0xec
 800aa04:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 800aa06:	f003 ffcb 	bl	800e9a0 <_fx_utility_FAT_entry_read>
 800aa0a:	f8c7 00a8 	str.w	r0, [r7, #168]	@ 0xa8

                    /* Check the return status.  */
                    if (status != FX_SUCCESS)
 800aa0e:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 800aa12:	2b00      	cmp	r3, #0
 800aa14:	d002      	beq.n	800aa1c <_fx_directory_search+0x486>
                    {

                        /* Return the bad status.  */
                        return(status);
 800aa16:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 800aa1a:	e2c5      	b.n	800afa8 <_fx_directory_search+0xa12>
                    }

                    /* Check for error situation.  */
                    if ((cluster < FX_FAT_ENTRY_START) || (cluster == next_cluster) || (i > media_ptr -> fx_media_total_clusters))
 800aa1c:	f8d7 30ec 	ldr.w	r3, [r7, #236]	@ 0xec
 800aa20:	2b01      	cmp	r3, #1
 800aa22:	d90b      	bls.n	800aa3c <_fx_directory_search+0x4a6>
 800aa24:	f8d7 20a0 	ldr.w	r2, [r7, #160]	@ 0xa0
 800aa28:	f8d7 30ec 	ldr.w	r3, [r7, #236]	@ 0xec
 800aa2c:	4293      	cmp	r3, r2
 800aa2e:	d005      	beq.n	800aa3c <_fx_directory_search+0x4a6>
 800aa30:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800aa32:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 800aa34:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 800aa38:	429a      	cmp	r2, r3
 800aa3a:	d201      	bcs.n	800aa40 <_fx_directory_search+0x4aa>
                    {

                        /* Return the bad status.  */
                        return(FX_FAT_READ_ERROR);
 800aa3c:	2303      	movs	r3, #3
 800aa3e:	e2b3      	b.n	800afa8 <_fx_directory_search+0xa12>
                    }

                    cluster = next_cluster;
 800aa40:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 800aa44:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
                while (cluster < media_ptr -> fx_media_fat_reserved)
 800aa48:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800aa4a:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 800aa4e:	f8d3 2478 	ldr.w	r2, [r3, #1144]	@ 0x478
 800aa52:	f8d7 30ec 	ldr.w	r3, [r7, #236]	@ 0xec
 800aa56:	4293      	cmp	r3, r2
 800aa58:	d3ca      	bcc.n	800a9f0 <_fx_directory_search+0x45a>
                }

                /* Now we can calculate the directory size.  */
                directory_size =  (((ULONG64) media_ptr -> fx_media_bytes_per_sector) *
 800aa5a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800aa5c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800aa5e:	2200      	movs	r2, #0
 800aa60:	469a      	mov	sl, r3
 800aa62:	4693      	mov	fp, r2
                                   ((ULONG64) media_ptr -> fx_media_sectors_per_cluster) * i)
 800aa64:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800aa66:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800aa68:	2200      	movs	r2, #0
 800aa6a:	613b      	str	r3, [r7, #16]
 800aa6c:	617a      	str	r2, [r7, #20]
                directory_size =  (((ULONG64) media_ptr -> fx_media_bytes_per_sector) *
 800aa6e:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 800aa72:	4603      	mov	r3, r0
 800aa74:	fb03 f20b 	mul.w	r2, r3, fp
 800aa78:	460b      	mov	r3, r1
 800aa7a:	fb0a f303 	mul.w	r3, sl, r3
 800aa7e:	4413      	add	r3, r2
 800aa80:	4602      	mov	r2, r0
 800aa82:	fbaa 4502 	umull	r4, r5, sl, r2
 800aa86:	442b      	add	r3, r5
 800aa88:	461d      	mov	r5, r3
                                   ((ULONG64) media_ptr -> fx_media_sectors_per_cluster) * i)
 800aa8a:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 800aa8e:	2200      	movs	r2, #0
 800aa90:	60bb      	str	r3, [r7, #8]
 800aa92:	60fa      	str	r2, [r7, #12]
 800aa94:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 800aa98:	4603      	mov	r3, r0
 800aa9a:	fb03 f205 	mul.w	r2, r3, r5
 800aa9e:	460b      	mov	r3, r1
 800aaa0:	fb04 f303 	mul.w	r3, r4, r3
 800aaa4:	4413      	add	r3, r2
 800aaa6:	4602      	mov	r2, r0
 800aaa8:	fba4 8902 	umull	r8, r9, r4, r2
 800aaac:	444b      	add	r3, r9
 800aaae:	4699      	mov	r9, r3
                directory_size =  (((ULONG64) media_ptr -> fx_media_bytes_per_sector) *
 800aab0:	f04f 0200 	mov.w	r2, #0
 800aab4:	f04f 0300 	mov.w	r3, #0
 800aab8:	ea4f 1258 	mov.w	r2, r8, lsr #5
 800aabc:	ea42 62c9 	orr.w	r2, r2, r9, lsl #27
 800aac0:	ea4f 1359 	mov.w	r3, r9, lsr #5
 800aac4:	e9c7 2338 	strd	r2, r3, [r7, #224]	@ 0xe0
                                    / (ULONG64) FX_DIR_ENTRY_SIZE;

                /* Also save this in the directory entry so we don't have to
                   calculate it later.  */
                search_dir_ptr -> fx_dir_entry_file_size =  directory_size;
 800aac8:	f8d7 10d4 	ldr.w	r1, [r7, #212]	@ 0xd4
 800aacc:	e9d7 2338 	ldrd	r2, r3, [r7, #224]	@ 0xe0
 800aad0:	e9c1 230e 	strd	r2, r3, [r1, #56]	@ 0x38
            }
#endif /* FX_ENABLE_EXFAT */

            /* If required, copy the last search directory entry into the
               destination.  */
            if (last_dir_ptr)
 800aad4:	6a3b      	ldr	r3, [r7, #32]
 800aad6:	2b00      	cmp	r3, #0
 800aad8:	d046      	beq.n	800ab68 <_fx_directory_search+0x5d2>
            {

                /* Copy the last search directory into the destination.  */

                /* First, save the name pointer from the list directory pointer.  */
                destination_name_ptr =  last_dir_ptr -> fx_dir_entry_name;
 800aada:	6a3b      	ldr	r3, [r7, #32]
 800aadc:	681b      	ldr	r3, [r3, #0]
 800aade:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0

                /* Copy the entire directory entry structure.  */
                *last_dir_ptr =  *search_dir_ptr;
 800aae2:	6a3a      	ldr	r2, [r7, #32]
 800aae4:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 800aae8:	4610      	mov	r0, r2
 800aaea:	4619      	mov	r1, r3
 800aaec:	2370      	movs	r3, #112	@ 0x70
 800aaee:	461a      	mov	r2, r3
 800aaf0:	f006 fb2b 	bl	801114a <memcpy>

                /* Restore the original name buffer pointer.  */
                last_dir_ptr -> fx_dir_entry_name =  destination_name_ptr;
 800aaf4:	6a3a      	ldr	r2, [r7, #32]
 800aaf6:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 800aafa:	6013      	str	r3, [r2, #0]

                /* Pickup pointer to name to copy.  */
                source_name_ptr =  search_dir_ptr -> fx_dir_entry_name;
 800aafc:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 800ab00:	681b      	ldr	r3, [r3, #0]
 800ab02:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac

                /* Loop to copy the name into the last directory name buffer.  */
                for (n = 0; n < FX_MAX_LONG_NAME_LEN; n++)
 800ab06:	2300      	movs	r3, #0
 800ab08:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
 800ab0c:	e01c      	b.n	800ab48 <_fx_directory_search+0x5b2>
                {

                    /* Copy a character.  */
                    destination_name_ptr[n] =  source_name_ptr[n];
 800ab0e:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
 800ab12:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 800ab16:	18d1      	adds	r1, r2, r3
 800ab18:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 800ab1c:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 800ab20:	441a      	add	r2, r3
 800ab22:	780b      	ldrb	r3, [r1, #0]
 800ab24:	7013      	strb	r3, [r2, #0]

                    /* See if we have copied the NULL termination character.  */
                    if (source_name_ptr[n] == (CHAR) FX_NULL)
 800ab26:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
 800ab2a:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 800ab2e:	4413      	add	r3, r2
 800ab30:	781b      	ldrb	r3, [r3, #0]
 800ab32:	2b00      	cmp	r3, #0
 800ab34:	d103      	bne.n	800ab3e <_fx_directory_search+0x5a8>
                    {
                
                        /* Determine if we should break here or at the top of the loop.  */
                        if (n < (FX_MAX_LONG_NAME_LEN - 1))
 800ab36:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 800ab3a:	2bfe      	cmp	r3, #254	@ 0xfe
 800ab3c:	d913      	bls.n	800ab66 <_fx_directory_search+0x5d0>
                for (n = 0; n < FX_MAX_LONG_NAME_LEN; n++)
 800ab3e:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 800ab42:	3301      	adds	r3, #1
 800ab44:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
 800ab48:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 800ab4c:	2bff      	cmp	r3, #255	@ 0xff
 800ab4e:	d9de      	bls.n	800ab0e <_fx_directory_search+0x578>
 800ab50:	e00a      	b.n	800ab68 <_fx_directory_search+0x5d2>
        }
        else
        {

            /* Directory size is the number of entries in the root directory.  */
            directory_size =  (ULONG)media_ptr -> fx_media_root_directory_entries;
 800ab52:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800ab54:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 800ab56:	2200      	movs	r2, #0
 800ab58:	603b      	str	r3, [r7, #0]
 800ab5a:	607a      	str	r2, [r7, #4]
 800ab5c:	e9d7 2300 	ldrd	r2, r3, [r7]
 800ab60:	e9c7 2338 	strd	r2, r3, [r7, #224]	@ 0xe0
 800ab64:	e000      	b.n	800ab68 <_fx_directory_search+0x5d2>
                            break;
 800ab66:	bf00      	nop
        }

        /* Loop through entries in the directory.  Yes, this is a
           linear search!  */
        i =      0;
 800ab68:	2300      	movs	r3, #0
 800ab6a:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
        found =  FX_FALSE;
 800ab6e:	2300      	movs	r3, #0
 800ab70:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8

            /* Read an entry from the directory.  */
#ifdef FX_ENABLE_EXFAT
            status =  _fx_directory_entry_read_ex(media_ptr, search_dir_ptr, &i, entry_ptr, hash);
#else
            status =  _fx_directory_entry_read(media_ptr, search_dir_ptr, &i, entry_ptr);
 800ab74:	f107 02a4 	add.w	r2, r7, #164	@ 0xa4
 800ab78:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800ab7a:	f8d7 10d4 	ldr.w	r1, [r7, #212]	@ 0xd4
 800ab7e:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 800ab80:	f7fd fefe 	bl	8008980 <_fx_directory_entry_read>
 800ab84:	f8c7 00a8 	str.w	r0, [r7, #168]	@ 0xa8
#endif /* FX_ENABLE_EXFAT */

            i++;
 800ab88:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 800ab8c:	3301      	adds	r3, #1
 800ab8e:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4

            /* Check for error status.  */
            if (status != FX_SUCCESS)
 800ab92:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 800ab96:	2b00      	cmp	r3, #0
 800ab98:	d002      	beq.n	800aba0 <_fx_directory_search+0x60a>
            {
                return(status);
 800ab9a:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 800ab9e:	e203      	b.n	800afa8 <_fx_directory_search+0xa12>

            /* Determine if this is the last directory entry.  */
#ifdef FX_ENABLE_EXFAT
            if (entry_ptr -> fx_dir_entry_type == FX_EXFAT_DIR_ENTRY_TYPE_END_MARKER)
#else
            if ((UCHAR)entry_ptr -> fx_dir_entry_name[0] == (UCHAR)FX_DIR_ENTRY_DONE)
 800aba0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800aba2:	681b      	ldr	r3, [r3, #0]
 800aba4:	781b      	ldrb	r3, [r3, #0]
 800aba6:	2b00      	cmp	r3, #0
 800aba8:	f000 80c6 	beq.w	800ad38 <_fx_directory_search+0x7a2>
            {
                break;
            }

            /* Determine if the entry is a volume label entry */
            if ((entry_ptr -> fx_dir_entry_attributes & FX_VOLUME))
 800abac:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800abae:	7f1b      	ldrb	r3, [r3, #28]
 800abb0:	f003 0308 	and.w	r3, r3, #8
 800abb4:	2b00      	cmp	r3, #0
 800abb6:	f040 80a9 	bne.w	800ad0c <_fx_directory_search+0x776>

            /* Determine if this is an empty entry.  */
#ifdef FX_ENABLE_EXFAT
            if (entry_ptr -> fx_dir_entry_type != FX_EXFAT_DIR_ENTRY_TYPE_FILE_DIRECTORY)
#else
            if (((UCHAR)entry_ptr -> fx_dir_entry_name[0] == (UCHAR)FX_DIR_ENTRY_FREE) && (entry_ptr -> fx_dir_entry_short_name[0] == 0))
 800abba:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800abbc:	681b      	ldr	r3, [r3, #0]
 800abbe:	781b      	ldrb	r3, [r3, #0]
 800abc0:	2be5      	cmp	r3, #229	@ 0xe5
 800abc2:	d104      	bne.n	800abce <_fx_directory_search+0x638>
 800abc4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800abc6:	791b      	ldrb	r3, [r3, #4]
 800abc8:	2b00      	cmp	r3, #0
 800abca:	f000 80a1 	beq.w	800ad10 <_fx_directory_search+0x77a>
                continue;
            }

            /* Compare the input name and extension with the directory
               entry.  */
            work_ptr =      &name[0];
 800abce:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 800abd2:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
            dir_name_ptr =  &(entry_ptr -> fx_dir_entry_name[0]);
 800abd6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800abd8:	681b      	ldr	r3, [r3, #0]
 800abda:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
            /* Loop to compare names.  */
            do
            {

                /* Pickup character of directory name.  */
                alpha =  *dir_name_ptr;
 800abde:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 800abe2:	781b      	ldrb	r3, [r3, #0]
 800abe4:	f887 30d3 	strb.w	r3, [r7, #211]	@ 0xd3

                /* Pickup character of name.  */
                name_alpha =  *work_ptr;
 800abe8:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 800abec:	781b      	ldrb	r3, [r3, #0]
 800abee:	f887 30d2 	strb.w	r3, [r7, #210]	@ 0xd2

                /* Determine if its case needs to be changed.  */
                if ((alpha >= 'a') && (alpha <= 'z'))
 800abf2:	f897 30d3 	ldrb.w	r3, [r7, #211]	@ 0xd3
 800abf6:	2b60      	cmp	r3, #96	@ 0x60
 800abf8:	d908      	bls.n	800ac0c <_fx_directory_search+0x676>
 800abfa:	f897 30d3 	ldrb.w	r3, [r7, #211]	@ 0xd3
 800abfe:	2b7a      	cmp	r3, #122	@ 0x7a
 800ac00:	d804      	bhi.n	800ac0c <_fx_directory_search+0x676>
                {

                    /* Yes, make upper case.  */
                    alpha =  (CHAR)((INT)alpha - 0x20);
 800ac02:	f897 30d3 	ldrb.w	r3, [r7, #211]	@ 0xd3
 800ac06:	3b20      	subs	r3, #32
 800ac08:	f887 30d3 	strb.w	r3, [r7, #211]	@ 0xd3
                }

                /* Determine if its case needs to be changed.  */
                if ((name_alpha >= 'a') && (name_alpha <= 'z'))
 800ac0c:	f897 30d2 	ldrb.w	r3, [r7, #210]	@ 0xd2
 800ac10:	2b60      	cmp	r3, #96	@ 0x60
 800ac12:	d908      	bls.n	800ac26 <_fx_directory_search+0x690>
 800ac14:	f897 30d2 	ldrb.w	r3, [r7, #210]	@ 0xd2
 800ac18:	2b7a      	cmp	r3, #122	@ 0x7a
 800ac1a:	d804      	bhi.n	800ac26 <_fx_directory_search+0x690>
                {

                    /* Yes, make upper case.  */
                    name_alpha =  (CHAR)((INT)name_alpha - 0x20);
 800ac1c:	f897 30d2 	ldrb.w	r3, [r7, #210]	@ 0xd2
 800ac20:	3b20      	subs	r3, #32
 800ac22:	f887 30d2 	strb.w	r3, [r7, #210]	@ 0xd2
                }

                /* Compare name with directory name.  */
                if (alpha != name_alpha)
 800ac26:	f897 20d3 	ldrb.w	r2, [r7, #211]	@ 0xd3
 800ac2a:	f897 30d2 	ldrb.w	r3, [r7, #210]	@ 0xd2
 800ac2e:	429a      	cmp	r2, r3
 800ac30:	d10f      	bne.n	800ac52 <_fx_directory_search+0x6bc>
                    /* The names don't match, get out of the loop. */
                    break;
                }

                /* Otherwise, increment the name pointers.  */
                work_ptr++;
 800ac32:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 800ac36:	3301      	adds	r3, #1
 800ac38:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
                dir_name_ptr++;
 800ac3c:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 800ac40:	3301      	adds	r3, #1
 800ac42:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
            } while (*dir_name_ptr);
 800ac46:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 800ac4a:	781b      	ldrb	r3, [r3, #0]
 800ac4c:	2b00      	cmp	r3, #0
 800ac4e:	d1c6      	bne.n	800abde <_fx_directory_search+0x648>
 800ac50:	e000      	b.n	800ac54 <_fx_directory_search+0x6be>
                    break;
 800ac52:	bf00      	nop

            /* Determine if the requested name has been found.  If so,
               return success to the caller.  */
            if ((*dir_name_ptr == 0) && (*work_ptr == *dir_name_ptr))
 800ac54:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 800ac58:	781b      	ldrb	r3, [r3, #0]
 800ac5a:	2b00      	cmp	r3, #0
 800ac5c:	d10b      	bne.n	800ac76 <_fx_directory_search+0x6e0>
 800ac5e:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 800ac62:	781a      	ldrb	r2, [r3, #0]
 800ac64:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 800ac68:	781b      	ldrb	r3, [r3, #0]
 800ac6a:	429a      	cmp	r2, r3
 800ac6c:	d103      	bne.n	800ac76 <_fx_directory_search+0x6e0>
            {

                /* Yes, the name was located.  All pertinent directory
                   information is in the directory entry field.  */
                found =  FX_TRUE;
 800ac6e:	2301      	movs	r3, #1
 800ac70:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
 800ac74:	e04d      	b.n	800ad12 <_fx_directory_search+0x77c>
            /* Determine if there is a short name to check.  */
#ifdef FX_ENABLE_EXFAT
            else if ((media_ptr -> fx_media_FAT_type != FX_exFAT) &&
                     (entry_ptr -> fx_dir_entry_short_name[0] != 0))
#else
            else if (entry_ptr -> fx_dir_entry_short_name[0] != 0)
 800ac76:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800ac78:	791b      	ldrb	r3, [r3, #4]
 800ac7a:	2b00      	cmp	r3, #0
 800ac7c:	d049      	beq.n	800ad12 <_fx_directory_search+0x77c>
            {

                /* Yes, check for the short part of the name.  */

                /* Compare the input name and extension with the directory entry.  */
                work_ptr =      &name[0];
 800ac7e:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 800ac82:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
                dir_name_ptr =  &(entry_ptr -> fx_dir_entry_short_name[0]);
 800ac86:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800ac88:	3304      	adds	r3, #4
 800ac8a:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
                /* Loop to compare names.  */
                do
                {

                    /* Pickup character of directory name.  */
                    alpha =  *dir_name_ptr;
 800ac8e:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 800ac92:	781b      	ldrb	r3, [r3, #0]
 800ac94:	f887 30d3 	strb.w	r3, [r7, #211]	@ 0xd3

                    /* Pickup character of name.  */
                    name_alpha =  *work_ptr;
 800ac98:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 800ac9c:	781b      	ldrb	r3, [r3, #0]
 800ac9e:	f887 30d2 	strb.w	r3, [r7, #210]	@ 0xd2

                    /* Determine if its case needs to be changed.  */
                    if ((name_alpha >= 'a') && (name_alpha <= 'z'))
 800aca2:	f897 30d2 	ldrb.w	r3, [r7, #210]	@ 0xd2
 800aca6:	2b60      	cmp	r3, #96	@ 0x60
 800aca8:	d908      	bls.n	800acbc <_fx_directory_search+0x726>
 800acaa:	f897 30d2 	ldrb.w	r3, [r7, #210]	@ 0xd2
 800acae:	2b7a      	cmp	r3, #122	@ 0x7a
 800acb0:	d804      	bhi.n	800acbc <_fx_directory_search+0x726>
                    {

                        /* Yes, make upper case.  */
                        name_alpha =  (CHAR)((INT)name_alpha - 0x20);
 800acb2:	f897 30d2 	ldrb.w	r3, [r7, #210]	@ 0xd2
 800acb6:	3b20      	subs	r3, #32
 800acb8:	f887 30d2 	strb.w	r3, [r7, #210]	@ 0xd2
                    }

                    /* Compare name with directory name.  */
                    if (alpha != name_alpha)
 800acbc:	f897 20d3 	ldrb.w	r2, [r7, #211]	@ 0xd3
 800acc0:	f897 30d2 	ldrb.w	r3, [r7, #210]	@ 0xd2
 800acc4:	429a      	cmp	r2, r3
 800acc6:	d10f      	bne.n	800ace8 <_fx_directory_search+0x752>
                        break;
                    }

                    /* Otherwise, move the name pointers and increment the
                       count.  */
                    work_ptr++;
 800acc8:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 800accc:	3301      	adds	r3, #1
 800acce:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
                    dir_name_ptr++;
 800acd2:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 800acd6:	3301      	adds	r3, #1
 800acd8:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
                } while (*dir_name_ptr);
 800acdc:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 800ace0:	781b      	ldrb	r3, [r3, #0]
 800ace2:	2b00      	cmp	r3, #0
 800ace4:	d1d3      	bne.n	800ac8e <_fx_directory_search+0x6f8>
 800ace6:	e000      	b.n	800acea <_fx_directory_search+0x754>
                        break;
 800ace8:	bf00      	nop

                /* Determine if the names match.  */
                if ((*dir_name_ptr == 0) && (*work_ptr == *dir_name_ptr))
 800acea:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 800acee:	781b      	ldrb	r3, [r3, #0]
 800acf0:	2b00      	cmp	r3, #0
 800acf2:	d10e      	bne.n	800ad12 <_fx_directory_search+0x77c>
 800acf4:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 800acf8:	781a      	ldrb	r2, [r3, #0]
 800acfa:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 800acfe:	781b      	ldrb	r3, [r3, #0]
 800ad00:	429a      	cmp	r2, r3
 800ad02:	d106      	bne.n	800ad12 <_fx_directory_search+0x77c>
                {

                    /* Yes, the name was located.  All pertinent directory
                        information is in the directory entry field.  */
                    found =  FX_TRUE;
 800ad04:	2301      	movs	r3, #1
 800ad06:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
 800ad0a:	e002      	b.n	800ad12 <_fx_directory_search+0x77c>
                continue;
 800ad0c:	bf00      	nop
 800ad0e:	e000      	b.n	800ad12 <_fx_directory_search+0x77c>
                continue;
 800ad10:	bf00      	nop
                }
            }
        } while ((i < directory_size) && (!found));
 800ad12:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 800ad16:	2200      	movs	r2, #0
 800ad18:	61bb      	str	r3, [r7, #24]
 800ad1a:	61fa      	str	r2, [r7, #28]
 800ad1c:	e9d7 2338 	ldrd	r2, r3, [r7, #224]	@ 0xe0
 800ad20:	69b9      	ldr	r1, [r7, #24]
 800ad22:	4291      	cmp	r1, r2
 800ad24:	69f9      	ldr	r1, [r7, #28]
 800ad26:	eb71 0303 	sbcs.w	r3, r1, r3
 800ad2a:	d206      	bcs.n	800ad3a <_fx_directory_search+0x7a4>
 800ad2c:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 800ad30:	2b00      	cmp	r3, #0
 800ad32:	f43f af1f 	beq.w	800ab74 <_fx_directory_search+0x5de>
 800ad36:	e000      	b.n	800ad3a <_fx_directory_search+0x7a4>
                break;
 800ad38:	bf00      	nop

        /* Now determine if we have a match.  */
        if (!found)
 800ad3a:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 800ad3e:	2b00      	cmp	r3, #0
 800ad40:	d101      	bne.n	800ad46 <_fx_directory_search+0x7b0>
        {

            /* Return a "not found" status to the caller.  */
            return(FX_NOT_FOUND);
 800ad42:	2304      	movs	r3, #4
 800ad44:	e130      	b.n	800afa8 <_fx_directory_search+0xa12>
        }

        /* Determine if the found entry is indeed a sub-directory.  */
        if (entry_ptr -> fx_dir_entry_attributes & FX_DIRECTORY)
 800ad46:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800ad48:	7f1b      	ldrb	r3, [r3, #28]
 800ad4a:	f003 0310 	and.w	r3, r3, #16
 800ad4e:	2b00      	cmp	r3, #0
 800ad50:	d04f      	beq.n	800adf2 <_fx_directory_search+0x85c>
        {

            /* Move the directory search pointer to this entry.  */
            search_dir =      *entry_ptr;
 800ad52:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800ad54:	f107 0030 	add.w	r0, r7, #48	@ 0x30
 800ad58:	4619      	mov	r1, r3
 800ad5a:	2370      	movs	r3, #112	@ 0x70
 800ad5c:	461a      	mov	r2, r3
 800ad5e:	f006 f9f4 	bl	801114a <memcpy>
            search_dir_ptr =  &search_dir;
 800ad62:	f107 0330 	add.w	r3, r7, #48	@ 0x30
 800ad66:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4

            /* Ensure that the search directory's last search cluster is cleared.  */
            search_dir_ptr -> fx_dir_entry_last_search_cluster =  0;
 800ad6a:	f8d7 20d4 	ldr.w	r2, [r7, #212]	@ 0xd4
 800ad6e:	2300      	movs	r3, #0
 800ad70:	6513      	str	r3, [r2, #80]	@ 0x50
               directory.  */
#ifdef FX_ENABLE_EXFAT
            if ((!search_dir_ptr -> fx_dir_entry_cluster)
                && (media_ptr -> fx_media_FAT_type != FX_exFAT))
#else
            if (!search_dir_ptr -> fx_dir_entry_cluster)
 800ad72:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 800ad76:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800ad78:	2b00      	cmp	r3, #0
 800ad7a:	d13f      	bne.n	800adfc <_fx_directory_search+0x866>
            {

                /* This is a backward link to the root directory.  Make
                   sure this is indicated in the search directory
                   information.  */
                search_dir_ptr -> fx_dir_entry_name[0] =  0;
 800ad7c:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 800ad80:	681a      	ldr	r2, [r3, #0]
 800ad82:	2300      	movs	r3, #0
 800ad84:	7013      	strb	r3, [r2, #0]

                /* Determine if we need to remember this in the last
                   directory searched return area.  */
                if (last_dir_ptr)
 800ad86:	6a3b      	ldr	r3, [r7, #32]
 800ad88:	2b00      	cmp	r3, #0
 800ad8a:	d02e      	beq.n	800adea <_fx_directory_search+0x854>
                {

                    /* Yes, return this value to the caller.  */

                    /* First, save the name pointer from the list directory pointer.  */
                    destination_name_ptr =  last_dir_ptr -> fx_dir_entry_name;
 800ad8c:	6a3b      	ldr	r3, [r7, #32]
 800ad8e:	681b      	ldr	r3, [r3, #0]
 800ad90:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0

                    /* Copy the entire directory entry structure.  */
                    *last_dir_ptr =  *search_dir_ptr;
 800ad94:	6a3a      	ldr	r2, [r7, #32]
 800ad96:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 800ad9a:	4610      	mov	r0, r2
 800ad9c:	4619      	mov	r1, r3
 800ad9e:	2370      	movs	r3, #112	@ 0x70
 800ada0:	461a      	mov	r2, r3
 800ada2:	f006 f9d2 	bl	801114a <memcpy>

                    /* Restore the original name buffer pointer.  */
                    last_dir_ptr -> fx_dir_entry_name =  destination_name_ptr;
 800ada6:	6a3a      	ldr	r2, [r7, #32]
 800ada8:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 800adac:	6013      	str	r3, [r2, #0]

                    /* Pickup pointer to name to copy.  */
                    source_name_ptr =  search_dir_ptr -> fx_dir_entry_name;
 800adae:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 800adb2:	681b      	ldr	r3, [r3, #0]
 800adb4:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac

                    /* Loop to copy the name into the last directory name buffer.  */
                    for (n = 0; n < FX_MAX_LONG_NAME_LEN; n++)
 800adb8:	2300      	movs	r3, #0
 800adba:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
 800adbe:	e010      	b.n	800ade2 <_fx_directory_search+0x84c>
                    {

                        /* Copy a character.  */
                        destination_name_ptr[n] =  source_name_ptr[n];
 800adc0:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
 800adc4:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 800adc8:	18d1      	adds	r1, r2, r3
 800adca:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 800adce:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 800add2:	441a      	add	r2, r3
 800add4:	780b      	ldrb	r3, [r1, #0]
 800add6:	7013      	strb	r3, [r2, #0]
                    for (n = 0; n < FX_MAX_LONG_NAME_LEN; n++)
 800add8:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 800addc:	3301      	adds	r3, #1
 800adde:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
 800ade2:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 800ade6:	2bff      	cmp	r3, #255	@ 0xff
 800ade8:	d9ea      	bls.n	800adc0 <_fx_directory_search+0x82a>
                    }
                }

                /* Set the search directory pointer to NULL to indicate
                   we are at the root directory.  */
                search_dir_ptr =  FX_NULL;
 800adea:	2300      	movs	r3, #0
 800adec:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
 800adf0:	e004      	b.n	800adfc <_fx_directory_search+0x866>
        else
        {

            /* This is not a directory, we better return not found
               since we can't continue the search.  */
            if (name_ptr)
 800adf2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800adf4:	2b00      	cmp	r3, #0
 800adf6:	d001      	beq.n	800adfc <_fx_directory_search+0x866>
            {

                /* Return not-found status to caller.  */
                return(FX_NOT_FOUND);
 800adf8:	2304      	movs	r3, #4
 800adfa:	e0d5      	b.n	800afa8 <_fx_directory_search+0xa12>
            }
        }
    } while (name_ptr);
 800adfc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800adfe:	2b00      	cmp	r3, #0
 800ae00:	f47f add6 	bne.w	800a9b0 <_fx_directory_search+0x41a>

    /* At this point, cache the found information.  If a subsequent search for the same name is done,
       it will return immediately.  */

    /* Set the index of the saved name string.  */
    v=  0;
 800ae04:	2300      	movs	r3, #0
 800ae06:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4

    /* First, build the full path and name.  */
    if ((*original_name != '\\') && (*original_name != '/') && (path_ptr))
 800ae0a:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 800ae0e:	781b      	ldrb	r3, [r3, #0]
 800ae10:	2b5c      	cmp	r3, #92	@ 0x5c
 800ae12:	d028      	beq.n	800ae66 <_fx_directory_search+0x8d0>
 800ae14:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 800ae18:	781b      	ldrb	r3, [r3, #0]
 800ae1a:	2b2f      	cmp	r3, #47	@ 0x2f
 800ae1c:	d023      	beq.n	800ae66 <_fx_directory_search+0x8d0>
 800ae1e:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 800ae22:	2b00      	cmp	r3, #0
 800ae24:	d01f      	beq.n	800ae66 <_fx_directory_search+0x8d0>
    {

        /* Copy the path into the destination.  */
        while ((v< (FX_MAX_LAST_NAME_LEN - 1)) && (path_ptr[v]))
 800ae26:	e012      	b.n	800ae4e <_fx_directory_search+0x8b8>
        {

            /* Copy one character.   */
            media_ptr -> fx_media_last_found_name[v] =  path_ptr[v];
 800ae28:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
 800ae2c:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800ae30:	4413      	add	r3, r2
 800ae32:	7819      	ldrb	r1, [r3, #0]
 800ae34:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800ae36:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800ae3a:	4413      	add	r3, r2
 800ae3c:	f503 736c 	add.w	r3, r3, #944	@ 0x3b0
 800ae40:	460a      	mov	r2, r1
 800ae42:	701a      	strb	r2, [r3, #0]

            /* Move to next character.  */
            v++;
 800ae44:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800ae48:	3301      	adds	r3, #1
 800ae4a:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
        while ((v< (FX_MAX_LAST_NAME_LEN - 1)) && (path_ptr[v]))
 800ae4e:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800ae52:	2bfe      	cmp	r3, #254	@ 0xfe
 800ae54:	d807      	bhi.n	800ae66 <_fx_directory_search+0x8d0>
 800ae56:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
 800ae5a:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800ae5e:	4413      	add	r3, r2
 800ae60:	781b      	ldrb	r3, [r3, #0]
 800ae62:	2b00      	cmp	r3, #0
 800ae64:	d1e0      	bne.n	800ae28 <_fx_directory_search+0x892>
        }
    }

    /* Now see if there is no directory path symbol in the name itself.  */
    if ((*original_name != '\\') && (*original_name != '/'))
 800ae66:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 800ae6a:	781b      	ldrb	r3, [r3, #0]
 800ae6c:	2b5c      	cmp	r3, #92	@ 0x5c
 800ae6e:	d012      	beq.n	800ae96 <_fx_directory_search+0x900>
 800ae70:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 800ae74:	781b      	ldrb	r3, [r3, #0]
 800ae76:	2b2f      	cmp	r3, #47	@ 0x2f
 800ae78:	d00d      	beq.n	800ae96 <_fx_directory_search+0x900>
    {

        /* If there is room, place a directory separator character.  */
        if (v < (FX_MAX_LAST_NAME_LEN - 1))
 800ae7a:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800ae7e:	2bfe      	cmp	r3, #254	@ 0xfe
 800ae80:	d809      	bhi.n	800ae96 <_fx_directory_search+0x900>
        {
            media_ptr -> fx_media_last_found_name[v++] =  '/';
 800ae82:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800ae86:	1c5a      	adds	r2, r3, #1
 800ae88:	f8c7 20f4 	str.w	r2, [r7, #244]	@ 0xf4
 800ae8c:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800ae8e:	4413      	add	r3, r2
 800ae90:	222f      	movs	r2, #47	@ 0x2f
 800ae92:	f883 23b0 	strb.w	r2, [r3, #944]	@ 0x3b0
        }
    }

    /* Now append the name to the path.  */
    j =  0;
 800ae96:	2300      	movs	r3, #0
 800ae98:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
    while ((v < FX_MAX_LAST_NAME_LEN) && (original_name[j]))
 800ae9c:	e017      	b.n	800aece <_fx_directory_search+0x938>
    {

        /* Copy one character.   */
        media_ptr -> fx_media_last_found_name[v] =  original_name[j];
 800ae9e:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 800aea2:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 800aea6:	4413      	add	r3, r2
 800aea8:	7819      	ldrb	r1, [r3, #0]
 800aeaa:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800aeac:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800aeb0:	4413      	add	r3, r2
 800aeb2:	f503 736c 	add.w	r3, r3, #944	@ 0x3b0
 800aeb6:	460a      	mov	r2, r1
 800aeb8:	701a      	strb	r2, [r3, #0]

        /* Move to next character.  */
        v++;
 800aeba:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800aebe:	3301      	adds	r3, #1
 800aec0:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
        j++;
 800aec4:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 800aec8:	3301      	adds	r3, #1
 800aeca:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
    while ((v < FX_MAX_LAST_NAME_LEN) && (original_name[j]))
 800aece:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800aed2:	2bff      	cmp	r3, #255	@ 0xff
 800aed4:	d807      	bhi.n	800aee6 <_fx_directory_search+0x950>
 800aed6:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 800aeda:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 800aede:	4413      	add	r3, r2
 800aee0:	781b      	ldrb	r3, [r3, #0]
 800aee2:	2b00      	cmp	r3, #0
 800aee4:	d1db      	bne.n	800ae9e <_fx_directory_search+0x908>
    }

    /* Null terminate the last name string.   */
    if (v< FX_MAX_LAST_NAME_LEN)
 800aee6:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800aeea:	2bff      	cmp	r3, #255	@ 0xff
 800aeec:	d808      	bhi.n	800af00 <_fx_directory_search+0x96a>
    {

        /* Null terminate.  */
        media_ptr -> fx_media_last_found_name[v] =  FX_NULL;
 800aeee:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800aef0:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800aef4:	4413      	add	r3, r2
 800aef6:	f503 736c 	add.w	r3, r3, #944	@ 0x3b0
 800aefa:	2200      	movs	r2, #0
 800aefc:	701a      	strb	r2, [r3, #0]
 800aefe:	e003      	b.n	800af08 <_fx_directory_search+0x972>
    }
    else
    {

        /* The string is too big, NULL the string so it won't be used in searching.  */
        media_ptr -> fx_media_last_found_name[0] =  FX_NULL;
 800af00:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800af02:	2200      	movs	r2, #0
 800af04:	f883 23b0 	strb.w	r2, [r3, #944]	@ 0x3b0
    }

    /* Determine if there is a search pointer.  */
    if (search_dir_ptr)
 800af08:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 800af0c:	2b00      	cmp	r3, #0
 800af0e:	d00e      	beq.n	800af2e <_fx_directory_search+0x998>
    {

        /* Yes, there is a search directory pointer so save it!   */
        media_ptr -> fx_media_last_found_directory =  *search_dir_ptr;
 800af10:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800af12:	f8d7 20d4 	ldr.w	r2, [r7, #212]	@ 0xd4
 800af16:	f503 73e8 	add.w	r3, r3, #464	@ 0x1d0
 800af1a:	4611      	mov	r1, r2
 800af1c:	2270      	movs	r2, #112	@ 0x70
 800af1e:	4618      	mov	r0, r3
 800af20:	f006 f913 	bl	801114a <memcpy>

        /* Indicate the search directory is valid.  */
        media_ptr -> fx_media_last_found_directory_valid =  FX_TRUE;
 800af24:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800af26:	2201      	movs	r2, #1
 800af28:	f8c3 21c8 	str.w	r2, [r3, #456]	@ 0x1c8
 800af2c:	e003      	b.n	800af36 <_fx_directory_search+0x9a0>
    }
    else
    {

        /* Indicate the search directory is not valid.  */
        media_ptr -> fx_media_last_found_directory_valid =  FX_FALSE;
 800af2e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800af30:	2200      	movs	r2, #0
 800af32:	f8c3 21c8 	str.w	r2, [r3, #456]	@ 0x1c8
    }

    /* Copy the directory entry.  */
    media_ptr -> fx_media_last_found_entry =  *entry_ptr;
 800af36:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800af38:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800af3a:	f503 7310 	add.w	r3, r3, #576	@ 0x240
 800af3e:	4611      	mov	r1, r2
 800af40:	2270      	movs	r2, #112	@ 0x70
 800af42:	4618      	mov	r0, r3
 800af44:	f006 f901 	bl	801114a <memcpy>

    /* Setup the directory entry for the last found internal file name.  */
    media_ptr -> fx_media_last_found_entry.fx_dir_entry_name =  media_ptr -> fx_media_last_found_file_name;
 800af48:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800af4a:	f503 722c 	add.w	r2, r3, #688	@ 0x2b0
 800af4e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800af50:	f8c3 2240 	str.w	r2, [r3, #576]	@ 0x240

    /* Copy the actual directory name into the cached directory name.  */
    for (index = 0; index < FX_MAX_LONG_NAME_LEN; index++)
 800af54:	2300      	movs	r3, #0
 800af56:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
 800af5a:	e01e      	b.n	800af9a <_fx_directory_search+0xa04>
    {

        /* Copy character into the cached directory name.  */
        media_ptr -> fx_media_last_found_file_name[index] =  entry_ptr ->  fx_dir_entry_name[index];
 800af5c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800af5e:	681a      	ldr	r2, [r3, #0]
 800af60:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 800af64:	4413      	add	r3, r2
 800af66:	7819      	ldrb	r1, [r3, #0]
 800af68:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800af6a:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 800af6e:	4413      	add	r3, r2
 800af70:	f503 732c 	add.w	r3, r3, #688	@ 0x2b0
 800af74:	460a      	mov	r2, r1
 800af76:	701a      	strb	r2, [r3, #0]

        /* See if we have copied the NULL termination character.  */
        if (entry_ptr -> fx_dir_entry_name[index] == (CHAR)FX_NULL)
 800af78:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800af7a:	681a      	ldr	r2, [r3, #0]
 800af7c:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 800af80:	4413      	add	r3, r2
 800af82:	781b      	ldrb	r3, [r3, #0]
 800af84:	2b00      	cmp	r3, #0
 800af86:	d103      	bne.n	800af90 <_fx_directory_search+0x9fa>
        {
                
            /* Check to see if we use the break to get out of the loop.  */
            if (index < (FX_MAX_LONG_NAME_LEN - 1))
 800af88:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 800af8c:	2bfe      	cmp	r3, #254	@ 0xfe
 800af8e:	d909      	bls.n	800afa4 <_fx_directory_search+0xa0e>
    for (index = 0; index < FX_MAX_LONG_NAME_LEN; index++)
 800af90:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 800af94:	3301      	adds	r3, #1
 800af96:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
 800af9a:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 800af9e:	2bff      	cmp	r3, #255	@ 0xff
 800afa0:	d9dc      	bls.n	800af5c <_fx_directory_search+0x9c6>
 800afa2:	e000      	b.n	800afa6 <_fx_directory_search+0xa10>
            {
                    
                /* Yes, not at the end of the string, break.  */
                break;
 800afa4:	bf00      	nop
            }
        }
    }
#endif

    return(FX_SUCCESS);
 800afa6:	2300      	movs	r3, #0
}
 800afa8:	4618      	mov	r0, r3
 800afaa:	f507 7780 	add.w	r7, r7, #256	@ 0x100
 800afae:	46bd      	mov	sp, r7
 800afb0:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

0800afb4 <_fx_file_close>:
/*  09-30-2020     William E. Lamie         Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _fx_file_close(FX_FILE *file_ptr)
{
 800afb4:	b580      	push	{r7, lr}
 800afb6:	b084      	sub	sp, #16
 800afb8:	af00      	add	r7, sp, #0
 800afba:	6078      	str	r0, [r7, #4]
FX_MEDIA *media_ptr;
FX_INT_SAVE_AREA


    /* First, determine if the file is still open.  */
    if (file_ptr -> fx_file_id != FX_FILE_ID)
 800afbc:	687b      	ldr	r3, [r7, #4]
 800afbe:	681b      	ldr	r3, [r3, #0]
 800afc0:	4a32      	ldr	r2, [pc, #200]	@ (800b08c <_fx_file_close+0xd8>)
 800afc2:	4293      	cmp	r3, r2
 800afc4:	d001      	beq.n	800afca <_fx_file_close+0x16>
    {

        /* Return the file not open error status.  */
        return(FX_NOT_OPEN);
 800afc6:	2307      	movs	r3, #7
 800afc8:	e05c      	b.n	800b084 <_fx_file_close+0xd0>
    }

    /* Setup a pointer to the associated media.  */
    media_ptr =  file_ptr -> fx_file_media_ptr;
 800afca:	687b      	ldr	r3, [r7, #4]
 800afcc:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800afce:	60fb      	str	r3, [r7, #12]

#ifndef FX_MEDIA_STATISTICS_DISABLE

    /* Increment the number of times this service has been called.  */
    media_ptr -> fx_media_file_closes++;
 800afd0:	68fb      	ldr	r3, [r7, #12]
 800afd2:	f8d3 312c 	ldr.w	r3, [r3, #300]	@ 0x12c
 800afd6:	1c5a      	adds	r2, r3, #1
 800afd8:	68fb      	ldr	r3, [r7, #12]
 800afda:	f8c3 212c 	str.w	r2, [r3, #300]	@ 0x12c
    FX_TRACE_OBJECT_UNREGISTER(file_ptr)

    /* Remove this file from the opened list for the media.  */

    /* See if the file is the only one on the open list for this media.  */
    if (file_ptr == file_ptr -> fx_file_opened_next)
 800afde:	687b      	ldr	r3, [r7, #4]
 800afe0:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800afe2:	687a      	ldr	r2, [r7, #4]
 800afe4:	429a      	cmp	r2, r3
 800afe6:	d104      	bne.n	800aff2 <_fx_file_close+0x3e>
    {

        /* Only opened file, just set the opened list to NULL.  */
        media_ptr -> fx_media_opened_file_list =  FX_NULL;
 800afe8:	68fb      	ldr	r3, [r7, #12]
 800afea:	2200      	movs	r2, #0
 800afec:	f8c3 20c8 	str.w	r2, [r3, #200]	@ 0xc8
 800aff0:	e014      	b.n	800b01c <_fx_file_close+0x68>
    }
    else
    {

        /* Otherwise, not the only opened file, link-up the neighbors.  */
        (file_ptr -> fx_file_opened_next) -> fx_file_opened_previous =
 800aff2:	687b      	ldr	r3, [r7, #4]
 800aff4:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
            file_ptr -> fx_file_opened_previous;
 800aff6:	687a      	ldr	r2, [r7, #4]
 800aff8:	6e12      	ldr	r2, [r2, #96]	@ 0x60
        (file_ptr -> fx_file_opened_next) -> fx_file_opened_previous =
 800affa:	661a      	str	r2, [r3, #96]	@ 0x60
        (file_ptr -> fx_file_opened_previous) -> fx_file_opened_next =
 800affc:	687b      	ldr	r3, [r7, #4]
 800affe:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
            file_ptr -> fx_file_opened_next;
 800b000:	687a      	ldr	r2, [r7, #4]
 800b002:	6dd2      	ldr	r2, [r2, #92]	@ 0x5c
        (file_ptr -> fx_file_opened_previous) -> fx_file_opened_next =
 800b004:	65da      	str	r2, [r3, #92]	@ 0x5c

        /* See if we have to update the opened list head pointer.  */
        if (media_ptr -> fx_media_opened_file_list == file_ptr)
 800b006:	68fb      	ldr	r3, [r7, #12]
 800b008:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
 800b00c:	687a      	ldr	r2, [r7, #4]
 800b00e:	429a      	cmp	r2, r3
 800b010:	d104      	bne.n	800b01c <_fx_file_close+0x68>
        {

            /* Yes, move the head pointer to the next opened file. */
            media_ptr -> fx_media_opened_file_list =  file_ptr -> fx_file_opened_next;
 800b012:	687b      	ldr	r3, [r7, #4]
 800b014:	6dda      	ldr	r2, [r3, #92]	@ 0x5c
 800b016:	68fb      	ldr	r3, [r7, #12]
 800b018:	f8c3 20c8 	str.w	r2, [r3, #200]	@ 0xc8
        }
    }

    /* Decrement the opened file counter.  */
    media_ptr -> fx_media_opened_file_count--;
 800b01c:	68fb      	ldr	r3, [r7, #12]
 800b01e:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
 800b022:	1e5a      	subs	r2, r3, #1
 800b024:	68fb      	ldr	r3, [r7, #12]
 800b026:	f8c3 20cc 	str.w	r2, [r3, #204]	@ 0xcc

    /* Finally, Indicate that this file is closed.  */
    file_ptr -> fx_file_id =  FX_FILE_CLOSED_ID;
 800b02a:	687b      	ldr	r3, [r7, #4]
 800b02c:	4a18      	ldr	r2, [pc, #96]	@ (800b090 <_fx_file_close+0xdc>)
 800b02e:	601a      	str	r2, [r3, #0]

    /* Check to see if this file needs to have its directory entry written
       back to the media.  */
    if ((file_ptr -> fx_file_open_mode == FX_OPEN_FOR_WRITE) &&
 800b030:	687b      	ldr	r3, [r7, #4]
 800b032:	689b      	ldr	r3, [r3, #8]
 800b034:	2b01      	cmp	r3, #1
 800b036:	d124      	bne.n	800b082 <_fx_file_close+0xce>
        (file_ptr -> fx_file_modified))
 800b038:	687b      	ldr	r3, [r7, #4]
 800b03a:	7b1b      	ldrb	r3, [r3, #12]
    if ((file_ptr -> fx_file_open_mode == FX_OPEN_FOR_WRITE) &&
 800b03c:	2b00      	cmp	r3, #0
 800b03e:	d020      	beq.n	800b082 <_fx_file_close+0xce>

        /* Lockout interrupts for time/date access.  */
        FX_DISABLE_INTS

        /* Set the new time and date.  */
        file_ptr -> fx_file_dir_entry.fx_dir_entry_time =  _fx_system_time;
 800b040:	4b14      	ldr	r3, [pc, #80]	@ (800b094 <_fx_file_close+0xe0>)
 800b042:	681a      	ldr	r2, [r3, #0]
 800b044:	687b      	ldr	r3, [r7, #4]
 800b046:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
        file_ptr -> fx_file_dir_entry.fx_dir_entry_date =  _fx_system_date;
 800b04a:	4b13      	ldr	r3, [pc, #76]	@ (800b098 <_fx_file_close+0xe4>)
 800b04c:	681a      	ldr	r2, [r3, #0]
 800b04e:	687b      	ldr	r3, [r7, #4]
 800b050:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98

        /* Set the last access date.  */
        file_ptr -> fx_file_dir_entry.fx_dir_entry_last_accessed_date =  _fx_system_date;
 800b054:	4b10      	ldr	r3, [pc, #64]	@ (800b098 <_fx_file_close+0xe4>)
 800b056:	681a      	ldr	r2, [r3, #0]
 800b058:	687b      	ldr	r3, [r7, #4]
 800b05a:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
        /* Restore interrupts.  */
        FX_RESTORE_INTS

        /* Copy the new file size into the directory entry.  */
        file_ptr -> fx_file_dir_entry.fx_dir_entry_file_size =
            file_ptr -> fx_file_current_file_size;
 800b05e:	687b      	ldr	r3, [r7, #4]
 800b060:	e9d3 2312 	ldrd	r2, r3, [r3, #72]	@ 0x48
        file_ptr -> fx_file_dir_entry.fx_dir_entry_file_size =
 800b064:	6879      	ldr	r1, [r7, #4]
 800b066:	e9c1 2328 	strd	r2, r3, [r1, #160]	@ 0xa0
                    media_ptr, &(file_ptr -> fx_file_dir_entry), UPDATE_STREAM);
        }
        else
        {
#endif /* FX_ENABLE_EXFAT */
            status = _fx_directory_entry_write(media_ptr, &(file_ptr -> fx_file_dir_entry));
 800b06a:	687b      	ldr	r3, [r7, #4]
 800b06c:	3368      	adds	r3, #104	@ 0x68
 800b06e:	4619      	mov	r1, r3
 800b070:	68f8      	ldr	r0, [r7, #12]
 800b072:	f7fe f80b 	bl	800908c <_fx_directory_entry_write>
 800b076:	60b8      	str	r0, [r7, #8]
#ifdef FX_ENABLE_EXFAT
        }
#endif /* FX_ENABLE_EXFAT */

        /* Check for a good status.  */
        if (status != FX_SUCCESS)
 800b078:	68bb      	ldr	r3, [r7, #8]
 800b07a:	2b00      	cmp	r3, #0
 800b07c:	d001      	beq.n	800b082 <_fx_file_close+0xce>

            /* Release media protection.  */
            FX_UNPROTECT

            /* Error writing the directory.  */
            return(status);
 800b07e:	68bb      	ldr	r3, [r7, #8]
 800b080:	e000      	b.n	800b084 <_fx_file_close+0xd0>

    /* Release media protection.  */
    FX_UNPROTECT

    /* Return status to the caller.  */
    return(FX_SUCCESS);
 800b082:	2300      	movs	r3, #0
}
 800b084:	4618      	mov	r0, r3
 800b086:	3710      	adds	r7, #16
 800b088:	46bd      	mov	sp, r7
 800b08a:	bd80      	pop	{r7, pc}
 800b08c:	46494c45 	.word	0x46494c45
 800b090:	46494c43 	.word	0x46494c43
 800b094:	20002c98 	.word	0x20002c98
 800b098:	20002c94 	.word	0x20002c94

0800b09c <_fx_file_create>:
/*  09-30-2020     William E. Lamie         Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _fx_file_create(FX_MEDIA *media_ptr, CHAR *file_name)
{
 800b09c:	b580      	push	{r7, lr}
 800b09e:	b0c0      	sub	sp, #256	@ 0x100
 800b0a0:	af02      	add	r7, sp, #8
 800b0a2:	6078      	str	r0, [r7, #4]
 800b0a4:	6039      	str	r1, [r7, #0]


#ifndef FX_MEDIA_STATISTICS_DISABLE

    /* Increment the number of times this service has been called.  */
    media_ptr -> fx_media_file_creates++;
 800b0a6:	687b      	ldr	r3, [r7, #4]
 800b0a8:	f8d3 3130 	ldr.w	r3, [r3, #304]	@ 0x130
 800b0ac:	1c5a      	adds	r2, r3, #1
 800b0ae:	687b      	ldr	r3, [r7, #4]
 800b0b0:	f8c3 2130 	str.w	r2, [r3, #304]	@ 0x130
#endif

    /* Determine if the supplied name is less than the maximum supported name size. The
       maximum name (FX_MAX_LONG_NAME_LEN) is defined in fx_api.h.  */
    i =  0;
 800b0b4:	2300      	movs	r3, #0
 800b0b6:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
    work_ptr =  (CHAR *)file_name;
 800b0ba:	683b      	ldr	r3, [r7, #0]
 800b0bc:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
    while (*work_ptr)
 800b0c0:	e020      	b.n	800b104 <_fx_file_create+0x68>
    {

        /* Determine if the character designates a new path.  */
        if ((*work_ptr == '\\') || (*work_ptr == '/'))
 800b0c2:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 800b0c6:	781b      	ldrb	r3, [r3, #0]
 800b0c8:	2b5c      	cmp	r3, #92	@ 0x5c
 800b0ca:	d004      	beq.n	800b0d6 <_fx_file_create+0x3a>
 800b0cc:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 800b0d0:	781b      	ldrb	r3, [r3, #0]
 800b0d2:	2b2f      	cmp	r3, #47	@ 0x2f
 800b0d4:	d103      	bne.n	800b0de <_fx_file_create+0x42>
        {
            /* Yes, reset the name size.  */
            i =  0;
 800b0d6:	2300      	movs	r3, #0
 800b0d8:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
 800b0dc:	e00d      	b.n	800b0fa <_fx_file_create+0x5e>
        }
        /* Check for leading spaces.  */
        else if ((*work_ptr != ' ') || (i != 0))
 800b0de:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 800b0e2:	781b      	ldrb	r3, [r3, #0]
 800b0e4:	2b20      	cmp	r3, #32
 800b0e6:	d103      	bne.n	800b0f0 <_fx_file_create+0x54>
 800b0e8:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800b0ec:	2b00      	cmp	r3, #0
 800b0ee:	d004      	beq.n	800b0fa <_fx_file_create+0x5e>
        {

            /* No leading spaces, increment the name size.  */
            i++;
 800b0f0:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800b0f4:	3301      	adds	r3, #1
 800b0f6:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
        }

        /* Move to the next character.  */
        work_ptr++;
 800b0fa:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 800b0fe:	3301      	adds	r3, #1
 800b100:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
    while (*work_ptr)
 800b104:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 800b108:	781b      	ldrb	r3, [r3, #0]
 800b10a:	2b00      	cmp	r3, #0
 800b10c:	d1d9      	bne.n	800b0c2 <_fx_file_create+0x26>
    }

    /* Determine if the supplied name is valid.  */
    if ((i == 0) || (i >= FX_MAX_LONG_NAME_LEN))
 800b10e:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800b112:	2b00      	cmp	r3, #0
 800b114:	d003      	beq.n	800b11e <_fx_file_create+0x82>
 800b116:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800b11a:	2bff      	cmp	r3, #255	@ 0xff
 800b11c:	d901      	bls.n	800b122 <_fx_file_create+0x86>
    {

        /* Return an invalid name value.  */
        return(FX_INVALID_NAME);
 800b11e:	230c      	movs	r3, #12
 800b120:	e07f      	b.n	800b222 <_fx_file_create+0x186>
    }

    /* Setup pointer to media name buffer.  */
    dir_entry.fx_dir_entry_name =  media_ptr -> fx_media_name_buffer + FX_MAX_LONG_NAME_LEN;
 800b122:	687b      	ldr	r3, [r7, #4]
 800b124:	f603 036c 	addw	r3, r3, #2156	@ 0x86c
 800b128:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800b12c:	67bb      	str	r3, [r7, #120]	@ 0x78

    /* Setup another pointer to another media name buffer.  */
    search_directory.fx_dir_entry_name =  media_ptr -> fx_media_name_buffer + FX_MAX_LONG_NAME_LEN * 2;
 800b12e:	687b      	ldr	r3, [r7, #4]
 800b130:	f603 036c 	addw	r3, r3, #2156	@ 0x86c
 800b134:	f503 7300 	add.w	r3, r3, #512	@ 0x200
 800b138:	60bb      	str	r3, [r7, #8]

    /* Clear the short name strings.  */
    dir_entry.fx_dir_entry_short_name[0] =        0;
 800b13a:	2300      	movs	r3, #0
 800b13c:	f887 307c 	strb.w	r3, [r7, #124]	@ 0x7c
    search_directory.fx_dir_entry_short_name[0] = 0;
 800b140:	2300      	movs	r3, #0
 800b142:	733b      	strb	r3, [r7, #12]

    /* Check the media to make sure it is open.  */
    if (media_ptr -> fx_media_id != FX_MEDIA_ID)
 800b144:	687b      	ldr	r3, [r7, #4]
 800b146:	681b      	ldr	r3, [r3, #0]
 800b148:	4a38      	ldr	r2, [pc, #224]	@ (800b22c <_fx_file_create+0x190>)
 800b14a:	4293      	cmp	r3, r2
 800b14c:	d001      	beq.n	800b152 <_fx_file_create+0xb6>
    {

        /* Return the media not opened error.  */
        return(FX_MEDIA_NOT_OPEN);
 800b14e:	2311      	movs	r3, #17
 800b150:	e067      	b.n	800b222 <_fx_file_create+0x186>
    /* Start transaction. */
    _fx_fault_tolerant_transaction_start(media_ptr);
#endif /* FX_ENABLE_FAULT_TOLERANT */

    /* Check for write protect at the media level (set by driver).  */
    if (media_ptr -> fx_media_driver_write_protect)
 800b152:	687b      	ldr	r3, [r7, #4]
 800b154:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
 800b158:	2b00      	cmp	r3, #0
 800b15a:	d001      	beq.n	800b160 <_fx_file_create+0xc4>

        /* Release media protection.  */
        FX_UNPROTECT

        /* Return write protect error.  */
        return(FX_WRITE_PROTECT);
 800b15c:	2323      	movs	r3, #35	@ 0x23
 800b15e:	e060      	b.n	800b222 <_fx_file_create+0x186>
    }

    /* Search the system for the supplied file name.  */
    status =  _fx_directory_search(media_ptr, file_name, &dir_entry, &search_directory, &name_ptr);
 800b160:	f107 0108 	add.w	r1, r7, #8
 800b164:	f107 0278 	add.w	r2, r7, #120	@ 0x78
 800b168:	f107 03e8 	add.w	r3, r7, #232	@ 0xe8
 800b16c:	9300      	str	r3, [sp, #0]
 800b16e:	460b      	mov	r3, r1
 800b170:	6839      	ldr	r1, [r7, #0]
 800b172:	6878      	ldr	r0, [r7, #4]
 800b174:	f7ff fa0f 	bl	800a596 <_fx_directory_search>
 800b178:	f8c7 00ec 	str.w	r0, [r7, #236]	@ 0xec

    /* Determine if the search was successful.  */
    if (status == FX_SUCCESS)
 800b17c:	f8d7 30ec 	ldr.w	r3, [r7, #236]	@ 0xec
 800b180:	2b00      	cmp	r3, #0
 800b182:	d101      	bne.n	800b188 <_fx_file_create+0xec>

        /* Release media protection.  */
        FX_UNPROTECT

        /* File found - Return the error code.  */
        return(FX_ALREADY_CREATED);
 800b184:	230b      	movs	r3, #11
 800b186:	e04c      	b.n	800b222 <_fx_file_create+0x186>
    }

    /* Determine if there is anything left after the name.  */
    if (_fx_directory_name_extract(name_ptr, &dir_entry.fx_dir_entry_name[0]))
 800b188:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 800b18c:	6fba      	ldr	r2, [r7, #120]	@ 0x78
 800b18e:	4611      	mov	r1, r2
 800b190:	4618      	mov	r0, r3
 800b192:	f7ff f99f 	bl	800a4d4 <_fx_directory_name_extract>
 800b196:	4603      	mov	r3, r0
 800b198:	2b00      	cmp	r3, #0
 800b19a:	d001      	beq.n	800b1a0 <_fx_file_create+0x104>
        /* Release media protection.  */
        FX_UNPROTECT

        /* Extra information after the file name, return an invalid path
           error.  */
        return(FX_INVALID_PATH);
 800b19c:	230d      	movs	r3, #13
 800b19e:	e040      	b.n	800b222 <_fx_file_create+0x186>
    /* Save the directory entry size.  */
    dir_size = search_directory.fx_dir_entry_file_size;
#endif /* FX_ENABLE_EXFAT */

    /* Find a free slot for the new file.  */
    status =  _fx_directory_free_search(media_ptr, &search_directory, &dir_entry);
 800b1a0:	f107 0278 	add.w	r2, r7, #120	@ 0x78
 800b1a4:	f107 0308 	add.w	r3, r7, #8
 800b1a8:	4619      	mov	r1, r3
 800b1aa:	6878      	ldr	r0, [r7, #4]
 800b1ac:	f7fe fdaa 	bl	8009d04 <_fx_directory_free_search>
 800b1b0:	f8c7 00ec 	str.w	r0, [r7, #236]	@ 0xec

    /* Determine if the search was successful.  */
    if (status != FX_SUCCESS)
 800b1b4:	f8d7 30ec 	ldr.w	r3, [r7, #236]	@ 0xec
 800b1b8:	2b00      	cmp	r3, #0
 800b1ba:	d002      	beq.n	800b1c2 <_fx_file_create+0x126>

        /* Release media protection.  */
        FX_UNPROTECT

        /* Return the error code.  */
        return(status);
 800b1bc:	f8d7 30ec 	ldr.w	r3, [r7, #236]	@ 0xec
 800b1c0:	e02f      	b.n	800b222 <_fx_file_create+0x186>
    }

    /* Populate the directory entry.  */

    /* Isolate the file name.  */
    _fx_directory_name_extract(name_ptr, &dir_entry.fx_dir_entry_name[0]);
 800b1c2:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 800b1c6:	6fba      	ldr	r2, [r7, #120]	@ 0x78
 800b1c8:	4611      	mov	r1, r2
 800b1ca:	4618      	mov	r0, r3
 800b1cc:	f7ff f982 	bl	800a4d4 <_fx_directory_name_extract>

    /* Disable interrupts for time/date access.  */
    FX_DISABLE_INTS

    /* Set time and date stamps.  */
    dir_entry.fx_dir_entry_time =  _fx_system_time;
 800b1d0:	4b17      	ldr	r3, [pc, #92]	@ (800b230 <_fx_file_create+0x194>)
 800b1d2:	681b      	ldr	r3, [r3, #0]
 800b1d4:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
    dir_entry.fx_dir_entry_date =  _fx_system_date;
 800b1d8:	4b16      	ldr	r3, [pc, #88]	@ (800b234 <_fx_file_create+0x198>)
 800b1da:	681b      	ldr	r3, [r3, #0]
 800b1dc:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8

    /* Restore interrupts.  */
    FX_RESTORE_INTS

    /* Set the attributes for the file.  */
    dir_entry.fx_dir_entry_attributes =  FX_ARCHIVE;
 800b1e0:	2320      	movs	r3, #32
 800b1e2:	f887 3094 	strb.w	r3, [r7, #148]	@ 0x94

    /* Set file size to 0. */
    dir_entry.fx_dir_entry_file_size =  0;
 800b1e6:	f04f 0200 	mov.w	r2, #0
 800b1ea:	f04f 0300 	mov.w	r3, #0
 800b1ee:	e9c7 232c 	strd	r2, r3, [r7, #176]	@ 0xb0
    /* Set available file size to 0. */
    dir_entry.fx_dir_entry_available_file_size = 0;
#endif /* FX_ENABLE_EXFAT */

    /* Set the cluster to NULL.  */
    dir_entry.fx_dir_entry_cluster =    FX_NULL;
 800b1f2:	2300      	movs	r3, #0
 800b1f4:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac

    /* Is there a leading dot?  */
    if (dir_entry.fx_dir_entry_name[0] == '.')
 800b1f8:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 800b1fa:	781b      	ldrb	r3, [r3, #0]
 800b1fc:	2b2e      	cmp	r3, #46	@ 0x2e
 800b1fe:	d106      	bne.n	800b20e <_fx_file_create+0x172>
    {

        /* Yes, toggle the hidden attribute bit.  */
        dir_entry.fx_dir_entry_attributes |=  FX_HIDDEN;
 800b200:	f897 3094 	ldrb.w	r3, [r7, #148]	@ 0x94
 800b204:	f043 0302 	orr.w	r3, r3, #2
 800b208:	b2db      	uxtb	r3, r3
 800b20a:	f887 3094 	strb.w	r3, [r7, #148]	@ 0x94
        status = _fx_directory_exFAT_entry_write(media_ptr, &dir_entry, UPDATE_FULL);
    }
    else
    {
#endif /* FX_ENABLE_EXFAT */
        status = _fx_directory_entry_write(media_ptr, &dir_entry);
 800b20e:	f107 0378 	add.w	r3, r7, #120	@ 0x78
 800b212:	4619      	mov	r1, r3
 800b214:	6878      	ldr	r0, [r7, #4]
 800b216:	f7fd ff39 	bl	800908c <_fx_directory_entry_write>
 800b21a:	f8c7 00ec 	str.w	r0, [r7, #236]	@ 0xec

    /* Release media protection.  */
    FX_UNPROTECT

    /* File create is complete, return status.  */
    return(status);
 800b21e:	f8d7 30ec 	ldr.w	r3, [r7, #236]	@ 0xec
}
 800b222:	4618      	mov	r0, r3
 800b224:	37f8      	adds	r7, #248	@ 0xf8
 800b226:	46bd      	mov	sp, r7
 800b228:	bd80      	pop	{r7, pc}
 800b22a:	bf00      	nop
 800b22c:	4d454449 	.word	0x4d454449
 800b230:	20002c98 	.word	0x20002c98
 800b234:	20002c94 	.word	0x20002c94

0800b238 <_fx_file_extended_seek>:
/*                                            relative cluster logic,     */
/*                                            resulting in version 6.1.7  */
/*                                                                        */
/**************************************************************************/
UINT  _fx_file_extended_seek(FX_FILE *file_ptr, ULONG64 byte_offset)
{
 800b238:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 800b23c:	b0c2      	sub	sp, #264	@ 0x108
 800b23e:	af00      	add	r7, sp, #0
 800b240:	f8c7 00dc 	str.w	r0, [r7, #220]	@ 0xdc
 800b244:	e9c7 2334 	strd	r2, r3, [r7, #208]	@ 0xd0

UINT      status;
ULONG     cluster;
ULONG     contents = 0;
 800b248:	2300      	movs	r3, #0
 800b24a:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
ULONG64   bytes_remaining;
FX_MEDIA *media_ptr;


    /* First, determine if the file is still open.  */
    if (file_ptr -> fx_file_id != FX_FILE_ID)
 800b24e:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 800b252:	681a      	ldr	r2, [r3, #0]
 800b254:	4bd3      	ldr	r3, [pc, #844]	@ (800b5a4 <_fx_file_extended_seek+0x36c>)
 800b256:	429a      	cmp	r2, r3
 800b258:	d001      	beq.n	800b25e <_fx_file_extended_seek+0x26>
    {

        /* Return the file not open error status.  */
        return(FX_NOT_OPEN);
 800b25a:	2307      	movs	r3, #7
 800b25c:	e279      	b.n	800b752 <_fx_file_extended_seek+0x51a>
    }

#ifndef FX_MEDIA_STATISTICS_DISABLE
    /* Setup pointer to media structure.  */
    media_ptr =  file_ptr -> fx_file_media_ptr;
 800b25e:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 800b262:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800b264:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4

    /* Increment the number of times this service has been called.  */
    media_ptr -> fx_media_file_seeks++;
 800b268:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800b26c:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
 800b270:	1c5a      	adds	r2, r3, #1
 800b272:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800b276:	f8c3 2148 	str.w	r2, [r3, #328]	@ 0x148
#endif

    /* Setup pointer to associated media control block.  */
    media_ptr =  file_ptr -> fx_file_media_ptr;
 800b27a:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 800b27e:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800b280:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4

    /* Protect against other threads accessing the media.  */
    FX_PROTECT

    /* Check if we actually have to do anything.  */
    if (byte_offset == file_ptr -> fx_file_current_file_offset)
 800b284:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 800b288:	e9d3 0110 	ldrd	r0, r1, [r3, #64]	@ 0x40
 800b28c:	e9d7 2334 	ldrd	r2, r3, [r7, #208]	@ 0xd0
 800b290:	428b      	cmp	r3, r1
 800b292:	bf08      	it	eq
 800b294:	4282      	cmpeq	r2, r0
 800b296:	d101      	bne.n	800b29c <_fx_file_extended_seek+0x64>

        /* Release media protection.  */
        FX_UNPROTECT

        /* Seek is complete, return successful status.  */
        return(FX_SUCCESS);
 800b298:	2300      	movs	r3, #0
 800b29a:	e25a      	b.n	800b752 <_fx_file_extended_seek+0x51a>
    }

    /* Calculate the number of bytes per cluster.  */
    bytes_per_cluster =  ((ULONG)media_ptr -> fx_media_bytes_per_sector) *
 800b29c:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800b2a0:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
        ((ULONG)media_ptr -> fx_media_sectors_per_cluster);
 800b2a2:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800b2a6:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
    bytes_per_cluster =  ((ULONG)media_ptr -> fx_media_bytes_per_sector) *
 800b2a8:	fb02 f303 	mul.w	r3, r2, r3
 800b2ac:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0

    /* Check for invalid value.  */
    if (bytes_per_cluster == 0)
 800b2b0:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 800b2b4:	2b00      	cmp	r3, #0
 800b2b6:	d101      	bne.n	800b2bc <_fx_file_extended_seek+0x84>

        /* Release media protection.  */
        FX_UNPROTECT

        /* Invalid media, return error.  */
        return(FX_MEDIA_INVALID);
 800b2b8:	2302      	movs	r3, #2
 800b2ba:	e24a      	b.n	800b752 <_fx_file_extended_seek+0x51a>
    }

    /* See if we need to adjust the byte offset.  */
    if (byte_offset > file_ptr -> fx_file_current_file_size)
 800b2bc:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 800b2c0:	e9d3 0112 	ldrd	r0, r1, [r3, #72]	@ 0x48
 800b2c4:	e9d7 2334 	ldrd	r2, r3, [r7, #208]	@ 0xd0
 800b2c8:	4290      	cmp	r0, r2
 800b2ca:	eb71 0303 	sbcs.w	r3, r1, r3
 800b2ce:	d205      	bcs.n	800b2dc <_fx_file_extended_seek+0xa4>
    {

        /* Adjust the byte offset down to the file size. */
        byte_offset =  file_ptr -> fx_file_current_file_size;
 800b2d0:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 800b2d4:	e9d3 2312 	ldrd	r2, r3, [r3, #72]	@ 0x48
 800b2d8:	e9c7 2334 	strd	r2, r3, [r7, #208]	@ 0xd0
    }

    /* Check if the desired position within the leading consecutive clusters.  */
    if (byte_offset >= (ULONG64)file_ptr -> fx_file_consecutive_cluster * (ULONG64)bytes_per_cluster)
 800b2dc:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 800b2e0:	699b      	ldr	r3, [r3, #24]
 800b2e2:	2200      	movs	r2, #0
 800b2e4:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
 800b2e8:	f8c7 20c4 	str.w	r2, [r7, #196]	@ 0xc4
 800b2ec:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 800b2f0:	2200      	movs	r2, #0
 800b2f2:	469a      	mov	sl, r3
 800b2f4:	4693      	mov	fp, r2
 800b2f6:	e9d7 0130 	ldrd	r0, r1, [r7, #192]	@ 0xc0
 800b2fa:	460b      	mov	r3, r1
 800b2fc:	fb0a f203 	mul.w	r2, sl, r3
 800b300:	4603      	mov	r3, r0
 800b302:	fb03 f30b 	mul.w	r3, r3, fp
 800b306:	4413      	add	r3, r2
 800b308:	4602      	mov	r2, r0
 800b30a:	fba2 450a 	umull	r4, r5, r2, sl
 800b30e:	442b      	add	r3, r5
 800b310:	461d      	mov	r5, r3
 800b312:	e9d7 2334 	ldrd	r2, r3, [r7, #208]	@ 0xd0
 800b316:	42a2      	cmp	r2, r4
 800b318:	41ab      	sbcs	r3, r5
 800b31a:	f0c0 8145 	bcc.w	800b5a8 <_fx_file_extended_seek+0x370>

            /* At this point, we are ready to walk list of clusters to setup the
               seek position of this file.  */

            /* check if byte_offset is greater than where we were left off earlier */
            if ((ULONG64)file_ptr -> fx_file_current_relative_cluster * (ULONG64)bytes_per_cluster < byte_offset)
 800b31e:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 800b322:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800b324:	2200      	movs	r2, #0
 800b326:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
 800b32a:	f8c7 20bc 	str.w	r2, [r7, #188]	@ 0xbc
 800b32e:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 800b332:	2200      	movs	r2, #0
 800b334:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
 800b338:	f8c7 20b4 	str.w	r2, [r7, #180]	@ 0xb4
 800b33c:	e9d7 452e 	ldrd	r4, r5, [r7, #184]	@ 0xb8
 800b340:	462b      	mov	r3, r5
 800b342:	e9d7 ab2c 	ldrd	sl, fp, [r7, #176]	@ 0xb0
 800b346:	4652      	mov	r2, sl
 800b348:	fb02 f203 	mul.w	r2, r2, r3
 800b34c:	465b      	mov	r3, fp
 800b34e:	4621      	mov	r1, r4
 800b350:	fb01 f303 	mul.w	r3, r1, r3
 800b354:	4413      	add	r3, r2
 800b356:	4622      	mov	r2, r4
 800b358:	4651      	mov	r1, sl
 800b35a:	fba2 8901 	umull	r8, r9, r2, r1
 800b35e:	444b      	add	r3, r9
 800b360:	4699      	mov	r9, r3
 800b362:	e9d7 2334 	ldrd	r2, r3, [r7, #208]	@ 0xd0
 800b366:	4590      	cmp	r8, r2
 800b368:	eb79 0303 	sbcs.w	r3, r9, r3
 800b36c:	d225      	bcs.n	800b3ba <_fx_file_extended_seek+0x182>
            {

                cluster =    file_ptr -> fx_file_current_physical_cluster;
 800b36e:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 800b372:	6a1b      	ldr	r3, [r3, #32]
 800b374:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104

                bytes_remaining =   byte_offset -
                    file_ptr -> fx_file_current_relative_cluster * bytes_per_cluster;
 800b378:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 800b37c:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 800b37e:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 800b382:	fb02 f303 	mul.w	r3, r2, r3
 800b386:	2200      	movs	r2, #0
 800b388:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
 800b38c:	f8c7 20ac 	str.w	r2, [r7, #172]	@ 0xac
                bytes_remaining =   byte_offset -
 800b390:	e9d7 2334 	ldrd	r2, r3, [r7, #208]	@ 0xd0
 800b394:	e9d7 452a 	ldrd	r4, r5, [r7, #168]	@ 0xa8
 800b398:	4621      	mov	r1, r4
 800b39a:	1a51      	subs	r1, r2, r1
 800b39c:	6139      	str	r1, [r7, #16]
 800b39e:	4629      	mov	r1, r5
 800b3a0:	eb63 0301 	sbc.w	r3, r3, r1
 800b3a4:	617b      	str	r3, [r7, #20]
 800b3a6:	e9d7 3404 	ldrd	r3, r4, [r7, #16]
 800b3aa:	e9c7 343e 	strd	r3, r4, [r7, #248]	@ 0xf8

                cluster_count = file_ptr -> fx_file_current_relative_cluster;
 800b3ae:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 800b3b2:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800b3b4:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
 800b3b8:	e0b0      	b.n	800b51c <_fx_file_extended_seek+0x2e4>
            }
            else
            {

                cluster =    file_ptr -> fx_file_first_physical_cluster +
 800b3ba:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 800b3be:	695a      	ldr	r2, [r3, #20]
                    (file_ptr -> fx_file_consecutive_cluster - 1);
 800b3c0:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 800b3c4:	699b      	ldr	r3, [r3, #24]
                cluster =    file_ptr -> fx_file_first_physical_cluster +
 800b3c6:	4413      	add	r3, r2
 800b3c8:	3b01      	subs	r3, #1
 800b3ca:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
                bytes_remaining =   byte_offset -
                    (file_ptr -> fx_file_consecutive_cluster - 1) * bytes_per_cluster;
 800b3ce:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 800b3d2:	699b      	ldr	r3, [r3, #24]
 800b3d4:	1e5a      	subs	r2, r3, #1
 800b3d6:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 800b3da:	fb02 f303 	mul.w	r3, r2, r3
 800b3de:	2200      	movs	r2, #0
 800b3e0:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
 800b3e4:	f8c7 20a4 	str.w	r2, [r7, #164]	@ 0xa4
                bytes_remaining =   byte_offset -
 800b3e8:	e9d7 2334 	ldrd	r2, r3, [r7, #208]	@ 0xd0
 800b3ec:	e9d7 4528 	ldrd	r4, r5, [r7, #160]	@ 0xa0
 800b3f0:	4621      	mov	r1, r4
 800b3f2:	1a51      	subs	r1, r2, r1
 800b3f4:	60b9      	str	r1, [r7, #8]
 800b3f6:	4629      	mov	r1, r5
 800b3f8:	eb63 0301 	sbc.w	r3, r3, r1
 800b3fc:	60fb      	str	r3, [r7, #12]
 800b3fe:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
 800b402:	e9c7 343e 	strd	r3, r4, [r7, #248]	@ 0xf8
                cluster_count =     (file_ptr -> fx_file_consecutive_cluster - 1);
 800b406:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 800b40a:	699b      	ldr	r3, [r3, #24]
 800b40c:	3b01      	subs	r3, #1
 800b40e:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
            }


            /* Follow the link of FAT entries.  */
            while ((cluster >= FX_FAT_ENTRY_START) && (cluster < media_ptr -> fx_media_fat_reserved))
 800b412:	e083      	b.n	800b51c <_fx_file_extended_seek+0x2e4>
            {

                /* Increment the number of clusters.  */
                cluster_count++;
 800b414:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 800b418:	3301      	adds	r3, #1
 800b41a:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100

                /* Read the current cluster entry from the FAT.  */
                status =  _fx_utility_FAT_entry_read(media_ptr, cluster, &contents);
 800b41e:	f107 03e4 	add.w	r3, r7, #228	@ 0xe4
 800b422:	461a      	mov	r2, r3
 800b424:	f8d7 1104 	ldr.w	r1, [r7, #260]	@ 0x104
 800b428:	f8d7 00f4 	ldr.w	r0, [r7, #244]	@ 0xf4
 800b42c:	f003 fab8 	bl	800e9a0 <_fx_utility_FAT_entry_read>
 800b430:	f8c7 00ec 	str.w	r0, [r7, #236]	@ 0xec

                /* Check the return value.  */
                if (status != FX_SUCCESS)
 800b434:	f8d7 30ec 	ldr.w	r3, [r7, #236]	@ 0xec
 800b438:	2b00      	cmp	r3, #0
 800b43a:	d002      	beq.n	800b442 <_fx_file_extended_seek+0x20a>

                    /* Release media protection.  */
                    FX_UNPROTECT

                    /* Return the error status.  */
                    return(status);
 800b43c:	f8d7 30ec 	ldr.w	r3, [r7, #236]	@ 0xec
 800b440:	e187      	b.n	800b752 <_fx_file_extended_seek+0x51a>
                }

                /* Save the last valid cluster.  */
                last_cluster =  cluster;
 800b442:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 800b446:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8

                /* Setup for the next cluster.  */
                cluster =  contents;
 800b44a:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 800b44e:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104

                /* Determine if this is the last written cluster.  */
                if (bytes_remaining > bytes_per_cluster)
 800b452:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 800b456:	2200      	movs	r2, #0
 800b458:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
 800b45c:	f8c7 209c 	str.w	r2, [r7, #156]	@ 0x9c
 800b460:	e9d7 233e 	ldrd	r2, r3, [r7, #248]	@ 0xf8
 800b464:	e9d7 4526 	ldrd	r4, r5, [r7, #152]	@ 0x98
 800b468:	4621      	mov	r1, r4
 800b46a:	4291      	cmp	r1, r2
 800b46c:	4629      	mov	r1, r5
 800b46e:	eb71 0303 	sbcs.w	r3, r1, r3
 800b472:	d216      	bcs.n	800b4a2 <_fx_file_extended_seek+0x26a>
                {

                    /* Still more seeking, just decrement the working byte offset.  */
                    bytes_remaining =  bytes_remaining - bytes_per_cluster;
 800b474:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 800b478:	2200      	movs	r2, #0
 800b47a:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
 800b47e:	f8c7 2094 	str.w	r2, [r7, #148]	@ 0x94
 800b482:	e9d7 233e 	ldrd	r2, r3, [r7, #248]	@ 0xf8
 800b486:	e9d7 4524 	ldrd	r4, r5, [r7, #144]	@ 0x90
 800b48a:	4621      	mov	r1, r4
 800b48c:	1a51      	subs	r1, r2, r1
 800b48e:	6039      	str	r1, [r7, #0]
 800b490:	4629      	mov	r1, r5
 800b492:	eb63 0301 	sbc.w	r3, r3, r1
 800b496:	607b      	str	r3, [r7, #4]
 800b498:	e9d7 3400 	ldrd	r3, r4, [r7]
 800b49c:	e9c7 343e 	strd	r3, r4, [r7, #248]	@ 0xf8
 800b4a0:	e03c      	b.n	800b51c <_fx_file_extended_seek+0x2e4>
                }
                else
                {

                    /* Remember this cluster number.  */
                    file_ptr -> fx_file_current_physical_cluster =  last_cluster;
 800b4a2:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
 800b4a6:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 800b4aa:	6213      	str	r3, [r2, #32]

                    /* Remember the relative cluster.  */
                    file_ptr -> fx_file_current_relative_cluster =  cluster_count - 1;
 800b4ac:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 800b4b0:	1e5a      	subs	r2, r3, #1
 800b4b2:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 800b4b6:	635a      	str	r2, [r3, #52]	@ 0x34

                    /* If the remaining bytes exactly fits the cluster size, check for
                       a possible adjustment to the next cluster.  */
                    if ((bytes_remaining == bytes_per_cluster) &&
 800b4b8:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 800b4bc:	2200      	movs	r2, #0
 800b4be:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
 800b4c2:	f8c7 208c 	str.w	r2, [r7, #140]	@ 0x8c
 800b4c6:	e9d7 233e 	ldrd	r2, r3, [r7, #248]	@ 0xf8
 800b4ca:	e9d7 4522 	ldrd	r4, r5, [r7, #136]	@ 0x88
 800b4ce:	4621      	mov	r1, r4
 800b4d0:	4628      	mov	r0, r5
 800b4d2:	4283      	cmp	r3, r0
 800b4d4:	bf08      	it	eq
 800b4d6:	428a      	cmpeq	r2, r1
 800b4d8:	d130      	bne.n	800b53c <_fx_file_extended_seek+0x304>
 800b4da:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 800b4de:	2b01      	cmp	r3, #1
 800b4e0:	d92c      	bls.n	800b53c <_fx_file_extended_seek+0x304>
                        (cluster >= FX_FAT_ENTRY_START) && (cluster < media_ptr -> fx_media_fat_reserved))
 800b4e2:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800b4e6:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 800b4ea:	f8d3 2478 	ldr.w	r2, [r3, #1144]	@ 0x478
 800b4ee:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 800b4f2:	4293      	cmp	r3, r2
 800b4f4:	d222      	bcs.n	800b53c <_fx_file_extended_seek+0x304>
                    {

                        /* We need to position to next allocated cluster.  */
                        file_ptr -> fx_file_current_physical_cluster =  cluster;
 800b4f6:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
 800b4fa:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 800b4fe:	6213      	str	r3, [r2, #32]
                        file_ptr -> fx_file_current_relative_cluster++;
 800b500:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 800b504:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800b506:	1c5a      	adds	r2, r3, #1
 800b508:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 800b50c:	635a      	str	r2, [r3, #52]	@ 0x34

                        /* Clear the remaining bytes.  */
                        bytes_remaining =  0;
 800b50e:	f04f 0200 	mov.w	r2, #0
 800b512:	f04f 0300 	mov.w	r3, #0
 800b516:	e9c7 233e 	strd	r2, r3, [r7, #248]	@ 0xf8
                    }

                    /* This is the cluster that contains the seek position.  */
                    break;
 800b51a:	e00f      	b.n	800b53c <_fx_file_extended_seek+0x304>
            while ((cluster >= FX_FAT_ENTRY_START) && (cluster < media_ptr -> fx_media_fat_reserved))
 800b51c:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 800b520:	2b01      	cmp	r3, #1
 800b522:	d90c      	bls.n	800b53e <_fx_file_extended_seek+0x306>
 800b524:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800b528:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 800b52c:	f8d3 2478 	ldr.w	r2, [r3, #1144]	@ 0x478
 800b530:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 800b534:	4293      	cmp	r3, r2
 800b536:	f4ff af6d 	bcc.w	800b414 <_fx_file_extended_seek+0x1dc>
 800b53a:	e000      	b.n	800b53e <_fx_file_extended_seek+0x306>
                    break;
 800b53c:	bf00      	nop
                }
            }
        
            /* Check for errors in traversal of the FAT chain.  */
            if (byte_offset > (((ULONG64) bytes_per_cluster) * ((ULONG64) cluster_count)))
 800b53e:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 800b542:	2200      	movs	r2, #0
 800b544:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
 800b548:	f8c7 2084 	str.w	r2, [r7, #132]	@ 0x84
 800b54c:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 800b550:	2200      	movs	r2, #0
 800b552:	67bb      	str	r3, [r7, #120]	@ 0x78
 800b554:	67fa      	str	r2, [r7, #124]	@ 0x7c
 800b556:	e9d7 4520 	ldrd	r4, r5, [r7, #128]	@ 0x80
 800b55a:	462b      	mov	r3, r5
 800b55c:	e9d7 891e 	ldrd	r8, r9, [r7, #120]	@ 0x78
 800b560:	4642      	mov	r2, r8
 800b562:	fb02 f203 	mul.w	r2, r2, r3
 800b566:	464b      	mov	r3, r9
 800b568:	4621      	mov	r1, r4
 800b56a:	fb01 f303 	mul.w	r3, r1, r3
 800b56e:	4413      	add	r3, r2
 800b570:	4622      	mov	r2, r4
 800b572:	4641      	mov	r1, r8
 800b574:	fba2 1201 	umull	r1, r2, r2, r1
 800b578:	f8c7 20cc 	str.w	r2, [r7, #204]	@ 0xcc
 800b57c:	460a      	mov	r2, r1
 800b57e:	f8c7 20c8 	str.w	r2, [r7, #200]	@ 0xc8
 800b582:	f8d7 20cc 	ldr.w	r2, [r7, #204]	@ 0xcc
 800b586:	4413      	add	r3, r2
 800b588:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
 800b58c:	e9d7 2334 	ldrd	r2, r3, [r7, #208]	@ 0xd0
 800b590:	e9d7 4532 	ldrd	r4, r5, [r7, #200]	@ 0xc8
 800b594:	4621      	mov	r1, r4
 800b596:	4291      	cmp	r1, r2
 800b598:	4629      	mov	r1, r5
 800b59a:	4199      	sbcs	r1, r3
 800b59c:	d22b      	bcs.n	800b5f6 <_fx_file_extended_seek+0x3be>
    
                /* Release media protection.  */
                FX_UNPROTECT

                /* This is an error that suggests a corrupt file.  */
                return(FX_FILE_CORRUPT);
 800b59e:	2308      	movs	r3, #8
 800b5a0:	e0d7      	b.n	800b752 <_fx_file_extended_seek+0x51a>
 800b5a2:	bf00      	nop
 800b5a4:	46494c45 	.word	0x46494c45
    }
    else
    {

        /* we should directly access the desired cluster */
        file_ptr -> fx_file_current_relative_cluster = (ULONG)(byte_offset / bytes_per_cluster);
 800b5a8:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 800b5ac:	2200      	movs	r2, #0
 800b5ae:	673b      	str	r3, [r7, #112]	@ 0x70
 800b5b0:	677a      	str	r2, [r7, #116]	@ 0x74
 800b5b2:	e9d7 231c 	ldrd	r2, r3, [r7, #112]	@ 0x70
 800b5b6:	e9d7 0134 	ldrd	r0, r1, [r7, #208]	@ 0xd0
 800b5ba:	f7f4 fe5d 	bl	8000278 <__aeabi_uldivmod>
 800b5be:	4602      	mov	r2, r0
 800b5c0:	460b      	mov	r3, r1
 800b5c2:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 800b5c6:	635a      	str	r2, [r3, #52]	@ 0x34

        file_ptr -> fx_file_current_physical_cluster =
            file_ptr -> fx_file_first_physical_cluster + file_ptr -> fx_file_current_relative_cluster;
 800b5c8:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 800b5cc:	695a      	ldr	r2, [r3, #20]
 800b5ce:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 800b5d2:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800b5d4:	441a      	add	r2, r3
        file_ptr -> fx_file_current_physical_cluster =
 800b5d6:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 800b5da:	621a      	str	r2, [r3, #32]

        bytes_remaining =  byte_offset % bytes_per_cluster;
 800b5dc:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 800b5e0:	2200      	movs	r2, #0
 800b5e2:	66bb      	str	r3, [r7, #104]	@ 0x68
 800b5e4:	66fa      	str	r2, [r7, #108]	@ 0x6c
 800b5e6:	e9d7 0134 	ldrd	r0, r1, [r7, #208]	@ 0xd0
 800b5ea:	e9d7 231a 	ldrd	r2, r3, [r7, #104]	@ 0x68
 800b5ee:	f7f4 fe43 	bl	8000278 <__aeabi_uldivmod>
 800b5f2:	e9c7 233e 	strd	r2, r3, [r7, #248]	@ 0xf8
    }


    /* Determine if the remaining bytes fit exactly into the cluster size.  */
    if (bytes_remaining == bytes_per_cluster)
 800b5f6:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 800b5fa:	2200      	movs	r2, #0
 800b5fc:	663b      	str	r3, [r7, #96]	@ 0x60
 800b5fe:	667a      	str	r2, [r7, #100]	@ 0x64
 800b600:	e9d7 233e 	ldrd	r2, r3, [r7, #248]	@ 0xf8
 800b604:	e9d7 4518 	ldrd	r4, r5, [r7, #96]	@ 0x60
 800b608:	4621      	mov	r1, r4
 800b60a:	4628      	mov	r0, r5
 800b60c:	4283      	cmp	r3, r0
 800b60e:	bf08      	it	eq
 800b610:	428a      	cmpeq	r2, r1
 800b612:	d151      	bne.n	800b6b8 <_fx_file_extended_seek+0x480>
    {

        /* Position to the end of the cluster.  */
        file_ptr -> fx_file_current_logical_sector = (ULONG)(((ULONG)media_ptr -> fx_media_data_sector_start) +
 800b614:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800b618:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
                                                             (((ULONG64)file_ptr -> fx_file_current_physical_cluster - FX_FAT_ENTRY_START) *
 800b61a:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 800b61e:	6a1b      	ldr	r3, [r3, #32]
        file_ptr -> fx_file_current_logical_sector = (ULONG)(((ULONG)media_ptr -> fx_media_data_sector_start) +
 800b620:	3b02      	subs	r3, #2
                                                              ((ULONG)media_ptr -> fx_media_sectors_per_cluster)) +
 800b622:	f8d7 10f4 	ldr.w	r1, [r7, #244]	@ 0xf4
 800b626:	6d49      	ldr	r1, [r1, #84]	@ 0x54
        file_ptr -> fx_file_current_logical_sector = (ULONG)(((ULONG)media_ptr -> fx_media_data_sector_start) +
 800b628:	fb01 f303 	mul.w	r3, r1, r3
 800b62c:	18d4      	adds	r4, r2, r3
                                                             ((bytes_remaining - 1) / (ULONG)media_ptr -> fx_media_bytes_per_sector));
 800b62e:	e9d7 233e 	ldrd	r2, r3, [r7, #248]	@ 0xf8
 800b632:	1e51      	subs	r1, r2, #1
 800b634:	65b9      	str	r1, [r7, #88]	@ 0x58
 800b636:	f143 33ff 	adc.w	r3, r3, #4294967295
 800b63a:	65fb      	str	r3, [r7, #92]	@ 0x5c
 800b63c:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800b640:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800b642:	2200      	movs	r2, #0
 800b644:	653b      	str	r3, [r7, #80]	@ 0x50
 800b646:	657a      	str	r2, [r7, #84]	@ 0x54
 800b648:	e9d7 2314 	ldrd	r2, r3, [r7, #80]	@ 0x50
 800b64c:	e9d7 0116 	ldrd	r0, r1, [r7, #88]	@ 0x58
 800b650:	f7f4 fe12 	bl	8000278 <__aeabi_uldivmod>
 800b654:	4602      	mov	r2, r0
 800b656:	460b      	mov	r3, r1
        file_ptr -> fx_file_current_logical_sector = (ULONG)(((ULONG)media_ptr -> fx_media_data_sector_start) +
 800b658:	4613      	mov	r3, r2
 800b65a:	4423      	add	r3, r4
 800b65c:	2200      	movs	r2, #0
 800b65e:	64bb      	str	r3, [r7, #72]	@ 0x48
 800b660:	64fa      	str	r2, [r7, #76]	@ 0x4c
 800b662:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 800b666:	e9d7 1212 	ldrd	r1, r2, [r7, #72]	@ 0x48
 800b66a:	e9c3 120a 	strd	r1, r2, [r3, #40]	@ 0x28
        file_ptr -> fx_file_current_relative_sector =   (UINT)(((bytes_remaining - 1) / (ULONG)media_ptr -> fx_media_bytes_per_sector));
 800b66e:	e9d7 233e 	ldrd	r2, r3, [r7, #248]	@ 0xf8
 800b672:	1e51      	subs	r1, r2, #1
 800b674:	6439      	str	r1, [r7, #64]	@ 0x40
 800b676:	f143 33ff 	adc.w	r3, r3, #4294967295
 800b67a:	647b      	str	r3, [r7, #68]	@ 0x44
 800b67c:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800b680:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800b682:	2200      	movs	r2, #0
 800b684:	63bb      	str	r3, [r7, #56]	@ 0x38
 800b686:	63fa      	str	r2, [r7, #60]	@ 0x3c
 800b688:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	@ 0x38
 800b68c:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	@ 0x40
 800b690:	f7f4 fdf2 	bl	8000278 <__aeabi_uldivmod>
 800b694:	4602      	mov	r2, r0
 800b696:	460b      	mov	r3, r1
 800b698:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 800b69c:	639a      	str	r2, [r3, #56]	@ 0x38
        file_ptr -> fx_file_current_file_offset =       byte_offset;
 800b69e:	f8d7 10dc 	ldr.w	r1, [r7, #220]	@ 0xdc
 800b6a2:	e9d7 2334 	ldrd	r2, r3, [r7, #208]	@ 0xd0
 800b6a6:	e9c1 2310 	strd	r2, r3, [r1, #64]	@ 0x40
        file_ptr -> fx_file_current_logical_offset =    media_ptr -> fx_media_bytes_per_sector;
 800b6aa:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800b6ae:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 800b6b0:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 800b6b4:	631a      	str	r2, [r3, #48]	@ 0x30
 800b6b6:	e04b      	b.n	800b750 <_fx_file_extended_seek+0x518>
    }
    else
    {

        /* Position the pointers to the new offset.  */
        file_ptr -> fx_file_current_logical_sector = (ULONG)(((ULONG)media_ptr -> fx_media_data_sector_start) +
 800b6b8:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800b6bc:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
                                                             (((ULONG64)file_ptr -> fx_file_current_physical_cluster - FX_FAT_ENTRY_START) *
 800b6be:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 800b6c2:	6a1b      	ldr	r3, [r3, #32]
        file_ptr -> fx_file_current_logical_sector = (ULONG)(((ULONG)media_ptr -> fx_media_data_sector_start) +
 800b6c4:	3b02      	subs	r3, #2
                                                              ((ULONG)media_ptr -> fx_media_sectors_per_cluster)) +
 800b6c6:	f8d7 10f4 	ldr.w	r1, [r7, #244]	@ 0xf4
 800b6ca:	6d49      	ldr	r1, [r1, #84]	@ 0x54
        file_ptr -> fx_file_current_logical_sector = (ULONG)(((ULONG)media_ptr -> fx_media_data_sector_start) +
 800b6cc:	fb01 f303 	mul.w	r3, r1, r3
 800b6d0:	18d4      	adds	r4, r2, r3
                                                             (bytes_remaining / (ULONG)media_ptr -> fx_media_bytes_per_sector));
 800b6d2:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800b6d6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800b6d8:	2200      	movs	r2, #0
 800b6da:	633b      	str	r3, [r7, #48]	@ 0x30
 800b6dc:	637a      	str	r2, [r7, #52]	@ 0x34
 800b6de:	e9d7 230c 	ldrd	r2, r3, [r7, #48]	@ 0x30
 800b6e2:	e9d7 013e 	ldrd	r0, r1, [r7, #248]	@ 0xf8
 800b6e6:	f7f4 fdc7 	bl	8000278 <__aeabi_uldivmod>
 800b6ea:	4602      	mov	r2, r0
 800b6ec:	460b      	mov	r3, r1
        file_ptr -> fx_file_current_logical_sector = (ULONG)(((ULONG)media_ptr -> fx_media_data_sector_start) +
 800b6ee:	4613      	mov	r3, r2
 800b6f0:	4423      	add	r3, r4
 800b6f2:	2200      	movs	r2, #0
 800b6f4:	62bb      	str	r3, [r7, #40]	@ 0x28
 800b6f6:	62fa      	str	r2, [r7, #44]	@ 0x2c
 800b6f8:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 800b6fc:	e9d7 120a 	ldrd	r1, r2, [r7, #40]	@ 0x28
 800b700:	e9c3 120a 	strd	r1, r2, [r3, #40]	@ 0x28
        file_ptr -> fx_file_current_relative_sector =   (UINT)((bytes_remaining / (ULONG)media_ptr -> fx_media_bytes_per_sector));
 800b704:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800b708:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800b70a:	2200      	movs	r2, #0
 800b70c:	623b      	str	r3, [r7, #32]
 800b70e:	627a      	str	r2, [r7, #36]	@ 0x24
 800b710:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 800b714:	e9d7 013e 	ldrd	r0, r1, [r7, #248]	@ 0xf8
 800b718:	f7f4 fdae 	bl	8000278 <__aeabi_uldivmod>
 800b71c:	4602      	mov	r2, r0
 800b71e:	460b      	mov	r3, r1
 800b720:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 800b724:	639a      	str	r2, [r3, #56]	@ 0x38
        file_ptr -> fx_file_current_file_offset =       byte_offset;
 800b726:	f8d7 10dc 	ldr.w	r1, [r7, #220]	@ 0xdc
 800b72a:	e9d7 2334 	ldrd	r2, r3, [r7, #208]	@ 0xd0
 800b72e:	e9c1 2310 	strd	r2, r3, [r1, #64]	@ 0x40
        file_ptr -> fx_file_current_logical_offset =    (ULONG)(bytes_remaining % ((ULONG)media_ptr -> fx_media_bytes_per_sector));
 800b732:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800b736:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800b738:	2200      	movs	r2, #0
 800b73a:	61bb      	str	r3, [r7, #24]
 800b73c:	61fa      	str	r2, [r7, #28]
 800b73e:	e9d7 013e 	ldrd	r0, r1, [r7, #248]	@ 0xf8
 800b742:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 800b746:	f7f4 fd97 	bl	8000278 <__aeabi_uldivmod>
 800b74a:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 800b74e:	631a      	str	r2, [r3, #48]	@ 0x30

    /* Release media protection.  */
    FX_UNPROTECT

    /* Seek is complete, return successful status.  */
    return(FX_SUCCESS);
 800b750:	2300      	movs	r3, #0
}
 800b752:	4618      	mov	r0, r3
 800b754:	f507 7784 	add.w	r7, r7, #264	@ 0x108
 800b758:	46bd      	mov	sp, r7
 800b75a:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 800b75e:	bf00      	nop

0800b760 <_fx_file_open>:
/*                                            consecutive detect,         */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _fx_file_open(FX_MEDIA *media_ptr, FX_FILE *file_ptr, CHAR *file_name, UINT open_type)
{
 800b760:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 800b764:	b0e8      	sub	sp, #416	@ 0x1a0
 800b766:	af02      	add	r7, sp, #8
 800b768:	f8c7 014c 	str.w	r0, [r7, #332]	@ 0x14c
 800b76c:	f8c7 1148 	str.w	r1, [r7, #328]	@ 0x148
 800b770:	f8c7 2144 	str.w	r2, [r7, #324]	@ 0x144
 800b774:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
UINT     status;
#ifndef FX_DISABLE_CONSECUTIVE_DETECT
UINT     leading_consecutive;
#endif /* FX_DISABLE_CONSECUTIVE_DETECT */
ULONG    cluster;
ULONG    contents = 0;
 800b778:	2300      	movs	r3, #0
 800b77a:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
#endif /* FX_DISABLE_FAST_OPEN */
UCHAR    not_a_file_attr;


    /* Check the media to make sure it is open.  */
    if (media_ptr -> fx_media_id != FX_MEDIA_ID)
 800b77e:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800b782:	681a      	ldr	r2, [r3, #0]
 800b784:	4bca      	ldr	r3, [pc, #808]	@ (800bab0 <_fx_file_open+0x350>)
 800b786:	429a      	cmp	r2, r3
 800b788:	d002      	beq.n	800b790 <_fx_file_open+0x30>
    {

        /* Return the media not opened error.  */
        return(FX_MEDIA_NOT_OPEN);
 800b78a:	2311      	movs	r3, #17
 800b78c:	f000 bc65 	b.w	800c05a <_fx_file_open+0x8fa>
    }

#ifndef FX_MEDIA_STATISTICS_DISABLE

    /* Increment the number of times this service has been called.  */
    media_ptr -> fx_media_file_opens++;
 800b790:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800b794:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
 800b798:	1c5a      	adds	r2, r3, #1
 800b79a:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800b79e:	f8c3 2138 	str.w	r2, [r3, #312]	@ 0x138
#endif

    /* Clear the notify function. */
    file_ptr -> fx_file_write_notify = FX_NULL;
 800b7a2:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 800b7a6:	2300      	movs	r3, #0
 800b7a8:	f8c2 31dc 	str.w	r3, [r2, #476]	@ 0x1dc
        fat_last        = FX_LAST_CLUSTER_exFAT;
        not_a_file_attr = FX_DIRECTORY;
    }
    else if (media_ptr -> fx_media_FAT_type == FX_FAT32)
#else
    if (media_ptr -> fx_media_32_bit_FAT)
 800b7ac:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800b7b0:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 800b7b2:	2b00      	cmp	r3, #0
 800b7b4:	d006      	beq.n	800b7c4 <_fx_file_open+0x64>
#endif /* FX_ENABLE_EXFAT */
    {
        fat_last        = FX_LAST_CLUSTER_1_32;
 800b7b6:	4bbf      	ldr	r3, [pc, #764]	@ (800bab4 <_fx_file_open+0x354>)
 800b7b8:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
        not_a_file_attr = FX_DIRECTORY | FX_VOLUME;
 800b7bc:	2318      	movs	r3, #24
 800b7be:	f887 3167 	strb.w	r3, [r7, #359]	@ 0x167
 800b7c2:	e006      	b.n	800b7d2 <_fx_file_open+0x72>
    }
    else
    {
        fat_last        = FX_LAST_CLUSTER_1;
 800b7c4:	f64f 73f8 	movw	r3, #65528	@ 0xfff8
 800b7c8:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
        not_a_file_attr = FX_DIRECTORY | FX_VOLUME;
 800b7cc:	2318      	movs	r3, #24
 800b7ce:	f887 3167 	strb.w	r3, [r7, #359]	@ 0x167
    }

#ifndef FX_DISABLE_FAST_OPEN
    /* Determine if a fast open is selected.  */
    if (open_type == FX_OPEN_FOR_READ_FAST)
 800b7d2:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 800b7d6:	2b02      	cmp	r3, #2
 800b7d8:	d106      	bne.n	800b7e8 <_fx_file_open+0x88>
    {

        /* Yes, convert the open type to a standard read.  */
        open_type =  FX_OPEN_FOR_READ;
 800b7da:	2300      	movs	r3, #0
 800b7dc:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140

        /* Set the open fast flag.  */
        fast_open =  FX_TRUE;
 800b7e0:	2301      	movs	r3, #1
 800b7e2:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168
 800b7e6:	e002      	b.n	800b7ee <_fx_file_open+0x8e>
    }
    else
    {

        /* A fast open is not selected, set the flag to false.  */
        fast_open =  FX_FALSE;
 800b7e8:	2300      	movs	r3, #0
 800b7ea:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168

    /* Protect against other threads accessing the media.  */
    FX_PROTECT

    /* Setup file name pointer.  */
    file_ptr -> fx_file_dir_entry.fx_dir_entry_name =  file_ptr -> fx_file_name_buffer;
 800b7ee:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 800b7f2:	f103 02d8 	add.w	r2, r3, #216	@ 0xd8
 800b7f6:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 800b7fa:	669a      	str	r2, [r3, #104]	@ 0x68
    file_ptr -> fx_file_dir_entry.fx_dir_entry_short_name[0] =  0;
 800b7fc:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 800b800:	2300      	movs	r3, #0
 800b802:	f882 306c 	strb.w	r3, [r2, #108]	@ 0x6c

    /* Search the system for the supplied file name.  */
    status =  _fx_directory_search(media_ptr, file_name, &(file_ptr -> fx_file_dir_entry), FX_NULL, FX_NULL);
 800b806:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 800b80a:	f103 0268 	add.w	r2, r3, #104	@ 0x68
 800b80e:	2300      	movs	r3, #0
 800b810:	9300      	str	r3, [sp, #0]
 800b812:	2300      	movs	r3, #0
 800b814:	f8d7 1144 	ldr.w	r1, [r7, #324]	@ 0x144
 800b818:	f8d7 014c 	ldr.w	r0, [r7, #332]	@ 0x14c
 800b81c:	f7fe febb 	bl	800a596 <_fx_directory_search>
 800b820:	f8c7 0160 	str.w	r0, [r7, #352]	@ 0x160

    /* Determine if the search was successful.  */
    if (status != FX_SUCCESS)
 800b824:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 800b828:	2b00      	cmp	r3, #0
 800b82a:	d003      	beq.n	800b834 <_fx_file_open+0xd4>

        /* Release media protection.  */
        FX_UNPROTECT

        /* Return the error code.  */
        return(status);
 800b82c:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 800b830:	f000 bc13 	b.w	800c05a <_fx_file_open+0x8fa>
    }

    /* Check to make sure the found entry is a file.  */
    if (file_ptr -> fx_file_dir_entry.fx_dir_entry_attributes & not_a_file_attr)
 800b834:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 800b838:	f893 2084 	ldrb.w	r2, [r3, #132]	@ 0x84
 800b83c:	f897 3167 	ldrb.w	r3, [r7, #359]	@ 0x167
 800b840:	4013      	ands	r3, r2
 800b842:	b2db      	uxtb	r3, r3
 800b844:	2b00      	cmp	r3, #0
 800b846:	d002      	beq.n	800b84e <_fx_file_open+0xee>

        /* Release media protection.  */
        FX_UNPROTECT

        /* Return the not a file error code.  */
        return(FX_NOT_A_FILE);
 800b848:	2305      	movs	r3, #5
 800b84a:	f000 bc06 	b.w	800c05a <_fx_file_open+0x8fa>
            open_count--;
        }
    }
    else
#else
    if (open_type == FX_OPEN_FOR_WRITE)
 800b84e:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 800b852:	2b01      	cmp	r3, #1
 800b854:	d149      	bne.n	800b8ea <_fx_file_open+0x18a>
    {

        /* A open for write request is present, check the file attributes
           and the list of open files for any other open instance of
           this file.  */
        if (media_ptr -> fx_media_driver_write_protect)
 800b856:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800b85a:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
 800b85e:	2b00      	cmp	r3, #0
 800b860:	d001      	beq.n	800b866 <_fx_file_open+0x106>

            /* Release media protection.  */
            FX_UNPROTECT

            /* Return write protect error.  */
            return(FX_WRITE_PROTECT);
 800b862:	2323      	movs	r3, #35	@ 0x23
 800b864:	e3f9      	b.n	800c05a <_fx_file_open+0x8fa>
        }

        if (file_ptr -> fx_file_dir_entry.fx_dir_entry_attributes & (UCHAR)(FX_READ_ONLY))
 800b866:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 800b86a:	f893 3084 	ldrb.w	r3, [r3, #132]	@ 0x84
 800b86e:	f003 0301 	and.w	r3, r3, #1
 800b872:	2b00      	cmp	r3, #0
 800b874:	d001      	beq.n	800b87a <_fx_file_open+0x11a>

            /* Release media protection.  */
            FX_UNPROTECT

            /* Return the not a file error code.  */
            return(FX_ACCESS_ERROR);
 800b876:	2306      	movs	r3, #6
 800b878:	e3ef      	b.n	800c05a <_fx_file_open+0x8fa>
        }

        /* Also search the opened files to see if this file is currently
           opened.  */
        open_count =  media_ptr -> fx_media_opened_file_count;
 800b87a:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800b87e:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
 800b882:	f8c7 318c 	str.w	r3, [r7, #396]	@ 0x18c
        search_ptr =  media_ptr -> fx_media_opened_file_list;
 800b886:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800b88a:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
 800b88e:	f8c7 3188 	str.w	r3, [r7, #392]	@ 0x188
        while (open_count)
 800b892:	e026      	b.n	800b8e2 <_fx_file_open+0x182>
                (search_ptr -> fx_file_dir_entry.fx_dir_entry_byte_offset ==
                 file_ptr -> fx_file_dir_entry.fx_dir_entry_byte_offset))
#else
            /* Look at each opened file to see if the same file is already opened
               for writing.  */
            if ((search_ptr -> fx_file_dir_entry.fx_dir_entry_log_sector ==
 800b894:	f8d7 3188 	ldr.w	r3, [r7, #392]	@ 0x188
 800b898:	e9d3 012a 	ldrd	r0, r1, [r3, #168]	@ 0xa8
                 file_ptr -> fx_file_dir_entry.fx_dir_entry_log_sector) &&
 800b89c:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 800b8a0:	e9d3 232a 	ldrd	r2, r3, [r3, #168]	@ 0xa8
            if ((search_ptr -> fx_file_dir_entry.fx_dir_entry_log_sector ==
 800b8a4:	4299      	cmp	r1, r3
 800b8a6:	bf08      	it	eq
 800b8a8:	4290      	cmpeq	r0, r2
 800b8aa:	d110      	bne.n	800b8ce <_fx_file_open+0x16e>
                (search_ptr -> fx_file_dir_entry.fx_dir_entry_byte_offset ==
 800b8ac:	f8d7 3188 	ldr.w	r3, [r7, #392]	@ 0x188
 800b8b0:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
                 file_ptr -> fx_file_dir_entry.fx_dir_entry_byte_offset) &&
 800b8b4:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 800b8b8:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
                 file_ptr -> fx_file_dir_entry.fx_dir_entry_log_sector) &&
 800b8bc:	429a      	cmp	r2, r3
 800b8be:	d106      	bne.n	800b8ce <_fx_file_open+0x16e>
                (search_ptr -> fx_file_open_mode == FX_OPEN_FOR_WRITE))
 800b8c0:	f8d7 3188 	ldr.w	r3, [r7, #392]	@ 0x188
 800b8c4:	689b      	ldr	r3, [r3, #8]
                 file_ptr -> fx_file_dir_entry.fx_dir_entry_byte_offset) &&
 800b8c6:	2b01      	cmp	r3, #1
 800b8c8:	d101      	bne.n	800b8ce <_fx_file_open+0x16e>

                /* Release media protection.  */
                FX_UNPROTECT

                /* The file is currently open.  */
                return(FX_ACCESS_ERROR);
 800b8ca:	2306      	movs	r3, #6
 800b8cc:	e3c5      	b.n	800c05a <_fx_file_open+0x8fa>
            }

            /* Adjust the pointer and decrement the search count.  */
            search_ptr =  search_ptr -> fx_file_opened_next;
 800b8ce:	f8d7 3188 	ldr.w	r3, [r7, #392]	@ 0x188
 800b8d2:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800b8d4:	f8c7 3188 	str.w	r3, [r7, #392]	@ 0x188
            open_count--;
 800b8d8:	f8d7 318c 	ldr.w	r3, [r7, #396]	@ 0x18c
 800b8dc:	3b01      	subs	r3, #1
 800b8de:	f8c7 318c 	str.w	r3, [r7, #396]	@ 0x18c
        while (open_count)
 800b8e2:	f8d7 318c 	ldr.w	r3, [r7, #396]	@ 0x18c
 800b8e6:	2b00      	cmp	r3, #0
 800b8e8:	d1d4      	bne.n	800b894 <_fx_file_open+0x134>
        }
    }

    /* At this point, we are ready to walk list of clusters to setup the
       initial condition of this file as well as to verify its integrity.  */
    cluster =           file_ptr -> fx_file_dir_entry.fx_dir_entry_cluster;
 800b8ea:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 800b8ee:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
 800b8f2:	f8c7 3190 	str.w	r3, [r7, #400]	@ 0x190
    bytes_remaining =   file_ptr -> fx_file_dir_entry.fx_dir_entry_file_size;
 800b8f6:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 800b8fa:	e9d3 2328 	ldrd	r2, r3, [r3, #160]	@ 0xa0
 800b8fe:	e9c7 235c 	strd	r2, r3, [r7, #368]	@ 0x170
    bytes_per_cluster = ((ULONG)media_ptr -> fx_media_bytes_per_sector) *
 800b902:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800b906:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
        ((ULONG)media_ptr -> fx_media_sectors_per_cluster);
 800b908:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800b90c:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
    bytes_per_cluster = ((ULONG)media_ptr -> fx_media_bytes_per_sector) *
 800b90e:	fb02 f303 	mul.w	r3, r2, r3
 800b912:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
    file_ptr -> fx_file_current_physical_cluster =  0;
 800b916:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 800b91a:	2300      	movs	r3, #0
 800b91c:	6213      	str	r3, [r2, #32]

    /* Check for invalid value.  */
    if (bytes_per_cluster == 0)
 800b91e:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 800b922:	2b00      	cmp	r3, #0
 800b924:	d101      	bne.n	800b92a <_fx_file_open+0x1ca>

        /* Release media protection.  */
        FX_UNPROTECT

        /* Invalid media, return error.  */
        return(FX_MEDIA_INVALID);
 800b926:	2302      	movs	r3, #2
 800b928:	e397      	b.n	800c05a <_fx_file_open+0x8fa>
    }

    last_cluster =      0;
 800b92a:	2300      	movs	r3, #0
 800b92c:	f8c7 3184 	str.w	r3, [r7, #388]	@ 0x184
    cluster_count =     0;
 800b930:	2300      	movs	r3, #0
 800b932:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180

#ifndef FX_DISABLE_CONSECUTIVE_DETECT
    leading_consecutive = 1;
 800b936:	2301      	movs	r3, #1
 800b938:	f8c7 3194 	str.w	r3, [r7, #404]	@ 0x194
#endif /* FX_DISABLE_CONSECUTIVE_DETECT */
    file_ptr -> fx_file_consecutive_cluster = 1;
 800b93c:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 800b940:	2301      	movs	r3, #1
 800b942:	6193      	str	r3, [r2, #24]
#ifndef FX_DISABLE_FAST_OPEN

    /* Determine if the file is being open for reading with the fast option.  */
    if (fast_open)
 800b944:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
 800b948:	2b00      	cmp	r3, #0
 800b94a:	f000 80f6 	beq.w	800bb3a <_fx_file_open+0x3da>
    {

        /* Calculate the bytes available.  */
        bytes_available =  ((bytes_remaining + bytes_per_cluster - 1) / bytes_per_cluster) * bytes_per_cluster;
 800b94e:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 800b952:	2200      	movs	r2, #0
 800b954:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
 800b958:	f8c7 211c 	str.w	r2, [r7, #284]	@ 0x11c
 800b95c:	e9d7 235c 	ldrd	r2, r3, [r7, #368]	@ 0x170
 800b960:	e9d7 8946 	ldrd	r8, r9, [r7, #280]	@ 0x118
 800b964:	4641      	mov	r1, r8
 800b966:	eb11 0a02 	adds.w	sl, r1, r2
 800b96a:	4649      	mov	r1, r9
 800b96c:	eb41 0b03 	adc.w	fp, r1, r3
 800b970:	f11a 33ff 	adds.w	r3, sl, #4294967295
 800b974:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
 800b978:	f14b 33ff 	adc.w	r3, fp, #4294967295
 800b97c:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
 800b980:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 800b984:	2200      	movs	r2, #0
 800b986:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
 800b98a:	f8c7 210c 	str.w	r2, [r7, #268]	@ 0x10c
 800b98e:	e9d7 2342 	ldrd	r2, r3, [r7, #264]	@ 0x108
 800b992:	e9d7 0144 	ldrd	r0, r1, [r7, #272]	@ 0x110
 800b996:	f7f4 fc6f 	bl	8000278 <__aeabi_uldivmod>
 800b99a:	4602      	mov	r2, r0
 800b99c:	460b      	mov	r3, r1
 800b99e:	4610      	mov	r0, r2
 800b9a0:	4619      	mov	r1, r3
 800b9a2:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 800b9a6:	2200      	movs	r2, #0
 800b9a8:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
 800b9ac:	f8c7 2104 	str.w	r2, [r7, #260]	@ 0x104
 800b9b0:	e9d7 8940 	ldrd	r8, r9, [r7, #256]	@ 0x100
 800b9b4:	4643      	mov	r3, r8
 800b9b6:	fb03 f201 	mul.w	r2, r3, r1
 800b9ba:	464b      	mov	r3, r9
 800b9bc:	fb00 f303 	mul.w	r3, r0, r3
 800b9c0:	4413      	add	r3, r2
 800b9c2:	4642      	mov	r2, r8
 800b9c4:	fba0 4502 	umull	r4, r5, r0, r2
 800b9c8:	442b      	add	r3, r5
 800b9ca:	461d      	mov	r5, r3
 800b9cc:	e9c7 455e 	strd	r4, r5, [r7, #376]	@ 0x178
 800b9d0:	e9c7 455e 	strd	r4, r5, [r7, #376]	@ 0x178
 800b9d4:	e11b      	b.n	800bc0e <_fx_file_open+0x4ae>
            /* Follow the link of FAT entries.  */
            while ((cluster >= FX_FAT_ENTRY_START) && (cluster < media_ptr -> fx_media_fat_reserved))
            {

                /* Increment the number of clusters.  */
                cluster_count++;
 800b9d6:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 800b9da:	3301      	adds	r3, #1
 800b9dc:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180

                /* Read the current cluster entry from the FAT.  */
                status =  _fx_utility_FAT_entry_read(media_ptr, cluster, &contents);
 800b9e0:	f507 73aa 	add.w	r3, r7, #340	@ 0x154
 800b9e4:	461a      	mov	r2, r3
 800b9e6:	f8d7 1190 	ldr.w	r1, [r7, #400]	@ 0x190
 800b9ea:	f8d7 014c 	ldr.w	r0, [r7, #332]	@ 0x14c
 800b9ee:	f002 ffd7 	bl	800e9a0 <_fx_utility_FAT_entry_read>
 800b9f2:	f8c7 0160 	str.w	r0, [r7, #352]	@ 0x160

                /* Check the return value.  */
                if (status != FX_SUCCESS)
 800b9f6:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 800b9fa:	2b00      	cmp	r3, #0
 800b9fc:	d002      	beq.n	800ba04 <_fx_file_open+0x2a4>

                    /* Release media protection.  */
                    FX_UNPROTECT

                    /* Return the error status.  */
                    return(status);
 800b9fe:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 800ba02:	e32a      	b.n	800c05a <_fx_file_open+0x8fa>
                }

                /* Determine if the cluster is invalid (points to itself) or the count exceeds the total number of clusters.  */
                if ((cluster == contents) || (cluster_count > media_ptr -> fx_media_total_clusters))
 800ba04:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 800ba08:	f8d7 3190 	ldr.w	r3, [r7, #400]	@ 0x190
 800ba0c:	4293      	cmp	r3, r2
 800ba0e:	d006      	beq.n	800ba1e <_fx_file_open+0x2be>
 800ba10:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800ba14:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 800ba16:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 800ba1a:	4293      	cmp	r3, r2
 800ba1c:	d901      	bls.n	800ba22 <_fx_file_open+0x2c2>

                    /* Release media protection.  */
                    FX_UNPROTECT

                    /* Return the bad status.  */
                    return(FX_FAT_READ_ERROR);
 800ba1e:	2303      	movs	r3, #3
 800ba20:	e31b      	b.n	800c05a <_fx_file_open+0x8fa>
                }

#ifndef FX_DISABLE_CONSECUTIVE_DETECT

                /* Check if present and next clusters are consecutive */
                if (cluster + 1 == contents)
 800ba22:	f8d7 3190 	ldr.w	r3, [r7, #400]	@ 0x190
 800ba26:	1c5a      	adds	r2, r3, #1
 800ba28:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 800ba2c:	429a      	cmp	r2, r3
 800ba2e:	d10b      	bne.n	800ba48 <_fx_file_open+0x2e8>
                {
            
                    /* Determine if clusters are consecutive so far.  */
                    if (leading_consecutive)
 800ba30:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
 800ba34:	2b00      	cmp	r3, #0
 800ba36:	d00a      	beq.n	800ba4e <_fx_file_open+0x2ee>
                    {

                        /* Yes, increment the number of leading consecutive clusters.  */
                        file_ptr -> fx_file_consecutive_cluster++;
 800ba38:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 800ba3c:	699b      	ldr	r3, [r3, #24]
 800ba3e:	1c5a      	adds	r2, r3, #1
 800ba40:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 800ba44:	619a      	str	r2, [r3, #24]
 800ba46:	e002      	b.n	800ba4e <_fx_file_open+0x2ee>
                }
                else
                {

                    /* The clusters are no longer consecutive, clear the consecutive flag.  */
                    leading_consecutive = 0;
 800ba48:	2300      	movs	r3, #0
 800ba4a:	f8c7 3194 	str.w	r3, [r7, #404]	@ 0x194
                }
#endif /* FX_DISABLE_CONSECUTIVE_DETECT */

                /* Save the last valid cluster.  */
                last_cluster =  cluster;
 800ba4e:	f8d7 3190 	ldr.w	r3, [r7, #400]	@ 0x190
 800ba52:	f8c7 3184 	str.w	r3, [r7, #388]	@ 0x184

                /* Setup for the next cluster.  */
                cluster =  contents;
 800ba56:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 800ba5a:	f8c7 3190 	str.w	r3, [r7, #400]	@ 0x190

                /* Determine if this is the last written cluster.  We need to remember this
                   for open for writing.  */
                if (bytes_remaining > bytes_per_cluster)
 800ba5e:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 800ba62:	2200      	movs	r2, #0
 800ba64:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
 800ba68:	f8c7 20fc 	str.w	r2, [r7, #252]	@ 0xfc
 800ba6c:	e9d7 235c 	ldrd	r2, r3, [r7, #368]	@ 0x170
 800ba70:	e9d7 453e 	ldrd	r4, r5, [r7, #248]	@ 0xf8
 800ba74:	4621      	mov	r1, r4
 800ba76:	4291      	cmp	r1, r2
 800ba78:	4629      	mov	r1, r5
 800ba7a:	eb71 0303 	sbcs.w	r3, r1, r3
 800ba7e:	d21b      	bcs.n	800bab8 <_fx_file_open+0x358>
                {

                    /* Still more written clusters, just decrement the counter.  */
                    bytes_remaining =  bytes_remaining - bytes_per_cluster;
 800ba80:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 800ba84:	2200      	movs	r2, #0
 800ba86:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
 800ba8a:	f8c7 20f4 	str.w	r2, [r7, #244]	@ 0xf4
 800ba8e:	e9d7 235c 	ldrd	r2, r3, [r7, #368]	@ 0x170
 800ba92:	e9d7 453c 	ldrd	r4, r5, [r7, #240]	@ 0xf0
 800ba96:	4621      	mov	r1, r4
 800ba98:	1a51      	subs	r1, r2, r1
 800ba9a:	6039      	str	r1, [r7, #0]
 800ba9c:	4629      	mov	r1, r5
 800ba9e:	eb63 0301 	sbc.w	r3, r3, r1
 800baa2:	607b      	str	r3, [r7, #4]
 800baa4:	e9d7 3400 	ldrd	r3, r4, [r7]
 800baa8:	e9c7 345c 	strd	r3, r4, [r7, #368]	@ 0x170
 800baac:	e045      	b.n	800bb3a <_fx_file_open+0x3da>
 800baae:	bf00      	nop
 800bab0:	4d454449 	.word	0x4d454449
 800bab4:	0ffffff8 	.word	0x0ffffff8
                }
                else if (!file_ptr -> fx_file_current_physical_cluster)
 800bab8:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 800babc:	6a1b      	ldr	r3, [r3, #32]
 800babe:	2b00      	cmp	r3, #0
 800bac0:	d13b      	bne.n	800bb3a <_fx_file_open+0x3da>
                {

                    /* Remember this cluster number.  */
                    file_ptr -> fx_file_current_physical_cluster =  last_cluster;
 800bac2:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 800bac6:	f8d7 3184 	ldr.w	r3, [r7, #388]	@ 0x184
 800baca:	6213      	str	r3, [r2, #32]

                    /* Remember the relative cluster.  */
                    file_ptr -> fx_file_current_relative_cluster =  cluster_count - 1;
 800bacc:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 800bad0:	1e5a      	subs	r2, r3, #1
 800bad2:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 800bad6:	635a      	str	r2, [r3, #52]	@ 0x34

                    /* If the remaining bytes exactly fits the cluster size, check for
                       a possible adjustment to the next cluster.  */
                    if ((bytes_remaining == bytes_per_cluster) &&
 800bad8:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 800badc:	2200      	movs	r2, #0
 800bade:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
 800bae2:	f8c7 20ec 	str.w	r2, [r7, #236]	@ 0xec
 800bae6:	e9d7 235c 	ldrd	r2, r3, [r7, #368]	@ 0x170
 800baea:	e9d7 453a 	ldrd	r4, r5, [r7, #232]	@ 0xe8
 800baee:	4621      	mov	r1, r4
 800baf0:	4628      	mov	r0, r5
 800baf2:	4283      	cmp	r3, r0
 800baf4:	bf08      	it	eq
 800baf6:	428a      	cmpeq	r2, r1
 800baf8:	d11f      	bne.n	800bb3a <_fx_file_open+0x3da>
 800bafa:	f8d7 3190 	ldr.w	r3, [r7, #400]	@ 0x190
 800bafe:	2b01      	cmp	r3, #1
 800bb00:	d91b      	bls.n	800bb3a <_fx_file_open+0x3da>
                        (cluster >= FX_FAT_ENTRY_START) && (cluster < media_ptr -> fx_media_fat_reserved))
 800bb02:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800bb06:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 800bb0a:	f8d3 2478 	ldr.w	r2, [r3, #1144]	@ 0x478
 800bb0e:	f8d7 3190 	ldr.w	r3, [r7, #400]	@ 0x190
 800bb12:	4293      	cmp	r3, r2
 800bb14:	d211      	bcs.n	800bb3a <_fx_file_open+0x3da>
                    {

                        /* We need to position to next allocated cluster.  */
                        file_ptr -> fx_file_current_physical_cluster =  cluster;
 800bb16:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 800bb1a:	f8d7 3190 	ldr.w	r3, [r7, #400]	@ 0x190
 800bb1e:	6213      	str	r3, [r2, #32]
                        file_ptr -> fx_file_current_relative_cluster++;
 800bb20:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 800bb24:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800bb26:	1c5a      	adds	r2, r3, #1
 800bb28:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 800bb2c:	635a      	str	r2, [r3, #52]	@ 0x34

                        /* Clear the remaining bytes.  */
                        bytes_remaining =  0;
 800bb2e:	f04f 0200 	mov.w	r2, #0
 800bb32:	f04f 0300 	mov.w	r3, #0
 800bb36:	e9c7 235c 	strd	r2, r3, [r7, #368]	@ 0x170
            while ((cluster >= FX_FAT_ENTRY_START) && (cluster < media_ptr -> fx_media_fat_reserved))
 800bb3a:	f8d7 3190 	ldr.w	r3, [r7, #400]	@ 0x190
 800bb3e:	2b01      	cmp	r3, #1
 800bb40:	d90a      	bls.n	800bb58 <_fx_file_open+0x3f8>
 800bb42:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800bb46:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 800bb4a:	f8d3 2478 	ldr.w	r2, [r3, #1144]	@ 0x478
 800bb4e:	f8d7 3190 	ldr.w	r3, [r7, #400]	@ 0x190
 800bb52:	4293      	cmp	r3, r2
 800bb54:	f4ff af3f 	bcc.w	800b9d6 <_fx_file_open+0x276>
                }
            }

            /* Determine if the number of clusters is large enough to support the
               specified file size.  */
            bytes_available =  ((ULONG64)media_ptr -> fx_media_bytes_per_sector) *
 800bb58:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800bb5c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800bb5e:	2200      	movs	r2, #0
 800bb60:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
 800bb64:	f8c7 20e4 	str.w	r2, [r7, #228]	@ 0xe4
                ((ULONG64)media_ptr -> fx_media_sectors_per_cluster) *
 800bb68:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800bb6c:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800bb6e:	2200      	movs	r2, #0
 800bb70:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
 800bb74:	f8c7 20dc 	str.w	r2, [r7, #220]	@ 0xdc
            bytes_available =  ((ULONG64)media_ptr -> fx_media_bytes_per_sector) *
 800bb78:	e9d7 4538 	ldrd	r4, r5, [r7, #224]	@ 0xe0
 800bb7c:	462b      	mov	r3, r5
 800bb7e:	e9d7 ab36 	ldrd	sl, fp, [r7, #216]	@ 0xd8
 800bb82:	4652      	mov	r2, sl
 800bb84:	fb02 f203 	mul.w	r2, r2, r3
 800bb88:	465b      	mov	r3, fp
 800bb8a:	4621      	mov	r1, r4
 800bb8c:	fb01 f303 	mul.w	r3, r1, r3
 800bb90:	4413      	add	r3, r2
 800bb92:	4622      	mov	r2, r4
 800bb94:	4651      	mov	r1, sl
 800bb96:	fba2 8901 	umull	r8, r9, r2, r1
 800bb9a:	444b      	add	r3, r9
 800bb9c:	4699      	mov	r9, r3
                ((ULONG64)cluster_count);
 800bb9e:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 800bba2:	2200      	movs	r2, #0
 800bba4:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
 800bba8:	f8c7 20d4 	str.w	r2, [r7, #212]	@ 0xd4
            bytes_available =  ((ULONG64)media_ptr -> fx_media_bytes_per_sector) *
 800bbac:	e9d7 0134 	ldrd	r0, r1, [r7, #208]	@ 0xd0
 800bbb0:	4603      	mov	r3, r0
 800bbb2:	fb03 f209 	mul.w	r2, r3, r9
 800bbb6:	460b      	mov	r3, r1
 800bbb8:	fb08 f303 	mul.w	r3, r8, r3
 800bbbc:	4413      	add	r3, r2
 800bbbe:	4602      	mov	r2, r0
 800bbc0:	fba8 1202 	umull	r1, r2, r8, r2
 800bbc4:	f8c7 2124 	str.w	r2, [r7, #292]	@ 0x124
 800bbc8:	460a      	mov	r2, r1
 800bbca:	f8c7 2120 	str.w	r2, [r7, #288]	@ 0x120
 800bbce:	f8d7 2124 	ldr.w	r2, [r7, #292]	@ 0x124
 800bbd2:	4413      	add	r3, r2
 800bbd4:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
 800bbd8:	e9d7 3448 	ldrd	r3, r4, [r7, #288]	@ 0x120
 800bbdc:	e9c7 345e 	strd	r3, r4, [r7, #376]	@ 0x178
 800bbe0:	e9c7 345e 	strd	r3, r4, [r7, #376]	@ 0x178

            /* Check the bytes available in the cluster chain against the directory entry file size.  */
            if ((bytes_available < file_ptr -> fx_file_dir_entry.fx_dir_entry_file_size) ||
 800bbe4:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 800bbe8:	e9d3 0128 	ldrd	r0, r1, [r3, #160]	@ 0xa0
 800bbec:	e9d7 235e 	ldrd	r2, r3, [r7, #376]	@ 0x178
 800bbf0:	4282      	cmp	r2, r0
 800bbf2:	418b      	sbcs	r3, r1
 800bbf4:	d309      	bcc.n	800bc0a <_fx_file_open+0x4aa>
 800bbf6:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 800bbfa:	2b00      	cmp	r3, #0
 800bbfc:	d007      	beq.n	800bc0e <_fx_file_open+0x4ae>
                ((cluster_count) && (contents < fat_last)))
 800bbfe:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 800bc02:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 800bc06:	4293      	cmp	r3, r2
 800bc08:	d901      	bls.n	800bc0e <_fx_file_open+0x4ae>
            {
                /* File is corrupt, release media protection.  */
                FX_UNPROTECT

                /* Return a corrupt file error status.  */
                return(FX_FILE_CORRUPT);
 800bc0a:	2308      	movs	r3, #8
 800bc0c:	e225      	b.n	800c05a <_fx_file_open+0x8fa>
#endif /* FX_ENABLE_EXFAT */
    }

    /* The file is okay, populate the file control block and complete the
       file open process.  */
    file_ptr -> fx_file_id =                        FX_FILE_ID;
 800bc0e:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 800bc12:	4baa      	ldr	r3, [pc, #680]	@ (800bebc <_fx_file_open+0x75c>)
 800bc14:	6013      	str	r3, [r2, #0]
    file_ptr -> fx_file_name =                      file_ptr -> fx_file_name_buffer;
 800bc16:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 800bc1a:	f103 02d8 	add.w	r2, r3, #216	@ 0xd8
 800bc1e:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 800bc22:	605a      	str	r2, [r3, #4]
    file_ptr -> fx_file_media_ptr =                 media_ptr;
 800bc24:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 800bc28:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800bc2c:	6593      	str	r3, [r2, #88]	@ 0x58
    file_ptr -> fx_file_open_mode =                 open_type;
 800bc2e:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 800bc32:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 800bc36:	6093      	str	r3, [r2, #8]
    file_ptr -> fx_file_modified =                  FX_FALSE;
 800bc38:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 800bc3c:	2300      	movs	r3, #0
 800bc3e:	7313      	strb	r3, [r2, #12]
    file_ptr -> fx_file_total_clusters =            cluster_count;
 800bc40:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 800bc44:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 800bc48:	6113      	str	r3, [r2, #16]
    file_ptr -> fx_file_first_physical_cluster =    file_ptr -> fx_file_dir_entry.fx_dir_entry_cluster;
 800bc4a:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 800bc4e:	f8d3 209c 	ldr.w	r2, [r3, #156]	@ 0x9c
 800bc52:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 800bc56:	615a      	str	r2, [r3, #20]
    file_ptr -> fx_file_last_physical_cluster =     last_cluster;
 800bc58:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 800bc5c:	f8d7 3184 	ldr.w	r3, [r7, #388]	@ 0x184
 800bc60:	61d3      	str	r3, [r2, #28]
    file_ptr -> fx_file_current_file_size =         file_ptr -> fx_file_dir_entry.fx_dir_entry_file_size;
 800bc62:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 800bc66:	e9d3 0128 	ldrd	r0, r1, [r3, #160]	@ 0xa0
 800bc6a:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 800bc6e:	e9c3 0112 	strd	r0, r1, [r3, #72]	@ 0x48
    file_ptr -> fx_file_current_available_size =    bytes_available;
 800bc72:	f8d7 1148 	ldr.w	r1, [r7, #328]	@ 0x148
 800bc76:	e9d7 235e 	ldrd	r2, r3, [r7, #376]	@ 0x178
 800bc7a:	e9c1 2314 	strd	r2, r3, [r1, #80]	@ 0x50
    file_ptr -> fx_file_disable_burst_cache =       FX_FALSE;
 800bc7e:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 800bc82:	2300      	movs	r3, #0
 800bc84:	f8c2 31d8 	str.w	r3, [r2, #472]	@ 0x1d8

    /* Set the current settings based on how the file was opened.  */
    if (open_type == FX_OPEN_FOR_READ)
 800bc88:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 800bc8c:	2b00      	cmp	r3, #0
 800bc8e:	d163      	bne.n	800bd58 <_fx_file_open+0x5f8>
    {

        /* Position the pointers to the beginning of the file.  */
        file_ptr -> fx_file_current_physical_cluster =  file_ptr -> fx_file_first_physical_cluster;
 800bc90:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 800bc94:	695a      	ldr	r2, [r3, #20]
 800bc96:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 800bc9a:	621a      	str	r2, [r3, #32]
        file_ptr -> fx_file_current_relative_cluster =  0;
 800bc9c:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 800bca0:	2200      	movs	r2, #0
 800bca2:	635a      	str	r2, [r3, #52]	@ 0x34
        file_ptr -> fx_file_current_logical_sector =    ((ULONG)media_ptr -> fx_media_data_sector_start) +
 800bca4:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800bca8:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800bcaa:	2200      	movs	r2, #0
 800bcac:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 800bcb0:	f8c7 20cc 	str.w	r2, [r7, #204]	@ 0xcc
            (((ULONG64)(file_ptr -> fx_file_first_physical_cluster - FX_FAT_ENTRY_START)) *
 800bcb4:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 800bcb8:	695b      	ldr	r3, [r3, #20]
 800bcba:	3b02      	subs	r3, #2
 800bcbc:	2200      	movs	r2, #0
 800bcbe:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
 800bcc2:	f8c7 20c4 	str.w	r2, [r7, #196]	@ 0xc4
             ((ULONG)media_ptr -> fx_media_sectors_per_cluster));
 800bcc6:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800bcca:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800bccc:	2200      	movs	r2, #0
 800bcce:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
 800bcd2:	f8c7 20bc 	str.w	r2, [r7, #188]	@ 0xbc
            (((ULONG64)(file_ptr -> fx_file_first_physical_cluster - FX_FAT_ENTRY_START)) *
 800bcd6:	e9d7 4530 	ldrd	r4, r5, [r7, #192]	@ 0xc0
 800bcda:	462b      	mov	r3, r5
 800bcdc:	e9d7 892e 	ldrd	r8, r9, [r7, #184]	@ 0xb8
 800bce0:	4642      	mov	r2, r8
 800bce2:	fb02 f203 	mul.w	r2, r2, r3
 800bce6:	464b      	mov	r3, r9
 800bce8:	4621      	mov	r1, r4
 800bcea:	fb01 f303 	mul.w	r3, r1, r3
 800bcee:	4413      	add	r3, r2
 800bcf0:	4622      	mov	r2, r4
 800bcf2:	4641      	mov	r1, r8
 800bcf4:	fba2 1201 	umull	r1, r2, r2, r1
 800bcf8:	f8c7 213c 	str.w	r2, [r7, #316]	@ 0x13c
 800bcfc:	460a      	mov	r2, r1
 800bcfe:	f8c7 2138 	str.w	r2, [r7, #312]	@ 0x138
 800bd02:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
 800bd06:	4413      	add	r3, r2
 800bd08:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
        file_ptr -> fx_file_current_logical_sector =    ((ULONG)media_ptr -> fx_media_data_sector_start) +
 800bd0c:	e9d7 4532 	ldrd	r4, r5, [r7, #200]	@ 0xc8
 800bd10:	4623      	mov	r3, r4
 800bd12:	e9d7 014e 	ldrd	r0, r1, [r7, #312]	@ 0x138
 800bd16:	4602      	mov	r2, r0
 800bd18:	189b      	adds	r3, r3, r2
 800bd1a:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
 800bd1e:	460b      	mov	r3, r1
 800bd20:	462a      	mov	r2, r5
 800bd22:	eb42 0303 	adc.w	r3, r2, r3
 800bd26:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
 800bd2a:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 800bd2e:	e9d7 122c 	ldrd	r1, r2, [r7, #176]	@ 0xb0
 800bd32:	e9c3 120a 	strd	r1, r2, [r3, #40]	@ 0x28
        file_ptr -> fx_file_current_relative_sector =   0;
 800bd36:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 800bd3a:	2200      	movs	r2, #0
 800bd3c:	639a      	str	r2, [r3, #56]	@ 0x38
        file_ptr -> fx_file_current_logical_offset =    0;
 800bd3e:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 800bd42:	2200      	movs	r2, #0
 800bd44:	631a      	str	r2, [r3, #48]	@ 0x30
        file_ptr -> fx_file_current_file_offset =       0;
 800bd46:	f8d7 1148 	ldr.w	r1, [r7, #328]	@ 0x148
 800bd4a:	f04f 0200 	mov.w	r2, #0
 800bd4e:	f04f 0300 	mov.w	r3, #0
 800bd52:	e9c1 2310 	strd	r2, r3, [r1, #64]	@ 0x40
 800bd56:	e140      	b.n	800bfda <_fx_file_open+0x87a>
    {

        /* Open for writing - position the pointers to the end of the file.  */

        /* Determine if the remaining bytes fit exactly into the cluster size.  */
        if (bytes_remaining == bytes_per_cluster)
 800bd58:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 800bd5c:	2200      	movs	r2, #0
 800bd5e:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
 800bd62:	f8c7 20ac 	str.w	r2, [r7, #172]	@ 0xac
 800bd66:	e9d7 235c 	ldrd	r2, r3, [r7, #368]	@ 0x170
 800bd6a:	e9d7 452a 	ldrd	r4, r5, [r7, #168]	@ 0xa8
 800bd6e:	4621      	mov	r1, r4
 800bd70:	4628      	mov	r0, r5
 800bd72:	4283      	cmp	r3, r0
 800bd74:	bf08      	it	eq
 800bd76:	428a      	cmpeq	r2, r1
 800bd78:	f040 80a2 	bne.w	800bec0 <_fx_file_open+0x760>
        {

            /* Position to the end of the cluster.  */
            file_ptr -> fx_file_current_logical_sector =    ((ULONG)media_ptr -> fx_media_data_sector_start) +
 800bd7c:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800bd80:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800bd82:	2200      	movs	r2, #0
 800bd84:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
 800bd88:	f8c7 20a4 	str.w	r2, [r7, #164]	@ 0xa4
                (((ULONG64)file_ptr -> fx_file_current_physical_cluster - FX_FAT_ENTRY_START) *
 800bd8c:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 800bd90:	6a1b      	ldr	r3, [r3, #32]
 800bd92:	2200      	movs	r2, #0
 800bd94:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
 800bd98:	f8c7 209c 	str.w	r2, [r7, #156]	@ 0x9c
 800bd9c:	e9d7 1226 	ldrd	r1, r2, [r7, #152]	@ 0x98
 800bda0:	460b      	mov	r3, r1
 800bda2:	3b02      	subs	r3, #2
 800bda4:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
 800bda8:	4613      	mov	r3, r2
 800bdaa:	f143 33ff 	adc.w	r3, r3, #4294967295
 800bdae:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
                 ((ULONG)media_ptr -> fx_media_sectors_per_cluster)) +
 800bdb2:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800bdb6:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800bdb8:	2200      	movs	r2, #0
 800bdba:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
 800bdbe:	f8c7 208c 	str.w	r2, [r7, #140]	@ 0x8c
                (((ULONG64)file_ptr -> fx_file_current_physical_cluster - FX_FAT_ENTRY_START) *
 800bdc2:	e9d7 4524 	ldrd	r4, r5, [r7, #144]	@ 0x90
 800bdc6:	462b      	mov	r3, r5
 800bdc8:	e9d7 8922 	ldrd	r8, r9, [r7, #136]	@ 0x88
 800bdcc:	4642      	mov	r2, r8
 800bdce:	fb02 f203 	mul.w	r2, r2, r3
 800bdd2:	464b      	mov	r3, r9
 800bdd4:	4621      	mov	r1, r4
 800bdd6:	fb01 f303 	mul.w	r3, r1, r3
 800bdda:	4413      	add	r3, r2
 800bddc:	4622      	mov	r2, r4
 800bdde:	4641      	mov	r1, r8
 800bde0:	fba2 1201 	umull	r1, r2, r2, r1
 800bde4:	f8c7 2134 	str.w	r2, [r7, #308]	@ 0x134
 800bde8:	460a      	mov	r2, r1
 800bdea:	f8c7 2130 	str.w	r2, [r7, #304]	@ 0x130
 800bdee:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 800bdf2:	4413      	add	r3, r2
 800bdf4:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
            file_ptr -> fx_file_current_logical_sector =    ((ULONG)media_ptr -> fx_media_data_sector_start) +
 800bdf8:	e9d7 4528 	ldrd	r4, r5, [r7, #160]	@ 0xa0
 800bdfc:	4623      	mov	r3, r4
 800bdfe:	e9d7 014c 	ldrd	r0, r1, [r7, #304]	@ 0x130
 800be02:	4602      	mov	r2, r0
 800be04:	189b      	adds	r3, r3, r2
 800be06:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
 800be0a:	460b      	mov	r3, r1
 800be0c:	462a      	mov	r2, r5
 800be0e:	eb42 0303 	adc.w	r3, r2, r3
 800be12:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
                ((ULONG)(((bytes_remaining - 1) / (ULONG)media_ptr -> fx_media_bytes_per_sector)));
 800be16:	e9d7 235c 	ldrd	r2, r3, [r7, #368]	@ 0x170
 800be1a:	1e51      	subs	r1, r2, #1
 800be1c:	67b9      	str	r1, [r7, #120]	@ 0x78
 800be1e:	f143 33ff 	adc.w	r3, r3, #4294967295
 800be22:	67fb      	str	r3, [r7, #124]	@ 0x7c
 800be24:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800be28:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800be2a:	2200      	movs	r2, #0
 800be2c:	673b      	str	r3, [r7, #112]	@ 0x70
 800be2e:	677a      	str	r2, [r7, #116]	@ 0x74
 800be30:	e9d7 231c 	ldrd	r2, r3, [r7, #112]	@ 0x70
 800be34:	e9d7 011e 	ldrd	r0, r1, [r7, #120]	@ 0x78
 800be38:	f7f4 fa1e 	bl	8000278 <__aeabi_uldivmod>
 800be3c:	4602      	mov	r2, r0
 800be3e:	460b      	mov	r3, r1
 800be40:	2300      	movs	r3, #0
 800be42:	66ba      	str	r2, [r7, #104]	@ 0x68
 800be44:	66fb      	str	r3, [r7, #108]	@ 0x6c
                 ((ULONG)media_ptr -> fx_media_sectors_per_cluster)) +
 800be46:	e9d7 4520 	ldrd	r4, r5, [r7, #128]	@ 0x80
 800be4a:	4623      	mov	r3, r4
 800be4c:	e9d7 011a 	ldrd	r0, r1, [r7, #104]	@ 0x68
 800be50:	4602      	mov	r2, r0
 800be52:	189b      	adds	r3, r3, r2
 800be54:	663b      	str	r3, [r7, #96]	@ 0x60
 800be56:	460b      	mov	r3, r1
 800be58:	462a      	mov	r2, r5
 800be5a:	eb42 0303 	adc.w	r3, r2, r3
 800be5e:	667b      	str	r3, [r7, #100]	@ 0x64
            file_ptr -> fx_file_current_logical_sector =    ((ULONG)media_ptr -> fx_media_data_sector_start) +
 800be60:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 800be64:	e9d7 1218 	ldrd	r1, r2, [r7, #96]	@ 0x60
 800be68:	e9c3 120a 	strd	r1, r2, [r3, #40]	@ 0x28
            file_ptr -> fx_file_current_relative_sector =   (ULONG)(((bytes_remaining - 1) / (ULONG)media_ptr -> fx_media_bytes_per_sector));
 800be6c:	e9d7 235c 	ldrd	r2, r3, [r7, #368]	@ 0x170
 800be70:	1e51      	subs	r1, r2, #1
 800be72:	65b9      	str	r1, [r7, #88]	@ 0x58
 800be74:	f143 33ff 	adc.w	r3, r3, #4294967295
 800be78:	65fb      	str	r3, [r7, #92]	@ 0x5c
 800be7a:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800be7e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800be80:	2200      	movs	r2, #0
 800be82:	653b      	str	r3, [r7, #80]	@ 0x50
 800be84:	657a      	str	r2, [r7, #84]	@ 0x54
 800be86:	e9d7 2314 	ldrd	r2, r3, [r7, #80]	@ 0x50
 800be8a:	e9d7 0116 	ldrd	r0, r1, [r7, #88]	@ 0x58
 800be8e:	f7f4 f9f3 	bl	8000278 <__aeabi_uldivmod>
 800be92:	4602      	mov	r2, r0
 800be94:	460b      	mov	r3, r1
 800be96:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 800be9a:	639a      	str	r2, [r3, #56]	@ 0x38
            file_ptr -> fx_file_current_file_offset =       file_ptr -> fx_file_current_file_size;
 800be9c:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 800bea0:	e9d3 2312 	ldrd	r2, r3, [r3, #72]	@ 0x48
 800bea4:	f8d7 1148 	ldr.w	r1, [r7, #328]	@ 0x148
 800bea8:	e9c1 2310 	strd	r2, r3, [r1, #64]	@ 0x40
            file_ptr -> fx_file_current_logical_offset =    media_ptr -> fx_media_bytes_per_sector;
 800beac:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800beb0:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 800beb2:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 800beb6:	631a      	str	r2, [r3, #48]	@ 0x30
 800beb8:	e08f      	b.n	800bfda <_fx_file_open+0x87a>
 800beba:	bf00      	nop
 800bebc:	46494c45 	.word	0x46494c45
        }
        else
        {

            /* Position file parameters at end of last cluster allocation.  */
            file_ptr -> fx_file_current_logical_sector =    ((ULONG)media_ptr -> fx_media_data_sector_start) +
 800bec0:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800bec4:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800bec6:	2200      	movs	r2, #0
 800bec8:	64bb      	str	r3, [r7, #72]	@ 0x48
 800beca:	64fa      	str	r2, [r7, #76]	@ 0x4c
                (((ULONG64)file_ptr -> fx_file_current_physical_cluster - FX_FAT_ENTRY_START) *
 800becc:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 800bed0:	6a1b      	ldr	r3, [r3, #32]
 800bed2:	2200      	movs	r2, #0
 800bed4:	643b      	str	r3, [r7, #64]	@ 0x40
 800bed6:	647a      	str	r2, [r7, #68]	@ 0x44
 800bed8:	e9d7 1210 	ldrd	r1, r2, [r7, #64]	@ 0x40
 800bedc:	460b      	mov	r3, r1
 800bede:	3b02      	subs	r3, #2
 800bee0:	63bb      	str	r3, [r7, #56]	@ 0x38
 800bee2:	4613      	mov	r3, r2
 800bee4:	f143 33ff 	adc.w	r3, r3, #4294967295
 800bee8:	63fb      	str	r3, [r7, #60]	@ 0x3c
                 ((ULONG)media_ptr -> fx_media_sectors_per_cluster)) +
 800beea:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800beee:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800bef0:	2200      	movs	r2, #0
 800bef2:	633b      	str	r3, [r7, #48]	@ 0x30
 800bef4:	637a      	str	r2, [r7, #52]	@ 0x34
                (((ULONG64)file_ptr -> fx_file_current_physical_cluster - FX_FAT_ENTRY_START) *
 800bef6:	e9d7 450e 	ldrd	r4, r5, [r7, #56]	@ 0x38
 800befa:	462b      	mov	r3, r5
 800befc:	e9d7 890c 	ldrd	r8, r9, [r7, #48]	@ 0x30
 800bf00:	4642      	mov	r2, r8
 800bf02:	fb02 f203 	mul.w	r2, r2, r3
 800bf06:	464b      	mov	r3, r9
 800bf08:	4621      	mov	r1, r4
 800bf0a:	fb01 f303 	mul.w	r3, r1, r3
 800bf0e:	4413      	add	r3, r2
 800bf10:	4622      	mov	r2, r4
 800bf12:	4641      	mov	r1, r8
 800bf14:	fba2 1201 	umull	r1, r2, r2, r1
 800bf18:	f8c7 212c 	str.w	r2, [r7, #300]	@ 0x12c
 800bf1c:	460a      	mov	r2, r1
 800bf1e:	f8c7 2128 	str.w	r2, [r7, #296]	@ 0x128
 800bf22:	f8d7 212c 	ldr.w	r2, [r7, #300]	@ 0x12c
 800bf26:	4413      	add	r3, r2
 800bf28:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
            file_ptr -> fx_file_current_logical_sector =    ((ULONG)media_ptr -> fx_media_data_sector_start) +
 800bf2c:	e9d7 4512 	ldrd	r4, r5, [r7, #72]	@ 0x48
 800bf30:	4623      	mov	r3, r4
 800bf32:	e9d7 014a 	ldrd	r0, r1, [r7, #296]	@ 0x128
 800bf36:	4602      	mov	r2, r0
 800bf38:	189b      	adds	r3, r3, r2
 800bf3a:	62bb      	str	r3, [r7, #40]	@ 0x28
 800bf3c:	460b      	mov	r3, r1
 800bf3e:	462a      	mov	r2, r5
 800bf40:	eb42 0303 	adc.w	r3, r2, r3
 800bf44:	62fb      	str	r3, [r7, #44]	@ 0x2c
                ((ULONG)((bytes_remaining / (ULONG)media_ptr -> fx_media_bytes_per_sector)));
 800bf46:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800bf4a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800bf4c:	2200      	movs	r2, #0
 800bf4e:	623b      	str	r3, [r7, #32]
 800bf50:	627a      	str	r2, [r7, #36]	@ 0x24
 800bf52:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 800bf56:	e9d7 015c 	ldrd	r0, r1, [r7, #368]	@ 0x170
 800bf5a:	f7f4 f98d 	bl	8000278 <__aeabi_uldivmod>
 800bf5e:	4602      	mov	r2, r0
 800bf60:	460b      	mov	r3, r1
 800bf62:	2300      	movs	r3, #0
 800bf64:	61ba      	str	r2, [r7, #24]
 800bf66:	61fb      	str	r3, [r7, #28]
                 ((ULONG)media_ptr -> fx_media_sectors_per_cluster)) +
 800bf68:	e9d7 450a 	ldrd	r4, r5, [r7, #40]	@ 0x28
 800bf6c:	4623      	mov	r3, r4
 800bf6e:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 800bf72:	4602      	mov	r2, r0
 800bf74:	189b      	adds	r3, r3, r2
 800bf76:	613b      	str	r3, [r7, #16]
 800bf78:	460b      	mov	r3, r1
 800bf7a:	462a      	mov	r2, r5
 800bf7c:	eb42 0303 	adc.w	r3, r2, r3
 800bf80:	617b      	str	r3, [r7, #20]
            file_ptr -> fx_file_current_logical_sector =    ((ULONG)media_ptr -> fx_media_data_sector_start) +
 800bf82:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 800bf86:	e9d7 1204 	ldrd	r1, r2, [r7, #16]
 800bf8a:	e9c3 120a 	strd	r1, r2, [r3, #40]	@ 0x28
            file_ptr -> fx_file_current_relative_sector =   (ULONG)((bytes_remaining / (ULONG)media_ptr -> fx_media_bytes_per_sector));
 800bf8e:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800bf92:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800bf94:	2200      	movs	r2, #0
 800bf96:	60bb      	str	r3, [r7, #8]
 800bf98:	60fa      	str	r2, [r7, #12]
 800bf9a:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 800bf9e:	e9d7 015c 	ldrd	r0, r1, [r7, #368]	@ 0x170
 800bfa2:	f7f4 f969 	bl	8000278 <__aeabi_uldivmod>
 800bfa6:	4602      	mov	r2, r0
 800bfa8:	460b      	mov	r3, r1
 800bfaa:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 800bfae:	639a      	str	r2, [r3, #56]	@ 0x38
            file_ptr -> fx_file_current_file_offset =       file_ptr -> fx_file_current_file_size;
 800bfb0:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 800bfb4:	e9d3 2312 	ldrd	r2, r3, [r3, #72]	@ 0x48
 800bfb8:	f8d7 1148 	ldr.w	r1, [r7, #328]	@ 0x148
 800bfbc:	e9c1 2310 	strd	r2, r3, [r1, #64]	@ 0x40
            file_ptr -> fx_file_current_logical_offset =    (ULONG)bytes_remaining % ((ULONG)media_ptr -> fx_media_bytes_per_sector);
 800bfc0:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 800bfc4:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 800bfc8:	6a92      	ldr	r2, [r2, #40]	@ 0x28
 800bfca:	fbb3 f1f2 	udiv	r1, r3, r2
 800bfce:	fb01 f202 	mul.w	r2, r1, r2
 800bfd2:	1a9a      	subs	r2, r3, r2
 800bfd4:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 800bfd8:	631a      	str	r2, [r3, #48]	@ 0x30
    file_ptr -> fx_file_maximum_size_used = file_ptr -> fx_file_current_file_size;
#endif /* FX_ENABLE_FAULT_TOLERANT */

    /* Place newly opened file on the list of open files for
       this media.  First, check for an empty list.  */
    if (media_ptr -> fx_media_opened_file_list)
 800bfda:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800bfde:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
 800bfe2:	2b00      	cmp	r3, #0
 800bfe4:	d01f      	beq.n	800c026 <_fx_file_open+0x8c6>
    {

        /* Pickup tail pointer.  */
        tail_ptr =  (media_ptr -> fx_media_opened_file_list) -> fx_file_opened_previous;
 800bfe6:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800bfea:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
 800bfee:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 800bff0:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158

        /* Place the new file in the list.  */
        (media_ptr -> fx_media_opened_file_list) -> fx_file_opened_previous =  file_ptr;
 800bff4:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800bff8:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
 800bffc:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 800c000:	661a      	str	r2, [r3, #96]	@ 0x60
        tail_ptr -> fx_file_opened_next =  file_ptr;
 800c002:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 800c006:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 800c00a:	65da      	str	r2, [r3, #92]	@ 0x5c

        /* Setup this file's opened links.  */
        file_ptr -> fx_file_opened_previous =  tail_ptr;
 800c00c:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 800c010:	f8d7 2158 	ldr.w	r2, [r7, #344]	@ 0x158
 800c014:	661a      	str	r2, [r3, #96]	@ 0x60
        file_ptr -> fx_file_opened_next =      media_ptr -> fx_media_opened_file_list;
 800c016:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800c01a:	f8d3 20c8 	ldr.w	r2, [r3, #200]	@ 0xc8
 800c01e:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 800c022:	65da      	str	r2, [r3, #92]	@ 0x5c
 800c024:	e00f      	b.n	800c046 <_fx_file_open+0x8e6>
    }
    else
    {

        /* The opened media list is empty.  Add the media to empty list.  */
        media_ptr -> fx_media_opened_file_list =   file_ptr;
 800c026:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800c02a:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 800c02e:	f8c3 20c8 	str.w	r2, [r3, #200]	@ 0xc8
        file_ptr ->  fx_file_opened_next =         file_ptr;
 800c032:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 800c036:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 800c03a:	65da      	str	r2, [r3, #92]	@ 0x5c
        file_ptr ->  fx_file_opened_previous =     file_ptr;
 800c03c:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 800c040:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 800c044:	661a      	str	r2, [r3, #96]	@ 0x60
    }

    /* Increment the opened file counter.  */
    media_ptr -> fx_media_opened_file_count++;
 800c046:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800c04a:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
 800c04e:	1c5a      	adds	r2, r3, #1
 800c050:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 800c054:	f8c3 20cc 	str.w	r2, [r3, #204]	@ 0xcc

    /* Release media protection.  */
    FX_UNPROTECT

    /* Open is complete, return successful status.  */
    return(FX_SUCCESS);
 800c058:	2300      	movs	r3, #0
}
 800c05a:	4618      	mov	r0, r3
 800c05c:	f507 77cc 	add.w	r7, r7, #408	@ 0x198
 800c060:	46bd      	mov	sp, r7
 800c062:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 800c066:	bf00      	nop

0800c068 <_fx_file_read>:
/*                                            memcpy usage,               */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _fx_file_read(FX_FILE *file_ptr, VOID *buffer_ptr, ULONG request_size, ULONG *actual_size)
{
 800c068:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 800c06c:	b0aa      	sub	sp, #168	@ 0xa8
 800c06e:	af04      	add	r7, sp, #16
 800c070:	66f8      	str	r0, [r7, #108]	@ 0x6c
 800c072:	66b9      	str	r1, [r7, #104]	@ 0x68
 800c074:	667a      	str	r2, [r7, #100]	@ 0x64
 800c076:	663b      	str	r3, [r7, #96]	@ 0x60
ULONG                  trace_timestamp;
#endif


    /* First, determine if the file is still open.  */
    if (file_ptr -> fx_file_id != FX_FILE_ID)
 800c078:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800c07a:	681a      	ldr	r2, [r3, #0]
 800c07c:	4b99      	ldr	r3, [pc, #612]	@ (800c2e4 <_fx_file_read+0x27c>)
 800c07e:	429a      	cmp	r2, r3
 800c080:	d001      	beq.n	800c086 <_fx_file_read+0x1e>
    {

        /* Return the file not open error status.  */
        return(FX_NOT_OPEN);
 800c082:	2307      	movs	r3, #7
 800c084:	e24c      	b.n	800c520 <_fx_file_read+0x4b8>
    }

#ifndef FX_MEDIA_STATISTICS_DISABLE
    /* Setup pointer to media structure.  */
    media_ptr =  file_ptr -> fx_file_media_ptr;
 800c086:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800c088:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800c08a:	67fb      	str	r3, [r7, #124]	@ 0x7c

    /* Increment the number of times this service has been called.  */
    media_ptr -> fx_media_file_reads++;
 800c08c:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 800c08e:	f8d3 313c 	ldr.w	r3, [r3, #316]	@ 0x13c
 800c092:	1c5a      	adds	r2, r3, #1
 800c094:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 800c096:	f8c3 213c 	str.w	r2, [r3, #316]	@ 0x13c
#endif

    /* Setup pointer to associated media control block.  */
    media_ptr =  file_ptr -> fx_file_media_ptr;
 800c09a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800c09c:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800c09e:	67fb      	str	r3, [r7, #124]	@ 0x7c

    /* Protect against other threads accessing the media.  */
    FX_PROTECT

    /* Next, determine if there is any more bytes to read in the file.  */
    if (file_ptr -> fx_file_current_file_offset >=
 800c0a0:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800c0a2:	e9d3 0110 	ldrd	r0, r1, [r3, #64]	@ 0x40
        file_ptr -> fx_file_current_file_size)
 800c0a6:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800c0a8:	e9d3 2312 	ldrd	r2, r3, [r3, #72]	@ 0x48
    if (file_ptr -> fx_file_current_file_offset >=
 800c0ac:	4290      	cmp	r0, r2
 800c0ae:	eb71 0303 	sbcs.w	r3, r1, r3
 800c0b2:	d304      	bcc.n	800c0be <_fx_file_read+0x56>
        /* Release media protection.  */
        FX_UNPROTECT

        /* The file is at the end, return the proper status and set the
           actual size to 0.  */
        *actual_size =  0;
 800c0b4:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 800c0b6:	2200      	movs	r2, #0
 800c0b8:	601a      	str	r2, [r3, #0]
        return(FX_END_OF_FILE);
 800c0ba:	2309      	movs	r3, #9
 800c0bc:	e230      	b.n	800c520 <_fx_file_read+0x4b8>
    }

    /* At this point there is something to read.  */

    /* Setup local buffer pointer.  */
    destination_ptr =  (UCHAR *)buffer_ptr;
 800c0be:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 800c0c0:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88

    /* Determine if there are less bytes left in the file than that specified
       by the request.  If so, adjust the requested size.  */
    if ((ULONG64)request_size >
 800c0c4:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 800c0c6:	2200      	movs	r2, #0
 800c0c8:	4698      	mov	r8, r3
 800c0ca:	4691      	mov	r9, r2
        (file_ptr -> fx_file_current_file_size - file_ptr -> fx_file_current_file_offset))
 800c0cc:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800c0ce:	e9d3 0112 	ldrd	r0, r1, [r3, #72]	@ 0x48
 800c0d2:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800c0d4:	e9d3 2310 	ldrd	r2, r3, [r3, #64]	@ 0x40
 800c0d8:	1a84      	subs	r4, r0, r2
 800c0da:	eb61 0503 	sbc.w	r5, r1, r3
    if ((ULONG64)request_size >
 800c0de:	4544      	cmp	r4, r8
 800c0e0:	eb75 0309 	sbcs.w	r3, r5, r9
 800c0e4:	d209      	bcs.n	800c0fa <_fx_file_read+0x92>
    {

        /* Adjust the bytes remaining to what's available.  */
        request_size =  (ULONG)(file_ptr -> fx_file_current_file_size - file_ptr -> fx_file_current_file_offset);
 800c0e6:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800c0e8:	e9d3 2312 	ldrd	r2, r3, [r3, #72]	@ 0x48
 800c0ec:	4611      	mov	r1, r2
 800c0ee:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800c0f0:	e9d3 2310 	ldrd	r2, r3, [r3, #64]	@ 0x40
 800c0f4:	4613      	mov	r3, r2
 800c0f6:	1acb      	subs	r3, r1, r3
 800c0f8:	667b      	str	r3, [r7, #100]	@ 0x64
    }

    /* Setup the remaining number of bytes to read.  */
    bytes_remaining =  request_size;
 800c0fa:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 800c0fc:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94

    /* Loop to read all of the bytes.  */
    while (bytes_remaining)
 800c100:	e1e9      	b.n	800c4d6 <_fx_file_read+0x46e>
    {

        /* Determine if a beginning or ending partial read is required.  */
        if ((file_ptr -> fx_file_current_logical_offset) ||
 800c102:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800c104:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800c106:	2b00      	cmp	r3, #0
 800c108:	d105      	bne.n	800c116 <_fx_file_read+0xae>
            (bytes_remaining < media_ptr -> fx_media_bytes_per_sector))
 800c10a:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 800c10c:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
        if ((file_ptr -> fx_file_current_logical_offset) ||
 800c10e:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 800c112:	4293      	cmp	r3, r2
 800c114:	d247      	bcs.n	800c1a6 <_fx_file_read+0x13e>
        {

            /* A partial sector read is required.  */

            /* Read the current logical sector.  */
            status =  _fx_utility_logical_sector_read(media_ptr,
 800c116:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800c118:	e9d3 010a 	ldrd	r0, r1, [r3, #40]	@ 0x28
                                                      file_ptr -> fx_file_current_logical_sector,
                                                      media_ptr -> fx_media_memory_buffer, ((ULONG) 1), FX_DATA_SECTOR);
 800c11c:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 800c11e:	689a      	ldr	r2, [r3, #8]
            status =  _fx_utility_logical_sector_read(media_ptr,
 800c120:	2304      	movs	r3, #4
 800c122:	9302      	str	r3, [sp, #8]
 800c124:	2301      	movs	r3, #1
 800c126:	9301      	str	r3, [sp, #4]
 800c128:	9200      	str	r2, [sp, #0]
 800c12a:	4602      	mov	r2, r0
 800c12c:	460b      	mov	r3, r1
 800c12e:	6ff8      	ldr	r0, [r7, #124]	@ 0x7c
 800c130:	f004 f844 	bl	80101bc <_fx_utility_logical_sector_read>
 800c134:	67b8      	str	r0, [r7, #120]	@ 0x78

            /* Check for good completion status.  */
            if (status !=  FX_SUCCESS)
 800c136:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 800c138:	2b00      	cmp	r3, #0
 800c13a:	d001      	beq.n	800c140 <_fx_file_read+0xd8>

                /* Release media protection.  */
                FX_UNPROTECT

                /* Return the error status.  */
                return(status);
 800c13c:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 800c13e:	e1ef      	b.n	800c520 <_fx_file_read+0x4b8>
            }

            /* Copy the appropriate number of bytes into the destination buffer.  */
            copy_bytes =  media_ptr -> fx_media_bytes_per_sector -
 800c140:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 800c142:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
                file_ptr -> fx_file_current_logical_offset;
 800c144:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800c146:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
            copy_bytes =  media_ptr -> fx_media_bytes_per_sector -
 800c148:	1ad3      	subs	r3, r2, r3
 800c14a:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c

            /* Check to see if only a portion of the read sector needs to be
               copied.  */
            if (copy_bytes > bytes_remaining)
 800c14e:	f8d7 208c 	ldr.w	r2, [r7, #140]	@ 0x8c
 800c152:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 800c156:	429a      	cmp	r2, r3
 800c158:	d903      	bls.n	800c162 <_fx_file_read+0xfa>
            {

                /* Adjust the number of bytes to copy.  */
                copy_bytes =  bytes_remaining;
 800c15a:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 800c15e:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
            }

            /* Actually perform the memory copy.  */
            _fx_utility_memory_copy(((UCHAR *)media_ptr -> fx_media_memory_buffer) + /* Use case of memcpy is verified. */
 800c162:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 800c164:	689a      	ldr	r2, [r3, #8]
                                    file_ptr -> fx_file_current_logical_offset,
 800c166:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800c168:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
            _fx_utility_memory_copy(((UCHAR *)media_ptr -> fx_media_memory_buffer) + /* Use case of memcpy is verified. */
 800c16a:	4413      	add	r3, r2
 800c16c:	f8d7 208c 	ldr.w	r2, [r7, #140]	@ 0x8c
 800c170:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 800c174:	4618      	mov	r0, r3
 800c176:	f004 fc1d 	bl	80109b4 <_fx_utility_memory_copy>
                                    destination_ptr, copy_bytes);

            /* Increment the logical sector byte offset.  */
            file_ptr -> fx_file_current_logical_offset =
                file_ptr -> fx_file_current_logical_offset + copy_bytes;
 800c17a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800c17c:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 800c17e:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 800c182:	441a      	add	r2, r3
            file_ptr -> fx_file_current_logical_offset =
 800c184:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800c186:	631a      	str	r2, [r3, #48]	@ 0x30

            /* Adjust the remaining bytes to read.  */
            bytes_remaining =  bytes_remaining - copy_bytes;
 800c188:	f8d7 2094 	ldr.w	r2, [r7, #148]	@ 0x94
 800c18c:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 800c190:	1ad3      	subs	r3, r2, r3
 800c192:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94

            /* Adjust the pointer to the destination buffer.  */
            destination_ptr =  destination_ptr + copy_bytes;
 800c196:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
 800c19a:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 800c19e:	4413      	add	r3, r2
 800c1a0:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
 800c1a4:	e0f3      	b.n	800c38e <_fx_file_read+0x326>
            /* Attempt to read multiple sectors directly into the destination
               buffer.  */

            /* Calculate the number of whole sectors to read directly into
               the destination buffer.  */
            sectors =  (UINT)(bytes_remaining / media_ptr -> fx_media_bytes_per_sector);
 800c1a6:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 800c1a8:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 800c1aa:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 800c1ae:	fbb3 f3f2 	udiv	r3, r3, r2
 800c1b2:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80


            next_cluster = cluster = file_ptr -> fx_file_current_physical_cluster;
 800c1b6:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800c1b8:	6a1b      	ldr	r3, [r3, #32]
 800c1ba:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
 800c1be:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 800c1c2:	677b      	str	r3, [r7, #116]	@ 0x74
            for (i = (media_ptr -> fx_media_sectors_per_cluster -
 800c1c4:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 800c1c6:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
                      file_ptr -> fx_file_current_relative_sector); i < sectors; i += media_ptr -> fx_media_sectors_per_cluster)
 800c1c8:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800c1ca:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
            for (i = (media_ptr -> fx_media_sectors_per_cluster -
 800c1cc:	1ad3      	subs	r3, r2, r3
 800c1ce:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
 800c1d2:	e02d      	b.n	800c230 <_fx_file_read+0x1c8>
                    cluster++;
                }
                else
                {
#endif /* FX_ENABLE_EXFAT */
                    status =  _fx_utility_FAT_entry_read(media_ptr, cluster, &next_cluster);
 800c1d4:	f107 0374 	add.w	r3, r7, #116	@ 0x74
 800c1d8:	461a      	mov	r2, r3
 800c1da:	f8d7 1084 	ldr.w	r1, [r7, #132]	@ 0x84
 800c1de:	6ff8      	ldr	r0, [r7, #124]	@ 0x7c
 800c1e0:	f002 fbde 	bl	800e9a0 <_fx_utility_FAT_entry_read>
 800c1e4:	67b8      	str	r0, [r7, #120]	@ 0x78

                    /* Determine if an error is present.  */
                    if ((status != FX_SUCCESS) || (next_cluster < FX_FAT_ENTRY_START) ||
 800c1e6:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 800c1e8:	2b00      	cmp	r3, #0
 800c1ea:	d10a      	bne.n	800c202 <_fx_file_read+0x19a>
 800c1ec:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 800c1ee:	2b01      	cmp	r3, #1
 800c1f0:	d907      	bls.n	800c202 <_fx_file_read+0x19a>
                        (next_cluster > media_ptr -> fx_media_fat_reserved))
 800c1f2:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 800c1f4:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 800c1f8:	f8d3 2478 	ldr.w	r2, [r3, #1144]	@ 0x478
 800c1fc:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
                    if ((status != FX_SUCCESS) || (next_cluster < FX_FAT_ENTRY_START) ||
 800c1fe:	429a      	cmp	r2, r3
 800c200:	d206      	bcs.n	800c210 <_fx_file_read+0x1a8>

                        /* Release media protection.  */
                        FX_UNPROTECT

                        /* Send error message back to caller.  */
                        if (status != FX_SUCCESS)
 800c202:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 800c204:	2b00      	cmp	r3, #0
 800c206:	d001      	beq.n	800c20c <_fx_file_read+0x1a4>
                        {
                            return(status);
 800c208:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 800c20a:	e189      	b.n	800c520 <_fx_file_read+0x4b8>
                        }
                        else
                        {
                            return(FX_FILE_CORRUPT);
 800c20c:	2308      	movs	r3, #8
 800c20e:	e187      	b.n	800c520 <_fx_file_read+0x4b8>
                        }
                    }

                    if (next_cluster != cluster + 1)
 800c210:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 800c214:	1c5a      	adds	r2, r3, #1
 800c216:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 800c218:	429a      	cmp	r2, r3
 800c21a:	d110      	bne.n	800c23e <_fx_file_read+0x1d6>
                    {
                        break;
                    }
                    else
                    {
                        cluster = next_cluster;
 800c21c:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 800c21e:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
                      file_ptr -> fx_file_current_relative_sector); i < sectors; i += media_ptr -> fx_media_sectors_per_cluster)
 800c222:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 800c224:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
 800c226:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 800c22a:	4413      	add	r3, r2
 800c22c:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
 800c230:	f8d7 2090 	ldr.w	r2, [r7, #144]	@ 0x90
 800c234:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 800c238:	429a      	cmp	r2, r3
 800c23a:	d3cb      	bcc.n	800c1d4 <_fx_file_read+0x16c>
 800c23c:	e000      	b.n	800c240 <_fx_file_read+0x1d8>
                        break;
 800c23e:	bf00      	nop
#ifdef FX_ENABLE_EXFAT
                }
#endif /* FX_ENABLE_EXFAT */
            }

            if (i < sectors)
 800c240:	f8d7 2090 	ldr.w	r2, [r7, #144]	@ 0x90
 800c244:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 800c248:	429a      	cmp	r2, r3
 800c24a:	d203      	bcs.n	800c254 <_fx_file_read+0x1ec>
            {
                sectors = i;
 800c24c:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 800c250:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
            }

            /* Determine if this is a single sector read request.  If so, read the sector so it will
               come from the internal cache.  */
            if (sectors == 1)
 800c254:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 800c258:	2b01      	cmp	r3, #1
 800c25a:	d11e      	bne.n	800c29a <_fx_file_read+0x232>
            {

                /* Read the current logical sector.  */
                status =  _fx_utility_logical_sector_read(media_ptr,
 800c25c:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800c25e:	e9d3 010a 	ldrd	r0, r1, [r3, #40]	@ 0x28
                                                          file_ptr -> fx_file_current_logical_sector,
                                                          media_ptr -> fx_media_memory_buffer, ((ULONG) 1), FX_DATA_SECTOR);
 800c262:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 800c264:	689a      	ldr	r2, [r3, #8]
                status =  _fx_utility_logical_sector_read(media_ptr,
 800c266:	2304      	movs	r3, #4
 800c268:	9302      	str	r3, [sp, #8]
 800c26a:	2301      	movs	r3, #1
 800c26c:	9301      	str	r3, [sp, #4]
 800c26e:	9200      	str	r2, [sp, #0]
 800c270:	4602      	mov	r2, r0
 800c272:	460b      	mov	r3, r1
 800c274:	6ff8      	ldr	r0, [r7, #124]	@ 0x7c
 800c276:	f003 ffa1 	bl	80101bc <_fx_utility_logical_sector_read>
 800c27a:	67b8      	str	r0, [r7, #120]	@ 0x78

                /* Check for good completion status.  */
                if (status !=  FX_SUCCESS)
 800c27c:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 800c27e:	2b00      	cmp	r3, #0
 800c280:	d001      	beq.n	800c286 <_fx_file_read+0x21e>

                    /* Release media protection.  */
                    FX_UNPROTECT

                    /* Return the error status.  */
                    return(status);
 800c282:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 800c284:	e14c      	b.n	800c520 <_fx_file_read+0x4b8>
                }

                /* Actually perform the memory copy.  */
                _fx_utility_memory_copy((UCHAR *)media_ptr -> fx_media_memory_buffer, destination_ptr, media_ptr -> fx_media_bytes_per_sector); /* Use case of memcpy is verified. */
 800c286:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 800c288:	6898      	ldr	r0, [r3, #8]
 800c28a:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 800c28c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800c28e:	461a      	mov	r2, r3
 800c290:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 800c294:	f004 fb8e 	bl	80109b4 <_fx_utility_memory_copy>
 800c298:	e026      	b.n	800c2e8 <_fx_file_read+0x280>

                /* Multiple sector read request.  Read all the sectors at once.  */

                /* Perform the data read directly into the user's buffer of
                   the appropriate number of sectors.  */
                media_ptr -> fx_media_disable_burst_cache = file_ptr -> fx_file_disable_burst_cache;
 800c29a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800c29c:	f8d3 21d8 	ldr.w	r2, [r3, #472]	@ 0x1d8
 800c2a0:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 800c2a2:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 800c2a6:	f8c3 2474 	str.w	r2, [r3, #1140]	@ 0x474
                status =  _fx_utility_logical_sector_read(media_ptr, file_ptr -> fx_file_current_logical_sector,
 800c2aa:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800c2ac:	e9d3 010a 	ldrd	r0, r1, [r3, #40]	@ 0x28
 800c2b0:	2304      	movs	r3, #4
 800c2b2:	9302      	str	r3, [sp, #8]
 800c2b4:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 800c2b8:	9301      	str	r3, [sp, #4]
 800c2ba:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 800c2be:	9300      	str	r3, [sp, #0]
 800c2c0:	4602      	mov	r2, r0
 800c2c2:	460b      	mov	r3, r1
 800c2c4:	6ff8      	ldr	r0, [r7, #124]	@ 0x7c
 800c2c6:	f003 ff79 	bl	80101bc <_fx_utility_logical_sector_read>
 800c2ca:	67b8      	str	r0, [r7, #120]	@ 0x78
                                                          destination_ptr, (ULONG) sectors, FX_DATA_SECTOR);
                media_ptr -> fx_media_disable_burst_cache = FX_FALSE;
 800c2cc:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 800c2ce:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 800c2d2:	461a      	mov	r2, r3
 800c2d4:	2300      	movs	r3, #0
 800c2d6:	f8c2 3474 	str.w	r3, [r2, #1140]	@ 0x474

                /* Check for good completion status.  */
                if (status !=  FX_SUCCESS)
 800c2da:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 800c2dc:	2b00      	cmp	r3, #0
 800c2de:	d003      	beq.n	800c2e8 <_fx_file_read+0x280>

                    /* Release media protection.  */
                    FX_UNPROTECT

                    /* Return the error status.  */
                    return(status);
 800c2e0:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 800c2e2:	e11d      	b.n	800c520 <_fx_file_read+0x4b8>
 800c2e4:	46494c45 	.word	0x46494c45

            /* Increment the current logical sector.  Subtract one from
               the sector count because we are going to use the logical
               offset to do additional sector/cluster arithmetic below.  */
            file_ptr -> fx_file_current_logical_sector =
                file_ptr -> fx_file_current_logical_sector +
 800c2e8:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800c2ea:	e9d3 010a 	ldrd	r0, r1, [r3, #40]	@ 0x28
                (sectors - 1);
 800c2ee:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 800c2f2:	3b01      	subs	r3, #1
 800c2f4:	2200      	movs	r2, #0
 800c2f6:	65bb      	str	r3, [r7, #88]	@ 0x58
 800c2f8:	65fa      	str	r2, [r7, #92]	@ 0x5c
                file_ptr -> fx_file_current_logical_sector +
 800c2fa:	e9d7 4516 	ldrd	r4, r5, [r7, #88]	@ 0x58
 800c2fe:	4623      	mov	r3, r4
 800c300:	18c3      	adds	r3, r0, r3
 800c302:	653b      	str	r3, [r7, #80]	@ 0x50
 800c304:	462b      	mov	r3, r5
 800c306:	eb41 0303 	adc.w	r3, r1, r3
 800c30a:	657b      	str	r3, [r7, #84]	@ 0x54
            file_ptr -> fx_file_current_logical_sector =
 800c30c:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800c30e:	e9d7 1214 	ldrd	r1, r2, [r7, #80]	@ 0x50
 800c312:	e9c3 120a 	strd	r1, r2, [r3, #40]	@ 0x28

            /* Move the relative sector and cluster as well.  */
            file_ptr -> fx_file_current_relative_cluster = file_ptr -> fx_file_current_relative_cluster +
 800c316:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800c318:	6b59      	ldr	r1, [r3, #52]	@ 0x34
                (file_ptr -> fx_file_current_relative_sector + (sectors - 1)) /
 800c31a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800c31c:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 800c31e:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 800c322:	4413      	add	r3, r2
 800c324:	1e5a      	subs	r2, r3, #1
                media_ptr -> fx_media_sectors_per_cluster;
 800c326:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 800c328:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
                (file_ptr -> fx_file_current_relative_sector + (sectors - 1)) /
 800c32a:	fbb2 f3f3 	udiv	r3, r2, r3
            file_ptr -> fx_file_current_relative_cluster = file_ptr -> fx_file_current_relative_cluster +
 800c32e:	18ca      	adds	r2, r1, r3
 800c330:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800c332:	635a      	str	r2, [r3, #52]	@ 0x34

            file_ptr -> fx_file_current_relative_sector =
                (file_ptr -> fx_file_current_relative_sector +
 800c334:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800c336:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 800c338:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 800c33c:	4413      	add	r3, r2
 800c33e:	1e59      	subs	r1, r3, #1
                 (sectors - 1)) % media_ptr -> fx_media_sectors_per_cluster;
 800c340:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 800c342:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
 800c344:	fbb1 f3f2 	udiv	r3, r1, r2
 800c348:	fb02 f303 	mul.w	r3, r2, r3
 800c34c:	1aca      	subs	r2, r1, r3
            file_ptr -> fx_file_current_relative_sector =
 800c34e:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800c350:	639a      	str	r2, [r3, #56]	@ 0x38

            /* Increment the logical sector byte offset.  */
            file_ptr -> fx_file_current_logical_offset =
                media_ptr -> fx_media_bytes_per_sector;
 800c352:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 800c354:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
            file_ptr -> fx_file_current_logical_offset =
 800c356:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800c358:	631a      	str	r2, [r3, #48]	@ 0x30

            file_ptr -> fx_file_current_physical_cluster = cluster;
 800c35a:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 800c35c:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 800c360:	6213      	str	r3, [r2, #32]

            /* Adjust the remaining bytes.  */
            bytes_remaining =  bytes_remaining -
                (((ULONG)media_ptr -> fx_media_bytes_per_sector) * sectors);
 800c362:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 800c364:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 800c366:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 800c36a:	fb03 f202 	mul.w	r2, r3, r2
            bytes_remaining =  bytes_remaining -
 800c36e:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 800c372:	1a9b      	subs	r3, r3, r2
 800c374:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94

            /* Adjust the pointer to the destination buffer.  */
            destination_ptr =  destination_ptr +
                (((ULONG)media_ptr -> fx_media_bytes_per_sector) * sectors);
 800c378:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 800c37a:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 800c37c:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 800c380:	fb03 f202 	mul.w	r2, r3, r2
            destination_ptr =  destination_ptr +
 800c384:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 800c388:	4413      	add	r3, r2
 800c38a:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
        }

        /* At this point, we have either read a partial sector or have successfully
           read one or more whole sectors.  Determine if we are at the end of
           the current logical sector.  */
        if (file_ptr -> fx_file_current_logical_offset >=
 800c38e:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800c390:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
            media_ptr -> fx_media_bytes_per_sector)
 800c392:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 800c394:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
        if (file_ptr -> fx_file_current_logical_offset >=
 800c396:	429a      	cmp	r2, r3
 800c398:	f0c0 809d 	bcc.w	800c4d6 <_fx_file_read+0x46e>
        {

            /* Determine if we are at the exact physical end of the file at the end of reading.  */
            if ((bytes_remaining == 0) && ((file_ptr -> fx_file_current_file_offset + (ULONG64)request_size) >=
 800c39c:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 800c3a0:	2b00      	cmp	r3, #0
 800c3a2:	d11a      	bne.n	800c3da <_fx_file_read+0x372>
 800c3a4:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800c3a6:	e9d3 2310 	ldrd	r2, r3, [r3, #64]	@ 0x40
 800c3aa:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 800c3ac:	2000      	movs	r0, #0
 800c3ae:	64b9      	str	r1, [r7, #72]	@ 0x48
 800c3b0:	64f8      	str	r0, [r7, #76]	@ 0x4c
 800c3b2:	e9d7 4512 	ldrd	r4, r5, [r7, #72]	@ 0x48
 800c3b6:	4621      	mov	r1, r4
 800c3b8:	1851      	adds	r1, r2, r1
 800c3ba:	6439      	str	r1, [r7, #64]	@ 0x40
 800c3bc:	4629      	mov	r1, r5
 800c3be:	414b      	adcs	r3, r1
 800c3c0:	647b      	str	r3, [r7, #68]	@ 0x44
                                           file_ptr -> fx_file_current_available_size))
 800c3c2:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800c3c4:	e9d3 2314 	ldrd	r2, r3, [r3, #80]	@ 0x50
            if ((bytes_remaining == 0) && ((file_ptr -> fx_file_current_file_offset + (ULONG64)request_size) >=
 800c3c8:	e9d7 4510 	ldrd	r4, r5, [r7, #64]	@ 0x40
 800c3cc:	4621      	mov	r1, r4
 800c3ce:	4291      	cmp	r1, r2
 800c3d0:	4629      	mov	r1, r5
 800c3d2:	eb71 0303 	sbcs.w	r3, r1, r3
 800c3d6:	f080 8084 	bcs.w	800c4e2 <_fx_file_read+0x47a>
            /* We need to move to the next logical sector, but first
               determine if the next logical sector is within the same
               cluster.  */

            /* Increment the current relative sector in the cluster.  */
            file_ptr -> fx_file_current_relative_sector++;
 800c3da:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800c3dc:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800c3de:	1c5a      	adds	r2, r3, #1
 800c3e0:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800c3e2:	639a      	str	r2, [r3, #56]	@ 0x38

            /* Determine if this is in a new cluster.  */
            if (file_ptr -> fx_file_current_relative_sector >=
 800c3e4:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800c3e6:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
                media_ptr -> fx_media_sectors_per_cluster)
 800c3e8:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 800c3ea:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
            if (file_ptr -> fx_file_current_relative_sector >=
 800c3ec:	429a      	cmp	r2, r3
 800c3ee:	d362      	bcc.n	800c4b6 <_fx_file_read+0x44e>
                {
#endif /* FX_ENABLE_EXFAT */

                    /* Read the FAT entry of the current cluster to find
                       the next cluster.  */
                    status =  _fx_utility_FAT_entry_read(media_ptr,
 800c3f0:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800c3f2:	6a19      	ldr	r1, [r3, #32]
 800c3f4:	f107 0374 	add.w	r3, r7, #116	@ 0x74
 800c3f8:	461a      	mov	r2, r3
 800c3fa:	6ff8      	ldr	r0, [r7, #124]	@ 0x7c
 800c3fc:	f002 fad0 	bl	800e9a0 <_fx_utility_FAT_entry_read>
 800c400:	67b8      	str	r0, [r7, #120]	@ 0x78
                                                         file_ptr -> fx_file_current_physical_cluster, &next_cluster);

                    /* Determine if an error is present.  */
                    if ((status != FX_SUCCESS) || (next_cluster < FX_FAT_ENTRY_START) ||
 800c402:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 800c404:	2b00      	cmp	r3, #0
 800c406:	d10a      	bne.n	800c41e <_fx_file_read+0x3b6>
 800c408:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 800c40a:	2b01      	cmp	r3, #1
 800c40c:	d907      	bls.n	800c41e <_fx_file_read+0x3b6>
                        (next_cluster > media_ptr -> fx_media_fat_reserved))
 800c40e:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 800c410:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 800c414:	f8d3 2478 	ldr.w	r2, [r3, #1144]	@ 0x478
 800c418:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
                    if ((status != FX_SUCCESS) || (next_cluster < FX_FAT_ENTRY_START) ||
 800c41a:	429a      	cmp	r2, r3
 800c41c:	d206      	bcs.n	800c42c <_fx_file_read+0x3c4>

                        /* Release media protection.  */
                        FX_UNPROTECT

                        /* Send error message back to caller.  */
                        if (status != FX_SUCCESS)
 800c41e:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 800c420:	2b00      	cmp	r3, #0
 800c422:	d001      	beq.n	800c428 <_fx_file_read+0x3c0>
                        {
                            return(status);
 800c424:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 800c426:	e07b      	b.n	800c520 <_fx_file_read+0x4b8>
                        }
                        else
                        {
                            return(FX_FILE_CORRUPT);
 800c428:	2308      	movs	r3, #8
 800c42a:	e079      	b.n	800c520 <_fx_file_read+0x4b8>
                }
#endif /* FX_ENABLE_EXFAT */

                /* Otherwise, we have a new cluster.  Save it in the file
                   control block and calculate a new logical sector value.  */
                file_ptr -> fx_file_current_physical_cluster =  next_cluster;
 800c42c:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 800c42e:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800c430:	621a      	str	r2, [r3, #32]
                file_ptr -> fx_file_current_relative_cluster++;
 800c432:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800c434:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800c436:	1c5a      	adds	r2, r3, #1
 800c438:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800c43a:	635a      	str	r2, [r3, #52]	@ 0x34
                file_ptr -> fx_file_current_logical_sector = ((ULONG)media_ptr -> fx_media_data_sector_start) +
 800c43c:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 800c43e:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800c440:	2200      	movs	r2, #0
 800c442:	63bb      	str	r3, [r7, #56]	@ 0x38
 800c444:	63fa      	str	r2, [r7, #60]	@ 0x3c
                    ((((ULONG64)next_cluster) - FX_FAT_ENTRY_START) *
 800c446:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 800c448:	2200      	movs	r2, #0
 800c44a:	633b      	str	r3, [r7, #48]	@ 0x30
 800c44c:	637a      	str	r2, [r7, #52]	@ 0x34
 800c44e:	e9d7 120c 	ldrd	r1, r2, [r7, #48]	@ 0x30
 800c452:	460b      	mov	r3, r1
 800c454:	3b02      	subs	r3, #2
 800c456:	62bb      	str	r3, [r7, #40]	@ 0x28
 800c458:	4613      	mov	r3, r2
 800c45a:	f143 33ff 	adc.w	r3, r3, #4294967295
 800c45e:	62fb      	str	r3, [r7, #44]	@ 0x2c
                     ((ULONG)media_ptr -> fx_media_sectors_per_cluster));
 800c460:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 800c462:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800c464:	2200      	movs	r2, #0
 800c466:	623b      	str	r3, [r7, #32]
 800c468:	627a      	str	r2, [r7, #36]	@ 0x24
                    ((((ULONG64)next_cluster) - FX_FAT_ENTRY_START) *
 800c46a:	e9d7 450a 	ldrd	r4, r5, [r7, #40]	@ 0x28
 800c46e:	462b      	mov	r3, r5
 800c470:	e9d7 8908 	ldrd	r8, r9, [r7, #32]
 800c474:	4642      	mov	r2, r8
 800c476:	fb02 f203 	mul.w	r2, r2, r3
 800c47a:	464b      	mov	r3, r9
 800c47c:	4621      	mov	r1, r4
 800c47e:	fb01 f303 	mul.w	r3, r1, r3
 800c482:	4413      	add	r3, r2
 800c484:	4622      	mov	r2, r4
 800c486:	4641      	mov	r1, r8
 800c488:	fba2 ab01 	umull	sl, fp, r2, r1
 800c48c:	445b      	add	r3, fp
 800c48e:	469b      	mov	fp, r3
                file_ptr -> fx_file_current_logical_sector = ((ULONG)media_ptr -> fx_media_data_sector_start) +
 800c490:	e9d7 120e 	ldrd	r1, r2, [r7, #56]	@ 0x38
 800c494:	460b      	mov	r3, r1
 800c496:	eb13 030a 	adds.w	r3, r3, sl
 800c49a:	61bb      	str	r3, [r7, #24]
 800c49c:	4613      	mov	r3, r2
 800c49e:	eb43 030b 	adc.w	r3, r3, fp
 800c4a2:	61fb      	str	r3, [r7, #28]
 800c4a4:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800c4a6:	e9d7 1206 	ldrd	r1, r2, [r7, #24]
 800c4aa:	e9c3 120a 	strd	r1, r2, [r3, #40]	@ 0x28
                file_ptr -> fx_file_current_relative_sector =  0;
 800c4ae:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 800c4b0:	2300      	movs	r3, #0
 800c4b2:	6393      	str	r3, [r2, #56]	@ 0x38
 800c4b4:	e00c      	b.n	800c4d0 <_fx_file_read+0x468>
            else
            {

                /* Still within the same cluster so just increment the
                   logical sector.  */
                file_ptr -> fx_file_current_logical_sector++;
 800c4b6:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800c4b8:	e9d3 230a 	ldrd	r2, r3, [r3, #40]	@ 0x28
 800c4bc:	1c51      	adds	r1, r2, #1
 800c4be:	6139      	str	r1, [r7, #16]
 800c4c0:	f143 0300 	adc.w	r3, r3, #0
 800c4c4:	617b      	str	r3, [r7, #20]
 800c4c6:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800c4c8:	e9d7 1204 	ldrd	r1, r2, [r7, #16]
 800c4cc:	e9c3 120a 	strd	r1, r2, [r3, #40]	@ 0x28
            }

            /* In either case, we are now positioned at a new sector so
               clear the logical sector offset.  */
            file_ptr -> fx_file_current_logical_offset =  0;
 800c4d0:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 800c4d2:	2300      	movs	r3, #0
 800c4d4:	6313      	str	r3, [r2, #48]	@ 0x30
    while (bytes_remaining)
 800c4d6:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 800c4da:	2b00      	cmp	r3, #0
 800c4dc:	f47f ae11 	bne.w	800c102 <_fx_file_read+0x9a>
 800c4e0:	e000      	b.n	800c4e4 <_fx_file_read+0x47c>
                break;
 800c4e2:	bf00      	nop
        }
    }

    /* Adjust the current file offset accordingly.  */
    file_ptr -> fx_file_current_file_offset =
        file_ptr -> fx_file_current_file_offset + (ULONG64)request_size;
 800c4e4:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800c4e6:	e9d3 2310 	ldrd	r2, r3, [r3, #64]	@ 0x40
 800c4ea:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 800c4ec:	2000      	movs	r0, #0
 800c4ee:	60b9      	str	r1, [r7, #8]
 800c4f0:	60f8      	str	r0, [r7, #12]
 800c4f2:	e9d7 4502 	ldrd	r4, r5, [r7, #8]
 800c4f6:	4621      	mov	r1, r4
 800c4f8:	1851      	adds	r1, r2, r1
 800c4fa:	6039      	str	r1, [r7, #0]
 800c4fc:	4629      	mov	r1, r5
 800c4fe:	eb43 0101 	adc.w	r1, r3, r1
 800c502:	6079      	str	r1, [r7, #4]
    file_ptr -> fx_file_current_file_offset =
 800c504:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800c506:	e9d7 1200 	ldrd	r1, r2, [r7]
 800c50a:	e9c3 1210 	strd	r1, r2, [r3, #64]	@ 0x40

    /* Store the number of bytes actually read.  */
    *actual_size =  request_size;
 800c50e:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 800c510:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 800c512:	601a      	str	r2, [r3, #0]

    /* Update the trace event with the bytes read.  */
    FX_TRACE_EVENT_UPDATE(trace_event, trace_timestamp, FX_TRACE_FILE_READ, 0, 0, 0, request_size)

    /* Update the last accessed date.  */
    file_ptr -> fx_file_dir_entry.fx_dir_entry_last_accessed_date =  _fx_system_date;
 800c514:	4b05      	ldr	r3, [pc, #20]	@ (800c52c <_fx_file_read+0x4c4>)
 800c516:	681a      	ldr	r2, [r3, #0]
 800c518:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800c51a:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90

    /* Release media protection.  */
    FX_UNPROTECT

    /* Return a successful status to the caller.  */
    return(FX_SUCCESS);
 800c51e:	2300      	movs	r3, #0
}
 800c520:	4618      	mov	r0, r3
 800c522:	3798      	adds	r7, #152	@ 0x98
 800c524:	46bd      	mov	sp, r7
 800c526:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 800c52a:	bf00      	nop
 800c52c:	20002c94 	.word	0x20002c94

0800c530 <_fx_file_seek>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
#ifndef FX_DISABLE_ONE_LINE_FUNCTION
UINT  _fx_file_seek(FX_FILE *file_ptr, ULONG byte_offset)
{
 800c530:	b580      	push	{r7, lr}
 800c532:	b082      	sub	sp, #8
 800c534:	af00      	add	r7, sp, #0
 800c536:	6078      	str	r0, [r7, #4]
 800c538:	6039      	str	r1, [r7, #0]

    return(_fx_file_extended_seek(file_ptr, (ULONG64) byte_offset));
 800c53a:	6839      	ldr	r1, [r7, #0]
 800c53c:	2000      	movs	r0, #0
 800c53e:	460a      	mov	r2, r1
 800c540:	4603      	mov	r3, r0
 800c542:	6878      	ldr	r0, [r7, #4]
 800c544:	f7fe fe78 	bl	800b238 <_fx_file_extended_seek>
 800c548:	4603      	mov	r3, r0
}
 800c54a:	4618      	mov	r0, r3
 800c54c:	3708      	adds	r7, #8
 800c54e:	46bd      	mov	sp, r7
 800c550:	bd80      	pop	{r7, pc}
	...

0800c554 <_fx_file_write>:
/*                                            memcpy usage,               */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _fx_file_write(FX_FILE *file_ptr, VOID *buffer_ptr, ULONG size)
{
 800c554:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 800c558:	f5ad 7d00 	sub.w	sp, sp, #512	@ 0x200
 800c55c:	af04      	add	r7, sp, #16
 800c55e:	f8c7 019c 	str.w	r0, [r7, #412]	@ 0x19c
 800c562:	f8c7 1198 	str.w	r1, [r7, #408]	@ 0x198
 800c566:	f8c7 2194 	str.w	r2, [r7, #404]	@ 0x194
UCHAR                  dont_use_fat_old = FX_FALSE; /* Used by exFAT logic to indicate whether or not the FAT table should be used. */
#endif /* FX_ENABLE_FAULT_TOLERANT */


    /* First, determine if the file is still open.  */
    if (file_ptr -> fx_file_id != FX_FILE_ID)
 800c56a:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800c56e:	681a      	ldr	r2, [r3, #0]
 800c570:	4bd1      	ldr	r3, [pc, #836]	@ (800c8b8 <_fx_file_write+0x364>)
 800c572:	429a      	cmp	r2, r3
 800c574:	d002      	beq.n	800c57c <_fx_file_write+0x28>
    {

        /* Return the file not open error status.  */
        return(FX_NOT_OPEN);
 800c576:	2307      	movs	r3, #7
 800c578:	f000 bea2 	b.w	800d2c0 <_fx_file_write+0xd6c>
    }

    /* Setup pointer to media structure.  */
    media_ptr =  file_ptr -> fx_file_media_ptr;
 800c57c:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800c580:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800c582:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac

#ifndef FX_MEDIA_STATISTICS_DISABLE

    /* Increment the number of times this service has been called.  */
    media_ptr -> fx_media_file_writes++;
 800c586:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800c58a:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
 800c58e:	1c5a      	adds	r2, r3, #1
 800c590:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800c594:	f8c3 2154 	str.w	r2, [r3, #340]	@ 0x154

#ifdef FX_ENABLE_EXFAT
    if ((media_ptr -> fx_media_FAT_type != FX_exFAT) &&
        (file_ptr -> fx_file_current_file_offset + size > 0xFFFFFFFFULL))
#else
    if (file_ptr -> fx_file_current_file_offset + size > 0xFFFFFFFFULL)
 800c598:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800c59c:	e9d3 2310 	ldrd	r2, r3, [r3, #64]	@ 0x40
 800c5a0:	f8d7 1194 	ldr.w	r1, [r7, #404]	@ 0x194
 800c5a4:	2000      	movs	r0, #0
 800c5a6:	460c      	mov	r4, r1
 800c5a8:	4605      	mov	r5, r0
 800c5aa:	eb12 0804 	adds.w	r8, r2, r4
 800c5ae:	eb43 0905 	adc.w	r9, r3, r5
 800c5b2:	f1b9 0f01 	cmp.w	r9, #1
 800c5b6:	d302      	bcc.n	800c5be <_fx_file_write+0x6a>
#endif /* FX_ENABLE_EXFAT */
    {

        /* Return the no more space error, since the new file size would be larger than
           the 32-bit field to represent it in the file's directory entry.  */
        return(FX_NO_MORE_SPACE);
 800c5b8:	230a      	movs	r3, #10
 800c5ba:	f000 be81 	b.w	800d2c0 <_fx_file_write+0xd6c>

    /* Protect against other threads accessing the media.  */
    FX_PROTECT

    /* Check for write protect at the media level (set by driver).  */
    if (media_ptr -> fx_media_driver_write_protect)
 800c5be:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800c5c2:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
 800c5c6:	2b00      	cmp	r3, #0
 800c5c8:	d002      	beq.n	800c5d0 <_fx_file_write+0x7c>

        /* Release media protection.  */
        FX_UNPROTECT

        /* Return write protect error.  */
        return(FX_WRITE_PROTECT);
 800c5ca:	2323      	movs	r3, #35	@ 0x23
 800c5cc:	f000 be78 	b.w	800d2c0 <_fx_file_write+0xd6c>
    }

    /* Make sure this file is open for writing.  */
    if (file_ptr -> fx_file_open_mode != FX_OPEN_FOR_WRITE)
 800c5d0:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800c5d4:	689b      	ldr	r3, [r3, #8]
 800c5d6:	2b01      	cmp	r3, #1
 800c5d8:	d002      	beq.n	800c5e0 <_fx_file_write+0x8c>
        /* Release media protection.  */
        FX_UNPROTECT

        /* Return the access error exception - a write was attempted from
           a file opened for reading!  */
        return(FX_ACCESS_ERROR);
 800c5da:	2306      	movs	r3, #6
 800c5dc:	f000 be70 	b.w	800d2c0 <_fx_file_write+0xd6c>
    /* Start transaction. */
    _fx_fault_tolerant_transaction_start(media_ptr);
#endif /* FX_ENABLE_FAULT_TOLERANT */

    /* Calculate the number of bytes per cluster.  */
    bytes_per_cluster =  ((ULONG)media_ptr -> fx_media_bytes_per_sector) *
 800c5e0:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800c5e4:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
        ((ULONG)media_ptr -> fx_media_sectors_per_cluster);
 800c5e6:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800c5ea:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
    bytes_per_cluster =  ((ULONG)media_ptr -> fx_media_bytes_per_sector) *
 800c5ec:	fb02 f303 	mul.w	r3, r2, r3
 800c5f0:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8

    /* Check for invalid value.  */
    if (bytes_per_cluster == 0)
 800c5f4:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 800c5f8:	2b00      	cmp	r3, #0
 800c5fa:	d102      	bne.n	800c602 <_fx_file_write+0xae>

        /* Release media protection.  */
        FX_UNPROTECT

        /* Invalid media, return error.  */
        return(FX_MEDIA_INVALID);
 800c5fc:	2302      	movs	r3, #2
 800c5fe:	f000 be5f 	b.w	800d2c0 <_fx_file_write+0xd6c>
    }

    /* Initialized first new cluster. */
    first_new_cluster =  0;
 800c602:	2300      	movs	r3, #0
 800c604:	f8c7 31d0 	str.w	r3, [r7, #464]	@ 0x1d0
    }
#endif /* FX_ENABLE_FAULT_TOLERANT */

    /* Next, determine if there is enough room to write the specified number of
       bytes to the clusters already allocated to this file.  */
    if (((file_ptr -> fx_file_current_available_size - file_ptr -> fx_file_current_file_offset) < size)
 800c608:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800c60c:	e9d3 0114 	ldrd	r0, r1, [r3, #80]	@ 0x50
 800c610:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800c614:	e9d3 2310 	ldrd	r2, r3, [r3, #64]	@ 0x40
 800c618:	ebb0 0a02 	subs.w	sl, r0, r2
 800c61c:	eb61 0b03 	sbc.w	fp, r1, r3
 800c620:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
 800c624:	2200      	movs	r2, #0
 800c626:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
 800c62a:	f8c7 215c 	str.w	r2, [r7, #348]	@ 0x15c
 800c62e:	e9d7 1256 	ldrd	r1, r2, [r7, #344]	@ 0x158
 800c632:	460b      	mov	r3, r1
 800c634:	459a      	cmp	sl, r3
 800c636:	4613      	mov	r3, r2
 800c638:	eb7b 0303 	sbcs.w	r3, fp, r3
 800c63c:	f080 827d 	bcs.w	800cb3a <_fx_file_write+0x5e6>

        if (file_ptr -> fx_file_current_available_size - file_ptr -> fx_file_current_file_offset < size)
        {
#endif /* FX_ENABLE_FAULT_TOLERANT */
            /* Calculate clusters that are needed for data append except ones overwritten. */
            clusters =  (UINT)((size + (bytes_per_cluster - 1) -
 800c640:	f8d7 21a8 	ldr.w	r2, [r7, #424]	@ 0x1a8
 800c644:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
 800c648:	4413      	add	r3, r2
 800c64a:	3b01      	subs	r3, #1
 800c64c:	2200      	movs	r2, #0
 800c64e:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
 800c652:	f8c7 2154 	str.w	r2, [r7, #340]	@ 0x154
                                (file_ptr -> fx_file_current_available_size - file_ptr -> fx_file_current_file_offset)) /
 800c656:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800c65a:	e9d3 0110 	ldrd	r0, r1, [r3, #64]	@ 0x40
 800c65e:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800c662:	e9d3 2314 	ldrd	r2, r3, [r3, #80]	@ 0x50
            clusters =  (UINT)((size + (bytes_per_cluster - 1) -
 800c666:	1a84      	subs	r4, r0, r2
 800c668:	f8c7 4148 	str.w	r4, [r7, #328]	@ 0x148
 800c66c:	eb61 0303 	sbc.w	r3, r1, r3
 800c670:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
 800c674:	e9d7 4554 	ldrd	r4, r5, [r7, #336]	@ 0x150
 800c678:	4623      	mov	r3, r4
 800c67a:	e9d7 0152 	ldrd	r0, r1, [r7, #328]	@ 0x148
 800c67e:	4602      	mov	r2, r0
 800c680:	189b      	adds	r3, r3, r2
 800c682:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
 800c686:	460b      	mov	r3, r1
 800c688:	462a      	mov	r2, r5
 800c68a:	eb42 0303 	adc.w	r3, r2, r3
 800c68e:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
                                (file_ptr -> fx_file_current_available_size - file_ptr -> fx_file_current_file_offset)) /
 800c692:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 800c696:	2200      	movs	r2, #0
 800c698:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
 800c69c:	f8c7 213c 	str.w	r2, [r7, #316]	@ 0x13c
 800c6a0:	e9d7 234e 	ldrd	r2, r3, [r7, #312]	@ 0x138
 800c6a4:	e9d7 0150 	ldrd	r0, r1, [r7, #320]	@ 0x140
 800c6a8:	f7f3 fde6 	bl	8000278 <__aeabi_uldivmod>
 800c6ac:	4602      	mov	r2, r0
 800c6ae:	460b      	mov	r3, r1
            clusters =  (UINT)((size + (bytes_per_cluster - 1) -
 800c6b0:	4613      	mov	r3, r2
 800c6b2:	f8c7 31c0 	str.w	r3, [r7, #448]	@ 0x1c0

        /* Determine if we have enough space left.  */
#ifdef FX_ENABLE_FAULT_TOLERANT
        if (clusters + replace_clusters > media_ptr -> fx_media_available_clusters)
#else
        if (clusters > media_ptr -> fx_media_available_clusters)
 800c6b6:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800c6ba:	6fda      	ldr	r2, [r3, #124]	@ 0x7c
 800c6bc:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 800c6c0:	4293      	cmp	r3, r2
 800c6c2:	d902      	bls.n	800c6ca <_fx_file_write+0x176>

            /* Release media protection.  */
            FX_UNPROTECT

            /* Out of disk space.  */
            return(FX_NO_MORE_SPACE);
 800c6c4:	230a      	movs	r3, #10
 800c6c6:	f000 bdfb 	b.w	800d2c0 <_fx_file_write+0xd6c>
        }

        /* Update the file total cluster count.  */
        file_ptr -> fx_file_total_clusters =  file_ptr -> fx_file_total_clusters + clusters;
 800c6ca:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800c6ce:	691a      	ldr	r2, [r3, #16]
 800c6d0:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 800c6d4:	441a      	add	r2, r3
 800c6d6:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800c6da:	611a      	str	r2, [r3, #16]
        /* Check for wrap-around when updating the available size.  */
#ifdef FX_ENABLE_EXFAT
        if ((media_ptr -> fx_media_FAT_type != FX_exFAT) &&
            (file_ptr -> fx_file_current_available_size + (ULONG64)bytes_per_cluster * (ULONG64)clusters > 0xFFFFFFFFULL))
#else
        if (file_ptr -> fx_file_current_available_size + (ULONG64)bytes_per_cluster * (ULONG64)clusters > 0xFFFFFFFFULL)
 800c6dc:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800c6e0:	e9d3 0114 	ldrd	r0, r1, [r3, #80]	@ 0x50
 800c6e4:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 800c6e8:	2200      	movs	r2, #0
 800c6ea:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
 800c6ee:	f8c7 2134 	str.w	r2, [r7, #308]	@ 0x134
 800c6f2:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 800c6f6:	2200      	movs	r2, #0
 800c6f8:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
 800c6fc:	f8c7 212c 	str.w	r2, [r7, #300]	@ 0x12c
 800c700:	e9d7 894c 	ldrd	r8, r9, [r7, #304]	@ 0x130
 800c704:	464b      	mov	r3, r9
 800c706:	e9d7 ab4a 	ldrd	sl, fp, [r7, #296]	@ 0x128
 800c70a:	4652      	mov	r2, sl
 800c70c:	fb02 f203 	mul.w	r2, r2, r3
 800c710:	465b      	mov	r3, fp
 800c712:	4644      	mov	r4, r8
 800c714:	fb04 f303 	mul.w	r3, r4, r3
 800c718:	4413      	add	r3, r2
 800c71a:	4642      	mov	r2, r8
 800c71c:	4654      	mov	r4, sl
 800c71e:	fba2 4204 	umull	r4, r2, r2, r4
 800c722:	f8c7 218c 	str.w	r2, [r7, #396]	@ 0x18c
 800c726:	4622      	mov	r2, r4
 800c728:	f8c7 2188 	str.w	r2, [r7, #392]	@ 0x188
 800c72c:	f8d7 218c 	ldr.w	r2, [r7, #396]	@ 0x18c
 800c730:	4413      	add	r3, r2
 800c732:	f8c7 318c 	str.w	r3, [r7, #396]	@ 0x18c
 800c736:	e9d7 4562 	ldrd	r4, r5, [r7, #392]	@ 0x188
 800c73a:	4623      	mov	r3, r4
 800c73c:	18c3      	adds	r3, r0, r3
 800c73e:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
 800c742:	462b      	mov	r3, r5
 800c744:	eb41 0303 	adc.w	r3, r1, r3
 800c748:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
 800c74c:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 800c750:	2b01      	cmp	r3, #1
 800c752:	d308      	bcc.n	800c766 <_fx_file_write+0x212>
#endif /* FX_ENABLE_EXFAT */
        {

            /* 32-bit wrap around condition is present.  Just set the available file size to all ones, which is
               the maximum file size.  */
            file_ptr -> fx_file_current_available_size =  0xFFFFFFFFULL;
 800c754:	f8d7 119c 	ldr.w	r1, [r7, #412]	@ 0x19c
 800c758:	f04f 32ff 	mov.w	r2, #4294967295
 800c75c:	f04f 0300 	mov.w	r3, #0
 800c760:	e9c1 2314 	strd	r2, r3, [r1, #80]	@ 0x50
 800c764:	e03d      	b.n	800c7e2 <_fx_file_write+0x28e>
        else
        {

            /* Normal condition, update the available size.  */
            file_ptr -> fx_file_current_available_size =
                file_ptr -> fx_file_current_available_size + (ULONG64)bytes_per_cluster * (ULONG64)clusters;
 800c766:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800c76a:	e9d3 0114 	ldrd	r0, r1, [r3, #80]	@ 0x50
 800c76e:	f8d7 31a8 	ldr.w	r3, [r7, #424]	@ 0x1a8
 800c772:	2200      	movs	r2, #0
 800c774:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
 800c778:	f8c7 211c 	str.w	r2, [r7, #284]	@ 0x11c
 800c77c:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 800c780:	2200      	movs	r2, #0
 800c782:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
 800c786:	f8c7 2114 	str.w	r2, [r7, #276]	@ 0x114
 800c78a:	e9d7 8946 	ldrd	r8, r9, [r7, #280]	@ 0x118
 800c78e:	464b      	mov	r3, r9
 800c790:	e9d7 ab44 	ldrd	sl, fp, [r7, #272]	@ 0x110
 800c794:	4652      	mov	r2, sl
 800c796:	fb02 f203 	mul.w	r2, r2, r3
 800c79a:	465b      	mov	r3, fp
 800c79c:	4644      	mov	r4, r8
 800c79e:	fb04 f303 	mul.w	r3, r4, r3
 800c7a2:	4413      	add	r3, r2
 800c7a4:	4642      	mov	r2, r8
 800c7a6:	4654      	mov	r4, sl
 800c7a8:	fba2 4204 	umull	r4, r2, r2, r4
 800c7ac:	f8c7 2184 	str.w	r2, [r7, #388]	@ 0x184
 800c7b0:	4622      	mov	r2, r4
 800c7b2:	f8c7 2180 	str.w	r2, [r7, #384]	@ 0x180
 800c7b6:	f8d7 2184 	ldr.w	r2, [r7, #388]	@ 0x184
 800c7ba:	4413      	add	r3, r2
 800c7bc:	f8c7 3184 	str.w	r3, [r7, #388]	@ 0x184
 800c7c0:	e9d7 4560 	ldrd	r4, r5, [r7, #384]	@ 0x180
 800c7c4:	4623      	mov	r3, r4
 800c7c6:	18c3      	adds	r3, r0, r3
 800c7c8:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
 800c7cc:	462b      	mov	r3, r5
 800c7ce:	eb41 0303 	adc.w	r3, r1, r3
 800c7d2:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
            file_ptr -> fx_file_current_available_size =
 800c7d6:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800c7da:	e9d7 1242 	ldrd	r1, r2, [r7, #264]	@ 0x108
 800c7de:	e9c3 1214 	strd	r1, r2, [r3, #80]	@ 0x50
        /* Account for newly allocated clusters. */
        clusters += replace_clusters;
#endif /* FX_ENABLE_FAULT_TOLERANT */

        /* Decrease the available clusters in the media control block. */
        media_ptr -> fx_media_available_clusters =  media_ptr -> fx_media_available_clusters - clusters;
 800c7e2:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800c7e6:	6fda      	ldr	r2, [r3, #124]	@ 0x7c
 800c7e8:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 800c7ec:	1ad2      	subs	r2, r2, r3
 800c7ee:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800c7f2:	67da      	str	r2, [r3, #124]	@ 0x7c
            dont_use_fat_old = (UCHAR)file_ptr -> fx_file_dir_entry.fx_dir_entry_dont_use_fat;
        }
#endif /* FX_ENABLE_EXFAT && FX_ENABLE_FAULT_TOLERANT */

        /* Search for the additional clusters we need.  */
        total_clusters =     media_ptr -> fx_media_total_clusters;
 800c7f4:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800c7f8:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800c7fa:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc
#endif /* FX_ENABLE_EXFAT */
        }
        else
#endif /* FX_ENABLE_FAULT_TOLERANT */
        {
            last_cluster =   file_ptr -> fx_file_last_physical_cluster;
 800c7fe:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800c802:	69db      	ldr	r3, [r3, #28]
 800c804:	f8c7 31cc 	str.w	r3, [r7, #460]	@ 0x1cc
        }

        FAT_index    =       media_ptr -> fx_media_cluster_search_start;
 800c808:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800c80c:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 800c810:	f8c7 31c4 	str.w	r3, [r7, #452]	@ 0x1c4

        /* Loop to find the needed clusters.  */
        while (clusters)
 800c814:	e159      	b.n	800caca <_fx_file_write+0x576>
        {

            /* Decrease the cluster count.  */
            clusters--;
 800c816:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 800c81a:	3b01      	subs	r3, #1
 800c81c:	f8c7 31c0 	str.w	r3, [r7, #448]	@ 0x1c0
                /* Loop to find the first available cluster.  */
                do
                {

                    /* Make sure we stop looking after one pass through the FAT table.  */
                    if (!total_clusters)
 800c820:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 800c824:	2b00      	cmp	r3, #0
 800c826:	d102      	bne.n	800c82e <_fx_file_write+0x2da>
                        /* Release media protection.  */
                        FX_UNPROTECT

                        /* Something is wrong with the media - the desired clusters were
                           not found in the FAT table.  */
                        return(FX_NO_MORE_SPACE);
 800c828:	230a      	movs	r3, #10
 800c82a:	f000 bd49 	b.w	800d2c0 <_fx_file_write+0xd6c>
                    }

                    /* Read FAT entry.  */
                    status =  _fx_utility_FAT_entry_read(media_ptr, FAT_index, &FAT_value);
 800c82e:	f507 73d0 	add.w	r3, r7, #416	@ 0x1a0
 800c832:	461a      	mov	r2, r3
 800c834:	f8d7 11c4 	ldr.w	r1, [r7, #452]	@ 0x1c4
 800c838:	f8d7 01ac 	ldr.w	r0, [r7, #428]	@ 0x1ac
 800c83c:	f002 f8b0 	bl	800e9a0 <_fx_utility_FAT_entry_read>
 800c840:	f8c7 01ec 	str.w	r0, [r7, #492]	@ 0x1ec

                    /* Check for a bad status.  */
                    if (status != FX_SUCCESS)
 800c844:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 800c848:	2b00      	cmp	r3, #0
 800c84a:	d003      	beq.n	800c854 <_fx_file_write+0x300>

                        /* Release media protection.  */
                        FX_UNPROTECT

                        /* Return the bad status.  */
                        return(status);
 800c84c:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 800c850:	f000 bd36 	b.w	800d2c0 <_fx_file_write+0xd6c>
                    }

                    /* Decrement the total cluster count.  */
                    total_clusters--;
 800c854:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
 800c858:	3b01      	subs	r3, #1
 800c85a:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc

                    /* Determine if the FAT entry is free.  */
                    if (FAT_value == FX_FREE_CLUSTER)
 800c85e:	f8d7 31a0 	ldr.w	r3, [r7, #416]	@ 0x1a0
 800c862:	2b00      	cmp	r3, #0
 800c864:	d116      	bne.n	800c894 <_fx_file_write+0x340>
                    {

                        /* Move cluster search pointer forward.  */
                        media_ptr -> fx_media_cluster_search_start =  FAT_index + 1;
 800c866:	f8d7 31c4 	ldr.w	r3, [r7, #452]	@ 0x1c4
 800c86a:	1c5a      	adds	r2, r3, #1
 800c86c:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800c870:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

                        /* Determine if this needs to be wrapped.  */
                        if (media_ptr -> fx_media_cluster_search_start >= (media_ptr -> fx_media_total_clusters + FX_FAT_ENTRY_START))
 800c874:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800c878:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
 800c87c:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800c880:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800c882:	3302      	adds	r3, #2
 800c884:	429a      	cmp	r2, r3
 800c886:	d319      	bcc.n	800c8bc <_fx_file_write+0x368>
                        {

                            /* Wrap the search to the beginning FAT entry.  */
                            media_ptr -> fx_media_cluster_search_start =  FX_FAT_ENTRY_START;
 800c888:	f8d7 21ac 	ldr.w	r2, [r7, #428]	@ 0x1ac
 800c88c:	2302      	movs	r3, #2
 800c88e:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80
                        }

                        /* Break this loop.  */
                        break;
 800c892:	e013      	b.n	800c8bc <_fx_file_write+0x368>
                    }
                    else
                    {

                        /* FAT entry is not free... Advance the FAT index.  */
                        FAT_index++;
 800c894:	f8d7 31c4 	ldr.w	r3, [r7, #452]	@ 0x1c4
 800c898:	3301      	adds	r3, #1
 800c89a:	f8c7 31c4 	str.w	r3, [r7, #452]	@ 0x1c4

                        /* Determine if we need to wrap the FAT index around.  */
                        if (FAT_index >= (media_ptr -> fx_media_total_clusters + FX_FAT_ENTRY_START))
 800c89e:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800c8a2:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800c8a4:	1c9a      	adds	r2, r3, #2
 800c8a6:	f8d7 31c4 	ldr.w	r3, [r7, #452]	@ 0x1c4
 800c8aa:	4293      	cmp	r3, r2
 800c8ac:	d3b8      	bcc.n	800c820 <_fx_file_write+0x2cc>
                        {

                            /* Wrap the search to the beginning FAT entry.  */
                            FAT_index =  FX_FAT_ENTRY_START;
 800c8ae:	2302      	movs	r3, #2
 800c8b0:	f8c7 31c4 	str.w	r3, [r7, #452]	@ 0x1c4
                    if (!total_clusters)
 800c8b4:	e7b4      	b.n	800c820 <_fx_file_write+0x2cc>
 800c8b6:	bf00      	nop
 800c8b8:	46494c45 	.word	0x46494c45
                        break;
 800c8bc:	bf00      	nop
#ifdef FX_ENABLE_EXFAT
            }
#endif /* FX_ENABLE_EXFAT */

            /* Determine if we have found the first new cluster yet.  */
            if (first_new_cluster == 0)
 800c8be:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
 800c8c2:	2b00      	cmp	r3, #0
 800c8c4:	d103      	bne.n	800c8ce <_fx_file_write+0x37a>
            {

                /* Remember the first new cluster. */
                first_new_cluster =  FAT_index;
 800c8c6:	f8d7 31c4 	ldr.w	r3, [r7, #452]	@ 0x1c4
 800c8ca:	f8c7 31d0 	str.w	r3, [r7, #464]	@ 0x1d0
#endif /* FX_ENABLE_FAULT_TOLERANT */
            }

            /* Make a quick check to see if an empty, cluster-less file
               is being written to for the first time.  */
            if (last_cluster)
 800c8ce:	f8d7 31cc 	ldr.w	r3, [r7, #460]	@ 0x1cc
 800c8d2:	2b00      	cmp	r3, #0
 800c8d4:	f000 8088 	beq.w	800c9e8 <_fx_file_write+0x494>
            {

                /* Check for the file's cluster.  We won't perform this link until the
                   entire FAT chain is built.  */
                if (last_cluster != file_ptr -> fx_file_last_physical_cluster)
 800c8d8:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800c8dc:	69da      	ldr	r2, [r3, #28]
 800c8de:	f8d7 31cc 	ldr.w	r3, [r7, #460]	@ 0x1cc
 800c8e2:	4293      	cmp	r3, r2
 800c8e4:	d009      	beq.n	800c8fa <_fx_file_write+0x3a6>
                    {
#endif /* FX_ENABLE_EXFAT */

                        /* Normal condition - link the last cluster with the new
                           found cluster.  */
                        status = _fx_utility_FAT_entry_write(media_ptr, last_cluster, FAT_index);
 800c8e6:	f8d7 21c4 	ldr.w	r2, [r7, #452]	@ 0x1c4
 800c8ea:	f8d7 11cc 	ldr.w	r1, [r7, #460]	@ 0x1cc
 800c8ee:	f8d7 01ac 	ldr.w	r0, [r7, #428]	@ 0x1ac
 800c8f2:	f002 fa7e 	bl	800edf2 <_fx_utility_FAT_entry_write>
 800c8f6:	f8c7 01ec 	str.w	r0, [r7, #492]	@ 0x1ec
                    }
#endif /* FX_ENABLE_EXFAT */
                }

                /* Check for a bad FAT write status.  */
                if (status !=  FX_SUCCESS)
 800c8fa:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 800c8fe:	2b00      	cmp	r3, #0
 800c900:	d003      	beq.n	800c90a <_fx_file_write+0x3b6>

                    /* Release media protection.  */
                    FX_UNPROTECT

                    /* Return the bad status.  */
                    return(status);
 800c902:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 800c906:	f000 bcdb 	b.w	800d2c0 <_fx_file_write+0xd6c>
                }

                /* Determine if we are adding a sector after a write filled the previously
                   allocated cluster exactly.  */
                if ((file_ptr -> fx_file_current_relative_sector >=
 800c90a:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800c90e:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
                     (media_ptr -> fx_media_sectors_per_cluster - 1)) &&
 800c910:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800c914:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800c916:	3b01      	subs	r3, #1
                if ((file_ptr -> fx_file_current_relative_sector >=
 800c918:	429a      	cmp	r2, r3
 800c91a:	f0c0 80cc 	bcc.w	800cab6 <_fx_file_write+0x562>
                    (file_ptr -> fx_file_current_logical_offset >=
 800c91e:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800c922:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
                     media_ptr -> fx_media_bytes_per_sector))
 800c924:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800c928:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
                     (media_ptr -> fx_media_sectors_per_cluster - 1)) &&
 800c92a:	429a      	cmp	r2, r3
 800c92c:	f0c0 80c3 	bcc.w	800cab6 <_fx_file_write+0x562>
                {

                    /* Yes, we need to adjust all of the pertinent file parameters for
                       writing into this newly allocated cluster.  */
                    file_ptr -> fx_file_current_physical_cluster =  FAT_index;
 800c930:	f8d7 219c 	ldr.w	r2, [r7, #412]	@ 0x19c
 800c934:	f8d7 31c4 	ldr.w	r3, [r7, #452]	@ 0x1c4
 800c938:	6213      	str	r3, [r2, #32]
                    file_ptr -> fx_file_current_relative_cluster++;
 800c93a:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800c93e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800c940:	1c5a      	adds	r2, r3, #1
 800c942:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800c946:	635a      	str	r2, [r3, #52]	@ 0x34
                    file_ptr -> fx_file_current_relative_sector =   0;
 800c948:	f8d7 219c 	ldr.w	r2, [r7, #412]	@ 0x19c
 800c94c:	2300      	movs	r3, #0
 800c94e:	6393      	str	r3, [r2, #56]	@ 0x38
                    file_ptr -> fx_file_current_logical_sector =    ((ULONG)media_ptr -> fx_media_data_sector_start) +
 800c950:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800c954:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800c956:	2200      	movs	r2, #0
 800c958:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
 800c95c:	f8c7 2104 	str.w	r2, [r7, #260]	@ 0x104
                        (((ULONG64)(FAT_index - FX_FAT_ENTRY_START)) *
 800c960:	f8d7 31c4 	ldr.w	r3, [r7, #452]	@ 0x1c4
 800c964:	3b02      	subs	r3, #2
 800c966:	2200      	movs	r2, #0
 800c968:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
 800c96c:	f8c7 20fc 	str.w	r2, [r7, #252]	@ 0xfc
                         ((ULONG)media_ptr -> fx_media_sectors_per_cluster));
 800c970:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800c974:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800c976:	2200      	movs	r2, #0
 800c978:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
 800c97c:	f8c7 20f4 	str.w	r2, [r7, #244]	@ 0xf4
                        (((ULONG64)(FAT_index - FX_FAT_ENTRY_START)) *
 800c980:	e9d7 453e 	ldrd	r4, r5, [r7, #248]	@ 0xf8
 800c984:	462b      	mov	r3, r5
 800c986:	e9d7 893c 	ldrd	r8, r9, [r7, #240]	@ 0xf0
 800c98a:	4642      	mov	r2, r8
 800c98c:	fb02 f203 	mul.w	r2, r2, r3
 800c990:	464b      	mov	r3, r9
 800c992:	4621      	mov	r1, r4
 800c994:	fb01 f303 	mul.w	r3, r1, r3
 800c998:	4413      	add	r3, r2
 800c99a:	4622      	mov	r2, r4
 800c99c:	4641      	mov	r1, r8
 800c99e:	fba2 1201 	umull	r1, r2, r2, r1
 800c9a2:	f8c7 217c 	str.w	r2, [r7, #380]	@ 0x17c
 800c9a6:	460a      	mov	r2, r1
 800c9a8:	f8c7 2178 	str.w	r2, [r7, #376]	@ 0x178
 800c9ac:	f8d7 217c 	ldr.w	r2, [r7, #380]	@ 0x17c
 800c9b0:	4413      	add	r3, r2
 800c9b2:	f8c7 317c 	str.w	r3, [r7, #380]	@ 0x17c
                    file_ptr -> fx_file_current_logical_sector =    ((ULONG)media_ptr -> fx_media_data_sector_start) +
 800c9b6:	e9d7 4540 	ldrd	r4, r5, [r7, #256]	@ 0x100
 800c9ba:	4623      	mov	r3, r4
 800c9bc:	e9d7 015e 	ldrd	r0, r1, [r7, #376]	@ 0x178
 800c9c0:	4602      	mov	r2, r0
 800c9c2:	189b      	adds	r3, r3, r2
 800c9c4:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
 800c9c8:	462b      	mov	r3, r5
 800c9ca:	460a      	mov	r2, r1
 800c9cc:	4153      	adcs	r3, r2
 800c9ce:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
 800c9d2:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800c9d6:	e9d7 123a 	ldrd	r1, r2, [r7, #232]	@ 0xe8
 800c9da:	e9c3 120a 	strd	r1, r2, [r3, #40]	@ 0x28
                    file_ptr -> fx_file_current_logical_offset =    0;
 800c9de:	f8d7 219c 	ldr.w	r2, [r7, #412]	@ 0x19c
 800c9e2:	2300      	movs	r3, #0
 800c9e4:	6313      	str	r3, [r2, #48]	@ 0x30
 800c9e6:	e066      	b.n	800cab6 <_fx_file_write+0x562>
            {

                /* This is the first cluster allocated for the file.  Just
                   remember it as being the first and setup the other file
                   pointers accordingly.  */
                file_ptr -> fx_file_first_physical_cluster =    FAT_index;
 800c9e8:	f8d7 219c 	ldr.w	r2, [r7, #412]	@ 0x19c
 800c9ec:	f8d7 31c4 	ldr.w	r3, [r7, #452]	@ 0x1c4
 800c9f0:	6153      	str	r3, [r2, #20]
                file_ptr -> fx_file_current_physical_cluster =  FAT_index;
 800c9f2:	f8d7 219c 	ldr.w	r2, [r7, #412]	@ 0x19c
 800c9f6:	f8d7 31c4 	ldr.w	r3, [r7, #452]	@ 0x1c4
 800c9fa:	6213      	str	r3, [r2, #32]
                file_ptr -> fx_file_current_relative_cluster =  0;
 800c9fc:	f8d7 219c 	ldr.w	r2, [r7, #412]	@ 0x19c
 800ca00:	2300      	movs	r3, #0
 800ca02:	6353      	str	r3, [r2, #52]	@ 0x34
                file_ptr -> fx_file_current_logical_sector =    ((ULONG)media_ptr -> fx_media_data_sector_start) +
 800ca04:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800ca08:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800ca0a:	2200      	movs	r2, #0
 800ca0c:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
 800ca10:	f8c7 20e4 	str.w	r2, [r7, #228]	@ 0xe4
                    (((ULONG64)(FAT_index - FX_FAT_ENTRY_START)) *
 800ca14:	f8d7 31c4 	ldr.w	r3, [r7, #452]	@ 0x1c4
 800ca18:	3b02      	subs	r3, #2
 800ca1a:	2200      	movs	r2, #0
 800ca1c:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
 800ca20:	f8c7 20dc 	str.w	r2, [r7, #220]	@ 0xdc
                     ((ULONG)media_ptr -> fx_media_sectors_per_cluster));
 800ca24:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800ca28:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800ca2a:	2200      	movs	r2, #0
 800ca2c:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
 800ca30:	f8c7 20d4 	str.w	r2, [r7, #212]	@ 0xd4
                    (((ULONG64)(FAT_index - FX_FAT_ENTRY_START)) *
 800ca34:	e9d7 4536 	ldrd	r4, r5, [r7, #216]	@ 0xd8
 800ca38:	462b      	mov	r3, r5
 800ca3a:	e9d7 8934 	ldrd	r8, r9, [r7, #208]	@ 0xd0
 800ca3e:	4642      	mov	r2, r8
 800ca40:	fb02 f203 	mul.w	r2, r2, r3
 800ca44:	464b      	mov	r3, r9
 800ca46:	4621      	mov	r1, r4
 800ca48:	fb01 f303 	mul.w	r3, r1, r3
 800ca4c:	4413      	add	r3, r2
 800ca4e:	4622      	mov	r2, r4
 800ca50:	4641      	mov	r1, r8
 800ca52:	fba2 1201 	umull	r1, r2, r2, r1
 800ca56:	f8c7 2174 	str.w	r2, [r7, #372]	@ 0x174
 800ca5a:	460a      	mov	r2, r1
 800ca5c:	f8c7 2170 	str.w	r2, [r7, #368]	@ 0x170
 800ca60:	f8d7 2174 	ldr.w	r2, [r7, #372]	@ 0x174
 800ca64:	4413      	add	r3, r2
 800ca66:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
                file_ptr -> fx_file_current_logical_sector =    ((ULONG)media_ptr -> fx_media_data_sector_start) +
 800ca6a:	e9d7 4538 	ldrd	r4, r5, [r7, #224]	@ 0xe0
 800ca6e:	4623      	mov	r3, r4
 800ca70:	e9d7 015c 	ldrd	r0, r1, [r7, #368]	@ 0x170
 800ca74:	4602      	mov	r2, r0
 800ca76:	189b      	adds	r3, r3, r2
 800ca78:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 800ca7c:	462b      	mov	r3, r5
 800ca7e:	460a      	mov	r2, r1
 800ca80:	4153      	adcs	r3, r2
 800ca82:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
 800ca86:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800ca8a:	e9d7 1232 	ldrd	r1, r2, [r7, #200]	@ 0xc8
 800ca8e:	e9c3 120a 	strd	r1, r2, [r3, #40]	@ 0x28
#ifdef FX_ENABLE_FAULT_TOLERANT
                if (file_ptr -> fx_file_last_physical_cluster == 0)
#endif /* FX_ENABLE_FAULT_TOLERANT */
                {
                    file_ptr -> fx_file_current_logical_offset =    0;
 800ca92:	f8d7 219c 	ldr.w	r2, [r7, #412]	@ 0x19c
 800ca96:	2300      	movs	r3, #0
 800ca98:	6313      	str	r3, [r2, #48]	@ 0x30
                    file_ptr -> fx_file_current_file_offset =       0;
 800ca9a:	f8d7 119c 	ldr.w	r1, [r7, #412]	@ 0x19c
 800ca9e:	f04f 0200 	mov.w	r2, #0
 800caa2:	f04f 0300 	mov.w	r3, #0
 800caa6:	e9c1 2310 	strd	r2, r3, [r1, #64]	@ 0x40
                }

                /* Also remember this as the first cluster in the directory
                   entry.  */
                file_ptr -> fx_file_dir_entry.fx_dir_entry_cluster =  FAT_index;
 800caaa:	f8d7 219c 	ldr.w	r2, [r7, #412]	@ 0x19c
 800caae:	f8d7 31c4 	ldr.w	r3, [r7, #452]	@ 0x1c4
 800cab2:	f8c2 309c 	str.w	r3, [r2, #156]	@ 0x9c
                }
            }
#endif /* FX_ENABLE_EXFAT */

            /* Otherwise, remember the new FAT index as the last.  */
            last_cluster =  FAT_index;
 800cab6:	f8d7 31c4 	ldr.w	r3, [r7, #452]	@ 0x1c4
 800caba:	f8c7 31cc 	str.w	r3, [r7, #460]	@ 0x1cc

            /* Move to the next FAT entry.  */
            FAT_index =  media_ptr -> fx_media_cluster_search_start;
 800cabe:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800cac2:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 800cac6:	f8c7 31c4 	str.w	r3, [r7, #452]	@ 0x1c4
        while (clusters)
 800caca:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
 800cace:	2b00      	cmp	r3, #0
 800cad0:	f47f aea1 	bne.w	800c816 <_fx_file_write+0x2c2>
            else
#endif /* FX_ENABLE_FAULT_TOLERANT */
            {

                /* Place an end-of-file marker on the last cluster.  */
                status = _fx_utility_FAT_entry_write(media_ptr, last_cluster, media_ptr -> fx_media_fat_last);
 800cad4:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800cad8:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 800cadc:	f8d3 347c 	ldr.w	r3, [r3, #1148]	@ 0x47c
 800cae0:	461a      	mov	r2, r3
 800cae2:	f8d7 11cc 	ldr.w	r1, [r7, #460]	@ 0x1cc
 800cae6:	f8d7 01ac 	ldr.w	r0, [r7, #428]	@ 0x1ac
 800caea:	f002 f982 	bl	800edf2 <_fx_utility_FAT_entry_write>
 800caee:	f8c7 01ec 	str.w	r0, [r7, #492]	@ 0x1ec
            }

            /* Check for a bad FAT write status.  */
            if (status !=  FX_SUCCESS)
 800caf2:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 800caf6:	2b00      	cmp	r3, #0
 800caf8:	d002      	beq.n	800cb00 <_fx_file_write+0x5ac>

                /* Release media protection.  */
                FX_UNPROTECT

                /* Return the bad status.  */
                return(status);
 800cafa:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 800cafe:	e3df      	b.n	800d2c0 <_fx_file_write+0xd6c>
#ifdef FX_ENABLE_EXFAT
        }
#endif /* FX_ENABLE_EXFAT */

        /* Determine if the file already had clusters.  */
        if (file_ptr -> fx_file_last_physical_cluster)
 800cb00:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800cb04:	69db      	ldr	r3, [r3, #28]
 800cb06:	2b00      	cmp	r3, #0
 800cb08:	d012      	beq.n	800cb30 <_fx_file_write+0x5dc>
                         ((replace_clusters == 0) && (first_new_cluster)))
                {
                    status = _fx_utility_FAT_entry_write(media_ptr, file_ptr -> fx_file_last_physical_cluster, first_new_cluster);
                }
#else
                status = _fx_utility_FAT_entry_write(media_ptr, file_ptr -> fx_file_last_physical_cluster, first_new_cluster);
 800cb0a:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800cb0e:	69db      	ldr	r3, [r3, #28]
 800cb10:	f8d7 21d0 	ldr.w	r2, [r7, #464]	@ 0x1d0
 800cb14:	4619      	mov	r1, r3
 800cb16:	f8d7 01ac 	ldr.w	r0, [r7, #428]	@ 0x1ac
 800cb1a:	f002 f96a 	bl	800edf2 <_fx_utility_FAT_entry_write>
 800cb1e:	f8c7 01ec 	str.w	r0, [r7, #492]	@ 0x1ec
#endif /* FX_ENABLE_FAULT_TOLERANT */

                /* Check for a bad FAT write status.  */
                if (status !=  FX_SUCCESS)
 800cb22:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 800cb26:	2b00      	cmp	r3, #0
 800cb28:	d002      	beq.n	800cb30 <_fx_file_write+0x5dc>

                    /* Release media protection.  */
                    FX_UNPROTECT

                    /* Return the bad status.  */
                    return(status);
 800cb2a:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 800cb2e:	e3c7      	b.n	800d2c0 <_fx_file_write+0xd6c>
        else
#endif /* FX_ENABLE_FAULT_TOLERANT */
        {

            /* Update the file control block with the last physical cluster.  */
            file_ptr -> fx_file_last_physical_cluster =  last_cluster;
 800cb30:	f8d7 219c 	ldr.w	r2, [r7, #412]	@ 0x19c
 800cb34:	f8d7 31cc 	ldr.w	r3, [r7, #460]	@ 0x1cc
 800cb38:	61d3      	str	r3, [r2, #28]
        }
    }

    /* Check for a need to increment to the next sector within a previously
       allocated cluster.  */
    if (file_ptr -> fx_file_current_logical_offset >=
 800cb3a:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800cb3e:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
        media_ptr -> fx_media_bytes_per_sector)
 800cb40:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800cb44:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
    if (file_ptr -> fx_file_current_logical_offset >=
 800cb46:	429a      	cmp	r2, r3
 800cb48:	d31b      	bcc.n	800cb82 <_fx_file_write+0x62e>
    {

        /* Update the sector specific file parameters to start at the
           next logical sector.  */
        file_ptr -> fx_file_current_logical_sector++;
 800cb4a:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800cb4e:	e9d3 230a 	ldrd	r2, r3, [r3, #40]	@ 0x28
 800cb52:	1c51      	adds	r1, r2, #1
 800cb54:	f8c7 10c0 	str.w	r1, [r7, #192]	@ 0xc0
 800cb58:	f143 0300 	adc.w	r3, r3, #0
 800cb5c:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
 800cb60:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800cb64:	e9d7 1230 	ldrd	r1, r2, [r7, #192]	@ 0xc0
 800cb68:	e9c3 120a 	strd	r1, r2, [r3, #40]	@ 0x28
        file_ptr -> fx_file_current_relative_sector++;
 800cb6c:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800cb70:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800cb72:	1c5a      	adds	r2, r3, #1
 800cb74:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800cb78:	639a      	str	r2, [r3, #56]	@ 0x38
        file_ptr -> fx_file_current_logical_offset =  0;
 800cb7a:	f8d7 219c 	ldr.w	r2, [r7, #412]	@ 0x19c
 800cb7e:	2300      	movs	r3, #0
 800cb80:	6313      	str	r3, [r2, #48]	@ 0x30
    }

    /* At this point there is enough room to perform the file write operation.  */

    /* Setup local buffer pointer.  */
    source_ptr =  (UCHAR *)buffer_ptr;
 800cb82:	f8d7 3198 	ldr.w	r3, [r7, #408]	@ 0x198
 800cb86:	f8c7 31d4 	str.w	r3, [r7, #468]	@ 0x1d4

    /* Setup the remaining number of bytes to write.  */
    bytes_remaining =  size;
 800cb8a:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
 800cb8e:	2200      	movs	r2, #0
 800cb90:	613b      	str	r3, [r7, #16]
 800cb92:	617a      	str	r2, [r7, #20]
 800cb94:	e9d7 3404 	ldrd	r3, r4, [r7, #16]
 800cb98:	e9c7 3478 	strd	r3, r4, [r7, #480]	@ 0x1e0
        }
    }
#endif /* FX_ENABLE_FAULT_TOLERANT */

    /* Loop to write all of the bytes.  */
    while (bytes_remaining)
 800cb9c:	e26c      	b.n	800d078 <_fx_file_write+0xb24>
    {

        /* Determine if a beginning or ending partial write is required.  */
        if ((file_ptr -> fx_file_current_logical_offset) ||
 800cb9e:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800cba2:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800cba4:	2b00      	cmp	r3, #0
 800cba6:	d111      	bne.n	800cbcc <_fx_file_write+0x678>
            (bytes_remaining < media_ptr -> fx_media_bytes_per_sector))
 800cba8:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800cbac:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800cbae:	2200      	movs	r2, #0
 800cbb0:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
 800cbb4:	f8c7 20bc 	str.w	r2, [r7, #188]	@ 0xbc
        if ((file_ptr -> fx_file_current_logical_offset) ||
 800cbb8:	e9d7 2378 	ldrd	r2, r3, [r7, #480]	@ 0x1e0
 800cbbc:	e9d7 452e 	ldrd	r4, r5, [r7, #184]	@ 0xb8
 800cbc0:	4621      	mov	r1, r4
 800cbc2:	428a      	cmp	r2, r1
 800cbc4:	4629      	mov	r1, r5
 800cbc6:	418b      	sbcs	r3, r1
 800cbc8:	f080 8088 	bcs.w	800ccdc <_fx_file_write+0x788>
                }
            }
            else
#endif /* FX_ENABLE_FAULT_TOLERANT */
            {
                status =  _fx_utility_logical_sector_read(media_ptr,
 800cbcc:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800cbd0:	e9d3 010a 	ldrd	r0, r1, [r3, #40]	@ 0x28
                                                          file_ptr -> fx_file_current_logical_sector,
                                                          media_ptr -> fx_media_memory_buffer, ((ULONG) 1), FX_DATA_SECTOR);
 800cbd4:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800cbd8:	689a      	ldr	r2, [r3, #8]
                status =  _fx_utility_logical_sector_read(media_ptr,
 800cbda:	2304      	movs	r3, #4
 800cbdc:	9302      	str	r3, [sp, #8]
 800cbde:	2301      	movs	r3, #1
 800cbe0:	9301      	str	r3, [sp, #4]
 800cbe2:	9200      	str	r2, [sp, #0]
 800cbe4:	4602      	mov	r2, r0
 800cbe6:	460b      	mov	r3, r1
 800cbe8:	f8d7 01ac 	ldr.w	r0, [r7, #428]	@ 0x1ac
 800cbec:	f003 fae6 	bl	80101bc <_fx_utility_logical_sector_read>
 800cbf0:	f8c7 01ec 	str.w	r0, [r7, #492]	@ 0x1ec
            }

            /* Check for good completion status.  */
            if (status !=  FX_SUCCESS)
 800cbf4:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 800cbf8:	2b00      	cmp	r3, #0
 800cbfa:	d002      	beq.n	800cc02 <_fx_file_write+0x6ae>

                /* Release media protection.  */
                FX_UNPROTECT

                /* Return the error status.  */
                return(status);
 800cbfc:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 800cc00:	e35e      	b.n	800d2c0 <_fx_file_write+0xd6c>
            }

            /* Copy the appropriate number of bytes into the destination buffer.  */
            copy_bytes =  media_ptr -> fx_media_bytes_per_sector -
 800cc02:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800cc06:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
                file_ptr -> fx_file_current_logical_offset;
 800cc08:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800cc0c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
            copy_bytes =  media_ptr -> fx_media_bytes_per_sector -
 800cc0e:	1ad3      	subs	r3, r2, r3
 800cc10:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8

            /* Check to see if only a portion of the sector needs to be
               copied.  */
            if (copy_bytes > bytes_remaining)
 800cc14:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 800cc18:	2200      	movs	r2, #0
 800cc1a:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
 800cc1e:	f8c7 20b4 	str.w	r2, [r7, #180]	@ 0xb4
 800cc22:	e9d7 2378 	ldrd	r2, r3, [r7, #480]	@ 0x1e0
 800cc26:	e9d7 452c 	ldrd	r4, r5, [r7, #176]	@ 0xb0
 800cc2a:	4621      	mov	r1, r4
 800cc2c:	428a      	cmp	r2, r1
 800cc2e:	4629      	mov	r1, r5
 800cc30:	418b      	sbcs	r3, r1
 800cc32:	d203      	bcs.n	800cc3c <_fx_file_write+0x6e8>
            {

                /* Adjust the number of bytes to copy.  */
                copy_bytes =  (ULONG)bytes_remaining;
 800cc34:	f8d7 31e0 	ldr.w	r3, [r7, #480]	@ 0x1e0
 800cc38:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8
            }

            /* Actually perform the memory copy.  */
            _fx_utility_memory_copy(source_ptr, ((UCHAR *)media_ptr -> fx_media_memory_buffer) +  /* Use case of memcpy is verified. */
 800cc3c:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800cc40:	689a      	ldr	r2, [r3, #8]
                                    file_ptr -> fx_file_current_logical_offset,
 800cc42:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800cc46:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
            _fx_utility_memory_copy(source_ptr, ((UCHAR *)media_ptr -> fx_media_memory_buffer) +  /* Use case of memcpy is verified. */
 800cc48:	4413      	add	r3, r2
 800cc4a:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 800cc4e:	4619      	mov	r1, r3
 800cc50:	f8d7 01d4 	ldr.w	r0, [r7, #468]	@ 0x1d4
 800cc54:	f003 feae 	bl	80109b4 <_fx_utility_memory_copy>
                                    copy_bytes);

            /* Write back the current logical sector.  */
            status =  _fx_utility_logical_sector_write(media_ptr, file_ptr -> fx_file_current_logical_sector,
 800cc58:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800cc5c:	e9d3 010a 	ldrd	r0, r1, [r3, #40]	@ 0x28
                                                       media_ptr -> fx_media_memory_buffer, ((ULONG) 1), FX_DATA_SECTOR);
 800cc60:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800cc64:	689a      	ldr	r2, [r3, #8]
            status =  _fx_utility_logical_sector_write(media_ptr, file_ptr -> fx_file_current_logical_sector,
 800cc66:	2304      	movs	r3, #4
 800cc68:	9302      	str	r3, [sp, #8]
 800cc6a:	2301      	movs	r3, #1
 800cc6c:	9301      	str	r3, [sp, #4]
 800cc6e:	9200      	str	r2, [sp, #0]
 800cc70:	4602      	mov	r2, r0
 800cc72:	460b      	mov	r3, r1
 800cc74:	f8d7 01ac 	ldr.w	r0, [r7, #428]	@ 0x1ac
 800cc78:	f003 fd34 	bl	80106e4 <_fx_utility_logical_sector_write>
 800cc7c:	f8c7 01ec 	str.w	r0, [r7, #492]	@ 0x1ec

            /* Check for good completion status.  */
            if (status !=  FX_SUCCESS)
 800cc80:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 800cc84:	2b00      	cmp	r3, #0
 800cc86:	d002      	beq.n	800cc8e <_fx_file_write+0x73a>

                /* Release media protection.  */
                FX_UNPROTECT

                /* Return the error status.  */
                return(status);
 800cc88:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 800cc8c:	e318      	b.n	800d2c0 <_fx_file_write+0xd6c>
            }


            /* Increment the logical sector byte offset.  */
            file_ptr -> fx_file_current_logical_offset =
                file_ptr -> fx_file_current_logical_offset + copy_bytes;
 800cc8e:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800cc92:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 800cc94:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 800cc98:	441a      	add	r2, r3
            file_ptr -> fx_file_current_logical_offset =
 800cc9a:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800cc9e:	631a      	str	r2, [r3, #48]	@ 0x30

            /* Adjust the remaining bytes to read.  */
            bytes_remaining =  bytes_remaining - copy_bytes;
 800cca0:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 800cca4:	2200      	movs	r2, #0
 800cca6:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
 800ccaa:	f8c7 20ac 	str.w	r2, [r7, #172]	@ 0xac
 800ccae:	e9d7 2378 	ldrd	r2, r3, [r7, #480]	@ 0x1e0
 800ccb2:	e9d7 452a 	ldrd	r4, r5, [r7, #168]	@ 0xa8
 800ccb6:	4621      	mov	r1, r4
 800ccb8:	1a51      	subs	r1, r2, r1
 800ccba:	60b9      	str	r1, [r7, #8]
 800ccbc:	4629      	mov	r1, r5
 800ccbe:	eb63 0301 	sbc.w	r3, r3, r1
 800ccc2:	60fb      	str	r3, [r7, #12]
 800ccc4:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
 800ccc8:	e9c7 3478 	strd	r3, r4, [r7, #480]	@ 0x1e0

            /* Adjust the pointer to the source buffer.  */
            source_ptr =  source_ptr + copy_bytes;
 800cccc:	f8d7 21d4 	ldr.w	r2, [r7, #468]	@ 0x1d4
 800ccd0:	f8d7 31d8 	ldr.w	r3, [r7, #472]	@ 0x1d8
 800ccd4:	4413      	add	r3, r2
 800ccd6:	f8c7 31d4 	str.w	r3, [r7, #468]	@ 0x1d4
 800ccda:	e0ff      	b.n	800cedc <_fx_file_write+0x988>
        {

            /* Attempt to write multiple sectors directly to the media.  */

            /* Calculate the number of whole sectors to write.  */
            sectors =  (UINT)(bytes_remaining / media_ptr -> fx_media_bytes_per_sector);
 800ccdc:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800cce0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800cce2:	2200      	movs	r2, #0
 800cce4:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
 800cce8:	f8c7 20a4 	str.w	r2, [r7, #164]	@ 0xa4
 800ccec:	e9d7 2328 	ldrd	r2, r3, [r7, #160]	@ 0xa0
 800ccf0:	e9d7 0178 	ldrd	r0, r1, [r7, #480]	@ 0x1e0
 800ccf4:	f7f3 fac0 	bl	8000278 <__aeabi_uldivmod>
 800ccf8:	4602      	mov	r2, r0
 800ccfa:	460b      	mov	r3, r1
 800ccfc:	4613      	mov	r3, r2
 800ccfe:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8

            next_cluster = cluster = file_ptr -> fx_file_current_physical_cluster;
 800cd02:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800cd06:	6a1b      	ldr	r3, [r3, #32]
 800cd08:	f8c7 31c8 	str.w	r3, [r7, #456]	@ 0x1c8
 800cd0c:	f8d7 31c8 	ldr.w	r3, [r7, #456]	@ 0x1c8
 800cd10:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4

            for (i = (media_ptr -> fx_media_sectors_per_cluster -
 800cd14:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800cd18:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
                      file_ptr -> fx_file_current_relative_sector); i < sectors; i += media_ptr -> fx_media_sectors_per_cluster)
 800cd1a:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800cd1e:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
            for (i = (media_ptr -> fx_media_sectors_per_cluster -
 800cd20:	1ad3      	subs	r3, r2, r3
 800cd22:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc
 800cd26:	e038      	b.n	800cd9a <_fx_file_write+0x846>
                    cluster++;
                }
                else
                {
#endif /* FX_ENABLE_EXFAT */
                    status =  _fx_utility_FAT_entry_read(media_ptr, cluster, &next_cluster);
 800cd28:	f507 73d2 	add.w	r3, r7, #420	@ 0x1a4
 800cd2c:	461a      	mov	r2, r3
 800cd2e:	f8d7 11c8 	ldr.w	r1, [r7, #456]	@ 0x1c8
 800cd32:	f8d7 01ac 	ldr.w	r0, [r7, #428]	@ 0x1ac
 800cd36:	f001 fe33 	bl	800e9a0 <_fx_utility_FAT_entry_read>
 800cd3a:	f8c7 01ec 	str.w	r0, [r7, #492]	@ 0x1ec

                    /* Determine if an error is present.  */
                    if ((status != FX_SUCCESS) || (next_cluster < FX_FAT_ENTRY_START) ||
 800cd3e:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 800cd42:	2b00      	cmp	r3, #0
 800cd44:	d10d      	bne.n	800cd62 <_fx_file_write+0x80e>
 800cd46:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 800cd4a:	2b01      	cmp	r3, #1
 800cd4c:	d909      	bls.n	800cd62 <_fx_file_write+0x80e>
                        (next_cluster > media_ptr -> fx_media_fat_reserved))
 800cd4e:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800cd52:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 800cd56:	f8d3 2478 	ldr.w	r2, [r3, #1144]	@ 0x478
 800cd5a:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
                    if ((status != FX_SUCCESS) || (next_cluster < FX_FAT_ENTRY_START) ||
 800cd5e:	429a      	cmp	r2, r3
 800cd60:	d208      	bcs.n	800cd74 <_fx_file_write+0x820>

                        /* Release media protection.  */
                        FX_UNPROTECT

                        /* Send error message back to caller.  */
                        if (status != FX_SUCCESS)
 800cd62:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 800cd66:	2b00      	cmp	r3, #0
 800cd68:	d002      	beq.n	800cd70 <_fx_file_write+0x81c>
                        {
                            return(status);
 800cd6a:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 800cd6e:	e2a7      	b.n	800d2c0 <_fx_file_write+0xd6c>
                        }
                        else
                        {
                            return(FX_FILE_CORRUPT);
 800cd70:	2308      	movs	r3, #8
 800cd72:	e2a5      	b.n	800d2c0 <_fx_file_write+0xd6c>
                        }
                    }

                    if (next_cluster != cluster + 1)
 800cd74:	f8d7 31c8 	ldr.w	r3, [r7, #456]	@ 0x1c8
 800cd78:	1c5a      	adds	r2, r3, #1
 800cd7a:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 800cd7e:	429a      	cmp	r2, r3
 800cd80:	d112      	bne.n	800cda8 <_fx_file_write+0x854>
                    {
                        break;
                    }
                    else
                    {
                        cluster = next_cluster;
 800cd82:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 800cd86:	f8c7 31c8 	str.w	r3, [r7, #456]	@ 0x1c8
                      file_ptr -> fx_file_current_relative_sector); i < sectors; i += media_ptr -> fx_media_sectors_per_cluster)
 800cd8a:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800cd8e:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
 800cd90:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 800cd94:	4413      	add	r3, r2
 800cd96:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc
 800cd9a:	f8d7 21dc 	ldr.w	r2, [r7, #476]	@ 0x1dc
 800cd9e:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 800cda2:	429a      	cmp	r2, r3
 800cda4:	d3c0      	bcc.n	800cd28 <_fx_file_write+0x7d4>
 800cda6:	e000      	b.n	800cdaa <_fx_file_write+0x856>
                        break;
 800cda8:	bf00      	nop
#ifdef FX_ENABLE_EXFAT
                }
#endif /* FX_ENABLE_EXFAT */
            }

            if (i < sectors)
 800cdaa:	f8d7 21dc 	ldr.w	r2, [r7, #476]	@ 0x1dc
 800cdae:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 800cdb2:	429a      	cmp	r2, r3
 800cdb4:	d203      	bcs.n	800cdbe <_fx_file_write+0x86a>
            {
                sectors = i;
 800cdb6:	f8d7 31dc 	ldr.w	r3, [r7, #476]	@ 0x1dc
 800cdba:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8
            }

            /* Perform the data write directly from the user's buffer of
               the appropriate number of sectors.  */
            status =  _fx_utility_logical_sector_write(media_ptr, file_ptr -> fx_file_current_logical_sector,
 800cdbe:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800cdc2:	e9d3 010a 	ldrd	r0, r1, [r3, #40]	@ 0x28
 800cdc6:	2304      	movs	r3, #4
 800cdc8:	9302      	str	r3, [sp, #8]
 800cdca:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 800cdce:	9301      	str	r3, [sp, #4]
 800cdd0:	f8d7 31d4 	ldr.w	r3, [r7, #468]	@ 0x1d4
 800cdd4:	9300      	str	r3, [sp, #0]
 800cdd6:	4602      	mov	r2, r0
 800cdd8:	460b      	mov	r3, r1
 800cdda:	f8d7 01ac 	ldr.w	r0, [r7, #428]	@ 0x1ac
 800cdde:	f003 fc81 	bl	80106e4 <_fx_utility_logical_sector_write>
 800cde2:	f8c7 01ec 	str.w	r0, [r7, #492]	@ 0x1ec
                                                       source_ptr, (ULONG) sectors, FX_DATA_SECTOR);

            /* Check for good completion status.  */
            if (status !=  FX_SUCCESS)
 800cde6:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 800cdea:	2b00      	cmp	r3, #0
 800cdec:	d002      	beq.n	800cdf4 <_fx_file_write+0x8a0>

                /* Release media protection.  */
                FX_UNPROTECT

                /* Return the error status.  */
                return(status);
 800cdee:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 800cdf2:	e265      	b.n	800d2c0 <_fx_file_write+0xd6c>

            /* Increment the current logical sector.  Subtract one from
               the sector count because we are going to use the logical
               offset to do additional sector/cluster arithmetic below.  */
            file_ptr -> fx_file_current_logical_sector =
                file_ptr -> fx_file_current_logical_sector +
 800cdf4:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800cdf8:	e9d3 010a 	ldrd	r0, r1, [r3, #40]	@ 0x28
                (sectors - 1);
 800cdfc:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 800ce00:	3b01      	subs	r3, #1
 800ce02:	2200      	movs	r2, #0
 800ce04:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
 800ce08:	f8c7 209c 	str.w	r2, [r7, #156]	@ 0x9c
                file_ptr -> fx_file_current_logical_sector +
 800ce0c:	e9d7 4526 	ldrd	r4, r5, [r7, #152]	@ 0x98
 800ce10:	4623      	mov	r3, r4
 800ce12:	18c3      	adds	r3, r0, r3
 800ce14:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
 800ce18:	462b      	mov	r3, r5
 800ce1a:	eb41 0303 	adc.w	r3, r1, r3
 800ce1e:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
            file_ptr -> fx_file_current_logical_sector =
 800ce22:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800ce26:	e9d7 1224 	ldrd	r1, r2, [r7, #144]	@ 0x90
 800ce2a:	e9c3 120a 	strd	r1, r2, [r3, #40]	@ 0x28

            /* Move the relative cluster and sector as well.  */
            file_ptr -> fx_file_current_relative_cluster = file_ptr -> fx_file_current_relative_cluster +
 800ce2e:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800ce32:	6b59      	ldr	r1, [r3, #52]	@ 0x34
                (file_ptr -> fx_file_current_relative_sector + (sectors - 1)) /
 800ce34:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800ce38:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 800ce3a:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 800ce3e:	4413      	add	r3, r2
 800ce40:	1e5a      	subs	r2, r3, #1
                media_ptr -> fx_media_sectors_per_cluster;
 800ce42:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800ce46:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
                (file_ptr -> fx_file_current_relative_sector + (sectors - 1)) /
 800ce48:	fbb2 f3f3 	udiv	r3, r2, r3
            file_ptr -> fx_file_current_relative_cluster = file_ptr -> fx_file_current_relative_cluster +
 800ce4c:	18ca      	adds	r2, r1, r3
 800ce4e:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800ce52:	635a      	str	r2, [r3, #52]	@ 0x34

            file_ptr -> fx_file_current_relative_sector =
                (file_ptr -> fx_file_current_relative_sector + (sectors - 1)) %
 800ce54:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800ce58:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 800ce5a:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 800ce5e:	4413      	add	r3, r2
 800ce60:	1e59      	subs	r1, r3, #1
                media_ptr -> fx_media_sectors_per_cluster;
 800ce62:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800ce66:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
                (file_ptr -> fx_file_current_relative_sector + (sectors - 1)) %
 800ce68:	fbb1 f3f2 	udiv	r3, r1, r2
 800ce6c:	fb02 f303 	mul.w	r3, r2, r3
 800ce70:	1aca      	subs	r2, r1, r3
            file_ptr -> fx_file_current_relative_sector =
 800ce72:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800ce76:	639a      	str	r2, [r3, #56]	@ 0x38

            /* Increment the logical sector byte offset.  */
            file_ptr -> fx_file_current_logical_offset =
                media_ptr -> fx_media_bytes_per_sector;
 800ce78:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800ce7c:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
            file_ptr -> fx_file_current_logical_offset =
 800ce7e:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800ce82:	631a      	str	r2, [r3, #48]	@ 0x30

            file_ptr -> fx_file_current_physical_cluster = cluster;
 800ce84:	f8d7 219c 	ldr.w	r2, [r7, #412]	@ 0x19c
 800ce88:	f8d7 31c8 	ldr.w	r3, [r7, #456]	@ 0x1c8
 800ce8c:	6213      	str	r3, [r2, #32]

            /* Adjust the remaining bytes.  */
            bytes_remaining =  bytes_remaining -
                (((ULONG)media_ptr -> fx_media_bytes_per_sector) * sectors);
 800ce8e:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800ce92:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 800ce94:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 800ce98:	fb02 f303 	mul.w	r3, r2, r3
 800ce9c:	2200      	movs	r2, #0
 800ce9e:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
 800cea2:	f8c7 208c 	str.w	r2, [r7, #140]	@ 0x8c
            bytes_remaining =  bytes_remaining -
 800cea6:	e9d7 2378 	ldrd	r2, r3, [r7, #480]	@ 0x1e0
 800ceaa:	e9d7 4522 	ldrd	r4, r5, [r7, #136]	@ 0x88
 800ceae:	4621      	mov	r1, r4
 800ceb0:	1a51      	subs	r1, r2, r1
 800ceb2:	6039      	str	r1, [r7, #0]
 800ceb4:	4629      	mov	r1, r5
 800ceb6:	eb63 0301 	sbc.w	r3, r3, r1
 800ceba:	607b      	str	r3, [r7, #4]
 800cebc:	e9d7 3400 	ldrd	r3, r4, [r7]
 800cec0:	e9c7 3478 	strd	r3, r4, [r7, #480]	@ 0x1e0

            /* Adjust the pointer to the source buffer.  */
            source_ptr =  source_ptr +
                (((ULONG)media_ptr -> fx_media_bytes_per_sector) * sectors);
 800cec4:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800cec8:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 800ceca:	f8d7 31b8 	ldr.w	r3, [r7, #440]	@ 0x1b8
 800cece:	fb03 f202 	mul.w	r2, r3, r2
            source_ptr =  source_ptr +
 800ced2:	f8d7 31d4 	ldr.w	r3, [r7, #468]	@ 0x1d4
 800ced6:	4413      	add	r3, r2
 800ced8:	f8c7 31d4 	str.w	r3, [r7, #468]	@ 0x1d4
        }

        /* At this point, we have either written a partial sector or have successfully
           written one or more whole sectors.  Determine if we are at the end of
           the current logical sector.  */
        if (file_ptr -> fx_file_current_logical_offset >=
 800cedc:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800cee0:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
            media_ptr -> fx_media_bytes_per_sector)
 800cee2:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800cee6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
        if (file_ptr -> fx_file_current_logical_offset >=
 800cee8:	429a      	cmp	r2, r3
 800ceea:	f0c0 80c5 	bcc.w	800d078 <_fx_file_write+0xb24>
        {

            /* Determine if we are at the exact physical end of the file.  */
            if ((bytes_remaining == 0) &&
 800ceee:	e9d7 2378 	ldrd	r2, r3, [r7, #480]	@ 0x1e0
 800cef2:	4313      	orrs	r3, r2
 800cef4:	d11f      	bne.n	800cf36 <_fx_file_write+0x9e2>
                ((file_ptr -> fx_file_current_file_offset + size) >=
 800cef6:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800cefa:	e9d3 2310 	ldrd	r2, r3, [r3, #64]	@ 0x40
 800cefe:	f8d7 1194 	ldr.w	r1, [r7, #404]	@ 0x194
 800cf02:	2000      	movs	r0, #0
 800cf04:	f8c7 1080 	str.w	r1, [r7, #128]	@ 0x80
 800cf08:	f8c7 0084 	str.w	r0, [r7, #132]	@ 0x84
 800cf0c:	e9d7 4520 	ldrd	r4, r5, [r7, #128]	@ 0x80
 800cf10:	4621      	mov	r1, r4
 800cf12:	1851      	adds	r1, r2, r1
 800cf14:	67b9      	str	r1, [r7, #120]	@ 0x78
 800cf16:	4629      	mov	r1, r5
 800cf18:	414b      	adcs	r3, r1
 800cf1a:	67fb      	str	r3, [r7, #124]	@ 0x7c
                 file_ptr -> fx_file_current_available_size))
 800cf1c:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800cf20:	e9d3 2314 	ldrd	r2, r3, [r3, #80]	@ 0x50
            if ((bytes_remaining == 0) &&
 800cf24:	e9d7 451e 	ldrd	r4, r5, [r7, #120]	@ 0x78
 800cf28:	4621      	mov	r1, r4
 800cf2a:	4291      	cmp	r1, r2
 800cf2c:	4629      	mov	r1, r5
 800cf2e:	eb71 0303 	sbcs.w	r3, r1, r3
 800cf32:	f080 80a7 	bcs.w	800d084 <_fx_file_write+0xb30>
            /* We need to move to the next logical sector, but first
               determine if the next logical sector is within the same
               cluster.  */

            /* Increment the current relative sector in the cluster.  */
            file_ptr -> fx_file_current_relative_sector++;
 800cf36:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800cf3a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800cf3c:	1c5a      	adds	r2, r3, #1
 800cf3e:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800cf42:	639a      	str	r2, [r3, #56]	@ 0x38

            /* Determine if this is in a new cluster.  */
            if (file_ptr -> fx_file_current_relative_sector >=
 800cf44:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800cf48:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
                media_ptr -> fx_media_sectors_per_cluster)
 800cf4a:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800cf4e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
            if (file_ptr -> fx_file_current_relative_sector >=
 800cf50:	429a      	cmp	r2, r3
 800cf52:	d37e      	bcc.n	800d052 <_fx_file_write+0xafe>
                {
#endif /* FX_ENABLE_EXFAT */

                    /* Read the FAT entry of the current cluster to find
                       the next cluster.  */
                    status =  _fx_utility_FAT_entry_read(media_ptr,
 800cf54:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800cf58:	6a19      	ldr	r1, [r3, #32]
 800cf5a:	f507 73d2 	add.w	r3, r7, #420	@ 0x1a4
 800cf5e:	461a      	mov	r2, r3
 800cf60:	f8d7 01ac 	ldr.w	r0, [r7, #428]	@ 0x1ac
 800cf64:	f001 fd1c 	bl	800e9a0 <_fx_utility_FAT_entry_read>
 800cf68:	f8c7 01ec 	str.w	r0, [r7, #492]	@ 0x1ec
                                                         file_ptr -> fx_file_current_physical_cluster, &next_cluster);

                    /* Determine if an error is present.  */
                    if ((status != FX_SUCCESS) || (next_cluster < FX_FAT_ENTRY_START) ||
 800cf6c:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 800cf70:	2b00      	cmp	r3, #0
 800cf72:	d10d      	bne.n	800cf90 <_fx_file_write+0xa3c>
 800cf74:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 800cf78:	2b01      	cmp	r3, #1
 800cf7a:	d909      	bls.n	800cf90 <_fx_file_write+0xa3c>
                        (next_cluster > media_ptr -> fx_media_fat_reserved))
 800cf7c:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800cf80:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 800cf84:	f8d3 2478 	ldr.w	r2, [r3, #1144]	@ 0x478
 800cf88:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
                    if ((status != FX_SUCCESS) || (next_cluster < FX_FAT_ENTRY_START) ||
 800cf8c:	429a      	cmp	r2, r3
 800cf8e:	d208      	bcs.n	800cfa2 <_fx_file_write+0xa4e>

                        /* Release media protection.  */
                        FX_UNPROTECT

                        /* Send error message back to caller.  */
                        if (status != FX_SUCCESS)
 800cf90:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 800cf94:	2b00      	cmp	r3, #0
 800cf96:	d002      	beq.n	800cf9e <_fx_file_write+0xa4a>
                        {
                            return(status);
 800cf98:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 800cf9c:	e190      	b.n	800d2c0 <_fx_file_write+0xd6c>
                        }
                        else
                        {
                            return(FX_FILE_CORRUPT);
 800cf9e:	2308      	movs	r3, #8
 800cfa0:	e18e      	b.n	800d2c0 <_fx_file_write+0xd6c>
                }
#endif /* FX_ENABLE_EXFAT */

                /* Otherwise, we have a new cluster.  Save it in the file
                   control block and calculate a new logical sector value.  */
                file_ptr -> fx_file_current_physical_cluster =  next_cluster;
 800cfa2:	f8d7 21a4 	ldr.w	r2, [r7, #420]	@ 0x1a4
 800cfa6:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800cfaa:	621a      	str	r2, [r3, #32]
                file_ptr -> fx_file_current_relative_cluster++;
 800cfac:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800cfb0:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800cfb2:	1c5a      	adds	r2, r3, #1
 800cfb4:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800cfb8:	635a      	str	r2, [r3, #52]	@ 0x34
                file_ptr -> fx_file_current_logical_sector = ((ULONG)media_ptr -> fx_media_data_sector_start) +
 800cfba:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800cfbe:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800cfc0:	2200      	movs	r2, #0
 800cfc2:	673b      	str	r3, [r7, #112]	@ 0x70
 800cfc4:	677a      	str	r2, [r7, #116]	@ 0x74
                    ((((ULONG64)next_cluster) - FX_FAT_ENTRY_START) *
 800cfc6:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 800cfca:	2200      	movs	r2, #0
 800cfcc:	66bb      	str	r3, [r7, #104]	@ 0x68
 800cfce:	66fa      	str	r2, [r7, #108]	@ 0x6c
 800cfd0:	e9d7 121a 	ldrd	r1, r2, [r7, #104]	@ 0x68
 800cfd4:	460b      	mov	r3, r1
 800cfd6:	3b02      	subs	r3, #2
 800cfd8:	663b      	str	r3, [r7, #96]	@ 0x60
 800cfda:	4613      	mov	r3, r2
 800cfdc:	f143 33ff 	adc.w	r3, r3, #4294967295
 800cfe0:	667b      	str	r3, [r7, #100]	@ 0x64
                     ((ULONG)media_ptr -> fx_media_sectors_per_cluster));
 800cfe2:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800cfe6:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800cfe8:	2200      	movs	r2, #0
 800cfea:	65bb      	str	r3, [r7, #88]	@ 0x58
 800cfec:	65fa      	str	r2, [r7, #92]	@ 0x5c
                    ((((ULONG64)next_cluster) - FX_FAT_ENTRY_START) *
 800cfee:	e9d7 4518 	ldrd	r4, r5, [r7, #96]	@ 0x60
 800cff2:	462b      	mov	r3, r5
 800cff4:	e9d7 8916 	ldrd	r8, r9, [r7, #88]	@ 0x58
 800cff8:	4642      	mov	r2, r8
 800cffa:	fb02 f203 	mul.w	r2, r2, r3
 800cffe:	464b      	mov	r3, r9
 800d000:	4621      	mov	r1, r4
 800d002:	fb01 f303 	mul.w	r3, r1, r3
 800d006:	4413      	add	r3, r2
 800d008:	4622      	mov	r2, r4
 800d00a:	4641      	mov	r1, r8
 800d00c:	fba2 1201 	umull	r1, r2, r2, r1
 800d010:	f8c7 216c 	str.w	r2, [r7, #364]	@ 0x16c
 800d014:	460a      	mov	r2, r1
 800d016:	f8c7 2168 	str.w	r2, [r7, #360]	@ 0x168
 800d01a:	f8d7 216c 	ldr.w	r2, [r7, #364]	@ 0x16c
 800d01e:	4413      	add	r3, r2
 800d020:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
                file_ptr -> fx_file_current_logical_sector = ((ULONG)media_ptr -> fx_media_data_sector_start) +
 800d024:	e9d7 451c 	ldrd	r4, r5, [r7, #112]	@ 0x70
 800d028:	4623      	mov	r3, r4
 800d02a:	e9d7 015a 	ldrd	r0, r1, [r7, #360]	@ 0x168
 800d02e:	4602      	mov	r2, r0
 800d030:	189b      	adds	r3, r3, r2
 800d032:	653b      	str	r3, [r7, #80]	@ 0x50
 800d034:	462b      	mov	r3, r5
 800d036:	460a      	mov	r2, r1
 800d038:	4153      	adcs	r3, r2
 800d03a:	657b      	str	r3, [r7, #84]	@ 0x54
 800d03c:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800d040:	e9d7 1214 	ldrd	r1, r2, [r7, #80]	@ 0x50
 800d044:	e9c3 120a 	strd	r1, r2, [r3, #40]	@ 0x28
                file_ptr -> fx_file_current_relative_sector =  0;
 800d048:	f8d7 219c 	ldr.w	r2, [r7, #412]	@ 0x19c
 800d04c:	2300      	movs	r3, #0
 800d04e:	6393      	str	r3, [r2, #56]	@ 0x38
 800d050:	e00e      	b.n	800d070 <_fx_file_write+0xb1c>
            else
            {

                /* Still within the same cluster so just increment the
                   logical sector.  */
                file_ptr -> fx_file_current_logical_sector++;
 800d052:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800d056:	e9d3 230a 	ldrd	r2, r3, [r3, #40]	@ 0x28
 800d05a:	1c51      	adds	r1, r2, #1
 800d05c:	64b9      	str	r1, [r7, #72]	@ 0x48
 800d05e:	f143 0300 	adc.w	r3, r3, #0
 800d062:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800d064:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800d068:	e9d7 1212 	ldrd	r1, r2, [r7, #72]	@ 0x48
 800d06c:	e9c3 120a 	strd	r1, r2, [r3, #40]	@ 0x28
            }

            /* In either case, we are now positioned at a new sector so
               clear the logical sector offset.  */
            file_ptr -> fx_file_current_logical_offset =  0;
 800d070:	f8d7 219c 	ldr.w	r2, [r7, #412]	@ 0x19c
 800d074:	2300      	movs	r3, #0
 800d076:	6313      	str	r3, [r2, #48]	@ 0x30
    while (bytes_remaining)
 800d078:	e9d7 2378 	ldrd	r2, r3, [r7, #480]	@ 0x1e0
 800d07c:	4313      	orrs	r3, r2
 800d07e:	f47f ad8e 	bne.w	800cb9e <_fx_file_write+0x64a>
 800d082:	e000      	b.n	800d086 <_fx_file_write+0xb32>
                break;
 800d084:	bf00      	nop
    }
#endif /* FX_ENABLE_FAULT_TOLERANT */

    /* Adjust the current file offset accordingly.  */
    file_ptr -> fx_file_current_file_offset =
        file_ptr -> fx_file_current_file_offset + size;
 800d086:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800d08a:	e9d3 2310 	ldrd	r2, r3, [r3, #64]	@ 0x40
 800d08e:	f8d7 1194 	ldr.w	r1, [r7, #404]	@ 0x194
 800d092:	2000      	movs	r0, #0
 800d094:	6439      	str	r1, [r7, #64]	@ 0x40
 800d096:	6478      	str	r0, [r7, #68]	@ 0x44
 800d098:	e9d7 4510 	ldrd	r4, r5, [r7, #64]	@ 0x40
 800d09c:	4621      	mov	r1, r4
 800d09e:	1851      	adds	r1, r2, r1
 800d0a0:	63b9      	str	r1, [r7, #56]	@ 0x38
 800d0a2:	4629      	mov	r1, r5
 800d0a4:	eb43 0101 	adc.w	r1, r3, r1
 800d0a8:	63f9      	str	r1, [r7, #60]	@ 0x3c
    file_ptr -> fx_file_current_file_offset =
 800d0aa:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800d0ae:	e9d7 120e 	ldrd	r1, r2, [r7, #56]	@ 0x38
 800d0b2:	e9c3 1210 	strd	r1, r2, [r3, #64]	@ 0x40

    /* Copy the new file size into the directory entry.  */
    file_ptr -> fx_file_dir_entry.fx_dir_entry_file_size =
        file_ptr -> fx_file_current_file_size;
 800d0b6:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800d0ba:	e9d3 2312 	ldrd	r2, r3, [r3, #72]	@ 0x48
    file_ptr -> fx_file_dir_entry.fx_dir_entry_file_size =
 800d0be:	f8d7 119c 	ldr.w	r1, [r7, #412]	@ 0x19c
 800d0c2:	e9c1 2328 	strd	r2, r3, [r1, #160]	@ 0xa0

    /* Determine if this write was done past the previous file size.  */
    if (file_ptr -> fx_file_current_file_offset >
 800d0c6:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800d0ca:	e9d3 2310 	ldrd	r2, r3, [r3, #64]	@ 0x40
        file_ptr -> fx_file_current_file_size)
 800d0ce:	f8d7 119c 	ldr.w	r1, [r7, #412]	@ 0x19c
 800d0d2:	e9d1 0112 	ldrd	r0, r1, [r1, #72]	@ 0x48
    if (file_ptr -> fx_file_current_file_offset >
 800d0d6:	4290      	cmp	r0, r2
 800d0d8:	eb71 0303 	sbcs.w	r3, r1, r3
 800d0dc:	f080 80de 	bcs.w	800d29c <_fx_file_write+0xd48>
    {

        /* Yes, we have written past the previous end of the file.  Update
           the file size.  */
        file_ptr -> fx_file_current_file_size =  file_ptr -> fx_file_current_file_offset;
 800d0e0:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800d0e4:	e9d3 2310 	ldrd	r2, r3, [r3, #64]	@ 0x40
 800d0e8:	f8d7 119c 	ldr.w	r1, [r7, #412]	@ 0x19c
 800d0ec:	e9c1 2312 	strd	r2, r3, [r1, #72]	@ 0x48

#ifndef FX_DONT_UPDATE_OPEN_FILES

        /* Search the opened files list to see if the same file is opened for reading.  */
        open_count =  media_ptr -> fx_media_opened_file_count;
 800d0f0:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800d0f4:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
 800d0f8:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
        search_ptr =  media_ptr -> fx_media_opened_file_list;
 800d0fc:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800d100:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
 800d104:	f8c7 31b0 	str.w	r3, [r7, #432]	@ 0x1b0
        while (open_count)
 800d108:	e0c3      	b.n	800d292 <_fx_file_write+0xd3e>
        {

            /* Is this file the same file opened for reading?  */
            if ((search_ptr != file_ptr) &&
 800d10a:	f8d7 21b0 	ldr.w	r2, [r7, #432]	@ 0x1b0
 800d10e:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800d112:	429a      	cmp	r2, r3
 800d114:	f000 80b3 	beq.w	800d27e <_fx_file_write+0xd2a>
                (search_ptr -> fx_file_dir_entry.fx_dir_entry_log_sector ==
 800d118:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 800d11c:	e9d3 012a 	ldrd	r0, r1, [r3, #168]	@ 0xa8
                 file_ptr -> fx_file_dir_entry.fx_dir_entry_log_sector) &&
 800d120:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800d124:	e9d3 232a 	ldrd	r2, r3, [r3, #168]	@ 0xa8
            if ((search_ptr != file_ptr) &&
 800d128:	4299      	cmp	r1, r3
 800d12a:	bf08      	it	eq
 800d12c:	4290      	cmpeq	r0, r2
 800d12e:	f040 80a6 	bne.w	800d27e <_fx_file_write+0xd2a>
                (search_ptr -> fx_file_dir_entry.fx_dir_entry_byte_offset ==
 800d132:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 800d136:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
                 file_ptr -> fx_file_dir_entry.fx_dir_entry_byte_offset))
 800d13a:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800d13e:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
                 file_ptr -> fx_file_dir_entry.fx_dir_entry_log_sector) &&
 800d142:	429a      	cmp	r2, r3
 800d144:	f040 809b 	bne.w	800d27e <_fx_file_write+0xd2a>
            {

                /* Yes, the same file is opened for reading.  */

                /* Setup the new size.  */
                search_ptr -> fx_file_current_file_size =  file_ptr -> fx_file_current_file_offset;
 800d148:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800d14c:	e9d3 2310 	ldrd	r2, r3, [r3, #64]	@ 0x40
 800d150:	f8d7 11b0 	ldr.w	r1, [r7, #432]	@ 0x1b0
 800d154:	e9c1 2312 	strd	r2, r3, [r1, #72]	@ 0x48

                /* Setup the new directory entry.  */
                search_ptr -> fx_file_dir_entry.fx_dir_entry_cluster =      file_ptr -> fx_file_dir_entry.fx_dir_entry_cluster;
 800d158:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800d15c:	f8d3 209c 	ldr.w	r2, [r3, #156]	@ 0x9c
 800d160:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 800d164:	f8c3 209c 	str.w	r2, [r3, #156]	@ 0x9c
                search_ptr -> fx_file_dir_entry.fx_dir_entry_file_size =    file_ptr -> fx_file_dir_entry.fx_dir_entry_file_size;
 800d168:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800d16c:	e9d3 2328 	ldrd	r2, r3, [r3, #160]	@ 0xa0
 800d170:	f8d7 11b0 	ldr.w	r1, [r7, #432]	@ 0x1b0
 800d174:	e9c1 2328 	strd	r2, r3, [r1, #160]	@ 0xa0
                search_ptr -> fx_file_dir_entry.fx_dir_entry_log_sector =   file_ptr -> fx_file_dir_entry.fx_dir_entry_log_sector;
 800d178:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800d17c:	e9d3 232a 	ldrd	r2, r3, [r3, #168]	@ 0xa8
 800d180:	f8d7 11b0 	ldr.w	r1, [r7, #432]	@ 0x1b0
 800d184:	e9c1 232a 	strd	r2, r3, [r1, #168]	@ 0xa8
                search_ptr -> fx_file_dir_entry.fx_dir_entry_byte_offset =  file_ptr -> fx_file_dir_entry.fx_dir_entry_byte_offset;
 800d188:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800d18c:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
 800d190:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 800d194:	f8c3 20b0 	str.w	r2, [r3, #176]	@ 0xb0

                /* Setup the last cluster. This really isn't used during reading, but it is nice to keep things
                   consistent.  */
                search_ptr -> fx_file_last_physical_cluster =  file_ptr -> fx_file_last_physical_cluster;
 800d198:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800d19c:	69da      	ldr	r2, [r3, #28]
 800d19e:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 800d1a2:	61da      	str	r2, [r3, #28]

                /* Update the available clusters as well.  */
                search_ptr -> fx_file_current_available_size =  file_ptr -> fx_file_current_available_size;
 800d1a4:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800d1a8:	e9d3 2314 	ldrd	r2, r3, [r3, #80]	@ 0x50
 800d1ac:	f8d7 11b0 	ldr.w	r1, [r7, #432]	@ 0x1b0
 800d1b0:	e9c1 2314 	strd	r2, r3, [r1, #80]	@ 0x50

                /* Determine if an empty file was previously opened.  */
                if (search_ptr -> fx_file_total_clusters == 0)
 800d1b4:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 800d1b8:	691b      	ldr	r3, [r3, #16]
 800d1ba:	2b00      	cmp	r3, #0
 800d1bc:	d15f      	bne.n	800d27e <_fx_file_write+0xd2a>
                {

                    /* Setup initial parameters.  */
                    search_ptr -> fx_file_total_clusters =            file_ptr -> fx_file_total_clusters;
 800d1be:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800d1c2:	691a      	ldr	r2, [r3, #16]
 800d1c4:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 800d1c8:	611a      	str	r2, [r3, #16]
                    search_ptr -> fx_file_current_physical_cluster =  file_ptr -> fx_file_first_physical_cluster;
 800d1ca:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800d1ce:	695a      	ldr	r2, [r3, #20]
 800d1d0:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 800d1d4:	621a      	str	r2, [r3, #32]
                    search_ptr -> fx_file_current_relative_cluster =  0;
 800d1d6:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 800d1da:	2200      	movs	r2, #0
 800d1dc:	635a      	str	r2, [r3, #52]	@ 0x34
                    search_ptr -> fx_file_current_logical_sector =    ((ULONG)media_ptr -> fx_media_data_sector_start) +
 800d1de:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800d1e2:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800d1e4:	2200      	movs	r2, #0
 800d1e6:	633b      	str	r3, [r7, #48]	@ 0x30
 800d1e8:	637a      	str	r2, [r7, #52]	@ 0x34
                        (((ULONG64)(file_ptr -> fx_file_first_physical_cluster - FX_FAT_ENTRY_START)) *
 800d1ea:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800d1ee:	695b      	ldr	r3, [r3, #20]
 800d1f0:	3b02      	subs	r3, #2
 800d1f2:	2200      	movs	r2, #0
 800d1f4:	62bb      	str	r3, [r7, #40]	@ 0x28
 800d1f6:	62fa      	str	r2, [r7, #44]	@ 0x2c
                         ((ULONG)media_ptr -> fx_media_sectors_per_cluster));
 800d1f8:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800d1fc:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800d1fe:	2200      	movs	r2, #0
 800d200:	623b      	str	r3, [r7, #32]
 800d202:	627a      	str	r2, [r7, #36]	@ 0x24
                        (((ULONG64)(file_ptr -> fx_file_first_physical_cluster - FX_FAT_ENTRY_START)) *
 800d204:	e9d7 450a 	ldrd	r4, r5, [r7, #40]	@ 0x28
 800d208:	462b      	mov	r3, r5
 800d20a:	e9d7 8908 	ldrd	r8, r9, [r7, #32]
 800d20e:	4642      	mov	r2, r8
 800d210:	fb02 f203 	mul.w	r2, r2, r3
 800d214:	464b      	mov	r3, r9
 800d216:	4621      	mov	r1, r4
 800d218:	fb01 f303 	mul.w	r3, r1, r3
 800d21c:	4413      	add	r3, r2
 800d21e:	4622      	mov	r2, r4
 800d220:	4641      	mov	r1, r8
 800d222:	fba2 1201 	umull	r1, r2, r2, r1
 800d226:	f8c7 2164 	str.w	r2, [r7, #356]	@ 0x164
 800d22a:	460a      	mov	r2, r1
 800d22c:	f8c7 2160 	str.w	r2, [r7, #352]	@ 0x160
 800d230:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 800d234:	4413      	add	r3, r2
 800d236:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
                    search_ptr -> fx_file_current_logical_sector =    ((ULONG)media_ptr -> fx_media_data_sector_start) +
 800d23a:	e9d7 450c 	ldrd	r4, r5, [r7, #48]	@ 0x30
 800d23e:	4623      	mov	r3, r4
 800d240:	e9d7 0158 	ldrd	r0, r1, [r7, #352]	@ 0x160
 800d244:	4602      	mov	r2, r0
 800d246:	189b      	adds	r3, r3, r2
 800d248:	61bb      	str	r3, [r7, #24]
 800d24a:	462b      	mov	r3, r5
 800d24c:	460a      	mov	r2, r1
 800d24e:	4153      	adcs	r3, r2
 800d250:	61fb      	str	r3, [r7, #28]
 800d252:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 800d256:	e9d7 1206 	ldrd	r1, r2, [r7, #24]
 800d25a:	e9c3 120a 	strd	r1, r2, [r3, #40]	@ 0x28
                    search_ptr -> fx_file_current_relative_sector =   0;
 800d25e:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 800d262:	2200      	movs	r2, #0
 800d264:	639a      	str	r2, [r3, #56]	@ 0x38
                    search_ptr -> fx_file_current_logical_offset =    0;
 800d266:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 800d26a:	2200      	movs	r2, #0
 800d26c:	631a      	str	r2, [r3, #48]	@ 0x30
                    search_ptr -> fx_file_current_file_offset =       0;
 800d26e:	f8d7 11b0 	ldr.w	r1, [r7, #432]	@ 0x1b0
 800d272:	f04f 0200 	mov.w	r2, #0
 800d276:	f04f 0300 	mov.w	r3, #0
 800d27a:	e9c1 2310 	strd	r2, r3, [r1, #64]	@ 0x40
                }
            }

            /* Adjust the pointer and decrement the search count.  */
            search_ptr =  search_ptr -> fx_file_opened_next;
 800d27e:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
 800d282:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800d284:	f8c7 31b0 	str.w	r3, [r7, #432]	@ 0x1b0
            open_count--;
 800d288:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 800d28c:	3b01      	subs	r3, #1
 800d28e:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
        while (open_count)
 800d292:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 800d296:	2b00      	cmp	r3, #0
 800d298:	f47f af37 	bne.w	800d10a <_fx_file_write+0xbb6>
        }
#endif
    }

    /* Finally, mark this file as modified.  */
    file_ptr -> fx_file_modified =  FX_TRUE;
 800d29c:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800d2a0:	2201      	movs	r2, #1
 800d2a2:	731a      	strb	r2, [r3, #12]
        file_ptr -> fx_file_maximum_size_used = file_ptr -> fx_file_current_file_offset;
    }
#endif /* FX_ENABLE_FAULT_TOLERANT */

    /* Invoke file write callback. */
    if (file_ptr -> fx_file_write_notify)
 800d2a4:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800d2a8:	f8d3 31dc 	ldr.w	r3, [r3, #476]	@ 0x1dc
 800d2ac:	2b00      	cmp	r3, #0
 800d2ae:	d006      	beq.n	800d2be <_fx_file_write+0xd6a>
    {
        file_ptr -> fx_file_write_notify(file_ptr);
 800d2b0:	f8d7 319c 	ldr.w	r3, [r7, #412]	@ 0x19c
 800d2b4:	f8d3 31dc 	ldr.w	r3, [r3, #476]	@ 0x1dc
 800d2b8:	f8d7 019c 	ldr.w	r0, [r7, #412]	@ 0x19c
 800d2bc:	4798      	blx	r3

    /* Release media protection.  */
    FX_UNPROTECT

    /* Return a successful status to the caller.  */
    return(FX_SUCCESS);
 800d2be:	2300      	movs	r3, #0
}
 800d2c0:	4618      	mov	r0, r3
 800d2c2:	f507 77f8 	add.w	r7, r7, #496	@ 0x1f0
 800d2c6:	46bd      	mov	sp, r7
 800d2c8:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

0800d2cc <_fx_media_abort>:
/*  09-30-2020     William E. Lamie         Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _fx_media_abort(FX_MEDIA  *media_ptr)
{
 800d2cc:	b580      	push	{r7, lr}
 800d2ce:	b084      	sub	sp, #16
 800d2d0:	af00      	add	r7, sp, #0
 800d2d2:	6078      	str	r0, [r7, #4]


#ifndef FX_MEDIA_STATISTICS_DISABLE

    /* Increment the number of times this service has been called.  */
    media_ptr -> fx_media_aborts++;
 800d2d4:	687b      	ldr	r3, [r7, #4]
 800d2d6:	f8d3 3158 	ldr.w	r3, [r3, #344]	@ 0x158
 800d2da:	1c5a      	adds	r2, r3, #1
 800d2dc:	687b      	ldr	r3, [r7, #4]
 800d2de:	f8c3 2158 	str.w	r2, [r3, #344]	@ 0x158
#endif

    /* Check the media to make sure it is open.  */
    if (media_ptr -> fx_media_id != FX_MEDIA_ID)
 800d2e2:	687b      	ldr	r3, [r7, #4]
 800d2e4:	681b      	ldr	r3, [r3, #0]
 800d2e6:	4a2b      	ldr	r2, [pc, #172]	@ (800d394 <_fx_media_abort+0xc8>)
 800d2e8:	4293      	cmp	r3, r2
 800d2ea:	d001      	beq.n	800d2f0 <_fx_media_abort+0x24>
    {

        /* Return the media not opened error.  */
        return(FX_MEDIA_NOT_OPEN);
 800d2ec:	2311      	movs	r3, #17
 800d2ee:	e04c      	b.n	800d38a <_fx_media_abort+0xbe>

    /* Protect against other threads accessing the media.  */
    FX_PROTECT

    /* Loop through the media's open files.  */
    open_count =  media_ptr -> fx_media_opened_file_count;
 800d2f0:	687b      	ldr	r3, [r7, #4]
 800d2f2:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
 800d2f6:	60fb      	str	r3, [r7, #12]
    file_ptr =    media_ptr -> fx_media_opened_file_list;
 800d2f8:	687b      	ldr	r3, [r7, #4]
 800d2fa:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
 800d2fe:	60bb      	str	r3, [r7, #8]
    while (open_count)
 800d300:	e008      	b.n	800d314 <_fx_media_abort+0x48>
    {

        /* Mark the file as aborted.  */
        file_ptr -> fx_file_id =  FX_FILE_ABORTED_ID;
 800d302:	68bb      	ldr	r3, [r7, #8]
 800d304:	4a24      	ldr	r2, [pc, #144]	@ (800d398 <_fx_media_abort+0xcc>)
 800d306:	601a      	str	r2, [r3, #0]

        /* Adjust the pointer and decrement the file opened count.  */
        file_ptr =  file_ptr -> fx_file_opened_next;
 800d308:	68bb      	ldr	r3, [r7, #8]
 800d30a:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800d30c:	60bb      	str	r3, [r7, #8]
        open_count--;
 800d30e:	68fb      	ldr	r3, [r7, #12]
 800d310:	3b01      	subs	r3, #1
 800d312:	60fb      	str	r3, [r7, #12]
    while (open_count)
 800d314:	68fb      	ldr	r3, [r7, #12]
 800d316:	2b00      	cmp	r3, #0
 800d318:	d1f3      	bne.n	800d302 <_fx_media_abort+0x36>
    }

    /* Build the "abort" I/O driver request.  */
    media_ptr -> fx_media_driver_request =      FX_DRIVER_ABORT;
 800d31a:	687b      	ldr	r3, [r7, #4]
 800d31c:	2203      	movs	r2, #3
 800d31e:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
    media_ptr -> fx_media_driver_status =       FX_IO_ERROR;
 800d322:	687b      	ldr	r3, [r7, #4]
 800d324:	2290      	movs	r2, #144	@ 0x90
 800d326:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c

    /* If trace is enabled, insert this event into the trace buffer.  */
    FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_ABORT, media_ptr, 0, 0, 0, FX_TRACE_INTERNAL_EVENTS, 0, 0)

    /* Call the specified I/O driver with the abort request.  */
    (media_ptr -> fx_media_driver_entry) (media_ptr);
 800d32a:	687b      	ldr	r3, [r7, #4]
 800d32c:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
 800d330:	6878      	ldr	r0, [r7, #4]
 800d332:	4798      	blx	r3

    /* Lockout interrupts for media removal.  */
    FX_DISABLE_INTS

    /* See if the media is the only one on the media opened list.  */
    if (_fx_system_media_opened_count == ((ULONG) 1))
 800d334:	4b19      	ldr	r3, [pc, #100]	@ (800d39c <_fx_media_abort+0xd0>)
 800d336:	681b      	ldr	r3, [r3, #0]
 800d338:	2b01      	cmp	r3, #1
 800d33a:	d103      	bne.n	800d344 <_fx_media_abort+0x78>
    {

        /* Only opened media, just set the opened list to NULL.  */
        _fx_system_media_opened_ptr =  FX_NULL;
 800d33c:	4b18      	ldr	r3, [pc, #96]	@ (800d3a0 <_fx_media_abort+0xd4>)
 800d33e:	2200      	movs	r2, #0
 800d340:	601a      	str	r2, [r3, #0]
 800d342:	e019      	b.n	800d378 <_fx_media_abort+0xac>
    }
    else
    {

        /* Otherwise, not the only opened media, link-up the neighbors.  */
        (media_ptr -> fx_media_opened_next) -> fx_media_opened_previous =
 800d344:	687b      	ldr	r3, [r7, #4]
 800d346:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
            media_ptr -> fx_media_opened_previous;
 800d34a:	687a      	ldr	r2, [r7, #4]
 800d34c:	f8d2 20d4 	ldr.w	r2, [r2, #212]	@ 0xd4
        (media_ptr -> fx_media_opened_next) -> fx_media_opened_previous =
 800d350:	f8c3 20d4 	str.w	r2, [r3, #212]	@ 0xd4
        (media_ptr -> fx_media_opened_previous) -> fx_media_opened_next =
 800d354:	687b      	ldr	r3, [r7, #4]
 800d356:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
            media_ptr -> fx_media_opened_next;
 800d35a:	687a      	ldr	r2, [r7, #4]
 800d35c:	f8d2 20d0 	ldr.w	r2, [r2, #208]	@ 0xd0
        (media_ptr -> fx_media_opened_previous) -> fx_media_opened_next =
 800d360:	f8c3 20d0 	str.w	r2, [r3, #208]	@ 0xd0

        /* See if we have to update the opened list head pointer.  */
        if (_fx_system_media_opened_ptr == media_ptr)
 800d364:	4b0e      	ldr	r3, [pc, #56]	@ (800d3a0 <_fx_media_abort+0xd4>)
 800d366:	681b      	ldr	r3, [r3, #0]
 800d368:	687a      	ldr	r2, [r7, #4]
 800d36a:	429a      	cmp	r2, r3
 800d36c:	d104      	bne.n	800d378 <_fx_media_abort+0xac>
        {

            /* Yes, move the head pointer to the next opened media. */
            _fx_system_media_opened_ptr =  media_ptr -> fx_media_opened_next;
 800d36e:	687b      	ldr	r3, [r7, #4]
 800d370:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
 800d374:	4a0a      	ldr	r2, [pc, #40]	@ (800d3a0 <_fx_media_abort+0xd4>)
 800d376:	6013      	str	r3, [r2, #0]
        }
    }

    /* Decrement the opened media counter.  */
    _fx_system_media_opened_count--;
 800d378:	4b08      	ldr	r3, [pc, #32]	@ (800d39c <_fx_media_abort+0xd0>)
 800d37a:	681b      	ldr	r3, [r3, #0]
 800d37c:	3b01      	subs	r3, #1
 800d37e:	4a07      	ldr	r2, [pc, #28]	@ (800d39c <_fx_media_abort+0xd0>)
 800d380:	6013      	str	r3, [r2, #0]

    /* Finally, Indicate that this media is aborted.  */
    media_ptr -> fx_media_id =  FX_MEDIA_ABORTED_ID;
 800d382:	687b      	ldr	r3, [r7, #4]
 800d384:	4a07      	ldr	r2, [pc, #28]	@ (800d3a4 <_fx_media_abort+0xd8>)
 800d386:	601a      	str	r2, [r3, #0]
    /* Release media protection.  */
    FX_UNPROTECT
#endif

    /* Return status to the caller.  */
    return(FX_SUCCESS);
 800d388:	2300      	movs	r3, #0
}
 800d38a:	4618      	mov	r0, r3
 800d38c:	3710      	adds	r7, #16
 800d38e:	46bd      	mov	sp, r7
 800d390:	bd80      	pop	{r7, pc}
 800d392:	bf00      	nop
 800d394:	4d454449 	.word	0x4d454449
 800d398:	46494c41 	.word	0x46494c41
 800d39c:	20002c90 	.word	0x20002c90
 800d3a0:	20002c8c 	.word	0x20002c8c
 800d3a4:	4d454441 	.word	0x4d454441

0800d3a8 <_fx_media_boot_info_extract>:
/*                                            check for bimap cache size, */
/*                                            resulting in version 6.1.10 */
/*                                                                        */
/**************************************************************************/
UINT  _fx_media_boot_info_extract(FX_MEDIA *media_ptr)
{
 800d3a8:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 800d3ac:	b084      	sub	sp, #16
 800d3ae:	af00      	add	r7, sp, #0
 800d3b0:	6078      	str	r0, [r7, #4]

UCHAR *boot_sector;


    /* Move the buffer pointer into a local copy.  */
    boot_sector =  media_ptr -> fx_media_driver_buffer;
 800d3b2:	687b      	ldr	r3, [r7, #4]
 800d3b4:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 800d3b8:	60fb      	str	r3, [r7, #12]

    /* Extract the number of bytes per sector.  */
    media_ptr -> fx_media_bytes_per_sector =    _fx_utility_16_unsigned_read(&boot_sector[FX_BYTES_SECTOR]);
 800d3ba:	68fb      	ldr	r3, [r7, #12]
 800d3bc:	330b      	adds	r3, #11
 800d3be:	4618      	mov	r0, r3
 800d3c0:	f001 fa88 	bl	800e8d4 <_fx_utility_16_unsigned_read>
 800d3c4:	4602      	mov	r2, r0
 800d3c6:	687b      	ldr	r3, [r7, #4]
 800d3c8:	629a      	str	r2, [r3, #40]	@ 0x28
    if (media_ptr -> fx_media_bytes_per_sector == 0)
 800d3ca:	687b      	ldr	r3, [r7, #4]
 800d3cc:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800d3ce:	2b00      	cmp	r3, #0
 800d3d0:	d101      	bne.n	800d3d6 <_fx_media_boot_info_extract+0x2e>
        return(_fx_utility_exFAT_geometry_check(media_ptr, boot_sector));
    }
    else
    {
#else
        return(FX_MEDIA_INVALID);
 800d3d2:	2302      	movs	r3, #2
 800d3d4:	e08c      	b.n	800d4f0 <_fx_media_boot_info_extract+0x148>
#endif /* FX_ENABLE_EXFAT */


        /* FAT12/16/32 volume.  */
        /* Extract the number of sectors per track.  */
        media_ptr -> fx_media_sectors_per_track =   _fx_utility_16_unsigned_read(&boot_sector[FX_SECTORS_PER_TRK]);
 800d3d6:	68fb      	ldr	r3, [r7, #12]
 800d3d8:	3318      	adds	r3, #24
 800d3da:	4618      	mov	r0, r3
 800d3dc:	f001 fa7a 	bl	800e8d4 <_fx_utility_16_unsigned_read>
 800d3e0:	4602      	mov	r2, r0
 800d3e2:	687b      	ldr	r3, [r7, #4]
 800d3e4:	62da      	str	r2, [r3, #44]	@ 0x2c

        /* Extract the number of heads.  */
        media_ptr -> fx_media_heads =               _fx_utility_16_unsigned_read(&boot_sector[FX_HEADS]);
 800d3e6:	68fb      	ldr	r3, [r7, #12]
 800d3e8:	331a      	adds	r3, #26
 800d3ea:	4618      	mov	r0, r3
 800d3ec:	f001 fa72 	bl	800e8d4 <_fx_utility_16_unsigned_read>
 800d3f0:	4602      	mov	r2, r0
 800d3f2:	687b      	ldr	r3, [r7, #4]
 800d3f4:	631a      	str	r2, [r3, #48]	@ 0x30

        /* Extract the total number of sectors.  */
        media_ptr -> fx_media_total_sectors =       _fx_utility_16_unsigned_read(&boot_sector[FX_SECTORS]);
 800d3f6:	68fb      	ldr	r3, [r7, #12]
 800d3f8:	3313      	adds	r3, #19
 800d3fa:	4618      	mov	r0, r3
 800d3fc:	f001 fa6a 	bl	800e8d4 <_fx_utility_16_unsigned_read>
 800d400:	4603      	mov	r3, r0
 800d402:	2200      	movs	r2, #0
 800d404:	4698      	mov	r8, r3
 800d406:	4691      	mov	r9, r2
 800d408:	687b      	ldr	r3, [r7, #4]
 800d40a:	e9c3 890e 	strd	r8, r9, [r3, #56]	@ 0x38
        if (media_ptr -> fx_media_total_sectors == 0)
 800d40e:	687b      	ldr	r3, [r7, #4]
 800d410:	e9d3 230e 	ldrd	r2, r3, [r3, #56]	@ 0x38
 800d414:	4313      	orrs	r3, r2
 800d416:	d10b      	bne.n	800d430 <_fx_media_boot_info_extract+0x88>
        {
            media_ptr -> fx_media_total_sectors = _fx_utility_32_unsigned_read(&boot_sector[FX_HUGE_SECTORS]);
 800d418:	68fb      	ldr	r3, [r7, #12]
 800d41a:	3320      	adds	r3, #32
 800d41c:	4618      	mov	r0, r3
 800d41e:	f001 fa81 	bl	800e924 <_fx_utility_32_unsigned_read>
 800d422:	4603      	mov	r3, r0
 800d424:	2200      	movs	r2, #0
 800d426:	461c      	mov	r4, r3
 800d428:	4615      	mov	r5, r2
 800d42a:	687b      	ldr	r3, [r7, #4]
 800d42c:	e9c3 450e 	strd	r4, r5, [r3, #56]	@ 0x38
        }

        if (media_ptr -> fx_media_total_sectors == 0)
 800d430:	687b      	ldr	r3, [r7, #4]
 800d432:	e9d3 230e 	ldrd	r2, r3, [r3, #56]	@ 0x38
 800d436:	4313      	orrs	r3, r2
 800d438:	d101      	bne.n	800d43e <_fx_media_boot_info_extract+0x96>
        {
            return(FX_MEDIA_INVALID);
 800d43a:	2302      	movs	r3, #2
 800d43c:	e058      	b.n	800d4f0 <_fx_media_boot_info_extract+0x148>
        }

        /* Extract the number of reserved sectors before the first FAT.  */
        media_ptr -> fx_media_reserved_sectors =    _fx_utility_16_unsigned_read(&boot_sector[FX_RESERVED_SECTORS]);
 800d43e:	68fb      	ldr	r3, [r7, #12]
 800d440:	330e      	adds	r3, #14
 800d442:	4618      	mov	r0, r3
 800d444:	f001 fa46 	bl	800e8d4 <_fx_utility_16_unsigned_read>
 800d448:	4602      	mov	r2, r0
 800d44a:	687b      	ldr	r3, [r7, #4]
 800d44c:	645a      	str	r2, [r3, #68]	@ 0x44
        if (media_ptr -> fx_media_reserved_sectors == 0)
 800d44e:	687b      	ldr	r3, [r7, #4]
 800d450:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800d452:	2b00      	cmp	r3, #0
 800d454:	d101      	bne.n	800d45a <_fx_media_boot_info_extract+0xb2>
        {
            return(FX_MEDIA_INVALID);
 800d456:	2302      	movs	r3, #2
 800d458:	e04a      	b.n	800d4f0 <_fx_media_boot_info_extract+0x148>
        }

        /* Extract the number of sectors per cluster.  */
        media_ptr -> fx_media_sectors_per_cluster = ((UINT)boot_sector[FX_SECTORS_CLUSTER] & 0xFF);
 800d45a:	68fb      	ldr	r3, [r7, #12]
 800d45c:	330d      	adds	r3, #13
 800d45e:	781b      	ldrb	r3, [r3, #0]
 800d460:	461a      	mov	r2, r3
 800d462:	687b      	ldr	r3, [r7, #4]
 800d464:	655a      	str	r2, [r3, #84]	@ 0x54

        /* There should always be at least one reserved sector, representing the boot record itself.  */
        if (media_ptr -> fx_media_sectors_per_cluster == 0)
 800d466:	687b      	ldr	r3, [r7, #4]
 800d468:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800d46a:	2b00      	cmp	r3, #0
 800d46c:	d101      	bne.n	800d472 <_fx_media_boot_info_extract+0xca>
        {
            return(FX_MEDIA_INVALID);
 800d46e:	2302      	movs	r3, #2
 800d470:	e03e      	b.n	800d4f0 <_fx_media_boot_info_extract+0x148>
        }

        /* Extract the number of sectors per FAT.  */
        media_ptr -> fx_media_sectors_per_FAT =     _fx_utility_16_unsigned_read(&boot_sector[FX_SECTORS_PER_FAT]);
 800d472:	68fb      	ldr	r3, [r7, #12]
 800d474:	3316      	adds	r3, #22
 800d476:	4618      	mov	r0, r3
 800d478:	f001 fa2c 	bl	800e8d4 <_fx_utility_16_unsigned_read>
 800d47c:	4602      	mov	r2, r0
 800d47e:	687b      	ldr	r3, [r7, #4]
 800d480:	659a      	str	r2, [r3, #88]	@ 0x58
        if (media_ptr -> fx_media_sectors_per_FAT == 0)
 800d482:	687b      	ldr	r3, [r7, #4]
 800d484:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800d486:	2b00      	cmp	r3, #0
 800d488:	d107      	bne.n	800d49a <_fx_media_boot_info_extract+0xf2>
        {
            media_ptr -> fx_media_sectors_per_FAT = _fx_utility_32_unsigned_read(&boot_sector[FX_SECTORS_PER_FAT_32]);
 800d48a:	68fb      	ldr	r3, [r7, #12]
 800d48c:	3324      	adds	r3, #36	@ 0x24
 800d48e:	4618      	mov	r0, r3
 800d490:	f001 fa48 	bl	800e924 <_fx_utility_32_unsigned_read>
 800d494:	4602      	mov	r2, r0
 800d496:	687b      	ldr	r3, [r7, #4]
 800d498:	659a      	str	r2, [r3, #88]	@ 0x58
        }

        if (media_ptr -> fx_media_sectors_per_FAT == 0)
 800d49a:	687b      	ldr	r3, [r7, #4]
 800d49c:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800d49e:	2b00      	cmp	r3, #0
 800d4a0:	d101      	bne.n	800d4a6 <_fx_media_boot_info_extract+0xfe>
        {
            return(FX_MEDIA_INVALID);
 800d4a2:	2302      	movs	r3, #2
 800d4a4:	e024      	b.n	800d4f0 <_fx_media_boot_info_extract+0x148>
        }

        /* Extract the number of FATs.  */
        media_ptr -> fx_media_number_of_FATs =      ((UINT)boot_sector[FX_NUMBER_OF_FATS] & 0xFF);
 800d4a6:	68fb      	ldr	r3, [r7, #12]
 800d4a8:	3310      	adds	r3, #16
 800d4aa:	781b      	ldrb	r3, [r3, #0]
 800d4ac:	461a      	mov	r2, r3
 800d4ae:	687b      	ldr	r3, [r7, #4]
 800d4b0:	65da      	str	r2, [r3, #92]	@ 0x5c
        if (media_ptr -> fx_media_number_of_FATs == 0)
 800d4b2:	687b      	ldr	r3, [r7, #4]
 800d4b4:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800d4b6:	2b00      	cmp	r3, #0
 800d4b8:	d101      	bne.n	800d4be <_fx_media_boot_info_extract+0x116>
        {
            return(FX_BOOT_ERROR);
 800d4ba:	2301      	movs	r3, #1
 800d4bc:	e018      	b.n	800d4f0 <_fx_media_boot_info_extract+0x148>

        /* Extract the number of hidden sectors.  */
#ifdef FX_DRIVER_USE_64BIT_LBA
        media_ptr -> fx_media_hidden_sectors =      _fx_utility_64_unsigned_read(&boot_sector[FX_HIDDEN_SECTORS]);
#else
        media_ptr -> fx_media_hidden_sectors =      _fx_utility_32_unsigned_read(&boot_sector[FX_HIDDEN_SECTORS]);
 800d4be:	68fb      	ldr	r3, [r7, #12]
 800d4c0:	331c      	adds	r3, #28
 800d4c2:	4618      	mov	r0, r3
 800d4c4:	f001 fa2e 	bl	800e924 <_fx_utility_32_unsigned_read>
 800d4c8:	4602      	mov	r2, r0
 800d4ca:	687b      	ldr	r3, [r7, #4]
 800d4cc:	671a      	str	r2, [r3, #112]	@ 0x70
#endif
        /* Extract the number of root directory entries.  */
        media_ptr -> fx_media_root_directory_entries =  _fx_utility_16_unsigned_read(&boot_sector[FX_ROOT_DIR_ENTRIES]);
 800d4ce:	68fb      	ldr	r3, [r7, #12]
 800d4d0:	3311      	adds	r3, #17
 800d4d2:	4618      	mov	r0, r3
 800d4d4:	f001 f9fe 	bl	800e8d4 <_fx_utility_16_unsigned_read>
 800d4d8:	4602      	mov	r2, r0
 800d4da:	687b      	ldr	r3, [r7, #4]
 800d4dc:	679a      	str	r2, [r3, #120]	@ 0x78

        /* Extract root directory starting cluster (32 bit only) and compute start sector */
        media_ptr -> fx_media_root_cluster_32 = _fx_utility_32_unsigned_read(&boot_sector[FX_ROOT_CLUSTER_32]);
 800d4de:	68fb      	ldr	r3, [r7, #12]
 800d4e0:	332c      	adds	r3, #44	@ 0x2c
 800d4e2:	4618      	mov	r0, r3
 800d4e4:	f001 fa1e 	bl	800e924 <_fx_utility_32_unsigned_read>
 800d4e8:	4602      	mov	r2, r0
 800d4ea:	687b      	ldr	r3, [r7, #4]
 800d4ec:	675a      	str	r2, [r3, #116]	@ 0x74
#ifdef FX_ENABLE_EXFAT
    }
#endif /* FX_ENABLE_EXFAT */

    /* Return a successful status.  */
    return(FX_SUCCESS);
 800d4ee:	2300      	movs	r3, #0
}
 800d4f0:	4618      	mov	r0, r3
 800d4f2:	3710      	adds	r7, #16
 800d4f4:	46bd      	mov	sp, r7
 800d4f6:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
	...

0800d4fc <_fx_media_close>:
/*                                            and cache,                  */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _fx_media_close(FX_MEDIA  *media_ptr)
{
 800d4fc:	b580      	push	{r7, lr}
 800d4fe:	b08c      	sub	sp, #48	@ 0x30
 800d500:	af04      	add	r7, sp, #16
 800d502:	6078      	str	r0, [r7, #4]
#endif /* FX_DISABLE_FILE_CLOSE */
UINT     status;


    /* Check the media to make sure it is open.  */
    if (media_ptr -> fx_media_id != FX_MEDIA_ID)
 800d504:	687b      	ldr	r3, [r7, #4]
 800d506:	681b      	ldr	r3, [r3, #0]
 800d508:	4a9f      	ldr	r2, [pc, #636]	@ (800d788 <_fx_media_close+0x28c>)
 800d50a:	4293      	cmp	r3, r2
 800d50c:	d001      	beq.n	800d512 <_fx_media_close+0x16>
    {

        /* Return the media not opened error.  */
        return(FX_MEDIA_NOT_OPEN);
 800d50e:	2311      	movs	r3, #17
 800d510:	e177      	b.n	800d802 <_fx_media_close+0x306>
    /* Protect against other threads accessing the media.  */
    FX_PROTECT

#ifndef FX_DISABLE_FILE_CLOSE
    /* Loop through the media's open files.  */
    open_count =  media_ptr -> fx_media_opened_file_count;
 800d512:	687b      	ldr	r3, [r7, #4]
 800d514:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
 800d518:	61fb      	str	r3, [r7, #28]
    file_ptr =    media_ptr -> fx_media_opened_file_list;
 800d51a:	687b      	ldr	r3, [r7, #4]
 800d51c:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
 800d520:	61bb      	str	r3, [r7, #24]
    while (open_count)
 800d522:	e032      	b.n	800d58a <_fx_media_close+0x8e>
    {

        /* Look at each opened file to see if the same file is opened
           for writing and has been written to.  */
        if ((file_ptr -> fx_file_open_mode == FX_OPEN_FOR_WRITE) &&
 800d524:	69bb      	ldr	r3, [r7, #24]
 800d526:	689b      	ldr	r3, [r3, #8]
 800d528:	2b01      	cmp	r3, #1
 800d52a:	d125      	bne.n	800d578 <_fx_media_close+0x7c>
            (file_ptr -> fx_file_modified))
 800d52c:	69bb      	ldr	r3, [r7, #24]
 800d52e:	7b1b      	ldrb	r3, [r3, #12]
        if ((file_ptr -> fx_file_open_mode == FX_OPEN_FOR_WRITE) &&
 800d530:	2b00      	cmp	r3, #0
 800d532:	d021      	beq.n	800d578 <_fx_media_close+0x7c>

            /* Lockout interrupts for time/date access.  */
            FX_DISABLE_INTS

            /* Set the new time and date.  */
            file_ptr -> fx_file_dir_entry.fx_dir_entry_time =  _fx_system_time;
 800d534:	4b95      	ldr	r3, [pc, #596]	@ (800d78c <_fx_media_close+0x290>)
 800d536:	681a      	ldr	r2, [r3, #0]
 800d538:	69bb      	ldr	r3, [r7, #24]
 800d53a:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
            file_ptr -> fx_file_dir_entry.fx_dir_entry_date =  _fx_system_date;
 800d53e:	4b94      	ldr	r3, [pc, #592]	@ (800d790 <_fx_media_close+0x294>)
 800d540:	681a      	ldr	r2, [r3, #0]
 800d542:	69bb      	ldr	r3, [r7, #24]
 800d544:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98
            /* Restore interrupt posture.  */
            FX_RESTORE_INTS

            /* Copy the new file size into the directory entry.  */
            file_ptr -> fx_file_dir_entry.fx_dir_entry_file_size =
                file_ptr -> fx_file_current_file_size;
 800d548:	69bb      	ldr	r3, [r7, #24]
 800d54a:	e9d3 2312 	ldrd	r2, r3, [r3, #72]	@ 0x48
            file_ptr -> fx_file_dir_entry.fx_dir_entry_file_size =
 800d54e:	69b9      	ldr	r1, [r7, #24]
 800d550:	e9c1 2328 	strd	r2, r3, [r1, #160]	@ 0xa0
                status = _fx_directory_exFAT_entry_write(media_ptr, &(file_ptr -> fx_file_dir_entry), UPDATE_STREAM);
            }
            else
            {
#endif /* FX_ENABLE_EXFAT */
                status = _fx_directory_entry_write(media_ptr, &(file_ptr -> fx_file_dir_entry));
 800d554:	69bb      	ldr	r3, [r7, #24]
 800d556:	3368      	adds	r3, #104	@ 0x68
 800d558:	4619      	mov	r1, r3
 800d55a:	6878      	ldr	r0, [r7, #4]
 800d55c:	f7fb fd96 	bl	800908c <_fx_directory_entry_write>
 800d560:	6178      	str	r0, [r7, #20]
#ifdef FX_ENABLE_EXFAT
            }
#endif /* FX_ENABLE_EXFAT */

            /* Determine if the status was unsuccessful. */
            if (status != FX_SUCCESS)
 800d562:	697b      	ldr	r3, [r7, #20]
 800d564:	2b00      	cmp	r3, #0
 800d566:	d004      	beq.n	800d572 <_fx_media_close+0x76>

                /* Release media protection.  */
                FX_UNPROTECT

                /* Call the media abort routine.  */
                _fx_media_abort(media_ptr);
 800d568:	6878      	ldr	r0, [r7, #4]
 800d56a:	f7ff feaf 	bl	800d2cc <_fx_media_abort>

                /* Return the error status.  */
                return(FX_IO_ERROR);
 800d56e:	2390      	movs	r3, #144	@ 0x90
 800d570:	e147      	b.n	800d802 <_fx_media_close+0x306>
            }

            /* Clear the file modified flag.  */
            file_ptr -> fx_file_modified =  FX_FALSE;
 800d572:	69bb      	ldr	r3, [r7, #24]
 800d574:	2200      	movs	r2, #0
 800d576:	731a      	strb	r2, [r3, #12]
        }

        /* Mark the file as closed.  */
        file_ptr -> fx_file_id =  FX_FILE_CLOSED_ID;
 800d578:	69bb      	ldr	r3, [r7, #24]
 800d57a:	4a86      	ldr	r2, [pc, #536]	@ (800d794 <_fx_media_close+0x298>)
 800d57c:	601a      	str	r2, [r3, #0]

        /* Adjust the pointer and decrement the opened count.  */
        file_ptr =  file_ptr -> fx_file_opened_next;
 800d57e:	69bb      	ldr	r3, [r7, #24]
 800d580:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800d582:	61bb      	str	r3, [r7, #24]
        open_count--;
 800d584:	69fb      	ldr	r3, [r7, #28]
 800d586:	3b01      	subs	r3, #1
 800d588:	61fb      	str	r3, [r7, #28]
    while (open_count)
 800d58a:	69fb      	ldr	r3, [r7, #28]
 800d58c:	2b00      	cmp	r3, #0
 800d58e:	d1c9      	bne.n	800d524 <_fx_media_close+0x28>
    }
#endif /* FX_DISABLE_FILE_CLOSE */

    /* Flush the cached individual FAT entries */
    _fx_utility_FAT_flush(media_ptr);
 800d590:	6878      	ldr	r0, [r7, #4]
 800d592:	f001 fd22 	bl	800efda <_fx_utility_FAT_flush>

    /* Flush changed sector(s) in the primary FAT to secondary FATs.  */
    _fx_utility_FAT_map_flush(media_ptr);
 800d596:	6878      	ldr	r0, [r7, #4]
 800d598:	f002 f870 	bl	800f67c <_fx_utility_FAT_map_flush>
        _fx_utility_exFAT_bitmap_flush(media_ptr);
    }
#endif /* FX_ENABLE_EXFAT */

    /* Flush the internal logical sector cache.  */
    status =  _fx_utility_logical_sector_flush(media_ptr, ((ULONG64) 1), (ULONG64) (media_ptr -> fx_media_total_sectors), FX_FALSE);
 800d59c:	687b      	ldr	r3, [r7, #4]
 800d59e:	e9d3 230e 	ldrd	r2, r3, [r3, #56]	@ 0x38
 800d5a2:	2100      	movs	r1, #0
 800d5a4:	9102      	str	r1, [sp, #8]
 800d5a6:	e9cd 2300 	strd	r2, r3, [sp]
 800d5aa:	f04f 0201 	mov.w	r2, #1
 800d5ae:	f04f 0300 	mov.w	r3, #0
 800d5b2:	6878      	ldr	r0, [r7, #4]
 800d5b4:	f002 fbec 	bl	800fd90 <_fx_utility_logical_sector_flush>
 800d5b8:	6178      	str	r0, [r7, #20]

    /* Determine if the flush was unsuccessful. */
    if (status != FX_SUCCESS)
 800d5ba:	697b      	ldr	r3, [r7, #20]
 800d5bc:	2b00      	cmp	r3, #0
 800d5be:	d004      	beq.n	800d5ca <_fx_media_close+0xce>

        /* Release media protection.  */
        FX_UNPROTECT

        /* Call the media abort routine.  */
        _fx_media_abort(media_ptr);
 800d5c0:	6878      	ldr	r0, [r7, #4]
 800d5c2:	f7ff fe83 	bl	800d2cc <_fx_media_abort>

        /* Return the error status.  */
        return(FX_IO_ERROR);
 800d5c6:	2390      	movs	r3, #144	@ 0x90
 800d5c8:	e11b      	b.n	800d802 <_fx_media_close+0x306>
    }

    /* Determine if the media needs to have the additional information sector updated. This will
       only be the case for 32-bit FATs. The logic here only needs to be done if the last reported
       available cluster count is different that the currently available clusters.  */
    if ((media_ptr -> fx_media_FAT32_additional_info_sector) &&
 800d5ca:	687b      	ldr	r3, [r7, #4]
 800d5cc:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 800d5ce:	2b00      	cmp	r3, #0
 800d5d0:	f000 80b1 	beq.w	800d736 <_fx_media_close+0x23a>
        (media_ptr -> fx_media_FAT32_additional_info_last_available != media_ptr -> fx_media_available_clusters) &&
 800d5d4:	687b      	ldr	r3, [r7, #4]
 800d5d6:	6eda      	ldr	r2, [r3, #108]	@ 0x6c
 800d5d8:	687b      	ldr	r3, [r7, #4]
 800d5da:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
    if ((media_ptr -> fx_media_FAT32_additional_info_sector) &&
 800d5dc:	429a      	cmp	r2, r3
 800d5de:	f000 80aa 	beq.w	800d736 <_fx_media_close+0x23a>
        (media_ptr -> fx_media_driver_write_protect == FX_FALSE))
 800d5e2:	687b      	ldr	r3, [r7, #4]
 800d5e4:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
        (media_ptr -> fx_media_FAT32_additional_info_last_available != media_ptr -> fx_media_available_clusters) &&
 800d5e8:	2b00      	cmp	r3, #0
 800d5ea:	f040 80a4 	bne.w	800d736 <_fx_media_close+0x23a>
    ULONG  signature;


#ifndef FX_DISABLE_CACHE
        /* Setup a pointer to the first cached entry's buffer.  */
        buffer_ptr =  (media_ptr -> fx_media_sector_cache_list_ptr) -> fx_cached_sector_memory_buffer;
 800d5ee:	687b      	ldr	r3, [r7, #4]
 800d5f0:	69db      	ldr	r3, [r3, #28]
 800d5f2:	681b      	ldr	r3, [r3, #0]
 800d5f4:	613b      	str	r3, [r7, #16]

        /* Invalidate this cache entry.  */
        (media_ptr -> fx_media_sector_cache_list_ptr) -> fx_cached_sector =  (~(ULONG64)0);
 800d5f6:	687b      	ldr	r3, [r7, #4]
 800d5f8:	69d9      	ldr	r1, [r3, #28]
 800d5fa:	f04f 32ff 	mov.w	r2, #4294967295
 800d5fe:	f04f 33ff 	mov.w	r3, #4294967295
 800d602:	e9c1 2302 	strd	r2, r3, [r1, #8]
        (media_ptr -> fx_media_sector_cache_list_ptr) -> fx_cached_sector_valid =  FX_FALSE;
 800d606:	687b      	ldr	r3, [r7, #4]
 800d608:	69db      	ldr	r3, [r3, #28]
 800d60a:	2200      	movs	r2, #0
 800d60c:	745a      	strb	r2, [r3, #17]
#else
        buffer_ptr =  media_ptr -> fx_media_memory_buffer;
#endif /* FX_DISABLE_CACHE */

        /* Read the FAT32 additional information sector from the device.  */
        media_ptr -> fx_media_driver_request =          FX_DRIVER_READ;
 800d60e:	687b      	ldr	r3, [r7, #4]
 800d610:	2200      	movs	r2, #0
 800d612:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
        media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 800d616:	687b      	ldr	r3, [r7, #4]
 800d618:	2290      	movs	r2, #144	@ 0x90
 800d61a:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
        media_ptr -> fx_media_driver_buffer =           buffer_ptr;
 800d61e:	687b      	ldr	r3, [r7, #4]
 800d620:	693a      	ldr	r2, [r7, #16]
 800d622:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
        media_ptr -> fx_media_driver_logical_sector =   media_ptr -> fx_media_FAT32_additional_info_sector;
 800d626:	687b      	ldr	r3, [r7, #4]
 800d628:	6e9a      	ldr	r2, [r3, #104]	@ 0x68
 800d62a:	687b      	ldr	r3, [r7, #4]
 800d62c:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
        media_ptr -> fx_media_driver_sectors =          1;
 800d630:	687b      	ldr	r3, [r7, #4]
 800d632:	2201      	movs	r2, #1
 800d634:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98
        media_ptr -> fx_media_driver_sector_type =      FX_DIRECTORY_SECTOR;
 800d638:	687b      	ldr	r3, [r7, #4]
 800d63a:	2203      	movs	r2, #3
 800d63c:	f8c3 20b8 	str.w	r2, [r3, #184]	@ 0xb8

#ifndef FX_MEDIA_STATISTICS_DISABLE

        /* Increment the number of driver read sector(s) requests.  */
        media_ptr -> fx_media_driver_read_requests++;
 800d640:	687b      	ldr	r3, [r7, #4]
 800d642:	f8d3 31ac 	ldr.w	r3, [r3, #428]	@ 0x1ac
 800d646:	1c5a      	adds	r2, r3, #1
 800d648:	687b      	ldr	r3, [r7, #4]
 800d64a:	f8c3 21ac 	str.w	r2, [r3, #428]	@ 0x1ac

        /* If trace is enabled, insert this event into the trace buffer.  */
        FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_READ, media_ptr, media_ptr -> fx_media_FAT32_additional_info_sector, 1, buffer_ptr, FX_TRACE_INTERNAL_EVENTS, 0, 0)

        /* Invoke the driver to read the FAT32 additional information sector.  */
        (media_ptr -> fx_media_driver_entry) (media_ptr);
 800d64e:	687b      	ldr	r3, [r7, #4]
 800d650:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
 800d654:	6878      	ldr	r0, [r7, #4]
 800d656:	4798      	blx	r3

        /* Determine if the FAT32 sector was read correctly. */
        if (media_ptr -> fx_media_driver_status != FX_SUCCESS)
 800d658:	687b      	ldr	r3, [r7, #4]
 800d65a:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800d65e:	2b00      	cmp	r3, #0
 800d660:	d004      	beq.n	800d66c <_fx_media_close+0x170>

            /* Release media protection.  */
            FX_UNPROTECT

            /* Call the media abort routine.  */
            _fx_media_abort(media_ptr);
 800d662:	6878      	ldr	r0, [r7, #4]
 800d664:	f7ff fe32 	bl	800d2cc <_fx_media_abort>

            /* Return the error status.  */
            return(FX_IO_ERROR);
 800d668:	2390      	movs	r3, #144	@ 0x90
 800d66a:	e0ca      	b.n	800d802 <_fx_media_close+0x306>
        }

        /* Setup a pointer into the FAT32 additional information sector.  */
        buffer_ptr =  media_ptr -> fx_media_driver_buffer;
 800d66c:	687b      	ldr	r3, [r7, #4]
 800d66e:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 800d672:	613b      	str	r3, [r7, #16]

        /* Pickup the first signature long word.  */
        signature =  _fx_utility_32_unsigned_read(&buffer_ptr[0]);
 800d674:	6938      	ldr	r0, [r7, #16]
 800d676:	f001 f955 	bl	800e924 <_fx_utility_32_unsigned_read>
 800d67a:	60f8      	str	r0, [r7, #12]

        /* Determine if the signature is correct.  */
        if (signature == 0x41615252)
 800d67c:	68fb      	ldr	r3, [r7, #12]
 800d67e:	4a46      	ldr	r2, [pc, #280]	@ (800d798 <_fx_media_close+0x29c>)
 800d680:	4293      	cmp	r3, r2
 800d682:	d158      	bne.n	800d736 <_fx_media_close+0x23a>
        {

            /* Yes, the first signature is correct, now pickup the next signature.  */
            signature =  _fx_utility_32_unsigned_read(&buffer_ptr[484]);
 800d684:	693b      	ldr	r3, [r7, #16]
 800d686:	f503 73f2 	add.w	r3, r3, #484	@ 0x1e4
 800d68a:	4618      	mov	r0, r3
 800d68c:	f001 f94a 	bl	800e924 <_fx_utility_32_unsigned_read>
 800d690:	60f8      	str	r0, [r7, #12]

            /* Determine if this signature is correct.  */
            if (signature == 0x61417272)
 800d692:	68fb      	ldr	r3, [r7, #12]
 800d694:	4a41      	ldr	r2, [pc, #260]	@ (800d79c <_fx_media_close+0x2a0>)
 800d696:	4293      	cmp	r3, r2
 800d698:	d14d      	bne.n	800d736 <_fx_media_close+0x23a>
            {

                /* Yes, we have a good FAT32 additional information sector.  */

                /* Set the free cluster count to the available clusters in the media control block.  */
                _fx_utility_32_unsigned_write(&buffer_ptr[488], media_ptr -> fx_media_available_clusters);
 800d69a:	693b      	ldr	r3, [r7, #16]
 800d69c:	f503 72f4 	add.w	r2, r3, #488	@ 0x1e8
 800d6a0:	687b      	ldr	r3, [r7, #4]
 800d6a2:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
 800d6a4:	4619      	mov	r1, r3
 800d6a6:	4610      	mov	r0, r2
 800d6a8:	f001 f959 	bl	800e95e <_fx_utility_32_unsigned_write>

                /* Set the next free cluster number hint to starting search cluster in the media control block.  */
                _fx_utility_32_unsigned_write(&buffer_ptr[492], media_ptr -> fx_media_cluster_search_start);
 800d6ac:	693b      	ldr	r3, [r7, #16]
 800d6ae:	f503 72f6 	add.w	r2, r3, #492	@ 0x1ec
 800d6b2:	687b      	ldr	r3, [r7, #4]
 800d6b4:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 800d6b8:	4619      	mov	r1, r3
 800d6ba:	4610      	mov	r0, r2
 800d6bc:	f001 f94f 	bl	800e95e <_fx_utility_32_unsigned_write>

                /* Now write the sector back out to the media.  */
                media_ptr -> fx_media_driver_request =          FX_DRIVER_WRITE;
 800d6c0:	687b      	ldr	r3, [r7, #4]
 800d6c2:	2201      	movs	r2, #1
 800d6c4:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
                media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 800d6c8:	687b      	ldr	r3, [r7, #4]
 800d6ca:	2290      	movs	r2, #144	@ 0x90
 800d6cc:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
                media_ptr -> fx_media_driver_buffer =           buffer_ptr;
 800d6d0:	687b      	ldr	r3, [r7, #4]
 800d6d2:	693a      	ldr	r2, [r7, #16]
 800d6d4:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
                media_ptr -> fx_media_driver_logical_sector =   media_ptr -> fx_media_FAT32_additional_info_sector;
 800d6d8:	687b      	ldr	r3, [r7, #4]
 800d6da:	6e9a      	ldr	r2, [r3, #104]	@ 0x68
 800d6dc:	687b      	ldr	r3, [r7, #4]
 800d6de:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
                media_ptr -> fx_media_driver_sectors =          1;
 800d6e2:	687b      	ldr	r3, [r7, #4]
 800d6e4:	2201      	movs	r2, #1
 800d6e6:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98
                media_ptr -> fx_media_driver_sector_type =      FX_DIRECTORY_SECTOR;
 800d6ea:	687b      	ldr	r3, [r7, #4]
 800d6ec:	2203      	movs	r2, #3
 800d6ee:	f8c3 20b8 	str.w	r2, [r3, #184]	@ 0xb8

                /* Set the system write flag since we are writing a directory sector.  */
                media_ptr -> fx_media_driver_system_write =  FX_TRUE;
 800d6f2:	687b      	ldr	r3, [r7, #4]
 800d6f4:	2201      	movs	r2, #1
 800d6f6:	f8c3 20b0 	str.w	r2, [r3, #176]	@ 0xb0

#ifndef FX_MEDIA_STATISTICS_DISABLE

                /* Increment the number of driver write sector(s) requests.  */
                media_ptr -> fx_media_driver_write_requests++;
 800d6fa:	687b      	ldr	r3, [r7, #4]
 800d6fc:	f8d3 31b0 	ldr.w	r3, [r3, #432]	@ 0x1b0
 800d700:	1c5a      	adds	r2, r3, #1
 800d702:	687b      	ldr	r3, [r7, #4]
 800d704:	f8c3 21b0 	str.w	r2, [r3, #432]	@ 0x1b0

                /* If trace is enabled, insert this event into the trace buffer.  */
                FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_WRITE, media_ptr, media_ptr -> fx_media_FAT32_additional_info_sector, 1, buffer_ptr, FX_TRACE_INTERNAL_EVENTS, 0, 0)

                /* Invoke the driver to write the FAT32 additional information sector.  */
                (media_ptr -> fx_media_driver_entry) (media_ptr);
 800d708:	687b      	ldr	r3, [r7, #4]
 800d70a:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
 800d70e:	6878      	ldr	r0, [r7, #4]
 800d710:	4798      	blx	r3

                /* Clear the system write flag.  */
                media_ptr -> fx_media_driver_system_write =  FX_FALSE;
 800d712:	687b      	ldr	r3, [r7, #4]
 800d714:	2200      	movs	r2, #0
 800d716:	f8c3 20b0 	str.w	r2, [r3, #176]	@ 0xb0

                /* Determine if the FAT32 sector was written correctly. */
                if (media_ptr -> fx_media_driver_status != FX_SUCCESS)
 800d71a:	687b      	ldr	r3, [r7, #4]
 800d71c:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800d720:	2b00      	cmp	r3, #0
 800d722:	d004      	beq.n	800d72e <_fx_media_close+0x232>

                    /* Release media protection.  */
                    FX_UNPROTECT

                    /* Call the media abort routine.  */
                    _fx_media_abort(media_ptr);
 800d724:	6878      	ldr	r0, [r7, #4]
 800d726:	f7ff fdd1 	bl	800d2cc <_fx_media_abort>

                    /* Return the sector IO error status.  */
                    return(FX_IO_ERROR);
 800d72a:	2390      	movs	r3, #144	@ 0x90
 800d72c:	e069      	b.n	800d802 <_fx_media_close+0x306>
                }

                /* Successful update of the FAT32 additional information sector. Update the
                   last written available cluster count.  */
                media_ptr -> fx_media_FAT32_additional_info_last_available =  media_ptr -> fx_media_available_clusters;
 800d72e:	687b      	ldr	r3, [r7, #4]
 800d730:	6fda      	ldr	r2, [r3, #124]	@ 0x7c
 800d732:	687b      	ldr	r3, [r7, #4]
 800d734:	66da      	str	r2, [r3, #108]	@ 0x6c
    }

#ifndef FX_MEDIA_STATISTICS_DISABLE

    /* Increment the number of driver flush requests.  */
    media_ptr -> fx_media_driver_flush_requests++;
 800d736:	687b      	ldr	r3, [r7, #4]
 800d738:	f8d3 31c0 	ldr.w	r3, [r3, #448]	@ 0x1c0
 800d73c:	1c5a      	adds	r2, r3, #1
 800d73e:	687b      	ldr	r3, [r7, #4]
 800d740:	f8c3 21c0 	str.w	r2, [r3, #448]	@ 0x1c0
#endif

    /* Build the "flush" I/O driver request.  */
    media_ptr -> fx_media_driver_request =      FX_DRIVER_FLUSH;
 800d744:	687b      	ldr	r3, [r7, #4]
 800d746:	2202      	movs	r2, #2
 800d748:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
    media_ptr -> fx_media_driver_status =       FX_IO_ERROR;
 800d74c:	687b      	ldr	r3, [r7, #4]
 800d74e:	2290      	movs	r2, #144	@ 0x90
 800d750:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c

    /* If trace is enabled, insert this event into the trace buffer.  */
    FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_FLUSH, media_ptr, 0, 0, 0, FX_TRACE_INTERNAL_EVENTS, 0, 0)

    /* Call the specified I/O driver with the flush request.  */
    (media_ptr -> fx_media_driver_entry) (media_ptr);
 800d754:	687b      	ldr	r3, [r7, #4]
 800d756:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
 800d75a:	6878      	ldr	r0, [r7, #4]
 800d75c:	4798      	blx	r3

    /* Build the "uninitialize" I/O driver request.  */
    media_ptr -> fx_media_driver_request =      FX_DRIVER_UNINIT;
 800d75e:	687b      	ldr	r3, [r7, #4]
 800d760:	2208      	movs	r2, #8
 800d762:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
    media_ptr -> fx_media_driver_status =       FX_IO_ERROR;
 800d766:	687b      	ldr	r3, [r7, #4]
 800d768:	2290      	movs	r2, #144	@ 0x90
 800d76a:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c

    /* If trace is enabled, insert this event into the trace buffer.  */
    FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_UNINIT, media_ptr, 0, 0, 0, FX_TRACE_INTERNAL_EVENTS, 0, 0)

    /* Call the specified I/O driver with the uninitialize request.  */
    (media_ptr -> fx_media_driver_entry) (media_ptr);
 800d76e:	687b      	ldr	r3, [r7, #4]
 800d770:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
 800d774:	6878      	ldr	r0, [r7, #4]
 800d776:	4798      	blx	r3

    /* Lockout interrupts for media removal.  */
    FX_DISABLE_INTS

    /* See if the media is the only one on the media opened list.  */
    if (_fx_system_media_opened_count == ((ULONG) 1))
 800d778:	4b09      	ldr	r3, [pc, #36]	@ (800d7a0 <_fx_media_close+0x2a4>)
 800d77a:	681b      	ldr	r3, [r3, #0]
 800d77c:	2b01      	cmp	r3, #1
 800d77e:	d113      	bne.n	800d7a8 <_fx_media_close+0x2ac>
    {

        /* Only opened media, just set the opened list to NULL.  */
        _fx_system_media_opened_ptr =  FX_NULL;
 800d780:	4b08      	ldr	r3, [pc, #32]	@ (800d7a4 <_fx_media_close+0x2a8>)
 800d782:	2200      	movs	r2, #0
 800d784:	601a      	str	r2, [r3, #0]
 800d786:	e029      	b.n	800d7dc <_fx_media_close+0x2e0>
 800d788:	4d454449 	.word	0x4d454449
 800d78c:	20002c98 	.word	0x20002c98
 800d790:	20002c94 	.word	0x20002c94
 800d794:	46494c43 	.word	0x46494c43
 800d798:	41615252 	.word	0x41615252
 800d79c:	61417272 	.word	0x61417272
 800d7a0:	20002c90 	.word	0x20002c90
 800d7a4:	20002c8c 	.word	0x20002c8c
    }
    else
    {

        /* Otherwise, not the only opened media, link-up the neighbors.  */
        (media_ptr -> fx_media_opened_next) -> fx_media_opened_previous =
 800d7a8:	687b      	ldr	r3, [r7, #4]
 800d7aa:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
            media_ptr -> fx_media_opened_previous;
 800d7ae:	687a      	ldr	r2, [r7, #4]
 800d7b0:	f8d2 20d4 	ldr.w	r2, [r2, #212]	@ 0xd4
        (media_ptr -> fx_media_opened_next) -> fx_media_opened_previous =
 800d7b4:	f8c3 20d4 	str.w	r2, [r3, #212]	@ 0xd4
        (media_ptr -> fx_media_opened_previous) -> fx_media_opened_next =
 800d7b8:	687b      	ldr	r3, [r7, #4]
 800d7ba:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
            media_ptr -> fx_media_opened_next;
 800d7be:	687a      	ldr	r2, [r7, #4]
 800d7c0:	f8d2 20d0 	ldr.w	r2, [r2, #208]	@ 0xd0
        (media_ptr -> fx_media_opened_previous) -> fx_media_opened_next =
 800d7c4:	f8c3 20d0 	str.w	r2, [r3, #208]	@ 0xd0

        /* See if we have to update the opened list head pointer.  */
        if (_fx_system_media_opened_ptr == media_ptr)
 800d7c8:	4b10      	ldr	r3, [pc, #64]	@ (800d80c <_fx_media_close+0x310>)
 800d7ca:	681b      	ldr	r3, [r3, #0]
 800d7cc:	687a      	ldr	r2, [r7, #4]
 800d7ce:	429a      	cmp	r2, r3
 800d7d0:	d104      	bne.n	800d7dc <_fx_media_close+0x2e0>
        {

            /* Yes, move the head pointer to the next opened media. */
            _fx_system_media_opened_ptr =  media_ptr -> fx_media_opened_next;
 800d7d2:	687b      	ldr	r3, [r7, #4]
 800d7d4:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
 800d7d8:	4a0c      	ldr	r2, [pc, #48]	@ (800d80c <_fx_media_close+0x310>)
 800d7da:	6013      	str	r3, [r2, #0]
        }
    }

    /* Decrement the opened media counter.  */
    _fx_system_media_opened_count--;
 800d7dc:	4b0c      	ldr	r3, [pc, #48]	@ (800d810 <_fx_media_close+0x314>)
 800d7de:	681b      	ldr	r3, [r3, #0]
 800d7e0:	3b01      	subs	r3, #1
 800d7e2:	4a0b      	ldr	r2, [pc, #44]	@ (800d810 <_fx_media_close+0x314>)
 800d7e4:	6013      	str	r3, [r2, #0]

    /* Finally, Indicate that this media is closed.  */
    media_ptr -> fx_media_id =  FX_MEDIA_CLOSED_ID;
 800d7e6:	687b      	ldr	r3, [r7, #4]
 800d7e8:	4a0a      	ldr	r2, [pc, #40]	@ (800d814 <_fx_media_close+0x318>)
 800d7ea:	601a      	str	r2, [r3, #0]
    tx_mutex_delete(& (media_ptr -> fx_media_protect));
#endif
#endif

    /* Invoke media close callback. */
    if (media_ptr -> fx_media_close_notify)
 800d7ec:	687b      	ldr	r3, [r7, #4]
 800d7ee:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
 800d7f2:	2b00      	cmp	r3, #0
 800d7f4:	d004      	beq.n	800d800 <_fx_media_close+0x304>
    {
        media_ptr -> fx_media_close_notify(media_ptr);
 800d7f6:	687b      	ldr	r3, [r7, #4]
 800d7f8:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
 800d7fc:	6878      	ldr	r0, [r7, #4]
 800d7fe:	4798      	blx	r3
    /* Release media protection.  */
    FX_UNPROTECT
#endif

    /* Return success status to the caller.  */
    return(FX_SUCCESS);
 800d800:	2300      	movs	r3, #0
}
 800d802:	4618      	mov	r0, r3
 800d804:	3720      	adds	r7, #32
 800d806:	46bd      	mov	sp, r7
 800d808:	bd80      	pop	{r7, pc}
 800d80a:	bf00      	nop
 800d80c:	20002c8c 	.word	0x20002c8c
 800d810:	20002c90 	.word	0x20002c90
 800d814:	4d454443 	.word	0x4d454443

0800d818 <_fx_media_flush>:
/*                                            disable cache,              */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _fx_media_flush(FX_MEDIA  *media_ptr)
{
 800d818:	b580      	push	{r7, lr}
 800d81a:	b08c      	sub	sp, #48	@ 0x30
 800d81c:	af04      	add	r7, sp, #16
 800d81e:	6078      	str	r0, [r7, #4]


#ifndef FX_MEDIA_STATISTICS_DISABLE

    /* Increment the number of times this service has been called.  */
    media_ptr -> fx_media_flushes++;
 800d820:	687b      	ldr	r3, [r7, #4]
 800d822:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
 800d826:	1c5a      	adds	r2, r3, #1
 800d828:	687b      	ldr	r3, [r7, #4]
 800d82a:	f8c3 215c 	str.w	r2, [r3, #348]	@ 0x15c
#endif

    /* Check the media to make sure it is open.  */
    if (media_ptr -> fx_media_id != FX_MEDIA_ID)
 800d82e:	687b      	ldr	r3, [r7, #4]
 800d830:	681b      	ldr	r3, [r3, #0]
 800d832:	4a94      	ldr	r2, [pc, #592]	@ (800da84 <_fx_media_flush+0x26c>)
 800d834:	4293      	cmp	r3, r2
 800d836:	d001      	beq.n	800d83c <_fx_media_flush+0x24>
    {

        /* Return the media not opened error.  */
        return(FX_MEDIA_NOT_OPEN);
 800d838:	2311      	movs	r3, #17
 800d83a:	e11f      	b.n	800da7c <_fx_media_flush+0x264>

    /* Protect against other threads accessing the media.  */
    FX_PROTECT

    /* Check for write protect at the media level (set by driver).  */
    if (media_ptr -> fx_media_driver_write_protect)
 800d83c:	687b      	ldr	r3, [r7, #4]
 800d83e:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
 800d842:	2b00      	cmp	r3, #0
 800d844:	d001      	beq.n	800d84a <_fx_media_flush+0x32>

        /* Release media protection.  */
        FX_UNPROTECT

        /* Return write protect error.  */
        return(FX_WRITE_PROTECT);
 800d846:	2323      	movs	r3, #35	@ 0x23
 800d848:	e118      	b.n	800da7c <_fx_media_flush+0x264>
    }

    /* Loop through the media's open files.  */
    open_count =  media_ptr -> fx_media_opened_file_count;
 800d84a:	687b      	ldr	r3, [r7, #4]
 800d84c:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
 800d850:	61fb      	str	r3, [r7, #28]
    file_ptr =    media_ptr -> fx_media_opened_file_list;
 800d852:	687b      	ldr	r3, [r7, #4]
 800d854:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
 800d858:	61bb      	str	r3, [r7, #24]
    while (open_count)
 800d85a:	e02c      	b.n	800d8b6 <_fx_media_flush+0x9e>
    {

        /* Look at each opened file to see if the same file is opened
           for writing and has been written to.  */
        if ((file_ptr -> fx_file_open_mode == FX_OPEN_FOR_WRITE) &&
 800d85c:	69bb      	ldr	r3, [r7, #24]
 800d85e:	689b      	ldr	r3, [r3, #8]
 800d860:	2b01      	cmp	r3, #1
 800d862:	d122      	bne.n	800d8aa <_fx_media_flush+0x92>
            (file_ptr -> fx_file_modified))
 800d864:	69bb      	ldr	r3, [r7, #24]
 800d866:	7b1b      	ldrb	r3, [r3, #12]
        if ((file_ptr -> fx_file_open_mode == FX_OPEN_FOR_WRITE) &&
 800d868:	2b00      	cmp	r3, #0
 800d86a:	d01e      	beq.n	800d8aa <_fx_media_flush+0x92>

            /* Protect against update.  */
            FX_DISABLE_INTS

            /* Set the new time and date.  */
            file_ptr -> fx_file_dir_entry.fx_dir_entry_time =  _fx_system_time;
 800d86c:	4b86      	ldr	r3, [pc, #536]	@ (800da88 <_fx_media_flush+0x270>)
 800d86e:	681a      	ldr	r2, [r3, #0]
 800d870:	69bb      	ldr	r3, [r7, #24]
 800d872:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
            file_ptr -> fx_file_dir_entry.fx_dir_entry_date =  _fx_system_date;
 800d876:	4b85      	ldr	r3, [pc, #532]	@ (800da8c <_fx_media_flush+0x274>)
 800d878:	681a      	ldr	r2, [r3, #0]
 800d87a:	69bb      	ldr	r3, [r7, #24]
 800d87c:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98
            /* Restore interrupts.  */
            FX_RESTORE_INTS

            /* Copy the new file size into the directory entry.  */
            file_ptr -> fx_file_dir_entry.fx_dir_entry_file_size =
                file_ptr -> fx_file_current_file_size;
 800d880:	69bb      	ldr	r3, [r7, #24]
 800d882:	e9d3 2312 	ldrd	r2, r3, [r3, #72]	@ 0x48
            file_ptr -> fx_file_dir_entry.fx_dir_entry_file_size =
 800d886:	69b9      	ldr	r1, [r7, #24]
 800d888:	e9c1 2328 	strd	r2, r3, [r1, #160]	@ 0xa0
                        media_ptr, &(file_ptr -> fx_file_dir_entry), UPDATE_STREAM);
            }
            else
            {
#endif /* FX_ENABLE_EXFAT */
                status = _fx_directory_entry_write(media_ptr, &(file_ptr -> fx_file_dir_entry));
 800d88c:	69bb      	ldr	r3, [r7, #24]
 800d88e:	3368      	adds	r3, #104	@ 0x68
 800d890:	4619      	mov	r1, r3
 800d892:	6878      	ldr	r0, [r7, #4]
 800d894:	f7fb fbfa 	bl	800908c <_fx_directory_entry_write>
 800d898:	6178      	str	r0, [r7, #20]
#ifdef FX_ENABLE_EXFAT
            }
#endif /* FX_ENABLE_EXFAT */

            /* Check for a good status.  */
            if (status != FX_SUCCESS)
 800d89a:	697b      	ldr	r3, [r7, #20]
 800d89c:	2b00      	cmp	r3, #0
 800d89e:	d001      	beq.n	800d8a4 <_fx_media_flush+0x8c>

                /* Release media protection.  */
                FX_UNPROTECT

                /* Error writing the directory.  */
                return(status);
 800d8a0:	697b      	ldr	r3, [r7, #20]
 800d8a2:	e0eb      	b.n	800da7c <_fx_media_flush+0x264>
            }

            /* Clear the file modified flag.  */
            file_ptr -> fx_file_modified =  FX_FALSE;
 800d8a4:	69bb      	ldr	r3, [r7, #24]
 800d8a6:	2200      	movs	r2, #0
 800d8a8:	731a      	strb	r2, [r3, #12]
        }

        /* Adjust the pointer and decrement the opened count.  */
        file_ptr =  file_ptr -> fx_file_opened_next;
 800d8aa:	69bb      	ldr	r3, [r7, #24]
 800d8ac:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800d8ae:	61bb      	str	r3, [r7, #24]
        open_count--;
 800d8b0:	69fb      	ldr	r3, [r7, #28]
 800d8b2:	3b01      	subs	r3, #1
 800d8b4:	61fb      	str	r3, [r7, #28]
    while (open_count)
 800d8b6:	69fb      	ldr	r3, [r7, #28]
 800d8b8:	2b00      	cmp	r3, #0
 800d8ba:	d1cf      	bne.n	800d85c <_fx_media_flush+0x44>
    }

    /* Flush the cached individual FAT entries */
    _fx_utility_FAT_flush(media_ptr);
 800d8bc:	6878      	ldr	r0, [r7, #4]
 800d8be:	f001 fb8c 	bl	800efda <_fx_utility_FAT_flush>

    /* Flush changed sector(s) in the primary FAT to secondary FATs.  */
    _fx_utility_FAT_map_flush(media_ptr);
 800d8c2:	6878      	ldr	r0, [r7, #4]
 800d8c4:	f001 feda 	bl	800f67c <_fx_utility_FAT_map_flush>
        _fx_utility_exFAT_bitmap_flush(media_ptr);
    }
#endif /* FX_ENABLE_EXFAT */

    /* Flush the internal logical sector cache.  */
    status =  _fx_utility_logical_sector_flush(media_ptr, ((ULONG64) 1), (ULONG64) (media_ptr -> fx_media_total_sectors), FX_FALSE);
 800d8c8:	687b      	ldr	r3, [r7, #4]
 800d8ca:	e9d3 230e 	ldrd	r2, r3, [r3, #56]	@ 0x38
 800d8ce:	2100      	movs	r1, #0
 800d8d0:	9102      	str	r1, [sp, #8]
 800d8d2:	e9cd 2300 	strd	r2, r3, [sp]
 800d8d6:	f04f 0201 	mov.w	r2, #1
 800d8da:	f04f 0300 	mov.w	r3, #0
 800d8de:	6878      	ldr	r0, [r7, #4]
 800d8e0:	f002 fa56 	bl	800fd90 <_fx_utility_logical_sector_flush>
 800d8e4:	6178      	str	r0, [r7, #20]

    /* Check for a good status.  */
    if (status != FX_SUCCESS)
 800d8e6:	697b      	ldr	r3, [r7, #20]
 800d8e8:	2b00      	cmp	r3, #0
 800d8ea:	d001      	beq.n	800d8f0 <_fx_media_flush+0xd8>

        /* Release media protection.  */
        FX_UNPROTECT

        /* Error writing the directory.  */
        return(status);
 800d8ec:	697b      	ldr	r3, [r7, #20]
 800d8ee:	e0c5      	b.n	800da7c <_fx_media_flush+0x264>
    }

    /* Determine if the media needs to have the additional information sector updated. This will
       only be the case for 32-bit FATs. The logic here only needs to be done if the last reported
       available cluster count is different that the currently available clusters.  */
    if ((media_ptr -> fx_media_FAT32_additional_info_sector) &&
 800d8f0:	687b      	ldr	r3, [r7, #4]
 800d8f2:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 800d8f4:	2b00      	cmp	r3, #0
 800d8f6:	f000 80a5 	beq.w	800da44 <_fx_media_flush+0x22c>
        (media_ptr -> fx_media_FAT32_additional_info_last_available != media_ptr -> fx_media_available_clusters))
 800d8fa:	687b      	ldr	r3, [r7, #4]
 800d8fc:	6eda      	ldr	r2, [r3, #108]	@ 0x6c
 800d8fe:	687b      	ldr	r3, [r7, #4]
 800d900:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
    if ((media_ptr -> fx_media_FAT32_additional_info_sector) &&
 800d902:	429a      	cmp	r2, r3
 800d904:	f000 809e 	beq.w	800da44 <_fx_media_flush+0x22c>
    ULONG  signature;

#ifndef FX_DISABLE_CACHE

        /* Setup a pointer to the first cached entry's buffer.  */
        buffer_ptr =  (media_ptr -> fx_media_sector_cache_list_ptr) -> fx_cached_sector_memory_buffer;
 800d908:	687b      	ldr	r3, [r7, #4]
 800d90a:	69db      	ldr	r3, [r3, #28]
 800d90c:	681b      	ldr	r3, [r3, #0]
 800d90e:	613b      	str	r3, [r7, #16]

        /* Invalidate this cache entry.  */
        (media_ptr -> fx_media_sector_cache_list_ptr) -> fx_cached_sector =  (~(ULONG64)0);
 800d910:	687b      	ldr	r3, [r7, #4]
 800d912:	69d9      	ldr	r1, [r3, #28]
 800d914:	f04f 32ff 	mov.w	r2, #4294967295
 800d918:	f04f 33ff 	mov.w	r3, #4294967295
 800d91c:	e9c1 2302 	strd	r2, r3, [r1, #8]
        (media_ptr -> fx_media_sector_cache_list_ptr) -> fx_cached_sector_valid =  FX_FALSE;
 800d920:	687b      	ldr	r3, [r7, #4]
 800d922:	69db      	ldr	r3, [r3, #28]
 800d924:	2200      	movs	r2, #0
 800d926:	745a      	strb	r2, [r3, #17]
#else
        buffer_ptr =  media_ptr -> fx_media_memory_buffer;
#endif /* FX_DISABLE_CACHE */

        /* Read the FAT32 additional information sector from the device.  */
        media_ptr -> fx_media_driver_request =          FX_DRIVER_READ;
 800d928:	687b      	ldr	r3, [r7, #4]
 800d92a:	2200      	movs	r2, #0
 800d92c:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
        media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 800d930:	687b      	ldr	r3, [r7, #4]
 800d932:	2290      	movs	r2, #144	@ 0x90
 800d934:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
        media_ptr -> fx_media_driver_buffer =           buffer_ptr;
 800d938:	687b      	ldr	r3, [r7, #4]
 800d93a:	693a      	ldr	r2, [r7, #16]
 800d93c:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
        media_ptr -> fx_media_driver_logical_sector =   media_ptr -> fx_media_FAT32_additional_info_sector;
 800d940:	687b      	ldr	r3, [r7, #4]
 800d942:	6e9a      	ldr	r2, [r3, #104]	@ 0x68
 800d944:	687b      	ldr	r3, [r7, #4]
 800d946:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
        media_ptr -> fx_media_driver_sectors =          1;
 800d94a:	687b      	ldr	r3, [r7, #4]
 800d94c:	2201      	movs	r2, #1
 800d94e:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98
        media_ptr -> fx_media_driver_sector_type =      FX_DIRECTORY_SECTOR;
 800d952:	687b      	ldr	r3, [r7, #4]
 800d954:	2203      	movs	r2, #3
 800d956:	f8c3 20b8 	str.w	r2, [r3, #184]	@ 0xb8

#ifndef FX_MEDIA_STATISTICS_DISABLE

        /* Increment the number of driver read sector(s) requests.  */
        media_ptr -> fx_media_driver_read_requests++;
 800d95a:	687b      	ldr	r3, [r7, #4]
 800d95c:	f8d3 31ac 	ldr.w	r3, [r3, #428]	@ 0x1ac
 800d960:	1c5a      	adds	r2, r3, #1
 800d962:	687b      	ldr	r3, [r7, #4]
 800d964:	f8c3 21ac 	str.w	r2, [r3, #428]	@ 0x1ac

        /* If trace is enabled, insert this event into the trace buffer.  */
        FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_READ, media_ptr, media_ptr -> fx_media_FAT32_additional_info_sector, 1, buffer_ptr, FX_TRACE_INTERNAL_EVENTS, 0, 0)

        /* Invoke the driver to read the FAT32 additional information sector.  */
        (media_ptr -> fx_media_driver_entry) (media_ptr);
 800d968:	687b      	ldr	r3, [r7, #4]
 800d96a:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
 800d96e:	6878      	ldr	r0, [r7, #4]
 800d970:	4798      	blx	r3

        /* Determine if the FAT32 sector was read correctly. */
        if (media_ptr -> fx_media_driver_status != FX_SUCCESS)
 800d972:	687b      	ldr	r3, [r7, #4]
 800d974:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800d978:	2b00      	cmp	r3, #0
 800d97a:	d001      	beq.n	800d980 <_fx_media_flush+0x168>

            /* Release media protection.  */
            FX_UNPROTECT

            /* Return the error status.  */
            return(FX_IO_ERROR);
 800d97c:	2390      	movs	r3, #144	@ 0x90
 800d97e:	e07d      	b.n	800da7c <_fx_media_flush+0x264>
        }

        /* Setup a pointer into the FAT32 additional information sector.  */
        buffer_ptr =  media_ptr -> fx_media_driver_buffer;
 800d980:	687b      	ldr	r3, [r7, #4]
 800d982:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 800d986:	613b      	str	r3, [r7, #16]

        /* Pickup the first signature long word.  */
        signature =  _fx_utility_32_unsigned_read(&buffer_ptr[0]);
 800d988:	6938      	ldr	r0, [r7, #16]
 800d98a:	f000 ffcb 	bl	800e924 <_fx_utility_32_unsigned_read>
 800d98e:	60f8      	str	r0, [r7, #12]

        /* Determine if the signature is correct.  */
        if (signature == 0x41615252)
 800d990:	68fb      	ldr	r3, [r7, #12]
 800d992:	4a3f      	ldr	r2, [pc, #252]	@ (800da90 <_fx_media_flush+0x278>)
 800d994:	4293      	cmp	r3, r2
 800d996:	d155      	bne.n	800da44 <_fx_media_flush+0x22c>
        {

            /* Yes, the first signature is correct, now pickup the next signature.  */
            signature =  _fx_utility_32_unsigned_read(&buffer_ptr[484]);
 800d998:	693b      	ldr	r3, [r7, #16]
 800d99a:	f503 73f2 	add.w	r3, r3, #484	@ 0x1e4
 800d99e:	4618      	mov	r0, r3
 800d9a0:	f000 ffc0 	bl	800e924 <_fx_utility_32_unsigned_read>
 800d9a4:	60f8      	str	r0, [r7, #12]

            /* Determine if this signature is correct.  */
            if (signature == 0x61417272)
 800d9a6:	68fb      	ldr	r3, [r7, #12]
 800d9a8:	4a3a      	ldr	r2, [pc, #232]	@ (800da94 <_fx_media_flush+0x27c>)
 800d9aa:	4293      	cmp	r3, r2
 800d9ac:	d14a      	bne.n	800da44 <_fx_media_flush+0x22c>
            {

                /* Yes, we have a good FAT32 additional information sector.  */

                /* Set the free cluster count to the available clusters in the media control block.  */
                _fx_utility_32_unsigned_write(&buffer_ptr[488], media_ptr -> fx_media_available_clusters);
 800d9ae:	693b      	ldr	r3, [r7, #16]
 800d9b0:	f503 72f4 	add.w	r2, r3, #488	@ 0x1e8
 800d9b4:	687b      	ldr	r3, [r7, #4]
 800d9b6:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
 800d9b8:	4619      	mov	r1, r3
 800d9ba:	4610      	mov	r0, r2
 800d9bc:	f000 ffcf 	bl	800e95e <_fx_utility_32_unsigned_write>

                /* Set the next free cluster number hint to starting search cluster in the media control block.  */
                _fx_utility_32_unsigned_write(&buffer_ptr[492], media_ptr -> fx_media_cluster_search_start);
 800d9c0:	693b      	ldr	r3, [r7, #16]
 800d9c2:	f503 72f6 	add.w	r2, r3, #492	@ 0x1ec
 800d9c6:	687b      	ldr	r3, [r7, #4]
 800d9c8:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 800d9cc:	4619      	mov	r1, r3
 800d9ce:	4610      	mov	r0, r2
 800d9d0:	f000 ffc5 	bl	800e95e <_fx_utility_32_unsigned_write>

                /* Now write the sector back out to the media.  */
                media_ptr -> fx_media_driver_request =          FX_DRIVER_WRITE;
 800d9d4:	687b      	ldr	r3, [r7, #4]
 800d9d6:	2201      	movs	r2, #1
 800d9d8:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
                media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 800d9dc:	687b      	ldr	r3, [r7, #4]
 800d9de:	2290      	movs	r2, #144	@ 0x90
 800d9e0:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
                media_ptr -> fx_media_driver_buffer =           buffer_ptr;
 800d9e4:	687b      	ldr	r3, [r7, #4]
 800d9e6:	693a      	ldr	r2, [r7, #16]
 800d9e8:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
                media_ptr -> fx_media_driver_logical_sector =   media_ptr -> fx_media_FAT32_additional_info_sector;
 800d9ec:	687b      	ldr	r3, [r7, #4]
 800d9ee:	6e9a      	ldr	r2, [r3, #104]	@ 0x68
 800d9f0:	687b      	ldr	r3, [r7, #4]
 800d9f2:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
                media_ptr -> fx_media_driver_sectors =          1;
 800d9f6:	687b      	ldr	r3, [r7, #4]
 800d9f8:	2201      	movs	r2, #1
 800d9fa:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98
                media_ptr -> fx_media_driver_sector_type =      FX_DIRECTORY_SECTOR;
 800d9fe:	687b      	ldr	r3, [r7, #4]
 800da00:	2203      	movs	r2, #3
 800da02:	f8c3 20b8 	str.w	r2, [r3, #184]	@ 0xb8

                /* Set the system write flag since we are writing a directory sector.  */
                media_ptr -> fx_media_driver_system_write =  FX_TRUE;
 800da06:	687b      	ldr	r3, [r7, #4]
 800da08:	2201      	movs	r2, #1
 800da0a:	f8c3 20b0 	str.w	r2, [r3, #176]	@ 0xb0

#ifndef FX_MEDIA_STATISTICS_DISABLE

                /* Increment the number of driver write sector(s) requests.  */
                media_ptr -> fx_media_driver_write_requests++;
 800da0e:	687b      	ldr	r3, [r7, #4]
 800da10:	f8d3 31b0 	ldr.w	r3, [r3, #432]	@ 0x1b0
 800da14:	1c5a      	adds	r2, r3, #1
 800da16:	687b      	ldr	r3, [r7, #4]
 800da18:	f8c3 21b0 	str.w	r2, [r3, #432]	@ 0x1b0

                /* If trace is enabled, insert this event into the trace buffer.  */
                FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_WRITE, media_ptr, media_ptr -> fx_media_FAT32_additional_info_sector, 1, buffer_ptr, FX_TRACE_INTERNAL_EVENTS, 0, 0)

                /* Invoke the driver to write the FAT32 additional information sector.  */
                (media_ptr -> fx_media_driver_entry) (media_ptr);
 800da1c:	687b      	ldr	r3, [r7, #4]
 800da1e:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
 800da22:	6878      	ldr	r0, [r7, #4]
 800da24:	4798      	blx	r3

                /* Clear the system write flag.  */
                media_ptr -> fx_media_driver_system_write =  FX_FALSE;
 800da26:	687b      	ldr	r3, [r7, #4]
 800da28:	2200      	movs	r2, #0
 800da2a:	f8c3 20b0 	str.w	r2, [r3, #176]	@ 0xb0

                /* Determine if the FAT32 sector was written correctly. */
                if (media_ptr -> fx_media_driver_status != FX_SUCCESS)
 800da2e:	687b      	ldr	r3, [r7, #4]
 800da30:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800da34:	2b00      	cmp	r3, #0
 800da36:	d001      	beq.n	800da3c <_fx_media_flush+0x224>

                    /* Release media protection.  */
                    FX_UNPROTECT

                    /* Return the sector IO error status.  */
                    return(FX_IO_ERROR);
 800da38:	2390      	movs	r3, #144	@ 0x90
 800da3a:	e01f      	b.n	800da7c <_fx_media_flush+0x264>
                }

                /* Successful update of the FAT32 additional information sector. Update the
                   last written available cluster count.  */
                media_ptr -> fx_media_FAT32_additional_info_last_available =  media_ptr -> fx_media_available_clusters;
 800da3c:	687b      	ldr	r3, [r7, #4]
 800da3e:	6fda      	ldr	r2, [r3, #124]	@ 0x7c
 800da40:	687b      	ldr	r3, [r7, #4]
 800da42:	66da      	str	r2, [r3, #108]	@ 0x6c
    }

#ifndef FX_MEDIA_STATISTICS_DISABLE

    /* Increment the number of driver flush requests.  */
    media_ptr -> fx_media_driver_flush_requests++;
 800da44:	687b      	ldr	r3, [r7, #4]
 800da46:	f8d3 31c0 	ldr.w	r3, [r3, #448]	@ 0x1c0
 800da4a:	1c5a      	adds	r2, r3, #1
 800da4c:	687b      	ldr	r3, [r7, #4]
 800da4e:	f8c3 21c0 	str.w	r2, [r3, #448]	@ 0x1c0
#endif

    /* Build the "flush" I/O driver request.  */
    media_ptr -> fx_media_driver_request =      FX_DRIVER_FLUSH;
 800da52:	687b      	ldr	r3, [r7, #4]
 800da54:	2202      	movs	r2, #2
 800da56:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
    media_ptr -> fx_media_driver_status =       FX_IO_ERROR;
 800da5a:	687b      	ldr	r3, [r7, #4]
 800da5c:	2290      	movs	r2, #144	@ 0x90
 800da5e:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c

    /* If trace is enabled, insert this event into the trace buffer.  */
    FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_FLUSH, media_ptr, 0, 0, 0, FX_TRACE_INTERNAL_EVENTS, 0, 0)

    /* Call the specified I/O driver with the flush request.  */
    (media_ptr -> fx_media_driver_entry) (media_ptr);
 800da62:	687b      	ldr	r3, [r7, #4]
 800da64:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
 800da68:	6878      	ldr	r0, [r7, #4]
 800da6a:	4798      	blx	r3

    /* Determine if the I/O driver flushed successfully.  */
    if (media_ptr -> fx_media_driver_status != FX_SUCCESS)
 800da6c:	687b      	ldr	r3, [r7, #4]
 800da6e:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800da72:	2b00      	cmp	r3, #0
 800da74:	d001      	beq.n	800da7a <_fx_media_flush+0x262>

        /* Release media protection.  */
        FX_UNPROTECT

        /* Return the driver error status.  */
        return(FX_IO_ERROR);
 800da76:	2390      	movs	r3, #144	@ 0x90
 800da78:	e000      	b.n	800da7c <_fx_media_flush+0x264>

    /* Release media protection.  */
    FX_UNPROTECT

    /* If we get here, return successful status to the caller.  */
    return(FX_SUCCESS);
 800da7a:	2300      	movs	r3, #0
}
 800da7c:	4618      	mov	r0, r3
 800da7e:	3720      	adds	r7, #32
 800da80:	46bd      	mov	sp, r7
 800da82:	bd80      	pop	{r7, pc}
 800da84:	4d454449 	.word	0x4d454449
 800da88:	20002c98 	.word	0x20002c98
 800da8c:	20002c94 	.word	0x20002c94
 800da90:	41615252 	.word	0x41615252
 800da94:	61417272 	.word	0x61417272

0800da98 <_fx_media_open>:
/*                                                                        */
/**************************************************************************/
UINT  _fx_media_open(FX_MEDIA *media_ptr, CHAR *media_name,
                     VOID (*media_driver)(FX_MEDIA *), VOID *driver_info_ptr,
                     VOID *memory_ptr, ULONG memory_size)
{
 800da98:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 800da9c:	b096      	sub	sp, #88	@ 0x58
 800da9e:	af04      	add	r7, sp, #16
 800daa0:	60f8      	str	r0, [r7, #12]
 800daa2:	60b9      	str	r1, [r7, #8]
 800daa4:	607a      	str	r2, [r7, #4]
 800daa6:	603b      	str	r3, [r7, #0]
FX_INT_SAVE_AREA


#ifndef FX_DISABLE_BUILD_OPTIONS
    /* Reference the version ID and option words to ensure they are linked in.  */
    if ((_fx_system_build_options_1 | _fx_system_build_options_2 | _fx_system_build_options_3) == 0 ||
 800daa8:	4bba      	ldr	r3, [pc, #744]	@ (800dd94 <_fx_media_open+0x2fc>)
 800daaa:	681a      	ldr	r2, [r3, #0]
 800daac:	4bba      	ldr	r3, [pc, #744]	@ (800dd98 <_fx_media_open+0x300>)
 800daae:	681b      	ldr	r3, [r3, #0]
 800dab0:	431a      	orrs	r2, r3
 800dab2:	4bba      	ldr	r3, [pc, #744]	@ (800dd9c <_fx_media_open+0x304>)
 800dab4:	681b      	ldr	r3, [r3, #0]
 800dab6:	4313      	orrs	r3, r2
 800dab8:	2b00      	cmp	r3, #0
 800daba:	d003      	beq.n	800dac4 <_fx_media_open+0x2c>
        _fx_version_id[0] == 0)
 800dabc:	4bb8      	ldr	r3, [pc, #736]	@ (800dda0 <_fx_media_open+0x308>)
 800dabe:	781b      	ldrb	r3, [r3, #0]
    if ((_fx_system_build_options_1 | _fx_system_build_options_2 | _fx_system_build_options_3) == 0 ||
 800dac0:	2b00      	cmp	r3, #0
 800dac2:	d102      	bne.n	800daca <_fx_media_open+0x32>
    {

        /* We should never get here!  */
        return(FX_NOT_IMPLEMENTED);
 800dac4:	2322      	movs	r3, #34	@ 0x22
 800dac6:	f000 bd3d 	b.w	800e544 <_fx_media_open+0xaac>
#ifdef FX_DISABLE_CACHE
    media_ptr -> fx_media_memory_buffer_sector = (ULONG64)-1;
#endif /* FX_DISABLE_CACHE */

    /* Save the basic information in the media control block.  */
    media_ptr -> fx_media_name =                        media_name;
 800daca:	68fb      	ldr	r3, [r7, #12]
 800dacc:	68ba      	ldr	r2, [r7, #8]
 800dace:	605a      	str	r2, [r3, #4]
    media_ptr -> fx_media_driver_entry =                media_driver;
 800dad0:	68fb      	ldr	r3, [r7, #12]
 800dad2:	687a      	ldr	r2, [r7, #4]
 800dad4:	f8c3 20bc 	str.w	r2, [r3, #188]	@ 0xbc
    media_ptr -> fx_media_memory_buffer =               (UCHAR *)memory_ptr;
 800dad8:	68fb      	ldr	r3, [r7, #12]
 800dada:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 800dadc:	609a      	str	r2, [r3, #8]
    media_ptr -> fx_media_memory_size =                 memory_size;
 800dade:	68fb      	ldr	r3, [r7, #12]
 800dae0:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 800dae2:	60da      	str	r2, [r3, #12]
#ifndef FX_DISABLE_FORCE_MEMORY_OPERATION
    media_ptr -> fx_media_disable_burst_cache =         FX_FALSE;
 800dae4:	68fb      	ldr	r3, [r7, #12]
 800dae6:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 800daea:	461a      	mov	r2, r3
 800daec:	2300      	movs	r3, #0
 800daee:	f8c2 3474 	str.w	r3, [r2, #1140]	@ 0x474
    media_ptr -> fx_media_FAT_type =                    0;
 800daf2:	68fb      	ldr	r3, [r7, #12]
 800daf4:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 800daf8:	2200      	movs	r2, #0
 800dafa:	f883 2480 	strb.w	r2, [r3, #1152]	@ 0x480
#endif /* FX_DISABLE_FORCE_MEMORY_OPERATION */

    /* Save the original memory pointer.  */
    original_memory_ptr =  (UCHAR *)memory_ptr;
 800dafe:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 800db00:	633b      	str	r3, [r7, #48]	@ 0x30

#ifndef FX_MEDIA_STATISTICS_DISABLE

    /* Clear the optional media statistics.  */
    media_ptr -> fx_media_directory_attributes_reads =  0;
 800db02:	68fb      	ldr	r3, [r7, #12]
 800db04:	2200      	movs	r2, #0
 800db06:	f8c3 20d8 	str.w	r2, [r3, #216]	@ 0xd8
    media_ptr -> fx_media_directory_attributes_sets =  0;
 800db0a:	68fb      	ldr	r3, [r7, #12]
 800db0c:	2200      	movs	r2, #0
 800db0e:	f8c3 20dc 	str.w	r2, [r3, #220]	@ 0xdc
    media_ptr -> fx_media_directory_creates =  0;
 800db12:	68fb      	ldr	r3, [r7, #12]
 800db14:	2200      	movs	r2, #0
 800db16:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
    media_ptr -> fx_media_directory_default_gets =  0;
 800db1a:	68fb      	ldr	r3, [r7, #12]
 800db1c:	2200      	movs	r2, #0
 800db1e:	f8c3 20e4 	str.w	r2, [r3, #228]	@ 0xe4
    media_ptr -> fx_media_directory_default_sets =  0;
 800db22:	68fb      	ldr	r3, [r7, #12]
 800db24:	2200      	movs	r2, #0
 800db26:	f8c3 20e8 	str.w	r2, [r3, #232]	@ 0xe8
    media_ptr -> fx_media_directory_deletes =  0;
 800db2a:	68fb      	ldr	r3, [r7, #12]
 800db2c:	2200      	movs	r2, #0
 800db2e:	f8c3 20ec 	str.w	r2, [r3, #236]	@ 0xec
    media_ptr -> fx_media_directory_first_entry_finds =  0;
 800db32:	68fb      	ldr	r3, [r7, #12]
 800db34:	2200      	movs	r2, #0
 800db36:	f8c3 20f0 	str.w	r2, [r3, #240]	@ 0xf0
    media_ptr -> fx_media_directory_first_full_entry_finds =  0;
 800db3a:	68fb      	ldr	r3, [r7, #12]
 800db3c:	2200      	movs	r2, #0
 800db3e:	f8c3 20f4 	str.w	r2, [r3, #244]	@ 0xf4
    media_ptr -> fx_media_directory_information_gets =  0;
 800db42:	68fb      	ldr	r3, [r7, #12]
 800db44:	2200      	movs	r2, #0
 800db46:	f8c3 20f8 	str.w	r2, [r3, #248]	@ 0xf8
    media_ptr -> fx_media_directory_local_path_clears =  0;
 800db4a:	68fb      	ldr	r3, [r7, #12]
 800db4c:	2200      	movs	r2, #0
 800db4e:	f8c3 20fc 	str.w	r2, [r3, #252]	@ 0xfc
    media_ptr -> fx_media_directory_local_path_gets =  0;
 800db52:	68fb      	ldr	r3, [r7, #12]
 800db54:	2200      	movs	r2, #0
 800db56:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
    media_ptr -> fx_media_directory_local_path_restores =  0;
 800db5a:	68fb      	ldr	r3, [r7, #12]
 800db5c:	2200      	movs	r2, #0
 800db5e:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
    media_ptr -> fx_media_directory_local_path_sets =  0;
 800db62:	68fb      	ldr	r3, [r7, #12]
 800db64:	2200      	movs	r2, #0
 800db66:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
    media_ptr -> fx_media_directory_name_tests =  0;
 800db6a:	68fb      	ldr	r3, [r7, #12]
 800db6c:	2200      	movs	r2, #0
 800db6e:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c
    media_ptr -> fx_media_directory_next_entry_finds =  0;
 800db72:	68fb      	ldr	r3, [r7, #12]
 800db74:	2200      	movs	r2, #0
 800db76:	f8c3 2110 	str.w	r2, [r3, #272]	@ 0x110
    media_ptr -> fx_media_directory_next_full_entry_finds =  0;
 800db7a:	68fb      	ldr	r3, [r7, #12]
 800db7c:	2200      	movs	r2, #0
 800db7e:	f8c3 2114 	str.w	r2, [r3, #276]	@ 0x114
    media_ptr -> fx_media_directory_renames =  0;
 800db82:	68fb      	ldr	r3, [r7, #12]
 800db84:	2200      	movs	r2, #0
 800db86:	f8c3 2118 	str.w	r2, [r3, #280]	@ 0x118
    media_ptr -> fx_media_file_allocates =  0;
 800db8a:	68fb      	ldr	r3, [r7, #12]
 800db8c:	2200      	movs	r2, #0
 800db8e:	f8c3 211c 	str.w	r2, [r3, #284]	@ 0x11c
    media_ptr -> fx_media_file_attributes_reads =  0;
 800db92:	68fb      	ldr	r3, [r7, #12]
 800db94:	2200      	movs	r2, #0
 800db96:	f8c3 2120 	str.w	r2, [r3, #288]	@ 0x120
    media_ptr -> fx_media_file_attributes_sets =  0;
 800db9a:	68fb      	ldr	r3, [r7, #12]
 800db9c:	2200      	movs	r2, #0
 800db9e:	f8c3 2124 	str.w	r2, [r3, #292]	@ 0x124
    media_ptr -> fx_media_file_best_effort_allocates =  0;
 800dba2:	68fb      	ldr	r3, [r7, #12]
 800dba4:	2200      	movs	r2, #0
 800dba6:	f8c3 2128 	str.w	r2, [r3, #296]	@ 0x128
    media_ptr -> fx_media_file_closes =  0;
 800dbaa:	68fb      	ldr	r3, [r7, #12]
 800dbac:	2200      	movs	r2, #0
 800dbae:	f8c3 212c 	str.w	r2, [r3, #300]	@ 0x12c
    media_ptr -> fx_media_file_creates =  0;
 800dbb2:	68fb      	ldr	r3, [r7, #12]
 800dbb4:	2200      	movs	r2, #0
 800dbb6:	f8c3 2130 	str.w	r2, [r3, #304]	@ 0x130
    media_ptr -> fx_media_file_deletes =  0;
 800dbba:	68fb      	ldr	r3, [r7, #12]
 800dbbc:	2200      	movs	r2, #0
 800dbbe:	f8c3 2134 	str.w	r2, [r3, #308]	@ 0x134
    media_ptr -> fx_media_file_opens =  0;
 800dbc2:	68fb      	ldr	r3, [r7, #12]
 800dbc4:	2200      	movs	r2, #0
 800dbc6:	f8c3 2138 	str.w	r2, [r3, #312]	@ 0x138
    media_ptr -> fx_media_file_reads =  0;
 800dbca:	68fb      	ldr	r3, [r7, #12]
 800dbcc:	2200      	movs	r2, #0
 800dbce:	f8c3 213c 	str.w	r2, [r3, #316]	@ 0x13c
    media_ptr -> fx_media_file_relative_seeks =  0;
 800dbd2:	68fb      	ldr	r3, [r7, #12]
 800dbd4:	2200      	movs	r2, #0
 800dbd6:	f8c3 2140 	str.w	r2, [r3, #320]	@ 0x140
    media_ptr -> fx_media_file_renames =  0;
 800dbda:	68fb      	ldr	r3, [r7, #12]
 800dbdc:	2200      	movs	r2, #0
 800dbde:	f8c3 2144 	str.w	r2, [r3, #324]	@ 0x144
    media_ptr -> fx_media_file_seeks =  0;
 800dbe2:	68fb      	ldr	r3, [r7, #12]
 800dbe4:	2200      	movs	r2, #0
 800dbe6:	f8c3 2148 	str.w	r2, [r3, #328]	@ 0x148
    media_ptr -> fx_media_file_truncates =  0;
 800dbea:	68fb      	ldr	r3, [r7, #12]
 800dbec:	2200      	movs	r2, #0
 800dbee:	f8c3 214c 	str.w	r2, [r3, #332]	@ 0x14c
    media_ptr -> fx_media_file_truncate_releases =  0;
 800dbf2:	68fb      	ldr	r3, [r7, #12]
 800dbf4:	2200      	movs	r2, #0
 800dbf6:	f8c3 2150 	str.w	r2, [r3, #336]	@ 0x150
    media_ptr -> fx_media_file_writes =  0;
 800dbfa:	68fb      	ldr	r3, [r7, #12]
 800dbfc:	2200      	movs	r2, #0
 800dbfe:	f8c3 2154 	str.w	r2, [r3, #340]	@ 0x154
    media_ptr -> fx_media_aborts =  0;
 800dc02:	68fb      	ldr	r3, [r7, #12]
 800dc04:	2200      	movs	r2, #0
 800dc06:	f8c3 2158 	str.w	r2, [r3, #344]	@ 0x158
    media_ptr -> fx_media_flushes =  0;
 800dc0a:	68fb      	ldr	r3, [r7, #12]
 800dc0c:	2200      	movs	r2, #0
 800dc0e:	f8c3 215c 	str.w	r2, [r3, #348]	@ 0x15c
    media_ptr -> fx_media_reads =  0;
 800dc12:	68fb      	ldr	r3, [r7, #12]
 800dc14:	2200      	movs	r2, #0
 800dc16:	f8c3 2160 	str.w	r2, [r3, #352]	@ 0x160
    media_ptr -> fx_media_writes =  0;
 800dc1a:	68fb      	ldr	r3, [r7, #12]
 800dc1c:	2200      	movs	r2, #0
 800dc1e:	f8c3 2164 	str.w	r2, [r3, #356]	@ 0x164
    media_ptr -> fx_media_directory_entry_reads =  0;
 800dc22:	68fb      	ldr	r3, [r7, #12]
 800dc24:	2200      	movs	r2, #0
 800dc26:	f8c3 2168 	str.w	r2, [r3, #360]	@ 0x168
    media_ptr -> fx_media_directory_entry_writes =  0;
 800dc2a:	68fb      	ldr	r3, [r7, #12]
 800dc2c:	2200      	movs	r2, #0
 800dc2e:	f8c3 216c 	str.w	r2, [r3, #364]	@ 0x16c
    media_ptr -> fx_media_directory_searches =  0;
 800dc32:	68fb      	ldr	r3, [r7, #12]
 800dc34:	2200      	movs	r2, #0
 800dc36:	f8c3 2170 	str.w	r2, [r3, #368]	@ 0x170
#ifndef FX_MEDIA_DISABLE_SEARCH_CACHE
    media_ptr -> fx_media_directory_search_cache_hits =  0;
 800dc3a:	68fb      	ldr	r3, [r7, #12]
 800dc3c:	2200      	movs	r2, #0
 800dc3e:	f8c3 21c4 	str.w	r2, [r3, #452]	@ 0x1c4
#endif
    media_ptr -> fx_media_directory_free_searches =  0;
 800dc42:	68fb      	ldr	r3, [r7, #12]
 800dc44:	2200      	movs	r2, #0
 800dc46:	f8c3 2174 	str.w	r2, [r3, #372]	@ 0x174
    media_ptr -> fx_media_fat_entry_reads =  0;
 800dc4a:	68fb      	ldr	r3, [r7, #12]
 800dc4c:	2200      	movs	r2, #0
 800dc4e:	f8c3 2178 	str.w	r2, [r3, #376]	@ 0x178
    media_ptr -> fx_media_fat_entry_writes =  0;
 800dc52:	68fb      	ldr	r3, [r7, #12]
 800dc54:	2200      	movs	r2, #0
 800dc56:	f8c3 217c 	str.w	r2, [r3, #380]	@ 0x17c
    media_ptr -> fx_media_fat_entry_cache_read_hits =  0;
 800dc5a:	68fb      	ldr	r3, [r7, #12]
 800dc5c:	2200      	movs	r2, #0
 800dc5e:	f8c3 2180 	str.w	r2, [r3, #384]	@ 0x180
    media_ptr -> fx_media_fat_entry_cache_read_misses =  0;
 800dc62:	68fb      	ldr	r3, [r7, #12]
 800dc64:	2200      	movs	r2, #0
 800dc66:	f8c3 2184 	str.w	r2, [r3, #388]	@ 0x184
    media_ptr -> fx_media_fat_entry_cache_write_hits =  0;
 800dc6a:	68fb      	ldr	r3, [r7, #12]
 800dc6c:	2200      	movs	r2, #0
 800dc6e:	f8c3 2188 	str.w	r2, [r3, #392]	@ 0x188
    media_ptr -> fx_media_fat_entry_cache_write_misses =  0;
 800dc72:	68fb      	ldr	r3, [r7, #12]
 800dc74:	2200      	movs	r2, #0
 800dc76:	f8c3 218c 	str.w	r2, [r3, #396]	@ 0x18c
    media_ptr -> fx_media_fat_cache_flushes =  0;
 800dc7a:	68fb      	ldr	r3, [r7, #12]
 800dc7c:	2200      	movs	r2, #0
 800dc7e:	f8c3 2190 	str.w	r2, [r3, #400]	@ 0x190
    media_ptr -> fx_media_fat_sector_reads =  0;
 800dc82:	68fb      	ldr	r3, [r7, #12]
 800dc84:	2200      	movs	r2, #0
 800dc86:	f8c3 2194 	str.w	r2, [r3, #404]	@ 0x194
    media_ptr -> fx_media_fat_sector_writes =  0;
 800dc8a:	68fb      	ldr	r3, [r7, #12]
 800dc8c:	2200      	movs	r2, #0
 800dc8e:	f8c3 2198 	str.w	r2, [r3, #408]	@ 0x198
    media_ptr -> fx_media_logical_sector_reads =  0;
 800dc92:	68fb      	ldr	r3, [r7, #12]
 800dc94:	2200      	movs	r2, #0
 800dc96:	f8c3 219c 	str.w	r2, [r3, #412]	@ 0x19c
    media_ptr -> fx_media_logical_sector_writes =  0;
 800dc9a:	68fb      	ldr	r3, [r7, #12]
 800dc9c:	2200      	movs	r2, #0
 800dc9e:	f8c3 21a0 	str.w	r2, [r3, #416]	@ 0x1a0
    media_ptr -> fx_media_logical_sector_cache_read_hits =  0;
 800dca2:	68fb      	ldr	r3, [r7, #12]
 800dca4:	2200      	movs	r2, #0
 800dca6:	f8c3 21a4 	str.w	r2, [r3, #420]	@ 0x1a4
    media_ptr -> fx_media_logical_sector_cache_read_misses =  0;
 800dcaa:	68fb      	ldr	r3, [r7, #12]
 800dcac:	2200      	movs	r2, #0
 800dcae:	f8c3 21a8 	str.w	r2, [r3, #424]	@ 0x1a8
    media_ptr -> fx_media_driver_read_requests =  0;
 800dcb2:	68fb      	ldr	r3, [r7, #12]
 800dcb4:	2200      	movs	r2, #0
 800dcb6:	f8c3 21ac 	str.w	r2, [r3, #428]	@ 0x1ac
    media_ptr -> fx_media_driver_write_requests =  0;
 800dcba:	68fb      	ldr	r3, [r7, #12]
 800dcbc:	2200      	movs	r2, #0
 800dcbe:	f8c3 21b0 	str.w	r2, [r3, #432]	@ 0x1b0
    media_ptr -> fx_media_driver_boot_read_requests =  0;
 800dcc2:	68fb      	ldr	r3, [r7, #12]
 800dcc4:	2200      	movs	r2, #0
 800dcc6:	f8c3 21b4 	str.w	r2, [r3, #436]	@ 0x1b4
    media_ptr -> fx_media_driver_boot_write_requests =  0;
 800dcca:	68fb      	ldr	r3, [r7, #12]
 800dccc:	2200      	movs	r2, #0
 800dcce:	f8c3 21b8 	str.w	r2, [r3, #440]	@ 0x1b8
    media_ptr -> fx_media_driver_release_sectors_requests =  0;
 800dcd2:	68fb      	ldr	r3, [r7, #12]
 800dcd4:	2200      	movs	r2, #0
 800dcd6:	f8c3 21bc 	str.w	r2, [r3, #444]	@ 0x1bc
    media_ptr -> fx_media_driver_flush_requests =  0;
 800dcda:	68fb      	ldr	r3, [r7, #12]
 800dcdc:	2200      	movs	r2, #0
 800dcde:	f8c3 21c0 	str.w	r2, [r3, #448]	@ 0x1c0
    /* If trace is enabled, insert this event into the trace buffer.  */
    FX_TRACE_IN_LINE_INSERT(FX_TRACE_MEDIA_OPEN, media_ptr, media_driver, memory_ptr, memory_size, FX_TRACE_MEDIA_EVENTS, 0, 0)

    /* Initialize the supplied media I/O driver.  First, build the
       initialize driver request.  */
    media_ptr -> fx_media_driver_request =              FX_DRIVER_INIT;
 800dce2:	68fb      	ldr	r3, [r7, #12]
 800dce4:	2204      	movs	r2, #4
 800dce6:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
    media_ptr -> fx_media_driver_status =               FX_IO_ERROR;
 800dcea:	68fb      	ldr	r3, [r7, #12]
 800dcec:	2290      	movs	r2, #144	@ 0x90
 800dcee:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
    media_ptr -> fx_media_driver_info =                 driver_info_ptr;
 800dcf2:	68fb      	ldr	r3, [r7, #12]
 800dcf4:	683a      	ldr	r2, [r7, #0]
 800dcf6:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
    media_ptr -> fx_media_driver_write_protect =        FX_FALSE;
 800dcfa:	68fb      	ldr	r3, [r7, #12]
 800dcfc:	2200      	movs	r2, #0
 800dcfe:	f8c3 20a8 	str.w	r2, [r3, #168]	@ 0xa8
    media_ptr -> fx_media_driver_free_sector_update =   FX_FALSE;
 800dd02:	68fb      	ldr	r3, [r7, #12]
 800dd04:	2200      	movs	r2, #0
 800dd06:	f8c3 20ac 	str.w	r2, [r3, #172]	@ 0xac
    media_ptr -> fx_media_driver_data_sector_read =     FX_FALSE;
 800dd0a:	68fb      	ldr	r3, [r7, #12]
 800dd0c:	2200      	movs	r2, #0
 800dd0e:	f8c3 20b4 	str.w	r2, [r3, #180]	@ 0xb4

    /* If trace is enabled, insert this event into the trace buffer.  */
    FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_INIT, media_ptr, 0, 0, 0, FX_TRACE_INTERNAL_EVENTS, 0, 0)

    /* Call the specified I/O driver with the initialize request.  */
    (media_ptr -> fx_media_driver_entry) (media_ptr);
 800dd12:	68fb      	ldr	r3, [r7, #12]
 800dd14:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
 800dd18:	68f8      	ldr	r0, [r7, #12]
 800dd1a:	4798      	blx	r3

    /* Determine if the I/O driver initialized successfully.  */
    if (media_ptr -> fx_media_driver_status != FX_SUCCESS)
 800dd1c:	68fb      	ldr	r3, [r7, #12]
 800dd1e:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800dd22:	2b00      	cmp	r3, #0
 800dd24:	d002      	beq.n	800dd2c <_fx_media_open+0x294>
    {

        /* Return the driver error status.  */
        return(FX_IO_ERROR);
 800dd26:	2390      	movs	r3, #144	@ 0x90
 800dd28:	f000 bc0c 	b.w	800e544 <_fx_media_open+0xaac>
    }

#ifndef FX_MEDIA_STATISTICS_DISABLE

    /* Increment the number of driver boot read requests.  */
    media_ptr -> fx_media_driver_boot_read_requests++;
 800dd2c:	68fb      	ldr	r3, [r7, #12]
 800dd2e:	f8d3 31b4 	ldr.w	r3, [r3, #436]	@ 0x1b4
 800dd32:	1c5a      	adds	r2, r3, #1
 800dd34:	68fb      	ldr	r3, [r7, #12]
 800dd36:	f8c3 21b4 	str.w	r2, [r3, #436]	@ 0x1b4
#endif

    /* Read the boot sector from the device.  Build the read boot sector
       command.  */
    media_ptr -> fx_media_driver_request =          FX_DRIVER_BOOT_READ;
 800dd3a:	68fb      	ldr	r3, [r7, #12]
 800dd3c:	2205      	movs	r2, #5
 800dd3e:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
    media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 800dd42:	68fb      	ldr	r3, [r7, #12]
 800dd44:	2290      	movs	r2, #144	@ 0x90
 800dd46:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
    media_ptr -> fx_media_driver_buffer =           memory_ptr;
 800dd4a:	68fb      	ldr	r3, [r7, #12]
 800dd4c:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 800dd4e:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
    media_ptr -> fx_media_driver_sectors =          1;
 800dd52:	68fb      	ldr	r3, [r7, #12]
 800dd54:	2201      	movs	r2, #1
 800dd56:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98
    media_ptr -> fx_media_driver_sector_type =      FX_BOOT_SECTOR;
 800dd5a:	68fb      	ldr	r3, [r7, #12]
 800dd5c:	2201      	movs	r2, #1
 800dd5e:	f8c3 20b8 	str.w	r2, [r3, #184]	@ 0xb8

    /* If trace is enabled, insert this event into the trace buffer.  */
    FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_BOOT_READ, media_ptr, memory_ptr, 0, 0, FX_TRACE_INTERNAL_EVENTS, 0, 0)

    /* Invoke the driver to read the boot sector.  */
    (media_ptr -> fx_media_driver_entry) (media_ptr);
 800dd62:	68fb      	ldr	r3, [r7, #12]
 800dd64:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
 800dd68:	68f8      	ldr	r0, [r7, #12]
 800dd6a:	4798      	blx	r3

    /* Determine if the boot sector was read correctly. */
    if (media_ptr -> fx_media_driver_status != FX_SUCCESS)
 800dd6c:	68fb      	ldr	r3, [r7, #12]
 800dd6e:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800dd72:	2b00      	cmp	r3, #0
 800dd74:	d016      	beq.n	800dda4 <_fx_media_open+0x30c>
    {

        /* Build the "uninitialize" I/O driver request.  */
        media_ptr -> fx_media_driver_request =      FX_DRIVER_UNINIT;
 800dd76:	68fb      	ldr	r3, [r7, #12]
 800dd78:	2208      	movs	r2, #8
 800dd7a:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
        media_ptr -> fx_media_driver_status =       FX_IO_ERROR;
 800dd7e:	68fb      	ldr	r3, [r7, #12]
 800dd80:	2290      	movs	r2, #144	@ 0x90
 800dd82:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c

        /* If trace is enabled, insert this event into the trace buffer.  */
        FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_UNINIT, media_ptr, 0, 0, 0, FX_TRACE_INTERNAL_EVENTS, 0, 0)

        /* Call the specified I/O driver with the uninitialize request.  */
        (media_ptr -> fx_media_driver_entry) (media_ptr);
 800dd86:	68fb      	ldr	r3, [r7, #12]
 800dd88:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
 800dd8c:	68f8      	ldr	r0, [r7, #12]
 800dd8e:	4798      	blx	r3

        /* Return the boot sector error status.  */
        return(FX_BOOT_ERROR);
 800dd90:	2301      	movs	r3, #1
 800dd92:	e3d7      	b.n	800e544 <_fx_media_open+0xaac>
 800dd94:	20002ca4 	.word	0x20002ca4
 800dd98:	20002ca8 	.word	0x20002ca8
 800dd9c:	20002cac 	.word	0x20002cac
 800dda0:	20000014 	.word	0x20000014
    }

    /* Extract and validate the media parameters from the boot sector.  */
    if (_fx_media_boot_info_extract(media_ptr) != FX_SUCCESS)
 800dda4:	68f8      	ldr	r0, [r7, #12]
 800dda6:	f7ff faff 	bl	800d3a8 <_fx_media_boot_info_extract>
 800ddaa:	4603      	mov	r3, r0
 800ddac:	2b00      	cmp	r3, #0
 800ddae:	d00e      	beq.n	800ddce <_fx_media_open+0x336>
    {

        /* Build the "uninitialize" I/O driver request.  */
        media_ptr -> fx_media_driver_request =      FX_DRIVER_UNINIT;
 800ddb0:	68fb      	ldr	r3, [r7, #12]
 800ddb2:	2208      	movs	r2, #8
 800ddb4:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
        media_ptr -> fx_media_driver_status =       FX_IO_ERROR;
 800ddb8:	68fb      	ldr	r3, [r7, #12]
 800ddba:	2290      	movs	r2, #144	@ 0x90
 800ddbc:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c

        /* If trace is enabled, insert this event into the trace buffer.  */
        FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_UNINIT, media_ptr, 0, 0, 0, FX_TRACE_INTERNAL_EVENTS, 0, 0)

        /* Call the specified I/O driver with the uninitialize request.  */
        (media_ptr -> fx_media_driver_entry) (media_ptr);
 800ddc0:	68fb      	ldr	r3, [r7, #12]
 800ddc2:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
 800ddc6:	68f8      	ldr	r0, [r7, #12]
 800ddc8:	4798      	blx	r3

        /* Return the invalid media error status.  */
        return(FX_MEDIA_INVALID);
 800ddca:	2302      	movs	r3, #2
 800ddcc:	e3ba      	b.n	800e544 <_fx_media_open+0xaac>
    }

    /* Pickup the additional info sector number. This will only be used in FAT32 situations.  */
    additional_info_sector =  _fx_utility_16_unsigned_read(&media_ptr -> fx_media_driver_buffer[48]);
 800ddce:	68fb      	ldr	r3, [r7, #12]
 800ddd0:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 800ddd4:	3330      	adds	r3, #48	@ 0x30
 800ddd6:	4618      	mov	r0, r3
 800ddd8:	f000 fd7c 	bl	800e8d4 <_fx_utility_16_unsigned_read>
 800dddc:	62f8      	str	r0, [r7, #44]	@ 0x2c

    /* Is there at least one?  */
    if (memory_size < media_ptr -> fx_media_bytes_per_sector)
 800ddde:	68fb      	ldr	r3, [r7, #12]
 800dde0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800dde2:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 800dde4:	429a      	cmp	r2, r3
 800dde6:	d20e      	bcs.n	800de06 <_fx_media_open+0x36e>
    {

        /* Build the "uninitialize" I/O driver request.  */
        media_ptr -> fx_media_driver_request =      FX_DRIVER_UNINIT;
 800dde8:	68fb      	ldr	r3, [r7, #12]
 800ddea:	2208      	movs	r2, #8
 800ddec:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
        media_ptr -> fx_media_driver_status =       FX_IO_ERROR;
 800ddf0:	68fb      	ldr	r3, [r7, #12]
 800ddf2:	2290      	movs	r2, #144	@ 0x90
 800ddf4:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c

        /* If trace is enabled, insert this event into the trace buffer.  */
        FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_UNINIT, media_ptr, 0, 0, 0, FX_TRACE_INTERNAL_EVENTS, 0, 0)

        /* Call the specified I/O driver with the uninitialize request.  */
        (media_ptr -> fx_media_driver_entry) (media_ptr);
 800ddf8:	68fb      	ldr	r3, [r7, #12]
 800ddfa:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
 800ddfe:	68f8      	ldr	r0, [r7, #12]
 800de00:	4798      	blx	r3

        /* Error in the buffer size supplied by user.  */
        return(FX_BUFFER_ERROR);
 800de02:	2321      	movs	r3, #33	@ 0x21
 800de04:	e39e      	b.n	800e544 <_fx_media_open+0xaac>
    }

#ifndef FX_DISABLE_CACHE
    /* Determine how many logical sectors can be cached with user's supplied
       buffer area - there must be at least enough for one sector!  */
    media_ptr -> fx_media_sector_cache_size =  memory_size / media_ptr -> fx_media_bytes_per_sector;
 800de06:	68fb      	ldr	r3, [r7, #12]
 800de08:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800de0a:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 800de0c:	fbb2 f2f3 	udiv	r2, r2, r3
 800de10:	68fb      	ldr	r3, [r7, #12]
 800de12:	615a      	str	r2, [r3, #20]
    /* If trace is enabled, register this object.  */
    FX_TRACE_OBJECT_REGISTER(FX_TRACE_OBJECT_TYPE_MEDIA, media_ptr, media_name, FX_MAX_FAT_CACHE, media_ptr -> fx_media_sector_cache_size)
    
    /* Adjust the internal cache to fit the fixed number of sector cache control blocks
       built into the media control block.  */
    if (media_ptr -> fx_media_sector_cache_size > FX_MAX_SECTOR_CACHE)
 800de14:	68fb      	ldr	r3, [r7, #12]
 800de16:	695b      	ldr	r3, [r3, #20]
 800de18:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800de1c:	d903      	bls.n	800de26 <_fx_media_open+0x38e>
    {

        /* Adjust the number of cache sectors downward.  If this is insufficient,
           the FX_MAX_SECTOR_CACHE constant in FX_API.H must be changed and the FileX
           library must be rebuilt.  */
        media_ptr -> fx_media_sector_cache_size =  FX_MAX_SECTOR_CACHE;
 800de1e:	68fb      	ldr	r3, [r7, #12]
 800de20:	f44f 7280 	mov.w	r2, #256	@ 0x100
 800de24:	615a      	str	r2, [r3, #20]
    }

    /* Otherwise, everything is okay.  Initialize the data structures for managing the
       logical sector cache.  */
    i =  (UINT)media_ptr -> fx_media_sector_cache_size;
 800de26:	68fb      	ldr	r3, [r7, #12]
 800de28:	695b      	ldr	r3, [r3, #20]
 800de2a:	63fb      	str	r3, [r7, #60]	@ 0x3c
    cache_entry_ptr =  media_ptr -> fx_media_sector_cache;
 800de2c:	68fb      	ldr	r3, [r7, #12]
 800de2e:	f503 6347 	add.w	r3, r3, #3184	@ 0xc70
 800de32:	637b      	str	r3, [r7, #52]	@ 0x34
    while (i--)
 800de34:	e01c      	b.n	800de70 <_fx_media_open+0x3d8>
    {

        /* Initialize each of the cache entries.  */
        cache_entry_ptr -> fx_cached_sector_memory_buffer =  (UCHAR *)memory_ptr;
 800de36:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800de38:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 800de3a:	601a      	str	r2, [r3, #0]
        cache_entry_ptr -> fx_cached_sector =                (~(ULONG64)0);
 800de3c:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 800de3e:	f04f 32ff 	mov.w	r2, #4294967295
 800de42:	f04f 33ff 	mov.w	r3, #4294967295
 800de46:	e9c1 2302 	strd	r2, r3, [r1, #8]
        cache_entry_ptr -> fx_cached_sector_buffer_dirty =   FX_FALSE;
 800de4a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800de4c:	2200      	movs	r2, #0
 800de4e:	741a      	strb	r2, [r3, #16]
        cache_entry_ptr -> fx_cached_sector_valid =          FX_FALSE;
 800de50:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800de52:	2200      	movs	r2, #0
 800de54:	745a      	strb	r2, [r3, #17]
        cache_entry_ptr -> fx_cached_sector_next_used =      cache_entry_ptr + 1;
 800de56:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800de58:	f103 0218 	add.w	r2, r3, #24
 800de5c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800de5e:	615a      	str	r2, [r3, #20]

        /* Move to the next cache sector entry.  */
        cache_entry_ptr++;
 800de60:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800de62:	3318      	adds	r3, #24
 800de64:	637b      	str	r3, [r7, #52]	@ 0x34

        /* Update the memory pointer to the next buffer slot.  */
        memory_ptr =  (VOID *)(((UCHAR *)memory_ptr) + media_ptr -> fx_media_bytes_per_sector);
 800de66:	68fb      	ldr	r3, [r7, #12]
 800de68:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800de6a:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 800de6c:	4413      	add	r3, r2
 800de6e:	66bb      	str	r3, [r7, #104]	@ 0x68
    while (i--)
 800de70:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800de72:	1e5a      	subs	r2, r3, #1
 800de74:	63fa      	str	r2, [r7, #60]	@ 0x3c
 800de76:	2b00      	cmp	r3, #0
 800de78:	d1dd      	bne.n	800de36 <_fx_media_open+0x39e>
    }

    /* Backup to the last cache entry to set its next pointer to NULL.  */
    cache_entry_ptr--;
 800de7a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800de7c:	3b18      	subs	r3, #24
 800de7e:	637b      	str	r3, [r7, #52]	@ 0x34
    cache_entry_ptr -> fx_cached_sector_next_used =  FX_NULL;
 800de80:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800de82:	2200      	movs	r2, #0
 800de84:	615a      	str	r2, [r3, #20]

    /* Remember the last memory address used by the caching logic.  */
    media_ptr -> fx_media_sector_cache_end =  ((UCHAR *)memory_ptr) - 1;
 800de86:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 800de88:	1e5a      	subs	r2, r3, #1
 800de8a:	68fb      	ldr	r3, [r7, #12]
 800de8c:	619a      	str	r2, [r3, #24]

    /* Setup the head pointer of the list.  */
    media_ptr -> fx_media_sector_cache_list_ptr =  media_ptr -> fx_media_sector_cache;
 800de8e:	68fb      	ldr	r3, [r7, #12]
 800de90:	f503 6247 	add.w	r2, r3, #3184	@ 0xc70
 800de94:	68fb      	ldr	r3, [r7, #12]
 800de96:	61da      	str	r2, [r3, #28]

    /* Setup the bit map that keeps track of the valid hashed cache logical sectors.  */
    media_ptr -> fx_media_sector_cache_hashed_sector_valid =  0;
 800de98:	68fb      	ldr	r3, [r7, #12]
 800de9a:	2200      	movs	r2, #0
 800de9c:	621a      	str	r2, [r3, #32]

    /* Clear the counter of the number of outstanding dirty sectors.  */
    media_ptr -> fx_media_sector_cache_dirty_count =  0;
 800de9e:	68fb      	ldr	r3, [r7, #12]
 800dea0:	2200      	movs	r2, #0
 800dea2:	625a      	str	r2, [r3, #36]	@ 0x24

    /* Determine if the logical sector cache should be managed by the hash function
       instead of the linear search. The cache must be a power of 2 that is between the
       minimum and maximum cache size.  */
    if ((media_ptr -> fx_media_sector_cache_size >= FX_SECTOR_CACHE_HASH_ENABLE) &&
 800dea4:	68fb      	ldr	r3, [r7, #12]
 800dea6:	695b      	ldr	r3, [r3, #20]
 800dea8:	2b0f      	cmp	r3, #15
 800deaa:	d91a      	bls.n	800dee2 <_fx_media_open+0x44a>
        ((media_ptr -> fx_media_sector_cache_size ^ (media_ptr -> fx_media_sector_cache_size - 1)) ==
 800deac:	68fb      	ldr	r3, [r7, #12]
 800deae:	695a      	ldr	r2, [r3, #20]
 800deb0:	68fb      	ldr	r3, [r7, #12]
 800deb2:	695b      	ldr	r3, [r3, #20]
 800deb4:	3b01      	subs	r3, #1
 800deb6:	405a      	eors	r2, r3
         (media_ptr -> fx_media_sector_cache_size | (media_ptr -> fx_media_sector_cache_size - 1))))
 800deb8:	68fb      	ldr	r3, [r7, #12]
 800deba:	6959      	ldr	r1, [r3, #20]
 800debc:	68fb      	ldr	r3, [r7, #12]
 800debe:	695b      	ldr	r3, [r3, #20]
 800dec0:	3b01      	subs	r3, #1
 800dec2:	430b      	orrs	r3, r1
    if ((media_ptr -> fx_media_sector_cache_size >= FX_SECTOR_CACHE_HASH_ENABLE) &&
 800dec4:	429a      	cmp	r2, r3
 800dec6:	d10c      	bne.n	800dee2 <_fx_media_open+0x44a>
    {


        /* Set the logical sector cache hash flag. When this flag is set, the logical
           sector cache is accessed with a hash function instead of a linear search.  */
        media_ptr -> fx_media_sector_cache_hashed =  FX_TRUE;
 800dec8:	68fb      	ldr	r3, [r7, #12]
 800deca:	2201      	movs	r2, #1
 800decc:	611a      	str	r2, [r3, #16]
        media_ptr -> fx_media_sector_cache_hash_mask =
            ((media_ptr -> fx_media_sector_cache_size / FX_SECTOR_CACHE_DEPTH) - 1);
 800dece:	68fb      	ldr	r3, [r7, #12]
 800ded0:	695b      	ldr	r3, [r3, #20]
 800ded2:	089b      	lsrs	r3, r3, #2
 800ded4:	3b01      	subs	r3, #1
        media_ptr -> fx_media_sector_cache_hash_mask =
 800ded6:	68fa      	ldr	r2, [r7, #12]
 800ded8:	f502 5200 	add.w	r2, r2, #8192	@ 0x2000
 800dedc:	f8c2 3470 	str.w	r3, [r2, #1136]	@ 0x470
 800dee0:	e002      	b.n	800dee8 <_fx_media_open+0x450>
    }
    else
    {

        /* Clear the logical sector cache flag.  */
        media_ptr -> fx_media_sector_cache_hashed =  FX_FALSE;
 800dee2:	68fb      	ldr	r3, [r7, #12]
 800dee4:	2200      	movs	r2, #0
 800dee6:	611a      	str	r2, [r3, #16]
    media_ptr -> fx_media_memory_buffer = memory_ptr;
#endif /* FX_DISABLE_CACHE */

#ifndef FX_DISABLE_FORCE_MEMORY_OPERATION
    /* Initialize the FAT cache entry array.  */
    for (i = 0; i < FX_MAX_FAT_CACHE; i++)
 800dee8:	2300      	movs	r3, #0
 800deea:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800deec:	e023      	b.n	800df36 <_fx_media_open+0x49e>
    {

        /* Clear entry in the FAT cache.  */
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_cluster =   0;
 800deee:	68f9      	ldr	r1, [r7, #12]
 800def0:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 800def2:	4613      	mov	r3, r2
 800def4:	005b      	lsls	r3, r3, #1
 800def6:	4413      	add	r3, r2
 800def8:	009b      	lsls	r3, r3, #2
 800defa:	440b      	add	r3, r1
 800defc:	f503 63e5 	add.w	r3, r3, #1832	@ 0x728
 800df00:	2200      	movs	r2, #0
 800df02:	601a      	str	r2, [r3, #0]
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_value   =   0;
 800df04:	68f9      	ldr	r1, [r7, #12]
 800df06:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 800df08:	4613      	mov	r3, r2
 800df0a:	005b      	lsls	r3, r3, #1
 800df0c:	4413      	add	r3, r2
 800df0e:	009b      	lsls	r3, r3, #2
 800df10:	440b      	add	r3, r1
 800df12:	f203 732c 	addw	r3, r3, #1836	@ 0x72c
 800df16:	2200      	movs	r2, #0
 800df18:	601a      	str	r2, [r3, #0]
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_dirty   =   0;
 800df1a:	68f9      	ldr	r1, [r7, #12]
 800df1c:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 800df1e:	4613      	mov	r3, r2
 800df20:	005b      	lsls	r3, r3, #1
 800df22:	4413      	add	r3, r2
 800df24:	009b      	lsls	r3, r3, #2
 800df26:	440b      	add	r3, r1
 800df28:	f503 63e6 	add.w	r3, r3, #1840	@ 0x730
 800df2c:	2200      	movs	r2, #0
 800df2e:	601a      	str	r2, [r3, #0]
    for (i = 0; i < FX_MAX_FAT_CACHE; i++)
 800df30:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800df32:	3301      	adds	r3, #1
 800df34:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800df36:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800df38:	2b0f      	cmp	r3, #15
 800df3a:	d9d8      	bls.n	800deee <_fx_media_open+0x456>
    }

    /* Initialize the secondary FAT update map.  */
    for (i = 0; i < FX_FAT_MAP_SIZE; i++)
 800df3c:	2300      	movs	r3, #0
 800df3e:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800df40:	e009      	b.n	800df56 <_fx_media_open+0x4be>
    {

        /* Clear bit map entry for secondary FAT update.  */
        media_ptr -> fx_media_fat_secondary_update_map[i] =  0;
 800df42:	68fa      	ldr	r2, [r7, #12]
 800df44:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800df46:	4413      	add	r3, r2
 800df48:	f503 63fd 	add.w	r3, r3, #2024	@ 0x7e8
 800df4c:	2200      	movs	r2, #0
 800df4e:	701a      	strb	r2, [r3, #0]
    for (i = 0; i < FX_FAT_MAP_SIZE; i++)
 800df50:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800df52:	3301      	adds	r3, #1
 800df54:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800df56:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800df58:	2b7f      	cmp	r3, #127	@ 0x7f
 800df5a:	d9f2      	bls.n	800df42 <_fx_media_open+0x4aa>
    if (media_ptr -> fx_media_FAT_type != FX_exFAT)
    {
#endif /* FX_ENABLE_EXFAT */

        /* Root_sector_start has been computed */
        media_ptr -> fx_media_root_sector_start =  media_ptr -> fx_media_reserved_sectors +
 800df5c:	68fb      	ldr	r3, [r7, #12]
 800df5e:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
            (media_ptr -> fx_media_number_of_FATs *
 800df60:	68fb      	ldr	r3, [r7, #12]
 800df62:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
             media_ptr -> fx_media_sectors_per_FAT);
 800df64:	68f9      	ldr	r1, [r7, #12]
 800df66:	6d89      	ldr	r1, [r1, #88]	@ 0x58
            (media_ptr -> fx_media_number_of_FATs *
 800df68:	fb01 f303 	mul.w	r3, r1, r3
        media_ptr -> fx_media_root_sector_start =  media_ptr -> fx_media_reserved_sectors +
 800df6c:	441a      	add	r2, r3
 800df6e:	68fb      	ldr	r3, [r7, #12]
 800df70:	649a      	str	r2, [r3, #72]	@ 0x48

        /* Calculate the number of directory sectors.  */
        media_ptr -> fx_media_root_sectors =
            ((media_ptr -> fx_media_root_directory_entries * FX_DIR_ENTRY_SIZE) +
 800df72:	68fb      	ldr	r3, [r7, #12]
 800df74:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 800df76:	015a      	lsls	r2, r3, #5
             media_ptr -> fx_media_bytes_per_sector - 1) /
 800df78:	68fb      	ldr	r3, [r7, #12]
 800df7a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
            ((media_ptr -> fx_media_root_directory_entries * FX_DIR_ENTRY_SIZE) +
 800df7c:	4413      	add	r3, r2
             media_ptr -> fx_media_bytes_per_sector - 1) /
 800df7e:	1e5a      	subs	r2, r3, #1
            media_ptr -> fx_media_bytes_per_sector;
 800df80:	68fb      	ldr	r3, [r7, #12]
 800df82:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
             media_ptr -> fx_media_bytes_per_sector - 1) /
 800df84:	fbb2 f2f3 	udiv	r2, r2, r3
        media_ptr -> fx_media_root_sectors =
 800df88:	68fb      	ldr	r3, [r7, #12]
 800df8a:	64da      	str	r2, [r3, #76]	@ 0x4c

        /* Calculate the starting data sector.  */
        media_ptr -> fx_media_data_sector_start =  media_ptr -> fx_media_root_sector_start +
 800df8c:	68fb      	ldr	r3, [r7, #12]
 800df8e:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
            media_ptr -> fx_media_root_sectors;
 800df90:	68fb      	ldr	r3, [r7, #12]
 800df92:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
        media_ptr -> fx_media_data_sector_start =  media_ptr -> fx_media_root_sector_start +
 800df94:	441a      	add	r2, r3
 800df96:	68fb      	ldr	r3, [r7, #12]
 800df98:	651a      	str	r2, [r3, #80]	@ 0x50

        /* Calculate the total number of clusters.  */
        media_ptr -> fx_media_total_clusters =  (ULONG)((media_ptr -> fx_media_total_sectors - media_ptr -> fx_media_data_sector_start) /
 800df9a:	68fb      	ldr	r3, [r7, #12]
 800df9c:	e9d3 230e 	ldrd	r2, r3, [r3, #56]	@ 0x38
 800dfa0:	68f9      	ldr	r1, [r7, #12]
 800dfa2:	6d09      	ldr	r1, [r1, #80]	@ 0x50
 800dfa4:	2000      	movs	r0, #0
 800dfa6:	460c      	mov	r4, r1
 800dfa8:	4605      	mov	r5, r0
 800dfaa:	ebb2 0804 	subs.w	r8, r2, r4
 800dfae:	eb63 0905 	sbc.w	r9, r3, r5
                                                            media_ptr -> fx_media_sectors_per_cluster);
 800dfb2:	68fb      	ldr	r3, [r7, #12]
 800dfb4:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800dfb6:	2200      	movs	r2, #0
 800dfb8:	469a      	mov	sl, r3
 800dfba:	4693      	mov	fp, r2
        media_ptr -> fx_media_total_clusters =  (ULONG)((media_ptr -> fx_media_total_sectors - media_ptr -> fx_media_data_sector_start) /
 800dfbc:	4652      	mov	r2, sl
 800dfbe:	465b      	mov	r3, fp
 800dfc0:	4640      	mov	r0, r8
 800dfc2:	4649      	mov	r1, r9
 800dfc4:	f7f2 f958 	bl	8000278 <__aeabi_uldivmod>
 800dfc8:	4602      	mov	r2, r0
 800dfca:	460b      	mov	r3, r1
 800dfcc:	68fb      	ldr	r3, [r7, #12]
 800dfce:	641a      	str	r2, [r3, #64]	@ 0x40

        /* Determine if a 12-bit FAT is in use.  */
        if (media_ptr -> fx_media_total_clusters < FX_12_BIT_FAT_SIZE)
 800dfd0:	68fb      	ldr	r3, [r7, #12]
 800dfd2:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800dfd4:	f640 72f5 	movw	r2, #4085	@ 0xff5
 800dfd8:	4293      	cmp	r3, r2
 800dfda:	d819      	bhi.n	800e010 <_fx_media_open+0x578>
        {

            /* Yes, 12-bit FAT is present.  Set flag accordingly.  */
            media_ptr -> fx_media_12_bit_FAT = FX_TRUE;
 800dfdc:	68fb      	ldr	r3, [r7, #12]
 800dfde:	2201      	movs	r2, #1
 800dfe0:	661a      	str	r2, [r3, #96]	@ 0x60
            media_ptr -> fx_media_32_bit_FAT = FX_FALSE;
 800dfe2:	68fb      	ldr	r3, [r7, #12]
 800dfe4:	2200      	movs	r2, #0
 800dfe6:	665a      	str	r2, [r3, #100]	@ 0x64
#ifdef FX_ENABLE_EXFAT
            media_ptr -> fx_media_FAT_type = FX_FAT12;
#endif /* FX_ENABLE_EXFAT */

            /* No additional information sector in FAT12.  */
            media_ptr -> fx_media_FAT32_additional_info_sector =  0;
 800dfe8:	68fb      	ldr	r3, [r7, #12]
 800dfea:	2200      	movs	r2, #0
 800dfec:	669a      	str	r2, [r3, #104]	@ 0x68

            /* Set FAT last and FAT reserved. */
            media_ptr -> fx_media_fat_reserved = FX_RESERVED_1;
 800dfee:	68fb      	ldr	r3, [r7, #12]
 800dff0:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 800dff4:	461a      	mov	r2, r3
 800dff6:	f64f 73f0 	movw	r3, #65520	@ 0xfff0
 800dffa:	f8c2 3478 	str.w	r3, [r2, #1144]	@ 0x478
            media_ptr -> fx_media_fat_last = FX_LAST_CLUSTER_2;
 800dffe:	68fb      	ldr	r3, [r7, #12]
 800e000:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 800e004:	461a      	mov	r2, r3
 800e006:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 800e00a:	f8c2 347c 	str.w	r3, [r2, #1148]	@ 0x47c
 800e00e:	e037      	b.n	800e080 <_fx_media_open+0x5e8>
        }
        else if (media_ptr -> fx_media_total_clusters < FX_16_BIT_FAT_SIZE)
 800e010:	68fb      	ldr	r3, [r7, #12]
 800e012:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800e014:	f64f 72f4 	movw	r2, #65524	@ 0xfff4
 800e018:	4293      	cmp	r3, r2
 800e01a:	d819      	bhi.n	800e050 <_fx_media_open+0x5b8>
        {

            /* A 16-bit FAT is present.  Set flag accordingly.  */
            media_ptr -> fx_media_12_bit_FAT =  FX_FALSE;
 800e01c:	68fb      	ldr	r3, [r7, #12]
 800e01e:	2200      	movs	r2, #0
 800e020:	661a      	str	r2, [r3, #96]	@ 0x60
            media_ptr -> fx_media_32_bit_FAT =  FX_FALSE;
 800e022:	68fb      	ldr	r3, [r7, #12]
 800e024:	2200      	movs	r2, #0
 800e026:	665a      	str	r2, [r3, #100]	@ 0x64
#ifdef FX_ENABLE_EXFAT
            media_ptr -> fx_media_FAT_type = FX_FAT16;
#endif /* FX_ENABLE_EXFAT */

            /* No additional information sector in FAT16.  */
            media_ptr -> fx_media_FAT32_additional_info_sector =  0;
 800e028:	68fb      	ldr	r3, [r7, #12]
 800e02a:	2200      	movs	r2, #0
 800e02c:	669a      	str	r2, [r3, #104]	@ 0x68

            /* Set FAT last and FAT reserved. */
            media_ptr -> fx_media_fat_reserved = FX_RESERVED_1;
 800e02e:	68fb      	ldr	r3, [r7, #12]
 800e030:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 800e034:	461a      	mov	r2, r3
 800e036:	f64f 73f0 	movw	r3, #65520	@ 0xfff0
 800e03a:	f8c2 3478 	str.w	r3, [r2, #1144]	@ 0x478
            media_ptr -> fx_media_fat_last = FX_LAST_CLUSTER_2;
 800e03e:	68fb      	ldr	r3, [r7, #12]
 800e040:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 800e044:	461a      	mov	r2, r3
 800e046:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 800e04a:	f8c2 347c 	str.w	r3, [r2, #1148]	@ 0x47c
 800e04e:	e017      	b.n	800e080 <_fx_media_open+0x5e8>
        }
        else
        {

            /* Yes, a 32-bit FAT is present.  */
            media_ptr -> fx_media_12_bit_FAT =  FX_FALSE;
 800e050:	68fb      	ldr	r3, [r7, #12]
 800e052:	2200      	movs	r2, #0
 800e054:	661a      	str	r2, [r3, #96]	@ 0x60
            media_ptr -> fx_media_32_bit_FAT =  FX_TRUE;
 800e056:	68fb      	ldr	r3, [r7, #12]
 800e058:	2201      	movs	r2, #1
 800e05a:	665a      	str	r2, [r3, #100]	@ 0x64
            media_ptr -> fx_media_FAT_type = FX_FAT32;
#endif /* FX_ENABLE_EXFAT */

            /* Save the additional information sector FAT32. This was read from the boot
               sector earlier in this routine. */
            media_ptr -> fx_media_FAT32_additional_info_sector =  additional_info_sector;
 800e05c:	68fb      	ldr	r3, [r7, #12]
 800e05e:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800e060:	669a      	str	r2, [r3, #104]	@ 0x68

            /* Set FAT last and FAT reserved. */
            media_ptr -> fx_media_fat_reserved = FX_RESERVED_1_32;
 800e062:	68fb      	ldr	r3, [r7, #12]
 800e064:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 800e068:	461a      	mov	r2, r3
 800e06a:	4b95      	ldr	r3, [pc, #596]	@ (800e2c0 <_fx_media_open+0x828>)
 800e06c:	f8c2 3478 	str.w	r3, [r2, #1144]	@ 0x478
            media_ptr -> fx_media_fat_last = FX_LAST_CLUSTER_2_32;
 800e070:	68fb      	ldr	r3, [r7, #12]
 800e072:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 800e076:	461a      	mov	r2, r3
 800e078:	f06f 4370 	mvn.w	r3, #4026531840	@ 0xf0000000
 800e07c:	f8c2 347c 	str.w	r3, [r2, #1148]	@ 0x47c
       it is variable in FAT32.  */
#ifdef FX_ENABLE_EXFAT
    if (media_ptr -> fx_media_32_bit_FAT == FX_TRUE || 
        (media_ptr -> fx_media_FAT_type == FX_exFAT))
#else
    if (media_ptr -> fx_media_32_bit_FAT == FX_TRUE)
 800e080:	68fb      	ldr	r3, [r7, #12]
 800e082:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 800e084:	2b01      	cmp	r3, #1
 800e086:	d15f      	bne.n	800e148 <_fx_media_open+0x6b0>
        if (media_ptr -> fx_media_32_bit_FAT == FX_TRUE)
        {
#endif /* FX_ENABLE_EXFAT */

            /* Root First cluster starts from at least cluster 2, or higher. */
            if (media_ptr -> fx_media_root_cluster_32 < FX_FAT_ENTRY_START)
 800e088:	68fb      	ldr	r3, [r7, #12]
 800e08a:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 800e08c:	2b01      	cmp	r3, #1
 800e08e:	d801      	bhi.n	800e094 <_fx_media_open+0x5fc>
            {
                return(FX_MEDIA_INVALID);
 800e090:	2302      	movs	r3, #2
 800e092:	e257      	b.n	800e544 <_fx_media_open+0xaac>
            }

            /* Calculate logical number of root dir sector.  */
            media_ptr -> fx_media_root_sector_start = media_ptr -> fx_media_data_sector_start +
 800e094:	68fb      	ldr	r3, [r7, #12]
 800e096:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
                (media_ptr -> fx_media_root_cluster_32 - FX_FAT_ENTRY_START) *
 800e098:	68fb      	ldr	r3, [r7, #12]
 800e09a:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 800e09c:	3b02      	subs	r3, #2
                media_ptr -> fx_media_sectors_per_cluster;
 800e09e:	68f9      	ldr	r1, [r7, #12]
 800e0a0:	6d49      	ldr	r1, [r1, #84]	@ 0x54
                (media_ptr -> fx_media_root_cluster_32 - FX_FAT_ENTRY_START) *
 800e0a2:	fb01 f303 	mul.w	r3, r1, r3
            media_ptr -> fx_media_root_sector_start = media_ptr -> fx_media_data_sector_start +
 800e0a6:	441a      	add	r2, r3
 800e0a8:	68fb      	ldr	r3, [r7, #12]
 800e0aa:	649a      	str	r2, [r3, #72]	@ 0x48
#ifdef FX_ENABLE_EXFAT
        }
#endif /* FX_ENABLE_EXFAT */

        /* Calculate maximum possible value for fx_media_root_directory_entries */
        i = 0;
 800e0ac:	2300      	movs	r3, #0
 800e0ae:	63fb      	str	r3, [r7, #60]	@ 0x3c
        for (cluster_number = media_ptr -> fx_media_root_cluster_32;;)
 800e0b0:	68fb      	ldr	r3, [r7, #12]
 800e0b2:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 800e0b4:	647b      	str	r3, [r7, #68]	@ 0x44
        {

            status =  _fx_utility_FAT_entry_read(media_ptr, cluster_number, &FAT_entry);
 800e0b6:	f107 0310 	add.w	r3, r7, #16
 800e0ba:	461a      	mov	r2, r3
 800e0bc:	6c79      	ldr	r1, [r7, #68]	@ 0x44
 800e0be:	68f8      	ldr	r0, [r7, #12]
 800e0c0:	f000 fc6e 	bl	800e9a0 <_fx_utility_FAT_entry_read>
 800e0c4:	62b8      	str	r0, [r7, #40]	@ 0x28
            i++;
 800e0c6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800e0c8:	3301      	adds	r3, #1
 800e0ca:	63fb      	str	r3, [r7, #60]	@ 0x3c
            /* Determine if the read was successful.  */
            if (status != FX_SUCCESS)
 800e0cc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800e0ce:	2b00      	cmp	r3, #0
 800e0d0:	d00e      	beq.n	800e0f0 <_fx_media_open+0x658>
            {

                /* Build the "uninitialize" I/O driver request.  */
                media_ptr -> fx_media_driver_request =      FX_DRIVER_UNINIT;
 800e0d2:	68fb      	ldr	r3, [r7, #12]
 800e0d4:	2208      	movs	r2, #8
 800e0d6:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
                media_ptr -> fx_media_driver_status =       FX_IO_ERROR;
 800e0da:	68fb      	ldr	r3, [r7, #12]
 800e0dc:	2290      	movs	r2, #144	@ 0x90
 800e0de:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c

                /* If trace is enabled, insert this event into the trace buffer.  */
                FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_UNINIT, media_ptr, 0, 0, 0, FX_TRACE_INTERNAL_EVENTS, 0, 0)

                /* Call the specified I/O driver with the uninitialize request.  */
                (media_ptr -> fx_media_driver_entry) (media_ptr);
 800e0e2:	68fb      	ldr	r3, [r7, #12]
 800e0e4:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
 800e0e8:	68f8      	ldr	r0, [r7, #12]
 800e0ea:	4798      	blx	r3

                return(FX_FAT_READ_ERROR);
 800e0ec:	2303      	movs	r3, #3
 800e0ee:	e229      	b.n	800e544 <_fx_media_open+0xaac>
            }

            if ((cluster_number == FAT_entry) || (i > media_ptr -> fx_media_total_clusters))
 800e0f0:	693b      	ldr	r3, [r7, #16]
 800e0f2:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 800e0f4:	429a      	cmp	r2, r3
 800e0f6:	d004      	beq.n	800e102 <_fx_media_open+0x66a>
 800e0f8:	68fb      	ldr	r3, [r7, #12]
 800e0fa:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800e0fc:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 800e0fe:	429a      	cmp	r2, r3
 800e100:	d90e      	bls.n	800e120 <_fx_media_open+0x688>
            {

                /* Build the "uninitialize" I/O driver request.  */
                media_ptr -> fx_media_driver_request =      FX_DRIVER_UNINIT;
 800e102:	68fb      	ldr	r3, [r7, #12]
 800e104:	2208      	movs	r2, #8
 800e106:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
                media_ptr -> fx_media_driver_status =       FX_IO_ERROR;
 800e10a:	68fb      	ldr	r3, [r7, #12]
 800e10c:	2290      	movs	r2, #144	@ 0x90
 800e10e:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c

                /* If trace is enabled, insert this event into the trace buffer.  */
                FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_UNINIT, media_ptr, 0, 0, 0, FX_TRACE_INTERNAL_EVENTS, 0, 0)

                /* Call the specified I/O driver with the uninitialize request.  */
                (media_ptr -> fx_media_driver_entry) (media_ptr);
 800e112:	68fb      	ldr	r3, [r7, #12]
 800e114:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
 800e118:	68f8      	ldr	r0, [r7, #12]
 800e11a:	4798      	blx	r3

                return(FX_FAT_READ_ERROR);
 800e11c:	2303      	movs	r3, #3
 800e11e:	e211      	b.n	800e544 <_fx_media_open+0xaac>
            }
            if (FAT_entry >= FX_RESERVED_1_32)
 800e120:	693b      	ldr	r3, [r7, #16]
 800e122:	4a68      	ldr	r2, [pc, #416]	@ (800e2c4 <_fx_media_open+0x82c>)
 800e124:	4293      	cmp	r3, r2
 800e126:	d802      	bhi.n	800e12e <_fx_media_open+0x696>
            {
                break;
            }
            cluster_number = FAT_entry;
 800e128:	693b      	ldr	r3, [r7, #16]
 800e12a:	647b      	str	r3, [r7, #68]	@ 0x44
            status =  _fx_utility_FAT_entry_read(media_ptr, cluster_number, &FAT_entry);
 800e12c:	e7c3      	b.n	800e0b6 <_fx_media_open+0x61e>
                break;
 800e12e:	bf00      	nop
        }

        /* Calculate the number of directory entries.  */
        media_ptr -> fx_media_root_directory_entries =  (i * media_ptr -> fx_media_sectors_per_cluster *
 800e130:	68fb      	ldr	r3, [r7, #12]
 800e132:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800e134:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 800e136:	fb02 f303 	mul.w	r3, r2, r3
                                                         media_ptr -> fx_media_bytes_per_sector) / FX_DIR_ENTRY_SIZE;
 800e13a:	68fa      	ldr	r2, [r7, #12]
 800e13c:	6a92      	ldr	r2, [r2, #40]	@ 0x28
        media_ptr -> fx_media_root_directory_entries =  (i * media_ptr -> fx_media_sectors_per_cluster *
 800e13e:	fb02 f303 	mul.w	r3, r2, r3
                                                         media_ptr -> fx_media_bytes_per_sector) / FX_DIR_ENTRY_SIZE;
 800e142:	095a      	lsrs	r2, r3, #5
        media_ptr -> fx_media_root_directory_entries =  (i * media_ptr -> fx_media_sectors_per_cluster *
 800e144:	68fb      	ldr	r3, [r7, #12]
 800e146:	679a      	str	r2, [r3, #120]	@ 0x78
    }

#ifndef FX_DISABLE_FORCE_MEMORY_OPERATION
    /* Calculate the number of available clusters.  */
    media_ptr -> fx_media_available_clusters =  0;
 800e148:	68fb      	ldr	r3, [r7, #12]
 800e14a:	2200      	movs	r2, #0
 800e14c:	67da      	str	r2, [r3, #124]	@ 0x7c

    /* Set the cluster search start to an invalid value.  */
    media_ptr -> fx_media_cluster_search_start =  0;
 800e14e:	68fb      	ldr	r3, [r7, #12]
 800e150:	2200      	movs	r2, #0
 800e152:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
#endif /* FX_DISABLE_FORCE_MEMORY_OPERATION */

    /* Determine if there is 32-bit FAT additional information sector. */
    if (media_ptr -> fx_media_FAT32_additional_info_sector)
 800e156:	68fb      	ldr	r3, [r7, #12]
 800e158:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 800e15a:	2b00      	cmp	r3, #0
 800e15c:	f000 808e 	beq.w	800e27c <_fx_media_open+0x7e4>
        /* Yes, read the FAT32 additional information sector to get the available cluster count and
           the hint for the first available cluster.  */

#ifndef FX_DISABLE_CACHE
        /* Setup a pointer to the first cached entry's buffer.  */
        buffer_ptr =  (media_ptr -> fx_media_sector_cache_list_ptr) -> fx_cached_sector_memory_buffer;
 800e160:	68fb      	ldr	r3, [r7, #12]
 800e162:	69db      	ldr	r3, [r3, #28]
 800e164:	681b      	ldr	r3, [r3, #0]
 800e166:	627b      	str	r3, [r7, #36]	@ 0x24

        /* Invalidate this cache entry.  */
        (media_ptr -> fx_media_sector_cache_list_ptr) -> fx_cached_sector =  (~((ULONG64) 0));
 800e168:	68fb      	ldr	r3, [r7, #12]
 800e16a:	69d9      	ldr	r1, [r3, #28]
 800e16c:	f04f 32ff 	mov.w	r2, #4294967295
 800e170:	f04f 33ff 	mov.w	r3, #4294967295
 800e174:	e9c1 2302 	strd	r2, r3, [r1, #8]
        (media_ptr -> fx_media_sector_cache_list_ptr) -> fx_cached_sector_valid =  FX_FALSE;
 800e178:	68fb      	ldr	r3, [r7, #12]
 800e17a:	69db      	ldr	r3, [r3, #28]
 800e17c:	2200      	movs	r2, #0
 800e17e:	745a      	strb	r2, [r3, #17]
        buffer_ptr =  media_ptr -> fx_media_memory_buffer;
        media_ptr -> fx_media_memory_buffer_sector = (ULONG64)-1;
#endif /* FX_DISABLE_CACHE */

        /* Read the FAT32 additional information sector from the device.  */
        media_ptr -> fx_media_driver_request =          FX_DRIVER_READ;
 800e180:	68fb      	ldr	r3, [r7, #12]
 800e182:	2200      	movs	r2, #0
 800e184:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
        media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 800e188:	68fb      	ldr	r3, [r7, #12]
 800e18a:	2290      	movs	r2, #144	@ 0x90
 800e18c:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
        media_ptr -> fx_media_driver_buffer =           buffer_ptr;
 800e190:	68fb      	ldr	r3, [r7, #12]
 800e192:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800e194:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
        media_ptr -> fx_media_driver_logical_sector =   media_ptr -> fx_media_FAT32_additional_info_sector;
 800e198:	68fb      	ldr	r3, [r7, #12]
 800e19a:	6e9a      	ldr	r2, [r3, #104]	@ 0x68
 800e19c:	68fb      	ldr	r3, [r7, #12]
 800e19e:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
        media_ptr -> fx_media_driver_sectors =          1;
 800e1a2:	68fb      	ldr	r3, [r7, #12]
 800e1a4:	2201      	movs	r2, #1
 800e1a6:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98
        media_ptr -> fx_media_driver_sector_type =      FX_DIRECTORY_SECTOR;
 800e1aa:	68fb      	ldr	r3, [r7, #12]
 800e1ac:	2203      	movs	r2, #3
 800e1ae:	f8c3 20b8 	str.w	r2, [r3, #184]	@ 0xb8

#ifndef FX_MEDIA_STATISTICS_DISABLE

        /* Increment the number of driver read sector(s) requests.  */
        media_ptr -> fx_media_driver_read_requests++;
 800e1b2:	68fb      	ldr	r3, [r7, #12]
 800e1b4:	f8d3 31ac 	ldr.w	r3, [r3, #428]	@ 0x1ac
 800e1b8:	1c5a      	adds	r2, r3, #1
 800e1ba:	68fb      	ldr	r3, [r7, #12]
 800e1bc:	f8c3 21ac 	str.w	r2, [r3, #428]	@ 0x1ac

        /* If trace is enabled, insert this event into the trace buffer.  */
        FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_READ, media_ptr, media_ptr -> fx_media_FAT32_additional_info_sector, 1, buffer_ptr, FX_TRACE_INTERNAL_EVENTS, 0, 0)

        /* Invoke the driver to read the FAT32 additional information sector.  */
        (media_ptr -> fx_media_driver_entry) (media_ptr);
 800e1c0:	68fb      	ldr	r3, [r7, #12]
 800e1c2:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
 800e1c6:	68f8      	ldr	r0, [r7, #12]
 800e1c8:	4798      	blx	r3

        /* Determine if the FAT32 sector was read correctly. */
        if (media_ptr -> fx_media_driver_status == FX_SUCCESS)
 800e1ca:	68fb      	ldr	r3, [r7, #12]
 800e1cc:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800e1d0:	2b00      	cmp	r3, #0
 800e1d2:	d150      	bne.n	800e276 <_fx_media_open+0x7de>
        {

            /* Yes, setup a pointer into the FAT32 additional information sector.  */
            buffer_ptr =  media_ptr -> fx_media_driver_buffer;
 800e1d4:	68fb      	ldr	r3, [r7, #12]
 800e1d6:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 800e1da:	627b      	str	r3, [r7, #36]	@ 0x24

            /* Pickup the first signature long word.  */
            signature =  _fx_utility_32_unsigned_read(&buffer_ptr[0]);
 800e1dc:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 800e1de:	f000 fba1 	bl	800e924 <_fx_utility_32_unsigned_read>
 800e1e2:	6238      	str	r0, [r7, #32]

            /* Determine if the signature is correct.  */
            if (signature == 0x41615252)
 800e1e4:	6a3b      	ldr	r3, [r7, #32]
 800e1e6:	4a38      	ldr	r2, [pc, #224]	@ (800e2c8 <_fx_media_open+0x830>)
 800e1e8:	4293      	cmp	r3, r2
 800e1ea:	d140      	bne.n	800e26e <_fx_media_open+0x7d6>
            {

                /* Yes, the first signature is correct, now pickup the next signature.  */
                signature =  _fx_utility_32_unsigned_read(&buffer_ptr[484]);
 800e1ec:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e1ee:	f503 73f2 	add.w	r3, r3, #484	@ 0x1e4
 800e1f2:	4618      	mov	r0, r3
 800e1f4:	f000 fb96 	bl	800e924 <_fx_utility_32_unsigned_read>
 800e1f8:	6238      	str	r0, [r7, #32]

                /* Determine if this signature is correct.  */
                if (signature == 0x61417272)
 800e1fa:	6a3b      	ldr	r3, [r7, #32]
 800e1fc:	4a33      	ldr	r2, [pc, #204]	@ (800e2cc <_fx_media_open+0x834>)
 800e1fe:	4293      	cmp	r3, r2
 800e200:	d131      	bne.n	800e266 <_fx_media_open+0x7ce>
                {

                    /* Yes, we have a good FAT32 additional information sector.  */

                    /* Pickup the current available cluster count on the media.  */
                    media_ptr -> fx_media_available_clusters =  _fx_utility_32_unsigned_read(&buffer_ptr[488]);
 800e202:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e204:	f503 73f4 	add.w	r3, r3, #488	@ 0x1e8
 800e208:	4618      	mov	r0, r3
 800e20a:	f000 fb8b 	bl	800e924 <_fx_utility_32_unsigned_read>
 800e20e:	4602      	mov	r2, r0
 800e210:	68fb      	ldr	r3, [r7, #12]
 800e212:	67da      	str	r2, [r3, #124]	@ 0x7c

                    /* Initialize the last reported available cluster count to the same value.  */
                    media_ptr -> fx_media_FAT32_additional_info_last_available =  media_ptr -> fx_media_available_clusters;
 800e214:	68fb      	ldr	r3, [r7, #12]
 800e216:	6fda      	ldr	r2, [r3, #124]	@ 0x7c
 800e218:	68fb      	ldr	r3, [r7, #12]
 800e21a:	66da      	str	r2, [r3, #108]	@ 0x6c

                    /* Pickup the hint for the starting free cluster search.  */
                    media_ptr -> fx_media_cluster_search_start =  _fx_utility_32_unsigned_read(&buffer_ptr[492]);
 800e21c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e21e:	f503 73f6 	add.w	r3, r3, #492	@ 0x1ec
 800e222:	4618      	mov	r0, r3
 800e224:	f000 fb7e 	bl	800e924 <_fx_utility_32_unsigned_read>
 800e228:	4602      	mov	r2, r0
 800e22a:	68fb      	ldr	r3, [r7, #12]
 800e22c:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

                    /* Perform a quick sanity check on the available cluster count and the starting free
                       cluster search.  */
                    if ((media_ptr -> fx_media_available_clusters > media_ptr -> fx_media_total_clusters) ||
 800e230:	68fb      	ldr	r3, [r7, #12]
 800e232:	6fda      	ldr	r2, [r3, #124]	@ 0x7c
 800e234:	68fb      	ldr	r3, [r7, #12]
 800e236:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800e238:	429a      	cmp	r2, r3
 800e23a:	d80c      	bhi.n	800e256 <_fx_media_open+0x7be>
                        (media_ptr -> fx_media_cluster_search_start > media_ptr -> fx_media_total_clusters + FX_FAT_ENTRY_START) ||
 800e23c:	68fb      	ldr	r3, [r7, #12]
 800e23e:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
 800e242:	68fb      	ldr	r3, [r7, #12]
 800e244:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800e246:	3302      	adds	r3, #2
                    if ((media_ptr -> fx_media_available_clusters > media_ptr -> fx_media_total_clusters) ||
 800e248:	429a      	cmp	r2, r3
 800e24a:	d804      	bhi.n	800e256 <_fx_media_open+0x7be>
                        (media_ptr -> fx_media_cluster_search_start < FX_FAT_ENTRY_START))
 800e24c:	68fb      	ldr	r3, [r7, #12]
 800e24e:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
                        (media_ptr -> fx_media_cluster_search_start > media_ptr -> fx_media_total_clusters + FX_FAT_ENTRY_START) ||
 800e252:	2b01      	cmp	r3, #1
 800e254:	d812      	bhi.n	800e27c <_fx_media_open+0x7e4>
                    {

                        /* Something is wrong, clear the available cluster count and search so the regular processing
                           is used.  */
                        media_ptr -> fx_media_available_clusters =    0;
 800e256:	68fb      	ldr	r3, [r7, #12]
 800e258:	2200      	movs	r2, #0
 800e25a:	67da      	str	r2, [r3, #124]	@ 0x7c
                        media_ptr -> fx_media_cluster_search_start =  0;
 800e25c:	68fb      	ldr	r3, [r7, #12]
 800e25e:	2200      	movs	r2, #0
 800e260:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
 800e264:	e00a      	b.n	800e27c <_fx_media_open+0x7e4>
                }
                else
                {

                    /* Signature is bad, invalidate the additional info sector.  */
                    media_ptr -> fx_media_FAT32_additional_info_sector =  0;
 800e266:	68fb      	ldr	r3, [r7, #12]
 800e268:	2200      	movs	r2, #0
 800e26a:	669a      	str	r2, [r3, #104]	@ 0x68
 800e26c:	e006      	b.n	800e27c <_fx_media_open+0x7e4>
            }
            else
            {

                /* Signature is bad, invalidate the additional info sector.  */
                media_ptr -> fx_media_FAT32_additional_info_sector =  0;
 800e26e:	68fb      	ldr	r3, [r7, #12]
 800e270:	2200      	movs	r2, #0
 800e272:	669a      	str	r2, [r3, #104]	@ 0x68
 800e274:	e002      	b.n	800e27c <_fx_media_open+0x7e4>
        }
        else
        {

            /* IO error trying to read additional information sector, invalidate the additional info sector.  */
            media_ptr -> fx_media_FAT32_additional_info_sector =  0;
 800e276:	68fb      	ldr	r3, [r7, #12]
 800e278:	2200      	movs	r2, #0
 800e27a:	669a      	str	r2, [r3, #104]	@ 0x68

    /* Search the media to find the first available cluster as well as the total
       available clusters.  */

    /* Determine what type of FAT is present.  */
    if (media_ptr -> fx_media_12_bit_FAT)
 800e27c:	68fb      	ldr	r3, [r7, #12]
 800e27e:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 800e280:	2b00      	cmp	r3, #0
 800e282:	d040      	beq.n	800e306 <_fx_media_open+0x86e>

        /* A 12-bit FAT is present.  Utilize the FAT entry read utility to pickup
           each FAT entry's contents.  */

        /* Loop to read each cluster entry in the first FAT.  */
        for (cluster_number =  FX_FAT_ENTRY_START;
 800e284:	2302      	movs	r3, #2
 800e286:	647b      	str	r3, [r7, #68]	@ 0x44
 800e288:	e036      	b.n	800e2f8 <_fx_media_open+0x860>
             cluster_number < (media_ptr -> fx_media_total_clusters) + FX_FAT_ENTRY_START;
             cluster_number++)
        {

            /* Read a FAT entry.  */
            status =  _fx_utility_FAT_entry_read(media_ptr, cluster_number, &FAT_entry);
 800e28a:	f107 0310 	add.w	r3, r7, #16
 800e28e:	461a      	mov	r2, r3
 800e290:	6c79      	ldr	r1, [r7, #68]	@ 0x44
 800e292:	68f8      	ldr	r0, [r7, #12]
 800e294:	f000 fb84 	bl	800e9a0 <_fx_utility_FAT_entry_read>
 800e298:	62b8      	str	r0, [r7, #40]	@ 0x28

            /* Determine if the read was successful.  */
            if (status != FX_SUCCESS)
 800e29a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800e29c:	2b00      	cmp	r3, #0
 800e29e:	d017      	beq.n	800e2d0 <_fx_media_open+0x838>
            {

                /* Build the "uninitialize" I/O driver request.  */
                media_ptr -> fx_media_driver_request =      FX_DRIVER_UNINIT;
 800e2a0:	68fb      	ldr	r3, [r7, #12]
 800e2a2:	2208      	movs	r2, #8
 800e2a4:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
                media_ptr -> fx_media_driver_status =       FX_IO_ERROR;
 800e2a8:	68fb      	ldr	r3, [r7, #12]
 800e2aa:	2290      	movs	r2, #144	@ 0x90
 800e2ac:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c

                /* If trace is enabled, insert this event into the trace buffer.  */
                FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_UNINIT, media_ptr, 0, 0, 0, FX_TRACE_INTERNAL_EVENTS, 0, 0)

                /* Call the specified I/O driver with the uninitialize request.  */
                (media_ptr -> fx_media_driver_entry) (media_ptr);
 800e2b0:	68fb      	ldr	r3, [r7, #12]
 800e2b2:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
 800e2b6:	68f8      	ldr	r0, [r7, #12]
 800e2b8:	4798      	blx	r3

                return(FX_FAT_READ_ERROR);
 800e2ba:	2303      	movs	r3, #3
 800e2bc:	e142      	b.n	800e544 <_fx_media_open+0xaac>
 800e2be:	bf00      	nop
 800e2c0:	0ffffff0 	.word	0x0ffffff0
 800e2c4:	0fffffef 	.word	0x0fffffef
 800e2c8:	41615252 	.word	0x41615252
 800e2cc:	61417272 	.word	0x61417272
            }

            /* Now determine if the FAT entry is available.  */
            if (FAT_entry == FX_FREE_CLUSTER)
 800e2d0:	693b      	ldr	r3, [r7, #16]
 800e2d2:	2b00      	cmp	r3, #0
 800e2d4:	d10d      	bne.n	800e2f2 <_fx_media_open+0x85a>
            {

                /* Increment the number of available clusters.  */
                media_ptr -> fx_media_available_clusters++;
 800e2d6:	68fb      	ldr	r3, [r7, #12]
 800e2d8:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
 800e2da:	1c5a      	adds	r2, r3, #1
 800e2dc:	68fb      	ldr	r3, [r7, #12]
 800e2de:	67da      	str	r2, [r3, #124]	@ 0x7c

                /* Determine if the starting free cluster has been found yet.  */
                if (media_ptr -> fx_media_cluster_search_start == 0)
 800e2e0:	68fb      	ldr	r3, [r7, #12]
 800e2e2:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 800e2e6:	2b00      	cmp	r3, #0
 800e2e8:	d103      	bne.n	800e2f2 <_fx_media_open+0x85a>
                {

                    /* Remember the first free cluster to start further searches from.  */
                    media_ptr -> fx_media_cluster_search_start =  cluster_number;
 800e2ea:	68fb      	ldr	r3, [r7, #12]
 800e2ec:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 800e2ee:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
             cluster_number++)
 800e2f2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800e2f4:	3301      	adds	r3, #1
 800e2f6:	647b      	str	r3, [r7, #68]	@ 0x44
             cluster_number < (media_ptr -> fx_media_total_clusters) + FX_FAT_ENTRY_START;
 800e2f8:	68fb      	ldr	r3, [r7, #12]
 800e2fa:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800e2fc:	3302      	adds	r3, #2
 800e2fe:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 800e300:	429a      	cmp	r2, r3
 800e302:	d3c2      	bcc.n	800e28a <_fx_media_open+0x7f2>
 800e304:	e0b4      	b.n	800e470 <_fx_media_open+0x9d8>
    }
#ifdef FX_ENABLE_EXFAT
    else if ((media_ptr -> fx_media_available_clusters == 0)
             && (media_ptr -> fx_media_FAT_type != FX_exFAT))
#else
    else if (media_ptr -> fx_media_available_clusters == 0)
 800e306:	68fb      	ldr	r3, [r7, #12]
 800e308:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
 800e30a:	2b00      	cmp	r3, #0
 800e30c:	f040 80b0 	bne.w	800e470 <_fx_media_open+0x9d8>
        /* A 16 or 32-bit FAT is present. Read directly into the logical sector
           cache memory to optimize I/O on larger devices. Since we are looking for
           values of zero, endian issues are not important.  */

        /* Invalidate the current logical sector cache.  */
        _fx_utility_logical_sector_flush(media_ptr, ((ULONG64) 1), (ULONG64) (media_ptr -> fx_media_total_sectors), FX_TRUE);
 800e310:	68fb      	ldr	r3, [r7, #12]
 800e312:	e9d3 230e 	ldrd	r2, r3, [r3, #56]	@ 0x38
 800e316:	2101      	movs	r1, #1
 800e318:	9102      	str	r1, [sp, #8]
 800e31a:	e9cd 2300 	strd	r2, r3, [sp]
 800e31e:	f04f 0201 	mov.w	r2, #1
 800e322:	f04f 0300 	mov.w	r3, #0
 800e326:	68f8      	ldr	r0, [r7, #12]
 800e328:	f001 fd32 	bl	800fd90 <_fx_utility_logical_sector_flush>

        /* Reset the memory pointer.  */
        media_ptr -> fx_media_memory_buffer =  original_memory_ptr;
 800e32c:	68fb      	ldr	r3, [r7, #12]
 800e32e:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 800e330:	609a      	str	r2, [r3, #8]

        /* Loop through all FAT sectors in the primary FAT.  The first two entries are
           examined in this loop, but they are always unavailable.  */
        cluster_number =  0;
 800e332:	2300      	movs	r3, #0
 800e334:	647b      	str	r3, [r7, #68]	@ 0x44
#ifndef FX_DISABLE_CACHE
        for (i = 0; i < media_ptr -> fx_media_sectors_per_FAT; i = i + media_ptr -> fx_media_sector_cache_size)
 800e336:	2300      	movs	r3, #0
 800e338:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800e33a:	e093      	b.n	800e464 <_fx_media_open+0x9cc>
        {

            /* Calculate the starting next FAT sector.  */
            FAT_sector =  media_ptr -> fx_media_reserved_sectors + i;
 800e33c:	68fb      	ldr	r3, [r7, #12]
 800e33e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800e340:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 800e342:	4413      	add	r3, r2
 800e344:	61fb      	str	r3, [r7, #28]

            /* Calculate how many sectors to read.  */
            FAT_read_sectors =  media_ptr -> fx_media_sectors_per_FAT - i;
 800e346:	68fb      	ldr	r3, [r7, #12]
 800e348:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
 800e34a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800e34c:	1ad3      	subs	r3, r2, r3
 800e34e:	643b      	str	r3, [r7, #64]	@ 0x40

            /* Determine if there is not enough memory to read the remaining FAT sectors.  */
            if (FAT_read_sectors > media_ptr -> fx_media_sector_cache_size)
 800e350:	68fb      	ldr	r3, [r7, #12]
 800e352:	695b      	ldr	r3, [r3, #20]
 800e354:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800e356:	429a      	cmp	r2, r3
 800e358:	d902      	bls.n	800e360 <_fx_media_open+0x8c8>
            {
                FAT_read_sectors =  media_ptr -> fx_media_sector_cache_size;
 800e35a:	68fb      	ldr	r3, [r7, #12]
 800e35c:	695b      	ldr	r3, [r3, #20]
 800e35e:	643b      	str	r3, [r7, #64]	@ 0x40
            /* Calculate how many sectors to read.  */
            FAT_read_sectors =  1;
#endif /* FX_DISABLE_CACHE */

            /* Read the FAT sectors directly from the driver.  */
            media_ptr -> fx_media_driver_request =          FX_DRIVER_READ;
 800e360:	68fb      	ldr	r3, [r7, #12]
 800e362:	2200      	movs	r2, #0
 800e364:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
            media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 800e368:	68fb      	ldr	r3, [r7, #12]
 800e36a:	2290      	movs	r2, #144	@ 0x90
 800e36c:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
            media_ptr -> fx_media_driver_buffer =           media_ptr -> fx_media_memory_buffer;
 800e370:	68fb      	ldr	r3, [r7, #12]
 800e372:	689a      	ldr	r2, [r3, #8]
 800e374:	68fb      	ldr	r3, [r7, #12]
 800e376:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
            media_ptr -> fx_media_driver_logical_sector =   FAT_sector;
 800e37a:	68fb      	ldr	r3, [r7, #12]
 800e37c:	69fa      	ldr	r2, [r7, #28]
 800e37e:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
            media_ptr -> fx_media_driver_sectors =          FAT_read_sectors;
 800e382:	68fb      	ldr	r3, [r7, #12]
 800e384:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800e386:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98
            media_ptr -> fx_media_driver_sector_type =      FX_FAT_SECTOR;
 800e38a:	68fb      	ldr	r3, [r7, #12]
 800e38c:	2202      	movs	r2, #2
 800e38e:	f8c3 20b8 	str.w	r2, [r3, #184]	@ 0xb8

            /* If trace is enabled, insert this event into the trace buffer.  */
            FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_READ, media_ptr, FAT_sector, FAT_read_sectors, media_ptr -> fx_media_memory_buffer, FX_TRACE_INTERNAL_EVENTS, 0, 0)

            /* Invoke the driver to read the FAT sectors.  */
            (media_ptr -> fx_media_driver_entry) (media_ptr);
 800e392:	68fb      	ldr	r3, [r7, #12]
 800e394:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
 800e398:	68f8      	ldr	r0, [r7, #12]
 800e39a:	4798      	blx	r3

            /* Determine if the read was successful.  */
            if (media_ptr -> fx_media_driver_status != FX_SUCCESS)
 800e39c:	68fb      	ldr	r3, [r7, #12]
 800e39e:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800e3a2:	2b00      	cmp	r3, #0
 800e3a4:	d00e      	beq.n	800e3c4 <_fx_media_open+0x92c>
            {

                /* Build the "uninitialize" I/O driver request.  */
                media_ptr -> fx_media_driver_request =      FX_DRIVER_UNINIT;
 800e3a6:	68fb      	ldr	r3, [r7, #12]
 800e3a8:	2208      	movs	r2, #8
 800e3aa:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
                media_ptr -> fx_media_driver_status =       FX_IO_ERROR;
 800e3ae:	68fb      	ldr	r3, [r7, #12]
 800e3b0:	2290      	movs	r2, #144	@ 0x90
 800e3b2:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c

                /* If trace is enabled, insert this event into the trace buffer.  */
                FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_UNINIT, media_ptr, 0, 0, 0, FX_TRACE_INTERNAL_EVENTS, 0, 0)

                /* Call the specified I/O driver with the uninitialize request.  */
                (media_ptr -> fx_media_driver_entry) (media_ptr);
 800e3b6:	68fb      	ldr	r3, [r7, #12]
 800e3b8:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
 800e3bc:	68f8      	ldr	r0, [r7, #12]
 800e3be:	4798      	blx	r3

                return(FX_FAT_READ_ERROR);
 800e3c0:	2303      	movs	r3, #3
 800e3c2:	e0bf      	b.n	800e544 <_fx_media_open+0xaac>
            }

            /* Calculate the number of bytes in the buffer.  */
            bytes_in_buffer =  (media_ptr -> fx_media_bytes_per_sector * FAT_read_sectors);
 800e3c4:	68fb      	ldr	r3, [r7, #12]
 800e3c6:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 800e3c8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800e3ca:	fb02 f303 	mul.w	r3, r2, r3
 800e3ce:	61bb      	str	r3, [r7, #24]

            /* Walk through the sector cache memory to search for available clusters and the first
               available if not already found.  */
            for (j = 0; j < bytes_in_buffer;)
 800e3d0:	2300      	movs	r3, #0
 800e3d2:	63bb      	str	r3, [r7, #56]	@ 0x38
 800e3d4:	e03d      	b.n	800e452 <_fx_media_open+0x9ba>
            {

                /* Check for a 32-bit FAT.  */
                if (media_ptr -> fx_media_32_bit_FAT)
 800e3d6:	68fb      	ldr	r3, [r7, #12]
 800e3d8:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 800e3da:	2b00      	cmp	r3, #0
 800e3dc:	d009      	beq.n	800e3f2 <_fx_media_open+0x95a>
                {

                    /* Pickup 32-bit FAT entry.  */
                    FAT_entry =  *((ULONG *)&(media_ptr -> fx_media_memory_buffer[j]));
 800e3de:	68fb      	ldr	r3, [r7, #12]
 800e3e0:	689a      	ldr	r2, [r3, #8]
 800e3e2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800e3e4:	4413      	add	r3, r2
 800e3e6:	681b      	ldr	r3, [r3, #0]
 800e3e8:	613b      	str	r3, [r7, #16]

                    /* Advance to next FAT entry.  */
                    j = j + 4;
 800e3ea:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800e3ec:	3304      	adds	r3, #4
 800e3ee:	63bb      	str	r3, [r7, #56]	@ 0x38
 800e3f0:	e011      	b.n	800e416 <_fx_media_open+0x97e>
                }
                else
                {

                    /* Process a 16-bit FAT entry.  */
                    FAT_entry =  (((ULONG)(media_ptr -> fx_media_memory_buffer[j])) & 0xFF) |
 800e3f2:	68fb      	ldr	r3, [r7, #12]
 800e3f4:	689a      	ldr	r2, [r3, #8]
 800e3f6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800e3f8:	4413      	add	r3, r2
 800e3fa:	781b      	ldrb	r3, [r3, #0]
 800e3fc:	4619      	mov	r1, r3
                        ((((ULONG)(media_ptr -> fx_media_memory_buffer[j + 1])) & 0xFF) << 8);
 800e3fe:	68fb      	ldr	r3, [r7, #12]
 800e400:	689a      	ldr	r2, [r3, #8]
 800e402:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800e404:	3301      	adds	r3, #1
 800e406:	4413      	add	r3, r2
 800e408:	781b      	ldrb	r3, [r3, #0]
 800e40a:	021b      	lsls	r3, r3, #8
                    FAT_entry =  (((ULONG)(media_ptr -> fx_media_memory_buffer[j])) & 0xFF) |
 800e40c:	430b      	orrs	r3, r1
 800e40e:	613b      	str	r3, [r7, #16]

                    /* Advance to next FAT entry.  */
                    j =  j + 2;
 800e410:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800e412:	3302      	adds	r3, #2
 800e414:	63bb      	str	r3, [r7, #56]	@ 0x38
                }

                /* Determine if the FAT entry is free.  */
                if (FAT_entry == FX_FREE_CLUSTER)
 800e416:	693b      	ldr	r3, [r7, #16]
 800e418:	2b00      	cmp	r3, #0
 800e41a:	d10d      	bne.n	800e438 <_fx_media_open+0x9a0>
                {

                    /* Entry is free, increment available clusters.  */
                    media_ptr -> fx_media_available_clusters++;
 800e41c:	68fb      	ldr	r3, [r7, #12]
 800e41e:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
 800e420:	1c5a      	adds	r2, r3, #1
 800e422:	68fb      	ldr	r3, [r7, #12]
 800e424:	67da      	str	r2, [r3, #124]	@ 0x7c

                    /* Determine if the starting free cluster has been found yet.  */
                    if (media_ptr -> fx_media_cluster_search_start == 0)
 800e426:	68fb      	ldr	r3, [r7, #12]
 800e428:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 800e42c:	2b00      	cmp	r3, #0
 800e42e:	d103      	bne.n	800e438 <_fx_media_open+0x9a0>
                    {

                        /* Remember the first free cluster to start further searches from.  */
                        media_ptr -> fx_media_cluster_search_start =  cluster_number;
 800e430:	68fb      	ldr	r3, [r7, #12]
 800e432:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 800e434:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
                    }
                }

                /* Increment the cluster number.  */
                cluster_number++;
 800e438:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800e43a:	3301      	adds	r3, #1
 800e43c:	647b      	str	r3, [r7, #68]	@ 0x44

                /* Determine if we have reviewed all FAT entries.  */
                if (cluster_number >= (media_ptr -> fx_media_total_clusters + FX_FAT_ENTRY_START))
 800e43e:	68fb      	ldr	r3, [r7, #12]
 800e440:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800e442:	3302      	adds	r3, #2
 800e444:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 800e446:	429a      	cmp	r2, r3
 800e448:	d303      	bcc.n	800e452 <_fx_media_open+0x9ba>
                {

                    /* Yes, we have looked at all the FAT entries.  */

                    /* Ensure that the outer loop terminates as well.  */
                    i = media_ptr -> fx_media_sectors_per_FAT;
 800e44a:	68fb      	ldr	r3, [r7, #12]
 800e44c:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800e44e:	63fb      	str	r3, [r7, #60]	@ 0x3c
                    break;
 800e450:	e003      	b.n	800e45a <_fx_media_open+0x9c2>
            for (j = 0; j < bytes_in_buffer;)
 800e452:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 800e454:	69bb      	ldr	r3, [r7, #24]
 800e456:	429a      	cmp	r2, r3
 800e458:	d3bd      	bcc.n	800e3d6 <_fx_media_open+0x93e>
        for (i = 0; i < media_ptr -> fx_media_sectors_per_FAT; i = i + media_ptr -> fx_media_sector_cache_size)
 800e45a:	68fb      	ldr	r3, [r7, #12]
 800e45c:	695b      	ldr	r3, [r3, #20]
 800e45e:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 800e460:	4413      	add	r3, r2
 800e462:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800e464:	68fb      	ldr	r3, [r7, #12]
 800e466:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800e468:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 800e46a:	429a      	cmp	r2, r3
 800e46c:	f4ff af66 	bcc.w	800e33c <_fx_media_open+0x8a4>
    }
#endif /* FX_ENABLE_EXFAT */

    /* If there were no free clusters, just set the search pointer to the
       first cluster number.  */
    if (media_ptr -> fx_media_cluster_search_start == 0)
 800e470:	68fb      	ldr	r3, [r7, #12]
 800e472:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 800e476:	2b00      	cmp	r3, #0
 800e478:	d103      	bne.n	800e482 <_fx_media_open+0x9ea>
    {
        media_ptr -> fx_media_cluster_search_start =  FX_FAT_ENTRY_START;
 800e47a:	68fb      	ldr	r3, [r7, #12]
 800e47c:	2202      	movs	r2, #2
 800e47e:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
    }

    /* Setup the current working directory fields to default to the root
       directory.  */
    media_ptr -> fx_media_default_path.fx_path_directory.fx_dir_entry_name =
        media_ptr -> fx_media_default_path.fx_path_name_buffer;
 800e482:	68fb      	ldr	r3, [r7, #12]
 800e484:	f503 62c4 	add.w	r2, r3, #1568	@ 0x620
    media_ptr -> fx_media_default_path.fx_path_directory.fx_dir_entry_name =
 800e488:	68fb      	ldr	r3, [r7, #12]
 800e48a:	f8c3 24b0 	str.w	r2, [r3, #1200]	@ 0x4b0
    media_ptr -> fx_media_default_path.fx_path_directory.fx_dir_entry_short_name[0] =  0;
 800e48e:	68fb      	ldr	r3, [r7, #12]
 800e490:	2200      	movs	r2, #0
 800e492:	f883 24b4 	strb.w	r2, [r3, #1204]	@ 0x4b4
    media_ptr -> fx_media_default_path.fx_path_directory.fx_dir_entry_name[0] =        0;
 800e496:	68fb      	ldr	r3, [r7, #12]
 800e498:	f8d3 34b0 	ldr.w	r3, [r3, #1200]	@ 0x4b0
 800e49c:	2200      	movs	r2, #0
 800e49e:	701a      	strb	r2, [r3, #0]
    media_ptr -> fx_media_default_path.fx_path_string[0] =                      (CHAR)0;
 800e4a0:	68fb      	ldr	r3, [r7, #12]
 800e4a2:	2200      	movs	r2, #0
 800e4a4:	f883 2520 	strb.w	r2, [r3, #1312]	@ 0x520
    media_ptr -> fx_media_default_path.fx_path_string[FX_MAXIMUM_PATH - 1] =      (CHAR)0;
 800e4a8:	68fb      	ldr	r3, [r7, #12]
 800e4aa:	2200      	movs	r2, #0
 800e4ac:	f883 261f 	strb.w	r2, [r3, #1567]	@ 0x61f
    media_ptr -> fx_media_default_path.fx_path_current_entry =                         0;
 800e4b0:	68fb      	ldr	r3, [r7, #12]
 800e4b2:	2200      	movs	r2, #0
 800e4b4:	f8c3 2720 	str.w	r2, [r3, #1824]	@ 0x720

#ifndef FX_MEDIA_DISABLE_SEARCH_CACHE

    /* Invalidate the previously found directory entry.  */
    media_ptr -> fx_media_last_found_name[0] =  0;
 800e4b8:	68fb      	ldr	r3, [r7, #12]
 800e4ba:	2200      	movs	r2, #0
 800e4bc:	f883 23b0 	strb.w	r2, [r3, #944]	@ 0x3b0
#endif

#ifndef FX_DISABLE_FORCE_MEMORY_OPERATION
    /* Initialize the opened file linked list and associated counter.  */
    media_ptr -> fx_media_opened_file_list =      FX_NULL;
 800e4c0:	68fb      	ldr	r3, [r7, #12]
 800e4c2:	2200      	movs	r2, #0
 800e4c4:	f8c3 20c8 	str.w	r2, [r3, #200]	@ 0xc8
    media_ptr -> fx_media_opened_file_count =     0;
 800e4c8:	68fb      	ldr	r3, [r7, #12]
 800e4ca:	2200      	movs	r2, #0
 800e4cc:	f8c3 20cc 	str.w	r2, [r3, #204]	@ 0xcc

    /* At this point, the media has been opened successfully.  Place the
       media on the linked list of currently opened media.  */

    /* Load the media ID field in the media control block.  */
    media_ptr -> fx_media_id =  (ULONG)FX_MEDIA_ID;
 800e4d0:	68fb      	ldr	r3, [r7, #12]
 800e4d2:	4a1f      	ldr	r2, [pc, #124]	@ (800e550 <_fx_media_open+0xab8>)
 800e4d4:	601a      	str	r2, [r3, #0]

    /* Place the thread on the list of opened media.  First,
       check for an empty list.  */
    if (_fx_system_media_opened_ptr)
 800e4d6:	4b1f      	ldr	r3, [pc, #124]	@ (800e554 <_fx_media_open+0xabc>)
 800e4d8:	681b      	ldr	r3, [r3, #0]
 800e4da:	2b00      	cmp	r3, #0
 800e4dc:	d017      	beq.n	800e50e <_fx_media_open+0xa76>
    {

        /* Pickup tail pointer.  */
        tail_ptr =  _fx_system_media_opened_ptr -> fx_media_opened_previous;
 800e4de:	4b1d      	ldr	r3, [pc, #116]	@ (800e554 <_fx_media_open+0xabc>)
 800e4e0:	681b      	ldr	r3, [r3, #0]
 800e4e2:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
 800e4e6:	617b      	str	r3, [r7, #20]

        /* Place the new media in the list.  */
        _fx_system_media_opened_ptr -> fx_media_opened_previous =  media_ptr;
 800e4e8:	4b1a      	ldr	r3, [pc, #104]	@ (800e554 <_fx_media_open+0xabc>)
 800e4ea:	681b      	ldr	r3, [r3, #0]
 800e4ec:	68fa      	ldr	r2, [r7, #12]
 800e4ee:	f8c3 20d4 	str.w	r2, [r3, #212]	@ 0xd4
        tail_ptr -> fx_media_opened_next =  media_ptr;
 800e4f2:	697b      	ldr	r3, [r7, #20]
 800e4f4:	68fa      	ldr	r2, [r7, #12]
 800e4f6:	f8c3 20d0 	str.w	r2, [r3, #208]	@ 0xd0

        /* Setup this media's opened links.  */
        media_ptr -> fx_media_opened_previous =  tail_ptr;
 800e4fa:	68fb      	ldr	r3, [r7, #12]
 800e4fc:	697a      	ldr	r2, [r7, #20]
 800e4fe:	f8c3 20d4 	str.w	r2, [r3, #212]	@ 0xd4
        media_ptr -> fx_media_opened_next =      _fx_system_media_opened_ptr;
 800e502:	4b14      	ldr	r3, [pc, #80]	@ (800e554 <_fx_media_open+0xabc>)
 800e504:	681a      	ldr	r2, [r3, #0]
 800e506:	68fb      	ldr	r3, [r7, #12]
 800e508:	f8c3 20d0 	str.w	r2, [r3, #208]	@ 0xd0
 800e50c:	e00a      	b.n	800e524 <_fx_media_open+0xa8c>
    }
    else
    {

        /* The opened media list is empty.  Add the media to empty list.  */
        _fx_system_media_opened_ptr =           media_ptr;
 800e50e:	4a11      	ldr	r2, [pc, #68]	@ (800e554 <_fx_media_open+0xabc>)
 800e510:	68fb      	ldr	r3, [r7, #12]
 800e512:	6013      	str	r3, [r2, #0]
        media_ptr -> fx_media_opened_next =     media_ptr;
 800e514:	68fb      	ldr	r3, [r7, #12]
 800e516:	68fa      	ldr	r2, [r7, #12]
 800e518:	f8c3 20d0 	str.w	r2, [r3, #208]	@ 0xd0
        media_ptr -> fx_media_opened_previous = media_ptr;
 800e51c:	68fb      	ldr	r3, [r7, #12]
 800e51e:	68fa      	ldr	r2, [r7, #12]
 800e520:	f8c3 20d4 	str.w	r2, [r3, #212]	@ 0xd4
    }

    /* Increment the opened media counter.  */
    _fx_system_media_opened_count++;
 800e524:	4b0c      	ldr	r3, [pc, #48]	@ (800e558 <_fx_media_open+0xac0>)
 800e526:	681b      	ldr	r3, [r3, #0]
 800e528:	3301      	adds	r3, #1
 800e52a:	4a0b      	ldr	r2, [pc, #44]	@ (800e558 <_fx_media_open+0xac0>)
 800e52c:	6013      	str	r3, [r2, #0]

    /* Invoke media open callback. */
    if (media_ptr -> fx_media_open_notify)
 800e52e:	68fb      	ldr	r3, [r7, #12]
 800e530:	f8d3 30c0 	ldr.w	r3, [r3, #192]	@ 0xc0
 800e534:	2b00      	cmp	r3, #0
 800e536:	d004      	beq.n	800e542 <_fx_media_open+0xaaa>
    {
        media_ptr -> fx_media_open_notify(media_ptr);
 800e538:	68fb      	ldr	r3, [r7, #12]
 800e53a:	f8d3 30c0 	ldr.w	r3, [r3, #192]	@ 0xc0
 800e53e:	68f8      	ldr	r0, [r7, #12]
 800e540:	4798      	blx	r3
    /* Release media protection.  */
    FX_UNPROTECT
#endif

    /* Return a successful status.  */
    return(FX_SUCCESS);
 800e542:	2300      	movs	r3, #0
}
 800e544:	4618      	mov	r0, r3
 800e546:	3748      	adds	r7, #72	@ 0x48
 800e548:	46bd      	mov	sp, r7
 800e54a:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 800e54e:	bf00      	nop
 800e550:	4d454449 	.word	0x4d454449
 800e554:	20002c8c 	.word	0x20002c8c
 800e558:	20002c90 	.word	0x20002c90

0800e55c <_fx_partition_offset_calculate>:
/*                                            resulting in version 6.1.6  */
/*                                                                        */
/**************************************************************************/
UINT  _fx_partition_offset_calculate(void  *partition_sector, UINT partition,
                                     ULONG *partition_start, ULONG *partition_size)
{
 800e55c:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 800e560:	b090      	sub	sp, #64	@ 0x40
 800e562:	af00      	add	r7, sp, #0
 800e564:	60f8      	str	r0, [r7, #12]
 800e566:	60b9      	str	r1, [r7, #8]
 800e568:	607a      	str	r2, [r7, #4]
 800e56a:	603b      	str	r3, [r7, #0]
ULONG64             total_sectors;
UCHAR               *partition_sector_ptr;


    /* Setup working pointer and initialize count.  */
    partition_sector_ptr =  partition_sector;
 800e56c:	68fb      	ldr	r3, [r7, #12]
 800e56e:	637b      	str	r3, [r7, #52]	@ 0x34
    count =  0;
 800e570:	2300      	movs	r3, #0
 800e572:	613b      	str	r3, [r7, #16]

    /* Check for a real boot sector instead of a partition table.  */
    if ((partition_sector_ptr[0] == 0xe9) || ((partition_sector_ptr[0] == 0xeb) && (partition_sector_ptr[2] == 0x90)))    
 800e574:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800e576:	781b      	ldrb	r3, [r3, #0]
 800e578:	2be9      	cmp	r3, #233	@ 0xe9
 800e57a:	d008      	beq.n	800e58e <_fx_partition_offset_calculate+0x32>
 800e57c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800e57e:	781b      	ldrb	r3, [r3, #0]
 800e580:	2beb      	cmp	r3, #235	@ 0xeb
 800e582:	d17d      	bne.n	800e680 <_fx_partition_offset_calculate+0x124>
 800e584:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800e586:	3302      	adds	r3, #2
 800e588:	781b      	ldrb	r3, [r3, #0]
 800e58a:	2b90      	cmp	r3, #144	@ 0x90
 800e58c:	d178      	bne.n	800e680 <_fx_partition_offset_calculate+0x124>
    {
    
        /* Yes, a real boot sector could be present.  */  

        /* See if there are good values for sectors per FAT.  */
        if (partition_sector_ptr[0x16] || partition_sector_ptr[0x17] || partition_sector_ptr[0x24] || partition_sector_ptr[0x25] || partition_sector_ptr[0x26] || partition_sector_ptr[0x27])
 800e58e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800e590:	3316      	adds	r3, #22
 800e592:	781b      	ldrb	r3, [r3, #0]
 800e594:	2b00      	cmp	r3, #0
 800e596:	d118      	bne.n	800e5ca <_fx_partition_offset_calculate+0x6e>
 800e598:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800e59a:	3317      	adds	r3, #23
 800e59c:	781b      	ldrb	r3, [r3, #0]
 800e59e:	2b00      	cmp	r3, #0
 800e5a0:	d113      	bne.n	800e5ca <_fx_partition_offset_calculate+0x6e>
 800e5a2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800e5a4:	3324      	adds	r3, #36	@ 0x24
 800e5a6:	781b      	ldrb	r3, [r3, #0]
 800e5a8:	2b00      	cmp	r3, #0
 800e5aa:	d10e      	bne.n	800e5ca <_fx_partition_offset_calculate+0x6e>
 800e5ac:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800e5ae:	3325      	adds	r3, #37	@ 0x25
 800e5b0:	781b      	ldrb	r3, [r3, #0]
 800e5b2:	2b00      	cmp	r3, #0
 800e5b4:	d109      	bne.n	800e5ca <_fx_partition_offset_calculate+0x6e>
 800e5b6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800e5b8:	3326      	adds	r3, #38	@ 0x26
 800e5ba:	781b      	ldrb	r3, [r3, #0]
 800e5bc:	2b00      	cmp	r3, #0
 800e5be:	d104      	bne.n	800e5ca <_fx_partition_offset_calculate+0x6e>
 800e5c0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800e5c2:	3327      	adds	r3, #39	@ 0x27
 800e5c4:	781b      	ldrb	r3, [r3, #0]
 800e5c6:	2b00      	cmp	r3, #0
 800e5c8:	d05a      	beq.n	800e680 <_fx_partition_offset_calculate+0x124>
        {

            /* There are values for sectors per FAT.  */

            /* Determine if there is a total sector count.  */
            total_sectors =  0;
 800e5ca:	f04f 0200 	mov.w	r2, #0
 800e5ce:	f04f 0300 	mov.w	r3, #0
 800e5d2:	e9c7 230e 	strd	r2, r3, [r7, #56]	@ 0x38

            if (partition_sector_ptr[0x13] || partition_sector_ptr[0x14])
 800e5d6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800e5d8:	3313      	adds	r3, #19
 800e5da:	781b      	ldrb	r3, [r3, #0]
 800e5dc:	2b00      	cmp	r3, #0
 800e5de:	d104      	bne.n	800e5ea <_fx_partition_offset_calculate+0x8e>
 800e5e0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800e5e2:	3314      	adds	r3, #20
 800e5e4:	781b      	ldrb	r3, [r3, #0]
 800e5e6:	2b00      	cmp	r3, #0
 800e5e8:	d00d      	beq.n	800e606 <_fx_partition_offset_calculate+0xaa>
            {

                /* Calculate the total sectors, FAT12/16.  */
                total_sectors =  (((ULONG) partition_sector_ptr[0x14]) << 8) | ((ULONG) partition_sector_ptr[0x13]);
 800e5ea:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800e5ec:	3314      	adds	r3, #20
 800e5ee:	781b      	ldrb	r3, [r3, #0]
 800e5f0:	021b      	lsls	r3, r3, #8
 800e5f2:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 800e5f4:	3213      	adds	r2, #19
 800e5f6:	7812      	ldrb	r2, [r2, #0]
 800e5f8:	4313      	orrs	r3, r2
 800e5fa:	2200      	movs	r2, #0
 800e5fc:	4698      	mov	r8, r3
 800e5fe:	4691      	mov	r9, r2
 800e600:	e9c7 890e 	strd	r8, r9, [r7, #56]	@ 0x38
 800e604:	e02a      	b.n	800e65c <_fx_partition_offset_calculate+0x100>
            }
            else if (partition_sector_ptr[0x20] || partition_sector_ptr[0x21] || partition_sector_ptr[0x22] || partition_sector_ptr[0x23])
 800e606:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800e608:	3320      	adds	r3, #32
 800e60a:	781b      	ldrb	r3, [r3, #0]
 800e60c:	2b00      	cmp	r3, #0
 800e60e:	d10e      	bne.n	800e62e <_fx_partition_offset_calculate+0xd2>
 800e610:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800e612:	3321      	adds	r3, #33	@ 0x21
 800e614:	781b      	ldrb	r3, [r3, #0]
 800e616:	2b00      	cmp	r3, #0
 800e618:	d109      	bne.n	800e62e <_fx_partition_offset_calculate+0xd2>
 800e61a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800e61c:	3322      	adds	r3, #34	@ 0x22
 800e61e:	781b      	ldrb	r3, [r3, #0]
 800e620:	2b00      	cmp	r3, #0
 800e622:	d104      	bne.n	800e62e <_fx_partition_offset_calculate+0xd2>
 800e624:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800e626:	3323      	adds	r3, #35	@ 0x23
 800e628:	781b      	ldrb	r3, [r3, #0]
 800e62a:	2b00      	cmp	r3, #0
 800e62c:	d016      	beq.n	800e65c <_fx_partition_offset_calculate+0x100>
            {

                /* Calculate the total sectors, FAT32.  */
                total_sectors =  (((ULONG) partition_sector_ptr[0x23]) << 24) | 
 800e62e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800e630:	3323      	adds	r3, #35	@ 0x23
 800e632:	781b      	ldrb	r3, [r3, #0]
 800e634:	061a      	lsls	r2, r3, #24
                                 (((ULONG) partition_sector_ptr[0x22]) << 16) |
 800e636:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800e638:	3322      	adds	r3, #34	@ 0x22
 800e63a:	781b      	ldrb	r3, [r3, #0]
 800e63c:	041b      	lsls	r3, r3, #16
                total_sectors =  (((ULONG) partition_sector_ptr[0x23]) << 24) | 
 800e63e:	431a      	orrs	r2, r3
                                 (((ULONG) partition_sector_ptr[0x21]) << 8)  |
 800e640:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800e642:	3321      	adds	r3, #33	@ 0x21
 800e644:	781b      	ldrb	r3, [r3, #0]
 800e646:	021b      	lsls	r3, r3, #8
                                 (((ULONG) partition_sector_ptr[0x22]) << 16) |
 800e648:	4313      	orrs	r3, r2
                                 ((ULONG) partition_sector_ptr[0x20]);
 800e64a:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 800e64c:	3220      	adds	r2, #32
 800e64e:	7812      	ldrb	r2, [r2, #0]
                                 (((ULONG) partition_sector_ptr[0x21]) << 8)  |
 800e650:	4313      	orrs	r3, r2
                total_sectors =  (((ULONG) partition_sector_ptr[0x23]) << 24) | 
 800e652:	2200      	movs	r2, #0
 800e654:	461c      	mov	r4, r3
 800e656:	4615      	mov	r5, r2
 800e658:	e9c7 450e 	strd	r4, r5, [r7, #56]	@ 0x38
            }       

            /* Determine if there is a total sector count.  */
            if (total_sectors)
 800e65c:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	@ 0x38
 800e660:	4313      	orrs	r3, r2
 800e662:	d00d      	beq.n	800e680 <_fx_partition_offset_calculate+0x124>
            {

                if (partition_start != FX_NULL)
 800e664:	687b      	ldr	r3, [r7, #4]
 800e666:	2b00      	cmp	r3, #0
 800e668:	d002      	beq.n	800e670 <_fx_partition_offset_calculate+0x114>
                {
                    /* Return an offset of 0, size of boot record, and a successful status.  */
                    *partition_start =  0;
 800e66a:	687b      	ldr	r3, [r7, #4]
 800e66c:	2200      	movs	r2, #0
 800e66e:	601a      	str	r2, [r3, #0]
                }

                /* Determine if the total sectors is required.  */
                if (partition_size != FX_NULL)
 800e670:	683b      	ldr	r3, [r7, #0]
 800e672:	2b00      	cmp	r3, #0
 800e674:	d002      	beq.n	800e67c <_fx_partition_offset_calculate+0x120>
                {

                    /* Return the total sectors.  */
                    *partition_size =  (ULONG)(total_sectors & 0xFFFFFFFF);
 800e676:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 800e678:	683b      	ldr	r3, [r7, #0]
 800e67a:	601a      	str	r2, [r3, #0]
                }

                /* Return success!  */
                return(FX_SUCCESS);
 800e67c:	2300      	movs	r3, #0
 800e67e:	e032      	b.n	800e6e6 <_fx_partition_offset_calculate+0x18a>
        }
#endif /* FX_ENABLE_EXFAT */
    }

    /* Check signature to make sure the buffer is valid.  */
    if ((partition_sector_ptr[510] != 0x55) || (partition_sector_ptr[511] != 0xAA))
 800e680:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800e682:	f503 73ff 	add.w	r3, r3, #510	@ 0x1fe
 800e686:	781b      	ldrb	r3, [r3, #0]
 800e688:	2b55      	cmp	r3, #85	@ 0x55
 800e68a:	d105      	bne.n	800e698 <_fx_partition_offset_calculate+0x13c>
 800e68c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800e68e:	f203 13ff 	addw	r3, r3, #511	@ 0x1ff
 800e692:	781b      	ldrb	r3, [r3, #0]
 800e694:	2baa      	cmp	r3, #170	@ 0xaa
 800e696:	d001      	beq.n	800e69c <_fx_partition_offset_calculate+0x140>
    {

        /* Invalid, return an error.  */
        return(FX_NOT_FOUND);
 800e698:	2304      	movs	r3, #4
 800e69a:	e024      	b.n	800e6e6 <_fx_partition_offset_calculate+0x18a>
    }
    
    /* Not bootable, look for specific partition.  */
    _fx_utility_partition_get(partition_table, &count, 0, partition_sector_ptr);
 800e69c:	f107 0110 	add.w	r1, r7, #16
 800e6a0:	f107 0014 	add.w	r0, r7, #20
 800e6a4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800e6a6:	2200      	movs	r2, #0
 800e6a8:	f000 f822 	bl	800e6f0 <_fx_utility_partition_get>

    /* Determine if return value is valid.  */
    if (partition >= count)
 800e6ac:	693b      	ldr	r3, [r7, #16]
 800e6ae:	68ba      	ldr	r2, [r7, #8]
 800e6b0:	429a      	cmp	r2, r3
 800e6b2:	d301      	bcc.n	800e6b8 <_fx_partition_offset_calculate+0x15c>
    {

        /* No, return an error.  */
        return(FX_NOT_FOUND);
 800e6b4:	2304      	movs	r3, #4
 800e6b6:	e016      	b.n	800e6e6 <_fx_partition_offset_calculate+0x18a>
    }

    /* Return the partition starting sector, if non-NULL.  */
    if (partition_start != FX_NULL)
 800e6b8:	687b      	ldr	r3, [r7, #4]
 800e6ba:	2b00      	cmp	r3, #0
 800e6bc:	d007      	beq.n	800e6ce <_fx_partition_offset_calculate+0x172>
    {
        *partition_start =  partition_table[partition].fx_media_part_start;
 800e6be:	68bb      	ldr	r3, [r7, #8]
 800e6c0:	00db      	lsls	r3, r3, #3
 800e6c2:	3340      	adds	r3, #64	@ 0x40
 800e6c4:	443b      	add	r3, r7
 800e6c6:	f853 2c2c 	ldr.w	r2, [r3, #-44]
 800e6ca:	687b      	ldr	r3, [r7, #4]
 800e6cc:	601a      	str	r2, [r3, #0]
    }

    /* Return the partition size, if non-NULL.  */
    if (partition_size != FX_NULL)
 800e6ce:	683b      	ldr	r3, [r7, #0]
 800e6d0:	2b00      	cmp	r3, #0
 800e6d2:	d007      	beq.n	800e6e4 <_fx_partition_offset_calculate+0x188>
    {
        *partition_size =  partition_table[partition].fx_media_part_size;
 800e6d4:	68bb      	ldr	r3, [r7, #8]
 800e6d6:	00db      	lsls	r3, r3, #3
 800e6d8:	3340      	adds	r3, #64	@ 0x40
 800e6da:	443b      	add	r3, r7
 800e6dc:	f853 2c28 	ldr.w	r2, [r3, #-40]
 800e6e0:	683b      	ldr	r3, [r7, #0]
 800e6e2:	601a      	str	r2, [r3, #0]
    }

    /* Return successful completion.  */
    return(FX_SUCCESS);
 800e6e4:	2300      	movs	r3, #0
}
 800e6e6:	4618      	mov	r0, r3
 800e6e8:	3740      	adds	r7, #64	@ 0x40
 800e6ea:	46bd      	mov	sp, r7
 800e6ec:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}

0800e6f0 <_fx_utility_partition_get>:
/*                                            resulting in version 6.1.6  */
/*                                                                        */
/**************************************************************************/
UINT  _fx_utility_partition_get(FX_MEDIA_PARTITION *partition_table, 
                                UINT *count, ULONG sector, UCHAR *sector_buffer)
{
 800e6f0:	b480      	push	{r7}
 800e6f2:	b089      	sub	sp, #36	@ 0x24
 800e6f4:	af00      	add	r7, sp, #0
 800e6f6:	60f8      	str	r0, [r7, #12]
 800e6f8:	60b9      	str	r1, [r7, #8]
 800e6fa:	607a      	str	r2, [r7, #4]
 800e6fc:	603b      	str	r3, [r7, #0]

    /* This parameter has not been supported yet. */
    FX_PARAMETER_NOT_USED(sector); 

    /* Initialize base sector.  */
    base_sector =  0;
 800e6fe:	2300      	movs	r3, #0
 800e700:	61bb      	str	r3, [r7, #24]

    for(i = 446; i <= 494; i+=16)
 800e702:	f44f 73df 	mov.w	r3, #446	@ 0x1be
 800e706:	61fb      	str	r3, [r7, #28]
 800e708:	e06f      	b.n	800e7ea <_fx_utility_partition_get+0xfa>
    {
        if (sector_buffer[i + 4] == 0) /* no partition entry here */
 800e70a:	69fb      	ldr	r3, [r7, #28]
 800e70c:	3304      	adds	r3, #4
 800e70e:	683a      	ldr	r2, [r7, #0]
 800e710:	4413      	add	r3, r2
 800e712:	781b      	ldrb	r3, [r3, #0]
 800e714:	2b00      	cmp	r3, #0
 800e716:	d10e      	bne.n	800e736 <_fx_utility_partition_get+0x46>
        {

            partition_table[*count].fx_media_part_start = 0;
 800e718:	68bb      	ldr	r3, [r7, #8]
 800e71a:	681b      	ldr	r3, [r3, #0]
 800e71c:	00db      	lsls	r3, r3, #3
 800e71e:	68fa      	ldr	r2, [r7, #12]
 800e720:	4413      	add	r3, r2
 800e722:	2200      	movs	r2, #0
 800e724:	601a      	str	r2, [r3, #0]
            partition_table[*count].fx_media_part_size  = 0;
 800e726:	68bb      	ldr	r3, [r7, #8]
 800e728:	681b      	ldr	r3, [r3, #0]
 800e72a:	00db      	lsls	r3, r3, #3
 800e72c:	68fa      	ldr	r2, [r7, #12]
 800e72e:	4413      	add	r3, r2
 800e730:	2200      	movs	r2, #0
 800e732:	605a      	str	r2, [r3, #4]
 800e734:	e051      	b.n	800e7da <_fx_utility_partition_get+0xea>
        }
        else
        {

            value =  (ULONG) sector_buffer[i + 8]; /* little endian start value */
 800e736:	69fb      	ldr	r3, [r7, #28]
 800e738:	3308      	adds	r3, #8
 800e73a:	683a      	ldr	r2, [r7, #0]
 800e73c:	4413      	add	r3, r2
 800e73e:	781b      	ldrb	r3, [r3, #0]
 800e740:	617b      	str	r3, [r7, #20]
            value =  (((ULONG) sector_buffer[i + 9]) << 8) | value;
 800e742:	69fb      	ldr	r3, [r7, #28]
 800e744:	3309      	adds	r3, #9
 800e746:	683a      	ldr	r2, [r7, #0]
 800e748:	4413      	add	r3, r2
 800e74a:	781b      	ldrb	r3, [r3, #0]
 800e74c:	021b      	lsls	r3, r3, #8
 800e74e:	697a      	ldr	r2, [r7, #20]
 800e750:	4313      	orrs	r3, r2
 800e752:	617b      	str	r3, [r7, #20]
            value =  (((ULONG) sector_buffer[i + 10]) << 16) | value;
 800e754:	69fb      	ldr	r3, [r7, #28]
 800e756:	330a      	adds	r3, #10
 800e758:	683a      	ldr	r2, [r7, #0]
 800e75a:	4413      	add	r3, r2
 800e75c:	781b      	ldrb	r3, [r3, #0]
 800e75e:	041b      	lsls	r3, r3, #16
 800e760:	697a      	ldr	r2, [r7, #20]
 800e762:	4313      	orrs	r3, r2
 800e764:	617b      	str	r3, [r7, #20]
            value =  (((ULONG) sector_buffer[i + 11]) << 24) | value;
 800e766:	69fb      	ldr	r3, [r7, #28]
 800e768:	330b      	adds	r3, #11
 800e76a:	683a      	ldr	r2, [r7, #0]
 800e76c:	4413      	add	r3, r2
 800e76e:	781b      	ldrb	r3, [r3, #0]
 800e770:	061b      	lsls	r3, r3, #24
 800e772:	697a      	ldr	r2, [r7, #20]
 800e774:	4313      	orrs	r3, r2
 800e776:	617b      	str	r3, [r7, #20]
            partition_table[*count].fx_media_part_start = value + base_sector;
 800e778:	68bb      	ldr	r3, [r7, #8]
 800e77a:	681b      	ldr	r3, [r3, #0]
 800e77c:	00db      	lsls	r3, r3, #3
 800e77e:	68fa      	ldr	r2, [r7, #12]
 800e780:	4413      	add	r3, r2
 800e782:	6979      	ldr	r1, [r7, #20]
 800e784:	69ba      	ldr	r2, [r7, #24]
 800e786:	440a      	add	r2, r1
 800e788:	601a      	str	r2, [r3, #0]

            value =  (ULONG) sector_buffer[i + 12]; /* little endian size value */
 800e78a:	69fb      	ldr	r3, [r7, #28]
 800e78c:	330c      	adds	r3, #12
 800e78e:	683a      	ldr	r2, [r7, #0]
 800e790:	4413      	add	r3, r2
 800e792:	781b      	ldrb	r3, [r3, #0]
 800e794:	617b      	str	r3, [r7, #20]
            value =  (((ULONG) sector_buffer[i + 13]) << 8) | value;
 800e796:	69fb      	ldr	r3, [r7, #28]
 800e798:	330d      	adds	r3, #13
 800e79a:	683a      	ldr	r2, [r7, #0]
 800e79c:	4413      	add	r3, r2
 800e79e:	781b      	ldrb	r3, [r3, #0]
 800e7a0:	021b      	lsls	r3, r3, #8
 800e7a2:	697a      	ldr	r2, [r7, #20]
 800e7a4:	4313      	orrs	r3, r2
 800e7a6:	617b      	str	r3, [r7, #20]
            value =  (((ULONG) sector_buffer[i + 14]) << 16) | value;
 800e7a8:	69fb      	ldr	r3, [r7, #28]
 800e7aa:	330e      	adds	r3, #14
 800e7ac:	683a      	ldr	r2, [r7, #0]
 800e7ae:	4413      	add	r3, r2
 800e7b0:	781b      	ldrb	r3, [r3, #0]
 800e7b2:	041b      	lsls	r3, r3, #16
 800e7b4:	697a      	ldr	r2, [r7, #20]
 800e7b6:	4313      	orrs	r3, r2
 800e7b8:	617b      	str	r3, [r7, #20]
            value =  (((ULONG) sector_buffer[i + 15]) << 24) | value;
 800e7ba:	69fb      	ldr	r3, [r7, #28]
 800e7bc:	330f      	adds	r3, #15
 800e7be:	683a      	ldr	r2, [r7, #0]
 800e7c0:	4413      	add	r3, r2
 800e7c2:	781b      	ldrb	r3, [r3, #0]
 800e7c4:	061b      	lsls	r3, r3, #24
 800e7c6:	697a      	ldr	r2, [r7, #20]
 800e7c8:	4313      	orrs	r3, r2
 800e7ca:	617b      	str	r3, [r7, #20]
            partition_table[*count].fx_media_part_size = value;
 800e7cc:	68bb      	ldr	r3, [r7, #8]
 800e7ce:	681b      	ldr	r3, [r3, #0]
 800e7d0:	00db      	lsls	r3, r3, #3
 800e7d2:	68fa      	ldr	r2, [r7, #12]
 800e7d4:	4413      	add	r3, r2
 800e7d6:	697a      	ldr	r2, [r7, #20]
 800e7d8:	605a      	str	r2, [r3, #4]
        }

        (*count)++;
 800e7da:	68bb      	ldr	r3, [r7, #8]
 800e7dc:	681b      	ldr	r3, [r3, #0]
 800e7de:	1c5a      	adds	r2, r3, #1
 800e7e0:	68bb      	ldr	r3, [r7, #8]
 800e7e2:	601a      	str	r2, [r3, #0]
    for(i = 446; i <= 494; i+=16)
 800e7e4:	69fb      	ldr	r3, [r7, #28]
 800e7e6:	3310      	adds	r3, #16
 800e7e8:	61fb      	str	r3, [r7, #28]
 800e7ea:	69fb      	ldr	r3, [r7, #28]
 800e7ec:	f5b3 7ff7 	cmp.w	r3, #494	@ 0x1ee
 800e7f0:	d98b      	bls.n	800e70a <_fx_utility_partition_get+0x1a>
    }

    /* Return success.  */
    return(FX_SUCCESS);
 800e7f2:	2300      	movs	r3, #0
}
 800e7f4:	4618      	mov	r0, r3
 800e7f6:	3724      	adds	r7, #36	@ 0x24
 800e7f8:	46bd      	mov	sp, r7
 800e7fa:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e7fe:	4770      	bx	lr

0800e800 <_fx_system_initialize>:
/*                                            disable build options,      */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _fx_system_initialize(VOID)
{
 800e800:	b480      	push	{r7}
 800e802:	af00      	add	r7, sp, #0
    /* If trace is enabled, insert this event into the trace buffer.  */
    FX_TRACE_IN_LINE_INSERT(FX_TRACE_SYSTEM_INITIALIZE, 0, 0, 0, 0, FX_TRACE_INTERNAL_EVENTS, 0, 0)

    /* Initialize the head pointer of the opened media list and the
       number of opened media.  */
    _fx_system_media_opened_ptr =       FX_NULL;
 800e804:	4b2a      	ldr	r3, [pc, #168]	@ (800e8b0 <_fx_system_initialize+0xb0>)
 800e806:	2200      	movs	r2, #0
 800e808:	601a      	str	r2, [r3, #0]
    _fx_system_media_opened_count =     0;
 800e80a:	4b2a      	ldr	r3, [pc, #168]	@ (800e8b4 <_fx_system_initialize+0xb4>)
 800e80c:	2200      	movs	r2, #0
 800e80e:	601a      	str	r2, [r3, #0]

    /* Initialize the time and date fields with their default values.  */
    _fx_system_date =   FX_INITIAL_DATE;
 800e810:	4b29      	ldr	r3, [pc, #164]	@ (800e8b8 <_fx_system_initialize+0xb8>)
 800e812:	f644 2221 	movw	r2, #18977	@ 0x4a21
 800e816:	601a      	str	r2, [r3, #0]
    _fx_system_time =   FX_INITIAL_TIME;
 800e818:	4b28      	ldr	r3, [pc, #160]	@ (800e8bc <_fx_system_initialize+0xbc>)
 800e81a:	2200      	movs	r2, #0
 800e81c:	601a      	str	r2, [r3, #0]

    /* Initialize the sector and FAT cache sizes.  */
    _fx_system_media_max_sector_cache =  FX_MAX_SECTOR_CACHE;
 800e81e:	4b28      	ldr	r3, [pc, #160]	@ (800e8c0 <_fx_system_initialize+0xc0>)
 800e820:	f44f 7280 	mov.w	r2, #256	@ 0x100
 800e824:	601a      	str	r2, [r3, #0]
    _fx_system_media_max_fat_cache =     FX_MAX_FAT_CACHE;
 800e826:	4b27      	ldr	r3, [pc, #156]	@ (800e8c4 <_fx_system_initialize+0xc4>)
 800e828:	2210      	movs	r2, #16
 800e82a:	601a      	str	r2, [r3, #0]
    /* Setup the build options variables.  */

    /* Setup the first build options variable.  */
    if (FX_MAX_LONG_NAME_LEN > 0xFF)
    {
        _fx_system_build_options_1 =  _fx_system_build_options_1 | (((ULONG)0xFF) << 24);
 800e82c:	4b26      	ldr	r3, [pc, #152]	@ (800e8c8 <_fx_system_initialize+0xc8>)
 800e82e:	681b      	ldr	r3, [r3, #0]
 800e830:	f043 437f 	orr.w	r3, r3, #4278190080	@ 0xff000000
 800e834:	4a24      	ldr	r2, [pc, #144]	@ (800e8c8 <_fx_system_initialize+0xc8>)
 800e836:	6013      	str	r3, [r2, #0]
    {
        _fx_system_build_options_1 =  _fx_system_build_options_1 | (((ULONG)(FX_MAX_LONG_NAME_LEN & 0xFF)) << 24);
    }
    if (FX_MAX_LAST_NAME_LEN > 0xFF)
    {
        _fx_system_build_options_1 =  _fx_system_build_options_1 | (((ULONG)0xFF) << 16);
 800e838:	4b23      	ldr	r3, [pc, #140]	@ (800e8c8 <_fx_system_initialize+0xc8>)
 800e83a:	681b      	ldr	r3, [r3, #0]
 800e83c:	f443 037f 	orr.w	r3, r3, #16711680	@ 0xff0000
 800e840:	4a21      	ldr	r2, [pc, #132]	@ (800e8c8 <_fx_system_initialize+0xc8>)
 800e842:	6013      	str	r3, [r2, #0]
    {
        _fx_system_build_options_1 =  _fx_system_build_options_1 | (((ULONG)(FX_MAX_LAST_NAME_LEN & 0xFF)) << 24);
    }

#ifdef FX_NO_TIMER
    _fx_system_build_options_1 = _fx_system_build_options_1 | (((ULONG)1) << 10);
 800e844:	4b20      	ldr	r3, [pc, #128]	@ (800e8c8 <_fx_system_initialize+0xc8>)
 800e846:	681b      	ldr	r3, [r3, #0]
 800e848:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
 800e84c:	4a1e      	ldr	r2, [pc, #120]	@ (800e8c8 <_fx_system_initialize+0xc8>)
 800e84e:	6013      	str	r3, [r2, #0]
#endif
#ifdef FX_SINGLE_THREAD
    _fx_system_build_options_1 = _fx_system_build_options_1 | (((ULONG)1) << 9);
 800e850:	4b1d      	ldr	r3, [pc, #116]	@ (800e8c8 <_fx_system_initialize+0xc8>)
 800e852:	681b      	ldr	r3, [r3, #0]
 800e854:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 800e858:	4a1b      	ldr	r2, [pc, #108]	@ (800e8c8 <_fx_system_initialize+0xc8>)
 800e85a:	6013      	str	r3, [r2, #0]
#endif
#ifdef FX_RENAME_PATH_INHERIT
    _fx_system_build_options_1 = _fx_system_build_options_1 | (((ULONG)1) << 3);
#endif
#ifdef FX_NO_LOCAL_PATH
    _fx_system_build_options_1 = _fx_system_build_options_1 | (((ULONG)1) << 2);
 800e85c:	4b1a      	ldr	r3, [pc, #104]	@ (800e8c8 <_fx_system_initialize+0xc8>)
 800e85e:	681b      	ldr	r3, [r3, #0]
 800e860:	f043 0304 	orr.w	r3, r3, #4
 800e864:	4a18      	ldr	r2, [pc, #96]	@ (800e8c8 <_fx_system_initialize+0xc8>)
 800e866:	6013      	str	r3, [r2, #0]
    {
        _fx_system_build_options_2 =  _fx_system_build_options_2 | (((ULONG)0xFFFF) << 16);
    }
    else
    {
        _fx_system_build_options_2 =  _fx_system_build_options_2 | (((ULONG)FX_MAX_SECTOR_CACHE) << 16);
 800e868:	4b18      	ldr	r3, [pc, #96]	@ (800e8cc <_fx_system_initialize+0xcc>)
 800e86a:	681b      	ldr	r3, [r3, #0]
 800e86c:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 800e870:	4a16      	ldr	r2, [pc, #88]	@ (800e8cc <_fx_system_initialize+0xcc>)
 800e872:	6013      	str	r3, [r2, #0]
    {
        _fx_system_build_options_2 =  _fx_system_build_options_2 | (((ULONG)0xFF) << 8);
    }
    else
    {
        _fx_system_build_options_2 =  _fx_system_build_options_2 | (((ULONG)FX_FAT_MAP_SIZE) << 8);
 800e874:	4b15      	ldr	r3, [pc, #84]	@ (800e8cc <_fx_system_initialize+0xcc>)
 800e876:	681b      	ldr	r3, [r3, #0]
 800e878:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 800e87c:	4a13      	ldr	r2, [pc, #76]	@ (800e8cc <_fx_system_initialize+0xcc>)
 800e87e:	6013      	str	r3, [r2, #0]
    {
        _fx_system_build_options_2 =  _fx_system_build_options_2 | ((ULONG)0xFF);
    }
    else
    {
        _fx_system_build_options_2 =  _fx_system_build_options_2 | ((ULONG)FX_MAX_FAT_CACHE);
 800e880:	4b12      	ldr	r3, [pc, #72]	@ (800e8cc <_fx_system_initialize+0xcc>)
 800e882:	681b      	ldr	r3, [r3, #0]
 800e884:	f043 0310 	orr.w	r3, r3, #16
 800e888:	4a10      	ldr	r2, [pc, #64]	@ (800e8cc <_fx_system_initialize+0xcc>)
 800e88a:	6013      	str	r3, [r2, #0]
    {
        _fx_system_build_options_3 =  _fx_system_build_options_3 | (((ULONG)0xFF) << 16);
    }
    else
    {
        _fx_system_build_options_3 =  _fx_system_build_options_3 | (((ULONG)FX_UPDATE_RATE_IN_SECONDS) << 16);
 800e88c:	4b10      	ldr	r3, [pc, #64]	@ (800e8d0 <_fx_system_initialize+0xd0>)
 800e88e:	681b      	ldr	r3, [r3, #0]
 800e890:	f443 2320 	orr.w	r3, r3, #655360	@ 0xa0000
 800e894:	4a0e      	ldr	r2, [pc, #56]	@ (800e8d0 <_fx_system_initialize+0xd0>)
 800e896:	6013      	str	r3, [r2, #0]
    {
        _fx_system_build_options_3 =  _fx_system_build_options_3 | ((ULONG)0xFFFF);
    }
    else
    {
        _fx_system_build_options_3 =  _fx_system_build_options_3 | ((ULONG)FX_UPDATE_RATE_IN_TICKS);
 800e898:	4b0d      	ldr	r3, [pc, #52]	@ (800e8d0 <_fx_system_initialize+0xd0>)
 800e89a:	681b      	ldr	r3, [r3, #0]
 800e89c:	f443 737a 	orr.w	r3, r3, #1000	@ 0x3e8
 800e8a0:	4a0b      	ldr	r2, [pc, #44]	@ (800e8d0 <_fx_system_initialize+0xd0>)
 800e8a2:	6013      	str	r3, [r2, #0]
    }
#endif /* FX_DISABLE_BUILD_OPTIONS */
}
 800e8a4:	bf00      	nop
 800e8a6:	46bd      	mov	sp, r7
 800e8a8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e8ac:	4770      	bx	lr
 800e8ae:	bf00      	nop
 800e8b0:	20002c8c 	.word	0x20002c8c
 800e8b4:	20002c90 	.word	0x20002c90
 800e8b8:	20002c94 	.word	0x20002c94
 800e8bc:	20002c98 	.word	0x20002c98
 800e8c0:	20002c9c 	.word	0x20002c9c
 800e8c4:	20002ca0 	.word	0x20002ca0
 800e8c8:	20002ca4 	.word	0x20002ca4
 800e8cc:	20002ca8 	.word	0x20002ca8
 800e8d0:	20002cac 	.word	0x20002cac

0800e8d4 <_fx_utility_16_unsigned_read>:
/*  09-30-2020     William E. Lamie         Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _fx_utility_16_unsigned_read(UCHAR *source_ptr)
{
 800e8d4:	b480      	push	{r7}
 800e8d6:	b085      	sub	sp, #20
 800e8d8:	af00      	add	r7, sp, #0
 800e8da:	6078      	str	r0, [r7, #4]

UINT value;

    /* Pickup the UINT from the destination with endian-awareness.  */
    value =  ((((UINT)*(source_ptr + 1)) & 0xFF) << 8) |
 800e8dc:	687b      	ldr	r3, [r7, #4]
 800e8de:	3301      	adds	r3, #1
 800e8e0:	781b      	ldrb	r3, [r3, #0]
 800e8e2:	021b      	lsls	r3, r3, #8
              ((UINT)*(source_ptr) & 0xFF);
 800e8e4:	687a      	ldr	r2, [r7, #4]
 800e8e6:	7812      	ldrb	r2, [r2, #0]
    value =  ((((UINT)*(source_ptr + 1)) & 0xFF) << 8) |
 800e8e8:	4313      	orrs	r3, r2
 800e8ea:	60fb      	str	r3, [r7, #12]

    /* Return value to caller.  */
    return(value);
 800e8ec:	68fb      	ldr	r3, [r7, #12]
}
 800e8ee:	4618      	mov	r0, r3
 800e8f0:	3714      	adds	r7, #20
 800e8f2:	46bd      	mov	sp, r7
 800e8f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e8f8:	4770      	bx	lr

0800e8fa <_fx_utility_16_unsigned_write>:
/*  09-30-2020     William E. Lamie         Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _fx_utility_16_unsigned_write(UCHAR *dest_ptr, UINT value)
{
 800e8fa:	b480      	push	{r7}
 800e8fc:	b083      	sub	sp, #12
 800e8fe:	af00      	add	r7, sp, #0
 800e900:	6078      	str	r0, [r7, #4]
 800e902:	6039      	str	r1, [r7, #0]

    /* Store the UINT into the destination with endian-awareness.  */
    *(dest_ptr) =       (UCHAR)(value & 0xFF);
 800e904:	683b      	ldr	r3, [r7, #0]
 800e906:	b2da      	uxtb	r2, r3
 800e908:	687b      	ldr	r3, [r7, #4]
 800e90a:	701a      	strb	r2, [r3, #0]
    *(dest_ptr + 1) =   (UCHAR)((value >> 8) & 0xFF);
 800e90c:	683b      	ldr	r3, [r7, #0]
 800e90e:	0a1a      	lsrs	r2, r3, #8
 800e910:	687b      	ldr	r3, [r7, #4]
 800e912:	3301      	adds	r3, #1
 800e914:	b2d2      	uxtb	r2, r2
 800e916:	701a      	strb	r2, [r3, #0]
}
 800e918:	bf00      	nop
 800e91a:	370c      	adds	r7, #12
 800e91c:	46bd      	mov	sp, r7
 800e91e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e922:	4770      	bx	lr

0800e924 <_fx_utility_32_unsigned_read>:
/*  09-30-2020     William E. Lamie         Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
ULONG  _fx_utility_32_unsigned_read(UCHAR *source_ptr)
{
 800e924:	b480      	push	{r7}
 800e926:	b085      	sub	sp, #20
 800e928:	af00      	add	r7, sp, #0
 800e92a:	6078      	str	r0, [r7, #4]

ULONG value;

    /* Pickup the UINT from the destination with endian-awareness.  */
    value =  ((((ULONG) *(source_ptr+3)) & 0xFF) << 24) |
 800e92c:	687b      	ldr	r3, [r7, #4]
 800e92e:	3303      	adds	r3, #3
 800e930:	781b      	ldrb	r3, [r3, #0]
 800e932:	061a      	lsls	r2, r3, #24
             ((((ULONG) *(source_ptr+2)) & 0xFF) << 16) |
 800e934:	687b      	ldr	r3, [r7, #4]
 800e936:	3302      	adds	r3, #2
 800e938:	781b      	ldrb	r3, [r3, #0]
 800e93a:	041b      	lsls	r3, r3, #16
    value =  ((((ULONG) *(source_ptr+3)) & 0xFF) << 24) |
 800e93c:	431a      	orrs	r2, r3
             ((((ULONG) *(source_ptr+1)) & 0xFF) << 8)  |
 800e93e:	687b      	ldr	r3, [r7, #4]
 800e940:	3301      	adds	r3, #1
 800e942:	781b      	ldrb	r3, [r3, #0]
 800e944:	021b      	lsls	r3, r3, #8
             ((((ULONG) *(source_ptr+2)) & 0xFF) << 16) |
 800e946:	4313      	orrs	r3, r2
              (((ULONG) *(source_ptr)) & 0xFF);
 800e948:	687a      	ldr	r2, [r7, #4]
 800e94a:	7812      	ldrb	r2, [r2, #0]
    value =  ((((ULONG) *(source_ptr+3)) & 0xFF) << 24) |
 800e94c:	4313      	orrs	r3, r2
 800e94e:	60fb      	str	r3, [r7, #12]

    /* Return value to caller.  */
    return(value);
 800e950:	68fb      	ldr	r3, [r7, #12]
}
 800e952:	4618      	mov	r0, r3
 800e954:	3714      	adds	r7, #20
 800e956:	46bd      	mov	sp, r7
 800e958:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e95c:	4770      	bx	lr

0800e95e <_fx_utility_32_unsigned_write>:
/*  09-30-2020     William E. Lamie         Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _fx_utility_32_unsigned_write(UCHAR *dest_ptr, ULONG value)
{
 800e95e:	b480      	push	{r7}
 800e960:	b083      	sub	sp, #12
 800e962:	af00      	add	r7, sp, #0
 800e964:	6078      	str	r0, [r7, #4]
 800e966:	6039      	str	r1, [r7, #0]

    /* Store the UINT into the destination with endian-awareness.  */
    *(dest_ptr) =       (UCHAR)(value & 0xFF);
 800e968:	683b      	ldr	r3, [r7, #0]
 800e96a:	b2da      	uxtb	r2, r3
 800e96c:	687b      	ldr	r3, [r7, #4]
 800e96e:	701a      	strb	r2, [r3, #0]
    *(dest_ptr + 1) =   (UCHAR)((value >> 8) & 0xFF);
 800e970:	683b      	ldr	r3, [r7, #0]
 800e972:	0a1a      	lsrs	r2, r3, #8
 800e974:	687b      	ldr	r3, [r7, #4]
 800e976:	3301      	adds	r3, #1
 800e978:	b2d2      	uxtb	r2, r2
 800e97a:	701a      	strb	r2, [r3, #0]
    *(dest_ptr + 2) =   (UCHAR)((value >> 16) & 0xFF);
 800e97c:	683b      	ldr	r3, [r7, #0]
 800e97e:	0c1a      	lsrs	r2, r3, #16
 800e980:	687b      	ldr	r3, [r7, #4]
 800e982:	3302      	adds	r3, #2
 800e984:	b2d2      	uxtb	r2, r2
 800e986:	701a      	strb	r2, [r3, #0]
    *(dest_ptr + 3) =   (UCHAR)((value >> 24) & 0xFF);
 800e988:	683b      	ldr	r3, [r7, #0]
 800e98a:	0e1a      	lsrs	r2, r3, #24
 800e98c:	687b      	ldr	r3, [r7, #4]
 800e98e:	3303      	adds	r3, #3
 800e990:	b2d2      	uxtb	r2, r2
 800e992:	701a      	strb	r2, [r3, #0]
}
 800e994:	bf00      	nop
 800e996:	370c      	adds	r7, #12
 800e998:	46bd      	mov	sp, r7
 800e99a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e99e:	4770      	bx	lr

0800e9a0 <_fx_utility_FAT_entry_read>:
/*                                            fixed compiler warning,     */
/*                                            resulting in version 6.2.0  */
/*                                                                        */
/**************************************************************************/
UINT  _fx_utility_FAT_entry_read(FX_MEDIA *media_ptr, ULONG cluster, ULONG *entry_ptr)
{
 800e9a0:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 800e9a4:	b098      	sub	sp, #96	@ 0x60
 800e9a6:	af04      	add	r7, sp, #16
 800e9a8:	61f8      	str	r0, [r7, #28]
 800e9aa:	61b9      	str	r1, [r7, #24]
 800e9ac:	617a      	str	r2, [r7, #20]
    }
#endif /* FX_ENABLE_FAULT_TOLERANT */

#ifndef FX_MEDIA_STATISTICS_DISABLE
    /* Increment the number of FAT entry reads and cache hits.  */
    media_ptr -> fx_media_fat_entry_reads++;
 800e9ae:	69fb      	ldr	r3, [r7, #28]
 800e9b0:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
 800e9b4:	1c5a      	adds	r2, r3, #1
 800e9b6:	69fb      	ldr	r3, [r7, #28]
 800e9b8:	f8c3 2178 	str.w	r2, [r3, #376]	@ 0x178
    media_ptr -> fx_media_fat_entry_cache_read_hits++;
 800e9bc:	69fb      	ldr	r3, [r7, #28]
 800e9be:	f8d3 3180 	ldr.w	r3, [r3, #384]	@ 0x180
 800e9c2:	1c5a      	adds	r2, r3, #1
 800e9c4:	69fb      	ldr	r3, [r7, #28]
 800e9c6:	f8c3 2180 	str.w	r2, [r3, #384]	@ 0x180

    /* Extended port-specific processing macro, which is by default defined to white space.  */
    FX_UTILITY_FAT_ENTRY_READ_EXTENSION

    /* Calculate the area of the cache for this FAT entry.  */
    index =  (cluster & FX_FAT_CACHE_HASH_MASK) * FX_FAT_CACHE_DEPTH;
 800e9ca:	69bb      	ldr	r3, [r7, #24]
 800e9cc:	f003 0303 	and.w	r3, r3, #3
 800e9d0:	009b      	lsls	r3, r3, #2
 800e9d2:	647b      	str	r3, [r7, #68]	@ 0x44

    /* Build a pointer to the cache entry.  */
    cache_entry_ptr =  &media_ptr -> fx_media_fat_cache[index];
 800e9d4:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 800e9d6:	4613      	mov	r3, r2
 800e9d8:	005b      	lsls	r3, r3, #1
 800e9da:	4413      	add	r3, r2
 800e9dc:	009b      	lsls	r3, r3, #2
 800e9de:	f503 63e5 	add.w	r3, r3, #1832	@ 0x728
 800e9e2:	69fa      	ldr	r2, [r7, #28]
 800e9e4:	4413      	add	r3, r2
 800e9e6:	643b      	str	r3, [r7, #64]	@ 0x40

#ifndef FX_DISABLE_FAT_ENTRY_REFRESH
    /* Determine if the FAT entry is in the cache - assuming the depth of the FAT cache is
       4 entries.  */
    if ((cache_entry_ptr -> fx_fat_cache_entry_cluster) == cluster)
 800e9e8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800e9ea:	681b      	ldr	r3, [r3, #0]
 800e9ec:	69ba      	ldr	r2, [r7, #24]
 800e9ee:	429a      	cmp	r2, r3
 800e9f0:	d105      	bne.n	800e9fe <_fx_utility_FAT_entry_read+0x5e>
    {

        /* Yes, return the cached value.  */
        *entry_ptr =  cache_entry_ptr -> fx_fat_cache_entry_value;
 800e9f2:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800e9f4:	685a      	ldr	r2, [r3, #4]
 800e9f6:	697b      	ldr	r3, [r7, #20]
 800e9f8:	601a      	str	r2, [r3, #0]

        /* Don't move anything since we found the entry.  */

        /* Return a successful status.  */
        return(FX_SUCCESS);
 800e9fa:	2300      	movs	r3, #0
 800e9fc:	e1f4      	b.n	800ede8 <_fx_utility_FAT_entry_read+0x448>
    }
    else if (((cache_entry_ptr + 1) -> fx_fat_cache_entry_cluster) == cluster)
 800e9fe:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800ea00:	330c      	adds	r3, #12
 800ea02:	681b      	ldr	r3, [r3, #0]
 800ea04:	69ba      	ldr	r2, [r7, #24]
 800ea06:	429a      	cmp	r2, r3
 800ea08:	d11d      	bne.n	800ea46 <_fx_utility_FAT_entry_read+0xa6>
    {

        /* Yes, return the cached value.  */
        *entry_ptr =  (cache_entry_ptr + 1) -> fx_fat_cache_entry_value;
 800ea0a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800ea0c:	330c      	adds	r3, #12
 800ea0e:	685a      	ldr	r2, [r3, #4]
 800ea10:	697b      	ldr	r3, [r7, #20]
 800ea12:	601a      	str	r2, [r3, #0]

        /* Just swap the first and second entry.  */
        temp_cache_entry =        *(cache_entry_ptr);
 800ea14:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800ea16:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 800ea1a:	ca07      	ldmia	r2, {r0, r1, r2}
 800ea1c:	e883 0007 	stmia.w	r3, {r0, r1, r2}
        *(cache_entry_ptr) =      *(cache_entry_ptr + 1);
 800ea20:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800ea22:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800ea24:	4614      	mov	r4, r2
 800ea26:	330c      	adds	r3, #12
 800ea28:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 800ea2c:	e884 0007 	stmia.w	r4, {r0, r1, r2}
        *(cache_entry_ptr + 1) =  temp_cache_entry;
 800ea30:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800ea32:	330c      	adds	r3, #12
 800ea34:	461c      	mov	r4, r3
 800ea36:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 800ea3a:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 800ea3e:	e884 0007 	stmia.w	r4, {r0, r1, r2}

        /* Return a successful status.  */
        return(FX_SUCCESS);
 800ea42:	2300      	movs	r3, #0
 800ea44:	e1d0      	b.n	800ede8 <_fx_utility_FAT_entry_read+0x448>
    }
    else if (((cache_entry_ptr + 2) -> fx_fat_cache_entry_cluster) == cluster)
 800ea46:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800ea48:	3318      	adds	r3, #24
 800ea4a:	681b      	ldr	r3, [r3, #0]
 800ea4c:	69ba      	ldr	r2, [r7, #24]
 800ea4e:	429a      	cmp	r2, r3
 800ea50:	d127      	bne.n	800eaa2 <_fx_utility_FAT_entry_read+0x102>
    {

        /* Yes, return the cached value.  */
        *entry_ptr =  (cache_entry_ptr + 2) -> fx_fat_cache_entry_value;
 800ea52:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800ea54:	3318      	adds	r3, #24
 800ea56:	685a      	ldr	r2, [r3, #4]
 800ea58:	697b      	ldr	r3, [r7, #20]
 800ea5a:	601a      	str	r2, [r3, #0]

        /* Move the third entry to the top and the first two entries down.  */
        temp_cache_entry =        *(cache_entry_ptr);
 800ea5c:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800ea5e:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 800ea62:	ca07      	ldmia	r2, {r0, r1, r2}
 800ea64:	e883 0007 	stmia.w	r3, {r0, r1, r2}
        *(cache_entry_ptr) =      *(cache_entry_ptr + 2);
 800ea68:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800ea6a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800ea6c:	4614      	mov	r4, r2
 800ea6e:	3318      	adds	r3, #24
 800ea70:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 800ea74:	e884 0007 	stmia.w	r4, {r0, r1, r2}
        *(cache_entry_ptr + 2) =  *(cache_entry_ptr + 1);
 800ea78:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800ea7a:	f103 0218 	add.w	r2, r3, #24
 800ea7e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800ea80:	4614      	mov	r4, r2
 800ea82:	330c      	adds	r3, #12
 800ea84:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 800ea88:	e884 0007 	stmia.w	r4, {r0, r1, r2}
        *(cache_entry_ptr + 1) =  temp_cache_entry;
 800ea8c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800ea8e:	330c      	adds	r3, #12
 800ea90:	461c      	mov	r4, r3
 800ea92:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 800ea96:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 800ea9a:	e884 0007 	stmia.w	r4, {r0, r1, r2}

        /* Return a successful status.  */
        return(FX_SUCCESS);
 800ea9e:	2300      	movs	r3, #0
 800eaa0:	e1a2      	b.n	800ede8 <_fx_utility_FAT_entry_read+0x448>
    }
    else if (((cache_entry_ptr + 3) -> fx_fat_cache_entry_cluster) == cluster)
 800eaa2:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800eaa4:	3324      	adds	r3, #36	@ 0x24
 800eaa6:	681b      	ldr	r3, [r3, #0]
 800eaa8:	69ba      	ldr	r2, [r7, #24]
 800eaaa:	429a      	cmp	r2, r3
 800eaac:	d131      	bne.n	800eb12 <_fx_utility_FAT_entry_read+0x172>
    {

        /* Yes, return the cached value.  */
        *entry_ptr =  (cache_entry_ptr + 3) -> fx_fat_cache_entry_value;
 800eaae:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800eab0:	3324      	adds	r3, #36	@ 0x24
 800eab2:	685a      	ldr	r2, [r3, #4]
 800eab4:	697b      	ldr	r3, [r7, #20]
 800eab6:	601a      	str	r2, [r3, #0]

        /* Move the last entry to the top and the first three entries down.  */
        temp_cache_entry =        *(cache_entry_ptr);
 800eab8:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800eaba:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 800eabe:	ca07      	ldmia	r2, {r0, r1, r2}
 800eac0:	e883 0007 	stmia.w	r3, {r0, r1, r2}
        *(cache_entry_ptr) =      *(cache_entry_ptr + 3);
 800eac4:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800eac6:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800eac8:	4614      	mov	r4, r2
 800eaca:	3324      	adds	r3, #36	@ 0x24
 800eacc:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 800ead0:	e884 0007 	stmia.w	r4, {r0, r1, r2}
        *(cache_entry_ptr + 3) =  *(cache_entry_ptr + 2);
 800ead4:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800ead6:	f103 0224 	add.w	r2, r3, #36	@ 0x24
 800eada:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800eadc:	4614      	mov	r4, r2
 800eade:	3318      	adds	r3, #24
 800eae0:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 800eae4:	e884 0007 	stmia.w	r4, {r0, r1, r2}
        *(cache_entry_ptr + 2) =  *(cache_entry_ptr + 1);
 800eae8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800eaea:	f103 0218 	add.w	r2, r3, #24
 800eaee:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800eaf0:	4614      	mov	r4, r2
 800eaf2:	330c      	adds	r3, #12
 800eaf4:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 800eaf8:	e884 0007 	stmia.w	r4, {r0, r1, r2}
        *(cache_entry_ptr + 1) =  temp_cache_entry;
 800eafc:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800eafe:	330c      	adds	r3, #12
 800eb00:	461c      	mov	r4, r3
 800eb02:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 800eb06:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 800eb0a:	e884 0007 	stmia.w	r4, {r0, r1, r2}

        /* Return a successful status.  */
        return(FX_SUCCESS);
 800eb0e:	2300      	movs	r3, #0
 800eb10:	e16a      	b.n	800ede8 <_fx_utility_FAT_entry_read+0x448>
    }
#endif /* FX_DISABLE_FAT_ENTRY_REFRESH */

    /* Determine if the oldest entry was modified, i.e. whether or not it is
       dirty.  */
    if (media_ptr -> fx_media_fat_cache[index + 3].fx_fat_cache_entry_dirty)
 800eb12:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800eb14:	1cda      	adds	r2, r3, #3
 800eb16:	69f9      	ldr	r1, [r7, #28]
 800eb18:	4613      	mov	r3, r2
 800eb1a:	005b      	lsls	r3, r3, #1
 800eb1c:	4413      	add	r3, r2
 800eb1e:	009b      	lsls	r3, r3, #2
 800eb20:	440b      	add	r3, r1
 800eb22:	f503 63e6 	add.w	r3, r3, #1840	@ 0x730
 800eb26:	681b      	ldr	r3, [r3, #0]
 800eb28:	2b00      	cmp	r3, #0
 800eb2a:	d008      	beq.n	800eb3e <_fx_utility_FAT_entry_read+0x19e>
    {

        /* Yes, the entry is dirty and needs to be flushed out.  */
        status = _fx_utility_FAT_flush(media_ptr);
 800eb2c:	69f8      	ldr	r0, [r7, #28]
 800eb2e:	f000 fa54 	bl	800efda <_fx_utility_FAT_flush>
 800eb32:	63f8      	str	r0, [r7, #60]	@ 0x3c

        /* Check for completion status.  */
        if (status != FX_SUCCESS)
 800eb34:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800eb36:	2b00      	cmp	r3, #0
 800eb38:	d001      	beq.n	800eb3e <_fx_utility_FAT_entry_read+0x19e>
        {

            /* Return error status.  */
            return(status);
 800eb3a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800eb3c:	e154      	b.n	800ede8 <_fx_utility_FAT_entry_read+0x448>
       actually read the FAT entry.  */

#ifndef FX_MEDIA_STATISTICS_DISABLE

    /* Decrement the number of cache hits.  */
    media_ptr -> fx_media_fat_entry_cache_read_hits--;
 800eb3e:	69fb      	ldr	r3, [r7, #28]
 800eb40:	f8d3 3180 	ldr.w	r3, [r3, #384]	@ 0x180
 800eb44:	1e5a      	subs	r2, r3, #1
 800eb46:	69fb      	ldr	r3, [r7, #28]
 800eb48:	f8c3 2180 	str.w	r2, [r3, #384]	@ 0x180

    /* Increment the number of cache misses.  */
    media_ptr -> fx_media_fat_entry_cache_read_misses++;
 800eb4c:	69fb      	ldr	r3, [r7, #28]
 800eb4e:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
 800eb52:	1c5a      	adds	r2, r3, #1
 800eb54:	69fb      	ldr	r3, [r7, #28]
 800eb56:	f8c3 2184 	str.w	r2, [r3, #388]	@ 0x184
#endif

    /* Determine which type of FAT is present.  */
    if (media_ptr -> fx_media_12_bit_FAT)
 800eb5a:	69fb      	ldr	r3, [r7, #28]
 800eb5c:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 800eb5e:	2b00      	cmp	r3, #0
 800eb60:	f000 80a7 	beq.w	800ecb2 <_fx_utility_FAT_entry_read+0x312>
    {

        /* Calculate the byte offset to the cluster entry.  */
        byte_offset =  (((ULONG)cluster << 1) + cluster) >> 1;
 800eb64:	69bb      	ldr	r3, [r7, #24]
 800eb66:	005a      	lsls	r2, r3, #1
 800eb68:	69bb      	ldr	r3, [r7, #24]
 800eb6a:	4413      	add	r3, r2
 800eb6c:	085b      	lsrs	r3, r3, #1
 800eb6e:	63bb      	str	r3, [r7, #56]	@ 0x38

        /* Calculate the FAT sector the requested FAT entry resides in.  */
        FAT_sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 800eb70:	69fb      	ldr	r3, [r7, #28]
 800eb72:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800eb74:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 800eb76:	fbb2 f2f3 	udiv	r2, r2, r3
            (ULONG)media_ptr -> fx_media_reserved_sectors;
 800eb7a:	69fb      	ldr	r3, [r7, #28]
 800eb7c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
        FAT_sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 800eb7e:	4413      	add	r3, r2
 800eb80:	637b      	str	r3, [r7, #52]	@ 0x34

        /* Read the sector in.  */
        status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 800eb82:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800eb84:	2200      	movs	r2, #0
 800eb86:	60bb      	str	r3, [r7, #8]
 800eb88:	60fa      	str	r2, [r7, #12]
                                                  media_ptr -> fx_media_memory_buffer, ((ULONG) 1), FX_FAT_SECTOR);
 800eb8a:	69fb      	ldr	r3, [r7, #28]
 800eb8c:	689b      	ldr	r3, [r3, #8]
        status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 800eb8e:	2202      	movs	r2, #2
 800eb90:	9202      	str	r2, [sp, #8]
 800eb92:	2201      	movs	r2, #1
 800eb94:	9201      	str	r2, [sp, #4]
 800eb96:	9300      	str	r3, [sp, #0]
 800eb98:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 800eb9c:	69f8      	ldr	r0, [r7, #28]
 800eb9e:	f001 fb0d 	bl	80101bc <_fx_utility_logical_sector_read>
 800eba2:	63f8      	str	r0, [r7, #60]	@ 0x3c

        /* Determine if an error occurred.  */
        if (status != FX_SUCCESS)
 800eba4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800eba6:	2b00      	cmp	r3, #0
 800eba8:	d001      	beq.n	800ebae <_fx_utility_FAT_entry_read+0x20e>
        {
            /* Return the error status.  */
            return(status);
 800ebaa:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800ebac:	e11c      	b.n	800ede8 <_fx_utility_FAT_entry_read+0x448>
        }

        /* Now calculate the byte offset into this FAT sector.  */
        byte_offset =  byte_offset -
            ((FAT_sector - (ULONG)media_ptr -> fx_media_reserved_sectors) *
 800ebae:	69fb      	ldr	r3, [r7, #28]
 800ebb0:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800ebb2:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 800ebb4:	1ad3      	subs	r3, r2, r3
             media_ptr -> fx_media_bytes_per_sector);
 800ebb6:	69fa      	ldr	r2, [r7, #28]
 800ebb8:	6a92      	ldr	r2, [r2, #40]	@ 0x28
            ((FAT_sector - (ULONG)media_ptr -> fx_media_reserved_sectors) *
 800ebba:	fb02 f303 	mul.w	r3, r2, r3
        byte_offset =  byte_offset -
 800ebbe:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 800ebc0:	1ad3      	subs	r3, r2, r3
 800ebc2:	63bb      	str	r3, [r7, #56]	@ 0x38

        /* Setup a pointer into the buffer.  */
        FAT_ptr =  (UCHAR *)media_ptr -> fx_media_memory_buffer + (UINT)byte_offset;
 800ebc4:	69fb      	ldr	r3, [r7, #28]
 800ebc6:	689a      	ldr	r2, [r3, #8]
 800ebc8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800ebca:	4413      	add	r3, r2
 800ebcc:	64fb      	str	r3, [r7, #76]	@ 0x4c

        /* Determine if the cluster entry is odd or even.  */
        if (cluster & 1)
 800ebce:	69bb      	ldr	r3, [r7, #24]
 800ebd0:	f003 0301 	and.w	r3, r3, #1
 800ebd4:	2b00      	cmp	r3, #0
 800ebd6:	d030      	beq.n	800ec3a <_fx_utility_FAT_entry_read+0x29a>
        {

            /* Odd cluster number.  */

            /* Pickup the lower nibble of the FAT entry.  */
            entry =  (((UINT)*FAT_ptr) & 0xF0) >> 4;
 800ebd8:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800ebda:	781b      	ldrb	r3, [r3, #0]
 800ebdc:	091b      	lsrs	r3, r3, #4
 800ebde:	b2db      	uxtb	r3, r3
 800ebe0:	64bb      	str	r3, [r7, #72]	@ 0x48

            /* Move to the next byte of the FAT entry.  */
            FAT_ptr++;
 800ebe2:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800ebe4:	3301      	adds	r3, #1
 800ebe6:	64fb      	str	r3, [r7, #76]	@ 0x4c

            /* Determine if we are now past the end of the FAT buffer in memory.  */
            if (byte_offset == (ULONG)(media_ptr -> fx_media_bytes_per_sector - 1))
 800ebe8:	69fb      	ldr	r3, [r7, #28]
 800ebea:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800ebec:	3b01      	subs	r3, #1
 800ebee:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 800ebf0:	429a      	cmp	r2, r3
 800ebf2:	d11b      	bne.n	800ec2c <_fx_utility_FAT_entry_read+0x28c>
            {

                /* Yes, we need to read the next sector.  */
                FAT_sector++;
 800ebf4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800ebf6:	3301      	adds	r3, #1
 800ebf8:	637b      	str	r3, [r7, #52]	@ 0x34
                status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 800ebfa:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800ebfc:	2200      	movs	r2, #0
 800ebfe:	603b      	str	r3, [r7, #0]
 800ec00:	607a      	str	r2, [r7, #4]
                                                          media_ptr -> fx_media_memory_buffer, ((ULONG) 1), FX_FAT_SECTOR);
 800ec02:	69fb      	ldr	r3, [r7, #28]
 800ec04:	689b      	ldr	r3, [r3, #8]
                status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 800ec06:	2202      	movs	r2, #2
 800ec08:	9202      	str	r2, [sp, #8]
 800ec0a:	2201      	movs	r2, #1
 800ec0c:	9201      	str	r2, [sp, #4]
 800ec0e:	9300      	str	r3, [sp, #0]
 800ec10:	e9d7 2300 	ldrd	r2, r3, [r7]
 800ec14:	69f8      	ldr	r0, [r7, #28]
 800ec16:	f001 fad1 	bl	80101bc <_fx_utility_logical_sector_read>
 800ec1a:	63f8      	str	r0, [r7, #60]	@ 0x3c

                /* Determine if an error occurred.  */
                if (status != FX_SUCCESS)
 800ec1c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800ec1e:	2b00      	cmp	r3, #0
 800ec20:	d001      	beq.n	800ec26 <_fx_utility_FAT_entry_read+0x286>
                {

                    /* Return the error status.  */
                    return(status);
 800ec22:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800ec24:	e0e0      	b.n	800ede8 <_fx_utility_FAT_entry_read+0x448>
                }

                /* Setup a pointer into the buffer.  */
                FAT_ptr =  (UCHAR *)media_ptr -> fx_media_memory_buffer;
 800ec26:	69fb      	ldr	r3, [r7, #28]
 800ec28:	689b      	ldr	r3, [r3, #8]
 800ec2a:	64fb      	str	r3, [r7, #76]	@ 0x4c
            }

            /* Pickup the upper 8 bits of the FAT entry.  */
            entry =  entry | (((UINT)*FAT_ptr) << 4);
 800ec2c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800ec2e:	781b      	ldrb	r3, [r3, #0]
 800ec30:	011b      	lsls	r3, r3, #4
 800ec32:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800ec34:	4313      	orrs	r3, r2
 800ec36:	64bb      	str	r3, [r7, #72]	@ 0x48
 800ec38:	e02f      	b.n	800ec9a <_fx_utility_FAT_entry_read+0x2fa>
        {

            /* Even cluster number.  */

            /* Pickup the lower byte of the FAT entry.  */
            entry =  (UINT)(((UINT)*FAT_ptr) & 0xFF);
 800ec3a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800ec3c:	781b      	ldrb	r3, [r3, #0]
 800ec3e:	64bb      	str	r3, [r7, #72]	@ 0x48

            /* Move to the next nibble of the FAT entry.  */
            FAT_ptr++;
 800ec40:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800ec42:	3301      	adds	r3, #1
 800ec44:	64fb      	str	r3, [r7, #76]	@ 0x4c

            /* Determine if we are now past the end of the FAT buffer in memory.  */
            if (byte_offset == (ULONG)(media_ptr -> fx_media_bytes_per_sector - 1))
 800ec46:	69fb      	ldr	r3, [r7, #28]
 800ec48:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800ec4a:	3b01      	subs	r3, #1
 800ec4c:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 800ec4e:	429a      	cmp	r2, r3
 800ec50:	d11b      	bne.n	800ec8a <_fx_utility_FAT_entry_read+0x2ea>
            {

                /* Yes, we need to read the next sector.  */
                FAT_sector++;
 800ec52:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800ec54:	3301      	adds	r3, #1
 800ec56:	637b      	str	r3, [r7, #52]	@ 0x34
                status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 800ec58:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800ec5a:	2200      	movs	r2, #0
 800ec5c:	469a      	mov	sl, r3
 800ec5e:	4693      	mov	fp, r2
                                                          media_ptr -> fx_media_memory_buffer, ((ULONG) 1), FX_FAT_SECTOR);
 800ec60:	69fb      	ldr	r3, [r7, #28]
 800ec62:	689b      	ldr	r3, [r3, #8]
                status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 800ec64:	2202      	movs	r2, #2
 800ec66:	9202      	str	r2, [sp, #8]
 800ec68:	2201      	movs	r2, #1
 800ec6a:	9201      	str	r2, [sp, #4]
 800ec6c:	9300      	str	r3, [sp, #0]
 800ec6e:	4652      	mov	r2, sl
 800ec70:	465b      	mov	r3, fp
 800ec72:	69f8      	ldr	r0, [r7, #28]
 800ec74:	f001 faa2 	bl	80101bc <_fx_utility_logical_sector_read>
 800ec78:	63f8      	str	r0, [r7, #60]	@ 0x3c

                /* Determine if an error occurred.  */
                if (status != FX_SUCCESS)
 800ec7a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800ec7c:	2b00      	cmp	r3, #0
 800ec7e:	d001      	beq.n	800ec84 <_fx_utility_FAT_entry_read+0x2e4>
                {
                    return(status);
 800ec80:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800ec82:	e0b1      	b.n	800ede8 <_fx_utility_FAT_entry_read+0x448>
                }

                /* Setup a pointer into the buffer.  */
                FAT_ptr =  (UCHAR *)media_ptr -> fx_media_memory_buffer;
 800ec84:	69fb      	ldr	r3, [r7, #28]
 800ec86:	689b      	ldr	r3, [r3, #8]
 800ec88:	64fb      	str	r3, [r7, #76]	@ 0x4c
            }

            /* Pickup the upper 4 bits of the FAT entry.  */
            entry =  entry | ((((UINT)*FAT_ptr) & 0x0F) << 8);
 800ec8a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800ec8c:	781b      	ldrb	r3, [r3, #0]
 800ec8e:	021b      	lsls	r3, r3, #8
 800ec90:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
 800ec94:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800ec96:	4313      	orrs	r3, r2
 800ec98:	64bb      	str	r3, [r7, #72]	@ 0x48
        }

        /* Determine if we need to do sign extension on the 12-bit eof value.  */
        if (entry >= FX_MAX_12BIT_CLUST)
 800ec9a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800ec9c:	f5b3 6f7f 	cmp.w	r3, #4080	@ 0xff0
 800eca0:	d303      	bcc.n	800ecaa <_fx_utility_FAT_entry_read+0x30a>
        {

            /* Yes, we need to sign extend.  */
            entry =  entry | FX_SIGN_EXTEND;
 800eca2:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800eca4:	f443 4370 	orr.w	r3, r3, #61440	@ 0xf000
 800eca8:	64bb      	str	r3, [r7, #72]	@ 0x48
        }

        *entry_ptr =  entry;
 800ecaa:	697b      	ldr	r3, [r7, #20]
 800ecac:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800ecae:	601a      	str	r2, [r3, #0]
 800ecb0:	e078      	b.n	800eda4 <_fx_utility_FAT_entry_read+0x404>

    /* Check for a 16-bit FAT.  */
#ifdef FX_ENABLE_EXFAT
    else if (FX_FAT16  == media_ptr -> fx_media_FAT_type)
#else
    else if (!media_ptr -> fx_media_32_bit_FAT)
 800ecb2:	69fb      	ldr	r3, [r7, #28]
 800ecb4:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 800ecb6:	2b00      	cmp	r3, #0
 800ecb8:	d139      	bne.n	800ed2e <_fx_utility_FAT_entry_read+0x38e>
    {

        /* 16-bit FAT is present.  */

        /* Calculate the byte offset to the cluster entry.  */
        byte_offset =  (((ULONG)cluster) * 2);
 800ecba:	69bb      	ldr	r3, [r7, #24]
 800ecbc:	005b      	lsls	r3, r3, #1
 800ecbe:	63bb      	str	r3, [r7, #56]	@ 0x38

        /* Calculate the FAT sector the requested FAT entry resides in.  */
        FAT_sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 800ecc0:	69fb      	ldr	r3, [r7, #28]
 800ecc2:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800ecc4:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 800ecc6:	fbb2 f2f3 	udiv	r2, r2, r3
            (ULONG)media_ptr -> fx_media_reserved_sectors;
 800ecca:	69fb      	ldr	r3, [r7, #28]
 800eccc:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
        FAT_sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 800ecce:	4413      	add	r3, r2
 800ecd0:	637b      	str	r3, [r7, #52]	@ 0x34

        /* Read the FAT sector.  */
        status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 800ecd2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800ecd4:	2200      	movs	r2, #0
 800ecd6:	4698      	mov	r8, r3
 800ecd8:	4691      	mov	r9, r2
                                                  media_ptr -> fx_media_memory_buffer, ((ULONG) 1), FX_FAT_SECTOR);
 800ecda:	69fb      	ldr	r3, [r7, #28]
 800ecdc:	689b      	ldr	r3, [r3, #8]
        status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 800ecde:	2202      	movs	r2, #2
 800ece0:	9202      	str	r2, [sp, #8]
 800ece2:	2201      	movs	r2, #1
 800ece4:	9201      	str	r2, [sp, #4]
 800ece6:	9300      	str	r3, [sp, #0]
 800ece8:	4642      	mov	r2, r8
 800ecea:	464b      	mov	r3, r9
 800ecec:	69f8      	ldr	r0, [r7, #28]
 800ecee:	f001 fa65 	bl	80101bc <_fx_utility_logical_sector_read>
 800ecf2:	63f8      	str	r0, [r7, #60]	@ 0x3c

        /* Determine if an error occurred.  */
        if (status != FX_SUCCESS)
 800ecf4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800ecf6:	2b00      	cmp	r3, #0
 800ecf8:	d001      	beq.n	800ecfe <_fx_utility_FAT_entry_read+0x35e>
        {

            /* Return the error code.  */
            return(status);
 800ecfa:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800ecfc:	e074      	b.n	800ede8 <_fx_utility_FAT_entry_read+0x448>
        }

        /* Now calculate the byte offset into this FAT sector.  */
        byte_offset =  byte_offset -
            ((FAT_sector - (ULONG)media_ptr -> fx_media_reserved_sectors) *
 800ecfe:	69fb      	ldr	r3, [r7, #28]
 800ed00:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800ed02:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 800ed04:	1ad3      	subs	r3, r2, r3
             media_ptr -> fx_media_bytes_per_sector);
 800ed06:	69fa      	ldr	r2, [r7, #28]
 800ed08:	6a92      	ldr	r2, [r2, #40]	@ 0x28
            ((FAT_sector - (ULONG)media_ptr -> fx_media_reserved_sectors) *
 800ed0a:	fb02 f303 	mul.w	r3, r2, r3
        byte_offset =  byte_offset -
 800ed0e:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 800ed10:	1ad3      	subs	r3, r2, r3
 800ed12:	63bb      	str	r3, [r7, #56]	@ 0x38

        /* Setup a pointer into the buffer.  */
        FAT_ptr =  (UCHAR *)media_ptr -> fx_media_memory_buffer + (UINT)byte_offset;
 800ed14:	69fb      	ldr	r3, [r7, #28]
 800ed16:	689a      	ldr	r2, [r3, #8]
 800ed18:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800ed1a:	4413      	add	r3, r2
 800ed1c:	64fb      	str	r3, [r7, #76]	@ 0x4c

        /* Pickup the FAT entry.  */
        entry =  _fx_utility_16_unsigned_read(FAT_ptr);
 800ed1e:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 800ed20:	f7ff fdd8 	bl	800e8d4 <_fx_utility_16_unsigned_read>
 800ed24:	64b8      	str	r0, [r7, #72]	@ 0x48

        *entry_ptr =  entry;
 800ed26:	697b      	ldr	r3, [r7, #20]
 800ed28:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800ed2a:	601a      	str	r2, [r3, #0]
 800ed2c:	e03a      	b.n	800eda4 <_fx_utility_FAT_entry_read+0x404>
    else
#endif /* FX_ENABLE_EXFAT */
    {

        /* Otherwise, a 32 bit FAT present.  */
        byte_offset =  (((ULONG)cluster) * 4);
 800ed2e:	69bb      	ldr	r3, [r7, #24]
 800ed30:	009b      	lsls	r3, r3, #2
 800ed32:	63bb      	str	r3, [r7, #56]	@ 0x38

        /* Calculate the FAT sector the requested FAT entry resides in.  */
        FAT_sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 800ed34:	69fb      	ldr	r3, [r7, #28]
 800ed36:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800ed38:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 800ed3a:	fbb2 f2f3 	udiv	r2, r2, r3
            (ULONG)media_ptr -> fx_media_reserved_sectors;
 800ed3e:	69fb      	ldr	r3, [r7, #28]
 800ed40:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
        FAT_sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 800ed42:	4413      	add	r3, r2
 800ed44:	637b      	str	r3, [r7, #52]	@ 0x34

        /* Calculate the byte offset to the FAT entry.  */
        byte_offset = (byte_offset % media_ptr -> fx_media_bytes_per_sector);
 800ed46:	69fb      	ldr	r3, [r7, #28]
 800ed48:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 800ed4a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800ed4c:	fbb3 f1f2 	udiv	r1, r3, r2
 800ed50:	fb01 f202 	mul.w	r2, r1, r2
 800ed54:	1a9b      	subs	r3, r3, r2
 800ed56:	63bb      	str	r3, [r7, #56]	@ 0x38

        /* Read the appropriate FAT sector.  */
        status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 800ed58:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800ed5a:	2200      	movs	r2, #0
 800ed5c:	461c      	mov	r4, r3
 800ed5e:	4615      	mov	r5, r2
                                                  media_ptr -> fx_media_memory_buffer, ((ULONG) 1), FX_FAT_SECTOR);
 800ed60:	69fb      	ldr	r3, [r7, #28]
 800ed62:	689b      	ldr	r3, [r3, #8]
        status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 800ed64:	2202      	movs	r2, #2
 800ed66:	9202      	str	r2, [sp, #8]
 800ed68:	2201      	movs	r2, #1
 800ed6a:	9201      	str	r2, [sp, #4]
 800ed6c:	9300      	str	r3, [sp, #0]
 800ed6e:	4622      	mov	r2, r4
 800ed70:	462b      	mov	r3, r5
 800ed72:	69f8      	ldr	r0, [r7, #28]
 800ed74:	f001 fa22 	bl	80101bc <_fx_utility_logical_sector_read>
 800ed78:	63f8      	str	r0, [r7, #60]	@ 0x3c

        /* Determine if an error occurred.  */
        if (status != FX_SUCCESS)
 800ed7a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800ed7c:	2b00      	cmp	r3, #0
 800ed7e:	d001      	beq.n	800ed84 <_fx_utility_FAT_entry_read+0x3e4>
        {

            /* Return the error code.  */
            return(status);
 800ed80:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800ed82:	e031      	b.n	800ede8 <_fx_utility_FAT_entry_read+0x448>
        }

        /* Setup a pointer into the buffer.  */
        FAT_ptr =  (UCHAR *)media_ptr -> fx_media_memory_buffer + (ULONG)byte_offset;
 800ed84:	69fb      	ldr	r3, [r7, #28]
 800ed86:	689a      	ldr	r2, [r3, #8]
 800ed88:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800ed8a:	4413      	add	r3, r2
 800ed8c:	64fb      	str	r3, [r7, #76]	@ 0x4c

        /* Pickup the FAT entry.  */
        entry32 =  _fx_utility_32_unsigned_read(FAT_ptr);
 800ed8e:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 800ed90:	f7ff fdc8 	bl	800e924 <_fx_utility_32_unsigned_read>
 800ed94:	6338      	str	r0, [r7, #48]	@ 0x30
        if (media_ptr -> fx_media_FAT_type == FX_FAT32)
        {
#endif /* FX_ENABLE_EXFAT */

            /* Clear upper nibble.  */
            entry32 = entry32 & 0x0FFFFFFF;
 800ed96:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800ed98:	f023 4370 	bic.w	r3, r3, #4026531840	@ 0xf0000000
 800ed9c:	633b      	str	r3, [r7, #48]	@ 0x30
#ifdef FX_ENABLE_EXFAT
        }
#endif /* FX_ENABLE_EXFAT */

        *entry_ptr =  entry32;
 800ed9e:	697b      	ldr	r3, [r7, #20]
 800eda0:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 800eda2:	601a      	str	r2, [r3, #0]
    }

    /* Move all the cache entries down so the oldest is at the bottom.  */
    *(cache_entry_ptr + 3) =  *(cache_entry_ptr + 2);
 800eda4:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800eda6:	f103 0224 	add.w	r2, r3, #36	@ 0x24
 800edaa:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800edac:	4614      	mov	r4, r2
 800edae:	3318      	adds	r3, #24
 800edb0:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 800edb4:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    *(cache_entry_ptr + 2) =  *(cache_entry_ptr + 1);
 800edb8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800edba:	f103 0218 	add.w	r2, r3, #24
 800edbe:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800edc0:	4614      	mov	r4, r2
 800edc2:	330c      	adds	r3, #12
 800edc4:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 800edc8:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    *(cache_entry_ptr + 1) =  *(cache_entry_ptr);
 800edcc:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800edce:	330c      	adds	r3, #12
 800edd0:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800edd2:	ca07      	ldmia	r2, {r0, r1, r2}
 800edd4:	e883 0007 	stmia.w	r3, {r0, r1, r2}

    /* Setup the new FAT entry in the cache.  */
    cache_entry_ptr -> fx_fat_cache_entry_cluster =  cluster;
 800edd8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800edda:	69ba      	ldr	r2, [r7, #24]
 800eddc:	601a      	str	r2, [r3, #0]
    cache_entry_ptr -> fx_fat_cache_entry_value   =  *entry_ptr;
 800edde:	697b      	ldr	r3, [r7, #20]
 800ede0:	681a      	ldr	r2, [r3, #0]
 800ede2:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800ede4:	605a      	str	r2, [r3, #4]

    /* Return success to the caller.  */
    return(FX_SUCCESS);
 800ede6:	2300      	movs	r3, #0
}
 800ede8:	4618      	mov	r0, r3
 800edea:	3750      	adds	r7, #80	@ 0x50
 800edec:	46bd      	mov	sp, r7
 800edee:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

0800edf2 <_fx_utility_FAT_entry_write>:
/*  09-30-2020     William E. Lamie         Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _fx_utility_FAT_entry_write(FX_MEDIA *media_ptr, ULONG cluster, ULONG next_cluster)
{
 800edf2:	b590      	push	{r4, r7, lr}
 800edf4:	b089      	sub	sp, #36	@ 0x24
 800edf6:	af00      	add	r7, sp, #0
 800edf8:	60f8      	str	r0, [r7, #12]
 800edfa:	60b9      	str	r1, [r7, #8]
 800edfc:	607a      	str	r2, [r7, #4]
    }
#endif /* FX_ENABLE_FAULT_TOLERANT */

#ifndef FX_MEDIA_STATISTICS_DISABLE
    /* Increment the number of FAT entry writes and cache hits.  */
    media_ptr -> fx_media_fat_entry_writes++;
 800edfe:	68fb      	ldr	r3, [r7, #12]
 800ee00:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
 800ee04:	1c5a      	adds	r2, r3, #1
 800ee06:	68fb      	ldr	r3, [r7, #12]
 800ee08:	f8c3 217c 	str.w	r2, [r3, #380]	@ 0x17c
    media_ptr -> fx_media_fat_entry_cache_write_hits++;
 800ee0c:	68fb      	ldr	r3, [r7, #12]
 800ee0e:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
 800ee12:	1c5a      	adds	r2, r3, #1
 800ee14:	68fb      	ldr	r3, [r7, #12]
 800ee16:	f8c3 2188 	str.w	r2, [r3, #392]	@ 0x188

    /* Extended port-specific processing macro, which is by default defined to white space.  */
    FX_UTILITY_FAT_ENTRY_WRITE_EXTENSION

    /* Calculate the area of the cache for this FAT entry.  */
    index =  (cluster & FX_FAT_CACHE_HASH_MASK) * FX_FAT_CACHE_DEPTH;
 800ee1a:	68bb      	ldr	r3, [r7, #8]
 800ee1c:	f003 0303 	and.w	r3, r3, #3
 800ee20:	009b      	lsls	r3, r3, #2
 800ee22:	61bb      	str	r3, [r7, #24]

    /* Build a pointer to the cache entry.  */
    cache_entry_ptr =  &media_ptr -> fx_media_fat_cache[index];
 800ee24:	69ba      	ldr	r2, [r7, #24]
 800ee26:	4613      	mov	r3, r2
 800ee28:	005b      	lsls	r3, r3, #1
 800ee2a:	4413      	add	r3, r2
 800ee2c:	009b      	lsls	r3, r3, #2
 800ee2e:	f503 63e5 	add.w	r3, r3, #1832	@ 0x728
 800ee32:	68fa      	ldr	r2, [r7, #12]
 800ee34:	4413      	add	r3, r2
 800ee36:	617b      	str	r3, [r7, #20]

    /* First search for the entry in the FAT entry cache.  */
    for (i = 0; i < FX_FAT_CACHE_DEPTH; i++)
 800ee38:	2300      	movs	r3, #0
 800ee3a:	61fb      	str	r3, [r7, #28]
 800ee3c:	e051      	b.n	800eee2 <_fx_utility_FAT_entry_write+0xf0>
    {

        /* See if the entry matches the write request.  */
        if (((cache_entry_ptr + i) -> fx_fat_cache_entry_cluster) == cluster)
 800ee3e:	69fa      	ldr	r2, [r7, #28]
 800ee40:	4613      	mov	r3, r2
 800ee42:	005b      	lsls	r3, r3, #1
 800ee44:	4413      	add	r3, r2
 800ee46:	009b      	lsls	r3, r3, #2
 800ee48:	461a      	mov	r2, r3
 800ee4a:	697b      	ldr	r3, [r7, #20]
 800ee4c:	4413      	add	r3, r2
 800ee4e:	681b      	ldr	r3, [r3, #0]
 800ee50:	68ba      	ldr	r2, [r7, #8]
 800ee52:	429a      	cmp	r2, r3
 800ee54:	d142      	bne.n	800eedc <_fx_utility_FAT_entry_write+0xea>
        {

            /* Yes, we have a matching entry.  Save the new information in the FAT
               cache and mark this entry as dirty.  */
            (cache_entry_ptr + i) -> fx_fat_cache_entry_value =     next_cluster;
 800ee56:	69fa      	ldr	r2, [r7, #28]
 800ee58:	4613      	mov	r3, r2
 800ee5a:	005b      	lsls	r3, r3, #1
 800ee5c:	4413      	add	r3, r2
 800ee5e:	009b      	lsls	r3, r3, #2
 800ee60:	461a      	mov	r2, r3
 800ee62:	697b      	ldr	r3, [r7, #20]
 800ee64:	4413      	add	r3, r2
 800ee66:	687a      	ldr	r2, [r7, #4]
 800ee68:	605a      	str	r2, [r3, #4]
            (cache_entry_ptr + i) -> fx_fat_cache_entry_dirty =     1;
 800ee6a:	69fa      	ldr	r2, [r7, #28]
 800ee6c:	4613      	mov	r3, r2
 800ee6e:	005b      	lsls	r3, r3, #1
 800ee70:	4413      	add	r3, r2
 800ee72:	009b      	lsls	r3, r3, #2
 800ee74:	461a      	mov	r2, r3
 800ee76:	697b      	ldr	r3, [r7, #20]
 800ee78:	4413      	add	r3, r2
 800ee7a:	2201      	movs	r2, #1
 800ee7c:	609a      	str	r2, [r3, #8]

            /* Determine if the driver has requested notification when data sectors in the media
               become free.  This can be useful to FLASH manager software.  */
            if ((media_ptr -> fx_media_driver_free_sector_update) && (next_cluster == FX_FREE_CLUSTER))
 800ee7e:	68fb      	ldr	r3, [r7, #12]
 800ee80:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
 800ee84:	2b00      	cmp	r3, #0
 800ee86:	d027      	beq.n	800eed8 <_fx_utility_FAT_entry_write+0xe6>
 800ee88:	687b      	ldr	r3, [r7, #4]
 800ee8a:	2b00      	cmp	r3, #0
 800ee8c:	d124      	bne.n	800eed8 <_fx_utility_FAT_entry_write+0xe6>
                   not in use.  */

#ifndef FX_MEDIA_STATISTICS_DISABLE

                /* Increment the number of driver release sectors requests.  */
                media_ptr -> fx_media_driver_release_sectors_requests++;
 800ee8e:	68fb      	ldr	r3, [r7, #12]
 800ee90:	f8d3 31bc 	ldr.w	r3, [r3, #444]	@ 0x1bc
 800ee94:	1c5a      	adds	r2, r3, #1
 800ee96:	68fb      	ldr	r3, [r7, #12]
 800ee98:	f8c3 21bc 	str.w	r2, [r3, #444]	@ 0x1bc
#endif

                /* This cluster is being released so inform the driver that the
                   corresponding sectors are now available.  */
                media_ptr -> fx_media_driver_request =          FX_DRIVER_RELEASE_SECTORS;
 800ee9c:	68fb      	ldr	r3, [r7, #12]
 800ee9e:	2206      	movs	r2, #6
 800eea0:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
                media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 800eea4:	68fb      	ldr	r3, [r7, #12]
 800eea6:	2290      	movs	r2, #144	@ 0x90
 800eea8:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
                media_ptr -> fx_media_driver_logical_sector =   (media_ptr -> fx_media_data_sector_start +
 800eeac:	68fb      	ldr	r3, [r7, #12]
 800eeae:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
                                                                 ((cluster - FX_FAT_ENTRY_START) * media_ptr -> fx_media_sectors_per_cluster));
 800eeb0:	68bb      	ldr	r3, [r7, #8]
 800eeb2:	3b02      	subs	r3, #2
 800eeb4:	68f9      	ldr	r1, [r7, #12]
 800eeb6:	6d49      	ldr	r1, [r1, #84]	@ 0x54
 800eeb8:	fb01 f303 	mul.w	r3, r1, r3
                media_ptr -> fx_media_driver_logical_sector =   (media_ptr -> fx_media_data_sector_start +
 800eebc:	441a      	add	r2, r3
 800eebe:	68fb      	ldr	r3, [r7, #12]
 800eec0:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
                media_ptr -> fx_media_driver_sectors =          media_ptr -> fx_media_sectors_per_cluster;
 800eec4:	68fb      	ldr	r3, [r7, #12]
 800eec6:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
 800eec8:	68fb      	ldr	r3, [r7, #12]
 800eeca:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98

                /* If trace is enabled, insert this event into the trace buffer.  */
                FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_RELEASE_SECTORS, media_ptr, media_ptr -> fx_media_driver_logical_sector, media_ptr -> fx_media_driver_sectors, 0, FX_TRACE_INTERNAL_EVENTS, 0, 0)

                /* Call the driver.  */
                (media_ptr -> fx_media_driver_entry)(media_ptr);
 800eece:	68fb      	ldr	r3, [r7, #12]
 800eed0:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
 800eed4:	68f8      	ldr	r0, [r7, #12]
 800eed6:	4798      	blx	r3
            }

            /* Done, return successful status.  */
            return(FX_SUCCESS);
 800eed8:	2300      	movs	r3, #0
 800eeda:	e07a      	b.n	800efd2 <_fx_utility_FAT_entry_write+0x1e0>
    for (i = 0; i < FX_FAT_CACHE_DEPTH; i++)
 800eedc:	69fb      	ldr	r3, [r7, #28]
 800eede:	3301      	adds	r3, #1
 800eee0:	61fb      	str	r3, [r7, #28]
 800eee2:	69fb      	ldr	r3, [r7, #28]
 800eee4:	2b03      	cmp	r3, #3
 800eee6:	d9aa      	bls.n	800ee3e <_fx_utility_FAT_entry_write+0x4c>
    /* If we reach this point, we know that the FAT write request is not in
       the cache.  */

#ifndef FX_MEDIA_STATISTICS_DISABLE
    /* Decrement the number of cache hits.  */
    media_ptr -> fx_media_fat_entry_cache_write_hits--;
 800eee8:	68fb      	ldr	r3, [r7, #12]
 800eeea:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
 800eeee:	1e5a      	subs	r2, r3, #1
 800eef0:	68fb      	ldr	r3, [r7, #12]
 800eef2:	f8c3 2188 	str.w	r2, [r3, #392]	@ 0x188

    /* Increment the number of cache misses.  */
    media_ptr -> fx_media_fat_entry_cache_write_misses++;
 800eef6:	68fb      	ldr	r3, [r7, #12]
 800eef8:	f8d3 318c 	ldr.w	r3, [r3, #396]	@ 0x18c
 800eefc:	1c5a      	adds	r2, r3, #1
 800eefe:	68fb      	ldr	r3, [r7, #12]
 800ef00:	f8c3 218c 	str.w	r2, [r3, #396]	@ 0x18c
#endif

    /* Determine if the oldest entry is dirty and needs to be flushed.  */
    if (media_ptr -> fx_media_fat_cache[index + 3].fx_fat_cache_entry_dirty == 1)
 800ef04:	69bb      	ldr	r3, [r7, #24]
 800ef06:	1cda      	adds	r2, r3, #3
 800ef08:	68f9      	ldr	r1, [r7, #12]
 800ef0a:	4613      	mov	r3, r2
 800ef0c:	005b      	lsls	r3, r3, #1
 800ef0e:	4413      	add	r3, r2
 800ef10:	009b      	lsls	r3, r3, #2
 800ef12:	440b      	add	r3, r1
 800ef14:	f503 63e6 	add.w	r3, r3, #1840	@ 0x730
 800ef18:	681b      	ldr	r3, [r3, #0]
 800ef1a:	2b01      	cmp	r3, #1
 800ef1c:	d108      	bne.n	800ef30 <_fx_utility_FAT_entry_write+0x13e>
    {

        /* Flush the dirty entry so it can be used to hold the current
           FAT entry write request.  */
        status = _fx_utility_FAT_flush(media_ptr);
 800ef1e:	68f8      	ldr	r0, [r7, #12]
 800ef20:	f000 f85b 	bl	800efda <_fx_utility_FAT_flush>
 800ef24:	6138      	str	r0, [r7, #16]

        /* Determine if the write was successful.  */
        if (status != FX_SUCCESS)
 800ef26:	693b      	ldr	r3, [r7, #16]
 800ef28:	2b00      	cmp	r3, #0
 800ef2a:	d001      	beq.n	800ef30 <_fx_utility_FAT_entry_write+0x13e>
        {

            /* No, return error status to caller.  */
            return(status);
 800ef2c:	693b      	ldr	r3, [r7, #16]
 800ef2e:	e050      	b.n	800efd2 <_fx_utility_FAT_entry_write+0x1e0>
        }

    }

    /* Move all the cache entries down so the oldest is at the bottom.  */
    *(cache_entry_ptr + 3) =  *(cache_entry_ptr + 2);
 800ef30:	697b      	ldr	r3, [r7, #20]
 800ef32:	f103 0224 	add.w	r2, r3, #36	@ 0x24
 800ef36:	697b      	ldr	r3, [r7, #20]
 800ef38:	4614      	mov	r4, r2
 800ef3a:	3318      	adds	r3, #24
 800ef3c:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 800ef40:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    *(cache_entry_ptr + 2) =  *(cache_entry_ptr + 1);
 800ef44:	697b      	ldr	r3, [r7, #20]
 800ef46:	f103 0218 	add.w	r2, r3, #24
 800ef4a:	697b      	ldr	r3, [r7, #20]
 800ef4c:	4614      	mov	r4, r2
 800ef4e:	330c      	adds	r3, #12
 800ef50:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 800ef54:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    *(cache_entry_ptr + 1) =  *(cache_entry_ptr);
 800ef58:	697b      	ldr	r3, [r7, #20]
 800ef5a:	330c      	adds	r3, #12
 800ef5c:	697a      	ldr	r2, [r7, #20]
 800ef5e:	ca07      	ldmia	r2, {r0, r1, r2}
 800ef60:	e883 0007 	stmia.w	r3, {r0, r1, r2}

    /* Save the current FAT entry write request and mark as dirty.  */
    cache_entry_ptr -> fx_fat_cache_entry_dirty =    1;
 800ef64:	697b      	ldr	r3, [r7, #20]
 800ef66:	2201      	movs	r2, #1
 800ef68:	609a      	str	r2, [r3, #8]
    cache_entry_ptr -> fx_fat_cache_entry_cluster =  cluster;
 800ef6a:	697b      	ldr	r3, [r7, #20]
 800ef6c:	68ba      	ldr	r2, [r7, #8]
 800ef6e:	601a      	str	r2, [r3, #0]
    cache_entry_ptr -> fx_fat_cache_entry_value =    next_cluster;
 800ef70:	697b      	ldr	r3, [r7, #20]
 800ef72:	687a      	ldr	r2, [r7, #4]
 800ef74:	605a      	str	r2, [r3, #4]

    /* Determine if the driver has requested notification when data sectors in the media
       become free.  This can be useful to FLASH manager software.  */
    if ((media_ptr -> fx_media_driver_free_sector_update) && (next_cluster == FX_FREE_CLUSTER))
 800ef76:	68fb      	ldr	r3, [r7, #12]
 800ef78:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
 800ef7c:	2b00      	cmp	r3, #0
 800ef7e:	d027      	beq.n	800efd0 <_fx_utility_FAT_entry_write+0x1de>
 800ef80:	687b      	ldr	r3, [r7, #4]
 800ef82:	2b00      	cmp	r3, #0
 800ef84:	d124      	bne.n	800efd0 <_fx_utility_FAT_entry_write+0x1de>
           not in use.  */

#ifndef FX_MEDIA_STATISTICS_DISABLE

        /* Increment the number of driver release sectors requests.  */
        media_ptr -> fx_media_driver_release_sectors_requests++;
 800ef86:	68fb      	ldr	r3, [r7, #12]
 800ef88:	f8d3 31bc 	ldr.w	r3, [r3, #444]	@ 0x1bc
 800ef8c:	1c5a      	adds	r2, r3, #1
 800ef8e:	68fb      	ldr	r3, [r7, #12]
 800ef90:	f8c3 21bc 	str.w	r2, [r3, #444]	@ 0x1bc
#endif

        /* This cluster is being released so inform the driver that the
              corresponding sectors are now available.  */
        media_ptr -> fx_media_driver_request =          FX_DRIVER_RELEASE_SECTORS;
 800ef94:	68fb      	ldr	r3, [r7, #12]
 800ef96:	2206      	movs	r2, #6
 800ef98:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
        media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 800ef9c:	68fb      	ldr	r3, [r7, #12]
 800ef9e:	2290      	movs	r2, #144	@ 0x90
 800efa0:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
        media_ptr -> fx_media_driver_logical_sector =   (media_ptr -> fx_media_data_sector_start +
 800efa4:	68fb      	ldr	r3, [r7, #12]
 800efa6:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
                                                         ((cluster - FX_FAT_ENTRY_START) * media_ptr -> fx_media_sectors_per_cluster));
 800efa8:	68bb      	ldr	r3, [r7, #8]
 800efaa:	3b02      	subs	r3, #2
 800efac:	68f9      	ldr	r1, [r7, #12]
 800efae:	6d49      	ldr	r1, [r1, #84]	@ 0x54
 800efb0:	fb01 f303 	mul.w	r3, r1, r3
        media_ptr -> fx_media_driver_logical_sector =   (media_ptr -> fx_media_data_sector_start +
 800efb4:	441a      	add	r2, r3
 800efb6:	68fb      	ldr	r3, [r7, #12]
 800efb8:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
        media_ptr -> fx_media_driver_sectors =          media_ptr -> fx_media_sectors_per_cluster;
 800efbc:	68fb      	ldr	r3, [r7, #12]
 800efbe:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
 800efc0:	68fb      	ldr	r3, [r7, #12]
 800efc2:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98

        /* If trace is enabled, insert this event into the trace buffer.  */
        FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_RELEASE_SECTORS, media_ptr, media_ptr -> fx_media_driver_logical_sector, media_ptr -> fx_media_driver_sectors, 0, FX_TRACE_INTERNAL_EVENTS, 0, 0)

        /* Call the driver.  */
        (media_ptr -> fx_media_driver_entry)(media_ptr);
 800efc6:	68fb      	ldr	r3, [r7, #12]
 800efc8:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
 800efcc:	68f8      	ldr	r0, [r7, #12]
 800efce:	4798      	blx	r3
    }

    /* Return success to caller.  */
    return(FX_SUCCESS);
 800efd0:	2300      	movs	r3, #0
}
 800efd2:	4618      	mov	r0, r3
 800efd4:	3724      	adds	r7, #36	@ 0x24
 800efd6:	46bd      	mov	sp, r7
 800efd8:	bd90      	pop	{r4, r7, pc}

0800efda <_fx_utility_FAT_flush>:
/*                                            FAT secondary update map,   */
/*                                            resulting in version 6.1.2  */
/*                                                                        */
/**************************************************************************/
UINT  _fx_utility_FAT_flush(FX_MEDIA *media_ptr)
{
 800efda:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 800efde:	b09a      	sub	sp, #104	@ 0x68
 800efe0:	af04      	add	r7, sp, #16
 800efe2:	61f8      	str	r0, [r7, #28]
INT    multi_sector_entry;
ULONG  sector;

#ifndef FX_MEDIA_STATISTICS_DISABLE
    /* Increment the number of cache flush requests.  */
    media_ptr -> fx_media_fat_cache_flushes++;
 800efe4:	69fb      	ldr	r3, [r7, #28]
 800efe6:	f8d3 3190 	ldr.w	r3, [r3, #400]	@ 0x190
 800efea:	1c5a      	adds	r2, r3, #1
 800efec:	69fb      	ldr	r3, [r7, #28]
 800efee:	f8c3 2190 	str.w	r2, [r3, #400]	@ 0x190
#endif

    /* Loop through the media's FAT cache and flush out dirty entries.  */
    for (index = 0; index < FX_MAX_FAT_CACHE; index++)
 800eff2:	2300      	movs	r3, #0
 800eff4:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800eff6:	e337      	b.n	800f668 <_fx_utility_FAT_flush+0x68e>
    {

        /* Determine if the entry is dirty.  */
        if ((media_ptr -> fx_media_fat_cache[index].fx_fat_cache_entry_dirty) == 0)
 800eff8:	69f9      	ldr	r1, [r7, #28]
 800effa:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 800effc:	4613      	mov	r3, r2
 800effe:	005b      	lsls	r3, r3, #1
 800f000:	4413      	add	r3, r2
 800f002:	009b      	lsls	r3, r3, #2
 800f004:	440b      	add	r3, r1
 800f006:	f503 63e6 	add.w	r3, r3, #1840	@ 0x730
 800f00a:	681b      	ldr	r3, [r3, #0]
 800f00c:	2b00      	cmp	r3, #0
 800f00e:	f000 8325 	beq.w	800f65c <_fx_utility_FAT_flush+0x682>

        /* Otherwise, the entry is indeed dirty and must be flushed out.  Process
           relative to the type of FAT that is being used.  */

        /* Pickup the contents of the FAT cache entry.  */
        cluster =       media_ptr -> fx_media_fat_cache[index].fx_fat_cache_entry_cluster;
 800f012:	69f9      	ldr	r1, [r7, #28]
 800f014:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 800f016:	4613      	mov	r3, r2
 800f018:	005b      	lsls	r3, r3, #1
 800f01a:	4413      	add	r3, r2
 800f01c:	009b      	lsls	r3, r3, #2
 800f01e:	440b      	add	r3, r1
 800f020:	f503 63e5 	add.w	r3, r3, #1832	@ 0x728
 800f024:	681b      	ldr	r3, [r3, #0]
 800f026:	643b      	str	r3, [r7, #64]	@ 0x40

        /* Determine which type of FAT is present.  */
#ifdef FX_ENABLE_EXFAT
        if (media_ptr -> fx_media_FAT_type == FX_FAT12)
#else
        if (media_ptr -> fx_media_12_bit_FAT)
 800f028:	69fb      	ldr	r3, [r7, #28]
 800f02a:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 800f02c:	2b00      	cmp	r3, #0
 800f02e:	f000 816c 	beq.w	800f30a <_fx_utility_FAT_flush+0x330>
#endif /* FX_ENABLE_EXFAT */
        {

            /* Calculate the byte offset to the cluster entry.  */
            byte_offset =  (((ULONG)cluster << 1) + cluster) >> 1;
 800f032:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f034:	005a      	lsls	r2, r3, #1
 800f036:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f038:	4413      	add	r3, r2
 800f03a:	085b      	lsrs	r3, r3, #1
 800f03c:	63fb      	str	r3, [r7, #60]	@ 0x3c

            /* Calculate the FAT sector the requested FAT entry resides in.  */
            FAT_sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 800f03e:	69fb      	ldr	r3, [r7, #28]
 800f040:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800f042:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 800f044:	fbb2 f2f3 	udiv	r2, r2, r3
                (ULONG)media_ptr -> fx_media_reserved_sectors;
 800f048:	69fb      	ldr	r3, [r7, #28]
 800f04a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
            FAT_sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 800f04c:	4413      	add	r3, r2
 800f04e:	657b      	str	r3, [r7, #84]	@ 0x54

            /* Initialize as not written.  */
            multi_sector_entry = -1;
 800f050:	f04f 33ff 	mov.w	r3, #4294967295
 800f054:	647b      	str	r3, [r7, #68]	@ 0x44

            for (;;)
            {

                /* Pickup the FAT sector.  */
                status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 800f056:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 800f058:	2200      	movs	r2, #0
 800f05a:	461c      	mov	r4, r3
 800f05c:	4615      	mov	r5, r2
                                                          media_ptr -> fx_media_memory_buffer, ((ULONG) 1), FX_FAT_SECTOR);
 800f05e:	69fb      	ldr	r3, [r7, #28]
 800f060:	689a      	ldr	r2, [r3, #8]
                status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 800f062:	2302      	movs	r3, #2
 800f064:	9302      	str	r3, [sp, #8]
 800f066:	2301      	movs	r3, #1
 800f068:	9301      	str	r3, [sp, #4]
 800f06a:	9200      	str	r2, [sp, #0]
 800f06c:	4622      	mov	r2, r4
 800f06e:	462b      	mov	r3, r5
 800f070:	69f8      	ldr	r0, [r7, #28]
 800f072:	f001 f8a3 	bl	80101bc <_fx_utility_logical_sector_read>
 800f076:	63b8      	str	r0, [r7, #56]	@ 0x38

                /* Determine if an error occurred.  */
                if (status != FX_SUCCESS)
 800f078:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f07a:	2b00      	cmp	r3, #0
 800f07c:	d001      	beq.n	800f082 <_fx_utility_FAT_flush+0xa8>
                {

                    /* Return the error status.  */
                    return(status);
 800f07e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f080:	e2f7      	b.n	800f672 <_fx_utility_FAT_flush+0x698>
                }

                /* Determine if a mulit-sector FAT update is present.  */
                if (multi_sector_entry != -1)
 800f082:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800f084:	f1b3 3fff 	cmp.w	r3, #4294967295
 800f088:	d037      	beq.n	800f0fa <_fx_utility_FAT_flush+0x120>

                    /* Yes, store the remaining portion of the new FAT entry in the
                       next FAT sector.  */

                    /* Setup a pointer into the buffer.  */
                    FAT_ptr =  (UCHAR *)media_ptr -> fx_media_memory_buffer;
 800f08a:	69fb      	ldr	r3, [r7, #28]
 800f08c:	689b      	ldr	r3, [r3, #8]
 800f08e:	62fb      	str	r3, [r7, #44]	@ 0x2c

                    /* Pickup the cluster and next cluster.  */
                    cluster = (media_ptr -> fx_media_fat_cache[multi_sector_entry].fx_fat_cache_entry_cluster);
 800f090:	69f9      	ldr	r1, [r7, #28]
 800f092:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 800f094:	4613      	mov	r3, r2
 800f096:	005b      	lsls	r3, r3, #1
 800f098:	4413      	add	r3, r2
 800f09a:	009b      	lsls	r3, r3, #2
 800f09c:	440b      	add	r3, r1
 800f09e:	f503 63e5 	add.w	r3, r3, #1832	@ 0x728
 800f0a2:	681b      	ldr	r3, [r3, #0]
 800f0a4:	643b      	str	r3, [r7, #64]	@ 0x40
                    next_cluster = media_ptr -> fx_media_fat_cache[multi_sector_entry].fx_fat_cache_entry_value;
 800f0a6:	69f9      	ldr	r1, [r7, #28]
 800f0a8:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 800f0aa:	4613      	mov	r3, r2
 800f0ac:	005b      	lsls	r3, r3, #1
 800f0ae:	4413      	add	r3, r2
 800f0b0:	009b      	lsls	r3, r3, #2
 800f0b2:	440b      	add	r3, r1
 800f0b4:	f203 732c 	addw	r3, r3, #1836	@ 0x72c
 800f0b8:	681b      	ldr	r3, [r3, #0]
 800f0ba:	62bb      	str	r3, [r7, #40]	@ 0x28

                    /* Determine if the cluster entry is odd or even.  */
                    if (cluster & 1)
 800f0bc:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f0be:	f003 0301 	and.w	r3, r3, #1
 800f0c2:	2b00      	cmp	r3, #0
 800f0c4:	d005      	beq.n	800f0d2 <_fx_utility_FAT_flush+0xf8>
                    {

                        /* Store the upper 8 bits of the FAT entry.  */
                        *FAT_ptr =  (UCHAR)((next_cluster >> 4) & 0xFF);
 800f0c6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800f0c8:	091b      	lsrs	r3, r3, #4
 800f0ca:	b2db      	uxtb	r3, r3
 800f0cc:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800f0ce:	7013      	strb	r3, [r2, #0]
 800f0d0:	e010      	b.n	800f0f4 <_fx_utility_FAT_flush+0x11a>
                    }
                    else
                    {

                        /* Store the upper 4 bits of the FAT entry.  */
                        temp =  ((UINT)*FAT_ptr) & 0xF0;
 800f0d2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800f0d4:	781b      	ldrb	r3, [r3, #0]
 800f0d6:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
 800f0da:	627b      	str	r3, [r7, #36]	@ 0x24
                        *FAT_ptr =  (UCHAR)(temp | ((next_cluster >> 8) & 0xF));
 800f0dc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f0de:	b2da      	uxtb	r2, r3
 800f0e0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800f0e2:	0a1b      	lsrs	r3, r3, #8
 800f0e4:	b2db      	uxtb	r3, r3
 800f0e6:	f003 030f 	and.w	r3, r3, #15
 800f0ea:	b2db      	uxtb	r3, r3
 800f0ec:	4313      	orrs	r3, r2
 800f0ee:	b2db      	uxtb	r3, r3
 800f0f0:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800f0f2:	7013      	strb	r3, [r2, #0]
                    }

                    /* Clear the multi-sector flag.  */
                    multi_sector_entry = -1;
 800f0f4:	f04f 33ff 	mov.w	r3, #4294967295
 800f0f8:	647b      	str	r3, [r7, #68]	@ 0x44
                }

                /* Loop through the remainder of the cache to check for multiple entries
                   within the same FAT sector being written out.  */
                for (i = index; i < FX_MAX_FAT_CACHE; i++)
 800f0fa:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800f0fc:	653b      	str	r3, [r7, #80]	@ 0x50
 800f0fe:	e0a0      	b.n	800f242 <_fx_utility_FAT_flush+0x268>
                {

                    /* Is the cache entry dirty?  */
                    if ((media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_dirty) == 0)
 800f100:	69f9      	ldr	r1, [r7, #28]
 800f102:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 800f104:	4613      	mov	r3, r2
 800f106:	005b      	lsls	r3, r3, #1
 800f108:	4413      	add	r3, r2
 800f10a:	009b      	lsls	r3, r3, #2
 800f10c:	440b      	add	r3, r1
 800f10e:	f503 63e6 	add.w	r3, r3, #1840	@ 0x730
 800f112:	681b      	ldr	r3, [r3, #0]
 800f114:	2b00      	cmp	r3, #0
 800f116:	f000 808a 	beq.w	800f22e <_fx_utility_FAT_flush+0x254>
                        /* Not dirty, does not need to be flushed.  */
                        continue;
                    }

                    /* Isolate the cluster.  */
                    cluster = (media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_cluster);
 800f11a:	69f9      	ldr	r1, [r7, #28]
 800f11c:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 800f11e:	4613      	mov	r3, r2
 800f120:	005b      	lsls	r3, r3, #1
 800f122:	4413      	add	r3, r2
 800f124:	009b      	lsls	r3, r3, #2
 800f126:	440b      	add	r3, r1
 800f128:	f503 63e5 	add.w	r3, r3, #1832	@ 0x728
 800f12c:	681b      	ldr	r3, [r3, #0]
 800f12e:	643b      	str	r3, [r7, #64]	@ 0x40

                    /* Calculate the byte offset to the cluster entry.  */
                    byte_offset =  (((ULONG)cluster << 1) + cluster) >> 1;
 800f130:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f132:	005a      	lsls	r2, r3, #1
 800f134:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f136:	4413      	add	r3, r2
 800f138:	085b      	lsrs	r3, r3, #1
 800f13a:	63fb      	str	r3, [r7, #60]	@ 0x3c

                    /* Pickup the sector.  */
                    sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 800f13c:	69fb      	ldr	r3, [r7, #28]
 800f13e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800f140:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 800f142:	fbb2 f2f3 	udiv	r2, r2, r3
                        (ULONG)media_ptr -> fx_media_reserved_sectors;
 800f146:	69fb      	ldr	r3, [r7, #28]
 800f148:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
                    sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 800f14a:	4413      	add	r3, r2
 800f14c:	633b      	str	r3, [r7, #48]	@ 0x30

                    /* Is it the current FAT sector?  */
                    if (sector != FAT_sector)
 800f14e:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 800f150:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 800f152:	429a      	cmp	r2, r3
 800f154:	d16d      	bne.n	800f232 <_fx_utility_FAT_flush+0x258>
                        /* Different FAT sector - not in this pass of the loop.  */
                        continue;
                    }

                    /* Pickup new value for this FAT entry.  */
                    next_cluster =  media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_value;
 800f156:	69f9      	ldr	r1, [r7, #28]
 800f158:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 800f15a:	4613      	mov	r3, r2
 800f15c:	005b      	lsls	r3, r3, #1
 800f15e:	4413      	add	r3, r2
 800f160:	009b      	lsls	r3, r3, #2
 800f162:	440b      	add	r3, r1
 800f164:	f203 732c 	addw	r3, r3, #1836	@ 0x72c
 800f168:	681b      	ldr	r3, [r3, #0]
 800f16a:	62bb      	str	r3, [r7, #40]	@ 0x28

                    /* Now calculate the byte offset into this FAT sector.  */
                    byte_offset =  byte_offset -
                        ((FAT_sector - (ULONG)media_ptr -> fx_media_reserved_sectors) *
 800f16c:	69fb      	ldr	r3, [r7, #28]
 800f16e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800f170:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 800f172:	1ad2      	subs	r2, r2, r3
                         media_ptr -> fx_media_bytes_per_sector);
 800f174:	69fb      	ldr	r3, [r7, #28]
 800f176:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
                        ((FAT_sector - (ULONG)media_ptr -> fx_media_reserved_sectors) *
 800f178:	fb02 f303 	mul.w	r3, r2, r3
                    byte_offset =  byte_offset -
 800f17c:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 800f17e:	1ad3      	subs	r3, r2, r3
 800f180:	63fb      	str	r3, [r7, #60]	@ 0x3c

                    /* Determine if we are now past the end of the FAT buffer in memory.  */
                    if (byte_offset == (ULONG)(media_ptr -> fx_media_bytes_per_sector - 1))
 800f182:	69fb      	ldr	r3, [r7, #28]
 800f184:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800f186:	3b01      	subs	r3, #1
 800f188:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 800f18a:	429a      	cmp	r2, r3
 800f18c:	d101      	bne.n	800f192 <_fx_utility_FAT_flush+0x1b8>
                    {

                        /* Yes, we need to read the next sector */
                        multi_sector_entry = (INT)i;
 800f18e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800f190:	647b      	str	r3, [r7, #68]	@ 0x44
                    }

                    /* Setup a pointer into the buffer.  */
                    FAT_ptr =  (UCHAR *)media_ptr -> fx_media_memory_buffer + (UINT)byte_offset;
 800f192:	69fb      	ldr	r3, [r7, #28]
 800f194:	689a      	ldr	r2, [r3, #8]
 800f196:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800f198:	4413      	add	r3, r2
 800f19a:	62fb      	str	r3, [r7, #44]	@ 0x2c

                    /* Clear the dirty flag.  */
                    media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_dirty = 0;
 800f19c:	69f9      	ldr	r1, [r7, #28]
 800f19e:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 800f1a0:	4613      	mov	r3, r2
 800f1a2:	005b      	lsls	r3, r3, #1
 800f1a4:	4413      	add	r3, r2
 800f1a6:	009b      	lsls	r3, r3, #2
 800f1a8:	440b      	add	r3, r1
 800f1aa:	f503 63e6 	add.w	r3, r3, #1840	@ 0x730
 800f1ae:	2200      	movs	r2, #0
 800f1b0:	601a      	str	r2, [r3, #0]

                    /* Determine if the cluster entry is odd or even.  */
                    if (cluster & 1)
 800f1b2:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f1b4:	f003 0301 	and.w	r3, r3, #1
 800f1b8:	2b00      	cmp	r3, #0
 800f1ba:	d01b      	beq.n	800f1f4 <_fx_utility_FAT_flush+0x21a>
                        /* Odd cluster number.  */

                        /* Pickup the upper nibble of the FAT entry.  */

                        /* First, set the lower nibble of the FAT entry.  */
                        temp =      (((UINT)*FAT_ptr) & 0x0F);
 800f1bc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800f1be:	781b      	ldrb	r3, [r3, #0]
 800f1c0:	f003 030f 	and.w	r3, r3, #15
 800f1c4:	627b      	str	r3, [r7, #36]	@ 0x24
                        *FAT_ptr =  (UCHAR)(temp | ((next_cluster << 4) & 0xF0));
 800f1c6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f1c8:	b2da      	uxtb	r2, r3
 800f1ca:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800f1cc:	b2db      	uxtb	r3, r3
 800f1ce:	011b      	lsls	r3, r3, #4
 800f1d0:	b2db      	uxtb	r3, r3
 800f1d2:	4313      	orrs	r3, r2
 800f1d4:	b2db      	uxtb	r3, r3
 800f1d6:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800f1d8:	7013      	strb	r3, [r2, #0]

                        /* Determine if this is a mulit-sector entry.  */
                        if ((multi_sector_entry) == (INT)i)
 800f1da:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800f1dc:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 800f1de:	429a      	cmp	r2, r3
 800f1e0:	d029      	beq.n	800f236 <_fx_utility_FAT_flush+0x25c>
                            /* Yes, requires multiple sector - will write rest of the part later.  */
                            continue;
                        }

                        /* Move to the next byte of the FAT entry.  */
                        FAT_ptr++;
 800f1e2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800f1e4:	3301      	adds	r3, #1
 800f1e6:	62fb      	str	r3, [r7, #44]	@ 0x2c

                        /* Store the upper 8 bits of the FAT entry.  */
                        *FAT_ptr =  (UCHAR)((next_cluster >> 4) & 0xFF);
 800f1e8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800f1ea:	091b      	lsrs	r3, r3, #4
 800f1ec:	b2db      	uxtb	r3, r3
 800f1ee:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800f1f0:	7013      	strb	r3, [r2, #0]
 800f1f2:	e023      	b.n	800f23c <_fx_utility_FAT_flush+0x262>
                    {

                        /* Even cluster number.  */

                        /* Store the lower byte of the FAT entry.  */
                        *FAT_ptr =  (UCHAR)(next_cluster & 0xFF);
 800f1f4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800f1f6:	b2db      	uxtb	r3, r3
 800f1f8:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800f1fa:	7013      	strb	r3, [r2, #0]

                        /* Determine if this is a mulit-sector entry.  */
                        if ((multi_sector_entry) == (INT)i)
 800f1fc:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800f1fe:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 800f200:	429a      	cmp	r2, r3
 800f202:	d01a      	beq.n	800f23a <_fx_utility_FAT_flush+0x260>
                            /* Yes, requires multiple sector - will write rest of the part later.  */
                            continue;
                        }

                        /* Move to the next nibble of the FAT entry.  */
                        FAT_ptr++;
 800f204:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800f206:	3301      	adds	r3, #1
 800f208:	62fb      	str	r3, [r7, #44]	@ 0x2c

                        /* Store the upper 4 bits of the FAT entry.  */
                        temp =  ((UINT)*FAT_ptr) & 0xF0;
 800f20a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800f20c:	781b      	ldrb	r3, [r3, #0]
 800f20e:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
 800f212:	627b      	str	r3, [r7, #36]	@ 0x24
                        *FAT_ptr =  (UCHAR)(temp | ((next_cluster >> 8) & 0xF));
 800f214:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f216:	b2da      	uxtb	r2, r3
 800f218:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800f21a:	0a1b      	lsrs	r3, r3, #8
 800f21c:	b2db      	uxtb	r3, r3
 800f21e:	f003 030f 	and.w	r3, r3, #15
 800f222:	b2db      	uxtb	r3, r3
 800f224:	4313      	orrs	r3, r2
 800f226:	b2db      	uxtb	r3, r3
 800f228:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800f22a:	7013      	strb	r3, [r2, #0]
 800f22c:	e006      	b.n	800f23c <_fx_utility_FAT_flush+0x262>
                        continue;
 800f22e:	bf00      	nop
 800f230:	e004      	b.n	800f23c <_fx_utility_FAT_flush+0x262>
                        continue;
 800f232:	bf00      	nop
 800f234:	e002      	b.n	800f23c <_fx_utility_FAT_flush+0x262>
                            continue;
 800f236:	bf00      	nop
 800f238:	e000      	b.n	800f23c <_fx_utility_FAT_flush+0x262>
                            continue;
 800f23a:	bf00      	nop
                for (i = index; i < FX_MAX_FAT_CACHE; i++)
 800f23c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800f23e:	3301      	adds	r3, #1
 800f240:	653b      	str	r3, [r7, #80]	@ 0x50
 800f242:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800f244:	2b0f      	cmp	r3, #15
 800f246:	f67f af5b 	bls.w	800f100 <_fx_utility_FAT_flush+0x126>
                    }
                }

                /* First, write out the current sector. */
                status =  _fx_utility_logical_sector_write(media_ptr, (ULONG64) FAT_sector,
 800f24a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 800f24c:	2200      	movs	r2, #0
 800f24e:	4698      	mov	r8, r3
 800f250:	4691      	mov	r9, r2
                                                           media_ptr -> fx_media_memory_buffer, ((ULONG) 1), FX_FAT_SECTOR);
 800f252:	69fb      	ldr	r3, [r7, #28]
 800f254:	689a      	ldr	r2, [r3, #8]
                status =  _fx_utility_logical_sector_write(media_ptr, (ULONG64) FAT_sector,
 800f256:	2302      	movs	r3, #2
 800f258:	9302      	str	r3, [sp, #8]
 800f25a:	2301      	movs	r3, #1
 800f25c:	9301      	str	r3, [sp, #4]
 800f25e:	9200      	str	r2, [sp, #0]
 800f260:	4642      	mov	r2, r8
 800f262:	464b      	mov	r3, r9
 800f264:	69f8      	ldr	r0, [r7, #28]
 800f266:	f001 fa3d 	bl	80106e4 <_fx_utility_logical_sector_write>
 800f26a:	63b8      	str	r0, [r7, #56]	@ 0x38
                /* Determine if an error occurred.  */
                if (status != FX_SUCCESS)
 800f26c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f26e:	2b00      	cmp	r3, #0
 800f270:	d001      	beq.n	800f276 <_fx_utility_FAT_flush+0x29c>
                {

                    /* Return the error status.  */
                    return(status);
 800f272:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f274:	e1fd      	b.n	800f672 <_fx_utility_FAT_flush+0x698>
                }

                /* Mark the FAT sector update bit map to indicate this sector has been written.  */
                if (media_ptr -> fx_media_sectors_per_FAT % (FX_FAT_MAP_SIZE << 3) == 0)
 800f276:	69fb      	ldr	r3, [r7, #28]
 800f278:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800f27a:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800f27e:	2b00      	cmp	r3, #0
 800f280:	d105      	bne.n	800f28e <_fx_utility_FAT_flush+0x2b4>
                {
                    sectors_per_bit =  (UCHAR)((UINT)media_ptr -> fx_media_sectors_per_FAT / (FX_FAT_MAP_SIZE << 3));
 800f282:	69fb      	ldr	r3, [r7, #28]
 800f284:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800f286:	0a9b      	lsrs	r3, r3, #10
 800f288:	f887 304b 	strb.w	r3, [r7, #75]	@ 0x4b
 800f28c:	e006      	b.n	800f29c <_fx_utility_FAT_flush+0x2c2>
                }
                else
                {
                    sectors_per_bit =  (UCHAR)((UINT)media_ptr -> fx_media_sectors_per_FAT / (FX_FAT_MAP_SIZE << 3) + 1);
 800f28e:	69fb      	ldr	r3, [r7, #28]
 800f290:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800f292:	0a9b      	lsrs	r3, r3, #10
 800f294:	b2db      	uxtb	r3, r3
 800f296:	3301      	adds	r3, #1
 800f298:	f887 304b 	strb.w	r3, [r7, #75]	@ 0x4b
                }

                /* Check for invalid value.  */
                if (sectors_per_bit == 0)
 800f29c:	f897 304b 	ldrb.w	r3, [r7, #75]	@ 0x4b
 800f2a0:	2b00      	cmp	r3, #0
 800f2a2:	d101      	bne.n	800f2a8 <_fx_utility_FAT_flush+0x2ce>
                {

                    /* Invalid media, return error.  */
                    return(FX_MEDIA_INVALID);
 800f2a4:	2302      	movs	r3, #2
 800f2a6:	e1e4      	b.n	800f672 <_fx_utility_FAT_flush+0x698>
                }

                ind = ((FAT_sector - media_ptr -> fx_media_reserved_sectors) / sectors_per_bit) >> 3;
 800f2a8:	69fb      	ldr	r3, [r7, #28]
 800f2aa:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800f2ac:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 800f2ae:	1ad2      	subs	r2, r2, r3
 800f2b0:	f897 304b 	ldrb.w	r3, [r7, #75]	@ 0x4b
 800f2b4:	fbb2 f3f3 	udiv	r3, r2, r3
 800f2b8:	08db      	lsrs	r3, r3, #3
 800f2ba:	637b      	str	r3, [r7, #52]	@ 0x34
                media_ptr -> fx_media_fat_secondary_update_map[ind] = 
                    (UCHAR)((INT)media_ptr -> fx_media_fat_secondary_update_map[ind]
 800f2bc:	69fa      	ldr	r2, [r7, #28]
 800f2be:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f2c0:	4413      	add	r3, r2
 800f2c2:	f503 63fd 	add.w	r3, r3, #2024	@ 0x7e8
 800f2c6:	781b      	ldrb	r3, [r3, #0]
 800f2c8:	b259      	sxtb	r1, r3
                    | (1 <<(((FAT_sector - media_ptr -> fx_media_reserved_sectors) / sectors_per_bit) & 7)));
 800f2ca:	69fb      	ldr	r3, [r7, #28]
 800f2cc:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 800f2ce:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 800f2d0:	1a9a      	subs	r2, r3, r2
 800f2d2:	f897 304b 	ldrb.w	r3, [r7, #75]	@ 0x4b
 800f2d6:	fbb2 f3f3 	udiv	r3, r2, r3
 800f2da:	f003 0207 	and.w	r2, r3, #7
 800f2de:	2301      	movs	r3, #1
 800f2e0:	4093      	lsls	r3, r2
 800f2e2:	b25b      	sxtb	r3, r3
 800f2e4:	430b      	orrs	r3, r1
 800f2e6:	b25b      	sxtb	r3, r3
                    (UCHAR)((INT)media_ptr -> fx_media_fat_secondary_update_map[ind]
 800f2e8:	b2d9      	uxtb	r1, r3
                media_ptr -> fx_media_fat_secondary_update_map[ind] = 
 800f2ea:	69fa      	ldr	r2, [r7, #28]
 800f2ec:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f2ee:	4413      	add	r3, r2
 800f2f0:	f503 62fd 	add.w	r2, r3, #2024	@ 0x7e8
 800f2f4:	460b      	mov	r3, r1
 800f2f6:	7013      	strb	r3, [r2, #0]

                /* Determine if the multi-sector flag is set.  */
                if (multi_sector_entry != -1)
 800f2f8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800f2fa:	f1b3 3fff 	cmp.w	r3, #4294967295
 800f2fe:	f000 81af 	beq.w	800f660 <_fx_utility_FAT_flush+0x686>
                {

                    /* Yes, position to the next sector and read it in.  */
                    FAT_sector++;
 800f302:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 800f304:	3301      	adds	r3, #1
 800f306:	657b      	str	r3, [r7, #84]	@ 0x54
                status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 800f308:	e6a5      	b.n	800f056 <_fx_utility_FAT_flush+0x7c>
            }
        }
#ifdef FX_ENABLE_EXFAT
        else if (media_ptr -> fx_media_FAT_type == FX_FAT16)
#else
        else if (!media_ptr -> fx_media_32_bit_FAT)
 800f30a:	69fb      	ldr	r3, [r7, #28]
 800f30c:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 800f30e:	2b00      	cmp	r3, #0
 800f310:	f040 80d2 	bne.w	800f4b8 <_fx_utility_FAT_flush+0x4de>
        {

            /* 16-bit FAT is present.  */

            /* Calculate the byte offset to the cluster entry.  */
            byte_offset =  (((ULONG)cluster) << 1);
 800f314:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f316:	005b      	lsls	r3, r3, #1
 800f318:	63fb      	str	r3, [r7, #60]	@ 0x3c

            /* Calculate the FAT sector the requested FAT entry resides in.  */
            FAT_sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 800f31a:	69fb      	ldr	r3, [r7, #28]
 800f31c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800f31e:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 800f320:	fbb2 f2f3 	udiv	r2, r2, r3
                (ULONG)media_ptr -> fx_media_reserved_sectors;
 800f324:	69fb      	ldr	r3, [r7, #28]
 800f326:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
            FAT_sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 800f328:	4413      	add	r3, r2
 800f32a:	657b      	str	r3, [r7, #84]	@ 0x54

            /* Read the FAT sector.  */
            status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 800f32c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 800f32e:	2200      	movs	r2, #0
 800f330:	469a      	mov	sl, r3
 800f332:	4693      	mov	fp, r2
                                                      media_ptr -> fx_media_memory_buffer, ((ULONG) 1), FX_FAT_SECTOR);
 800f334:	69fb      	ldr	r3, [r7, #28]
 800f336:	689a      	ldr	r2, [r3, #8]
            status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 800f338:	2302      	movs	r3, #2
 800f33a:	9302      	str	r3, [sp, #8]
 800f33c:	2301      	movs	r3, #1
 800f33e:	9301      	str	r3, [sp, #4]
 800f340:	9200      	str	r2, [sp, #0]
 800f342:	4652      	mov	r2, sl
 800f344:	465b      	mov	r3, fp
 800f346:	69f8      	ldr	r0, [r7, #28]
 800f348:	f000 ff38 	bl	80101bc <_fx_utility_logical_sector_read>
 800f34c:	63b8      	str	r0, [r7, #56]	@ 0x38

            /* Determine if an error occurred.  */
            if (status != FX_SUCCESS)
 800f34e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f350:	2b00      	cmp	r3, #0
 800f352:	d001      	beq.n	800f358 <_fx_utility_FAT_flush+0x37e>
            {

                /* Return the error status.  */
                return(status);
 800f354:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f356:	e18c      	b.n	800f672 <_fx_utility_FAT_flush+0x698>
            }

            /* Loop through the remainder of the cache to check for multiple entries
               within the same FAT sector being written out.  */
            for (i = index; i < FX_MAX_FAT_CACHE; i++)
 800f358:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800f35a:	653b      	str	r3, [r7, #80]	@ 0x50
 800f35c:	e057      	b.n	800f40e <_fx_utility_FAT_flush+0x434>
            {

                /* Determine if the entry is dirty.  */
                if (media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_dirty == 0)
 800f35e:	69f9      	ldr	r1, [r7, #28]
 800f360:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 800f362:	4613      	mov	r3, r2
 800f364:	005b      	lsls	r3, r3, #1
 800f366:	4413      	add	r3, r2
 800f368:	009b      	lsls	r3, r3, #2
 800f36a:	440b      	add	r3, r1
 800f36c:	f503 63e6 	add.w	r3, r3, #1840	@ 0x730
 800f370:	681b      	ldr	r3, [r3, #0]
 800f372:	2b00      	cmp	r3, #0
 800f374:	d045      	beq.n	800f402 <_fx_utility_FAT_flush+0x428>
                    /* Not dirty, does not need to be flushed.  */
                    continue;
                }

                /* Isolate the cluster.  */
                cluster = (media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_cluster);
 800f376:	69f9      	ldr	r1, [r7, #28]
 800f378:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 800f37a:	4613      	mov	r3, r2
 800f37c:	005b      	lsls	r3, r3, #1
 800f37e:	4413      	add	r3, r2
 800f380:	009b      	lsls	r3, r3, #2
 800f382:	440b      	add	r3, r1
 800f384:	f503 63e5 	add.w	r3, r3, #1832	@ 0x728
 800f388:	681b      	ldr	r3, [r3, #0]
 800f38a:	643b      	str	r3, [r7, #64]	@ 0x40

                /* Calculate the byte offset to the cluster entry.  */
                byte_offset =  (((ULONG)cluster) * 2);
 800f38c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f38e:	005b      	lsls	r3, r3, #1
 800f390:	63fb      	str	r3, [r7, #60]	@ 0x3c

                /* Pickup the sector.  */
                sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 800f392:	69fb      	ldr	r3, [r7, #28]
 800f394:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800f396:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 800f398:	fbb2 f2f3 	udiv	r2, r2, r3
                    (ULONG)media_ptr -> fx_media_reserved_sectors;
 800f39c:	69fb      	ldr	r3, [r7, #28]
 800f39e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
                sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 800f3a0:	4413      	add	r3, r2
 800f3a2:	633b      	str	r3, [r7, #48]	@ 0x30

                /* Is it the current FAT sector?  */
                if (sector != FAT_sector)
 800f3a4:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 800f3a6:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 800f3a8:	429a      	cmp	r2, r3
 800f3aa:	d12c      	bne.n	800f406 <_fx_utility_FAT_flush+0x42c>
                    continue;
                }

                /* Now calculate the byte offset into this FAT sector.  */
                byte_offset =  byte_offset -
                    ((FAT_sector - (ULONG)media_ptr -> fx_media_reserved_sectors) *
 800f3ac:	69fb      	ldr	r3, [r7, #28]
 800f3ae:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800f3b0:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 800f3b2:	1ad2      	subs	r2, r2, r3
                     media_ptr -> fx_media_bytes_per_sector);
 800f3b4:	69fb      	ldr	r3, [r7, #28]
 800f3b6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
                    ((FAT_sector - (ULONG)media_ptr -> fx_media_reserved_sectors) *
 800f3b8:	fb02 f303 	mul.w	r3, r2, r3
                byte_offset =  byte_offset -
 800f3bc:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 800f3be:	1ad3      	subs	r3, r2, r3
 800f3c0:	63fb      	str	r3, [r7, #60]	@ 0x3c

                /* Setup a pointer into the buffer.  */
                FAT_ptr =  (UCHAR *)media_ptr -> fx_media_memory_buffer + (UINT)byte_offset;
 800f3c2:	69fb      	ldr	r3, [r7, #28]
 800f3c4:	689a      	ldr	r2, [r3, #8]
 800f3c6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800f3c8:	4413      	add	r3, r2
 800f3ca:	62fb      	str	r3, [r7, #44]	@ 0x2c

                /* Pickup new value for this FAT entry.  */
                next_cluster =  media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_value;
 800f3cc:	69f9      	ldr	r1, [r7, #28]
 800f3ce:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 800f3d0:	4613      	mov	r3, r2
 800f3d2:	005b      	lsls	r3, r3, #1
 800f3d4:	4413      	add	r3, r2
 800f3d6:	009b      	lsls	r3, r3, #2
 800f3d8:	440b      	add	r3, r1
 800f3da:	f203 732c 	addw	r3, r3, #1836	@ 0x72c
 800f3de:	681b      	ldr	r3, [r3, #0]
 800f3e0:	62bb      	str	r3, [r7, #40]	@ 0x28

                /* Store the FAT entry.  */
                _fx_utility_16_unsigned_write(FAT_ptr, (UINT)next_cluster);
 800f3e2:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 800f3e4:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 800f3e6:	f7ff fa88 	bl	800e8fa <_fx_utility_16_unsigned_write>

                /* Clear the dirty flag.  */
                media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_dirty = 0;
 800f3ea:	69f9      	ldr	r1, [r7, #28]
 800f3ec:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 800f3ee:	4613      	mov	r3, r2
 800f3f0:	005b      	lsls	r3, r3, #1
 800f3f2:	4413      	add	r3, r2
 800f3f4:	009b      	lsls	r3, r3, #2
 800f3f6:	440b      	add	r3, r1
 800f3f8:	f503 63e6 	add.w	r3, r3, #1840	@ 0x730
 800f3fc:	2200      	movs	r2, #0
 800f3fe:	601a      	str	r2, [r3, #0]
 800f400:	e002      	b.n	800f408 <_fx_utility_FAT_flush+0x42e>
                    continue;
 800f402:	bf00      	nop
 800f404:	e000      	b.n	800f408 <_fx_utility_FAT_flush+0x42e>
                    continue;
 800f406:	bf00      	nop
            for (i = index; i < FX_MAX_FAT_CACHE; i++)
 800f408:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800f40a:	3301      	adds	r3, #1
 800f40c:	653b      	str	r3, [r7, #80]	@ 0x50
 800f40e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800f410:	2b0f      	cmp	r3, #15
 800f412:	d9a4      	bls.n	800f35e <_fx_utility_FAT_flush+0x384>
            }

            /* Write the last written FAT sector out.  */
            status =  _fx_utility_logical_sector_write(media_ptr, (ULONG64) FAT_sector,
 800f414:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 800f416:	2200      	movs	r2, #0
 800f418:	613b      	str	r3, [r7, #16]
 800f41a:	617a      	str	r2, [r7, #20]
                                                       media_ptr -> fx_media_memory_buffer, ((ULONG) 1), FX_FAT_SECTOR);
 800f41c:	69fb      	ldr	r3, [r7, #28]
 800f41e:	689a      	ldr	r2, [r3, #8]
            status =  _fx_utility_logical_sector_write(media_ptr, (ULONG64) FAT_sector,
 800f420:	2302      	movs	r3, #2
 800f422:	9302      	str	r3, [sp, #8]
 800f424:	2301      	movs	r3, #1
 800f426:	9301      	str	r3, [sp, #4]
 800f428:	9200      	str	r2, [sp, #0]
 800f42a:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 800f42e:	69f8      	ldr	r0, [r7, #28]
 800f430:	f001 f958 	bl	80106e4 <_fx_utility_logical_sector_write>
 800f434:	63b8      	str	r0, [r7, #56]	@ 0x38

            /* Determine if an error occurred.  */
            if (status != FX_SUCCESS)
 800f436:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f438:	2b00      	cmp	r3, #0
 800f43a:	d001      	beq.n	800f440 <_fx_utility_FAT_flush+0x466>
            {
                /* Return the error status.  */
                return(status);
 800f43c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f43e:	e118      	b.n	800f672 <_fx_utility_FAT_flush+0x698>
            }

            /* Mark the FAT sector update bit map to indicate this sector has been
               written.  */
            if (media_ptr -> fx_media_sectors_per_FAT % (FX_FAT_MAP_SIZE << 3) == 0)
 800f440:	69fb      	ldr	r3, [r7, #28]
 800f442:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800f444:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800f448:	2b00      	cmp	r3, #0
 800f44a:	d105      	bne.n	800f458 <_fx_utility_FAT_flush+0x47e>
            {
                sectors_per_bit =  (UCHAR)(media_ptr -> fx_media_sectors_per_FAT / (FX_FAT_MAP_SIZE << 3));
 800f44c:	69fb      	ldr	r3, [r7, #28]
 800f44e:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800f450:	0a9b      	lsrs	r3, r3, #10
 800f452:	f887 304b 	strb.w	r3, [r7, #75]	@ 0x4b
 800f456:	e006      	b.n	800f466 <_fx_utility_FAT_flush+0x48c>
            }
            else
            {
                sectors_per_bit =  (UCHAR)((media_ptr -> fx_media_sectors_per_FAT / (FX_FAT_MAP_SIZE << 3)) + 1);
 800f458:	69fb      	ldr	r3, [r7, #28]
 800f45a:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800f45c:	0a9b      	lsrs	r3, r3, #10
 800f45e:	b2db      	uxtb	r3, r3
 800f460:	3301      	adds	r3, #1
 800f462:	f887 304b 	strb.w	r3, [r7, #75]	@ 0x4b
            }
            ind = ((FAT_sector - media_ptr -> fx_media_reserved_sectors) / sectors_per_bit) >> 3;
 800f466:	69fb      	ldr	r3, [r7, #28]
 800f468:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800f46a:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 800f46c:	1ad2      	subs	r2, r2, r3
 800f46e:	f897 304b 	ldrb.w	r3, [r7, #75]	@ 0x4b
 800f472:	fbb2 f3f3 	udiv	r3, r2, r3
 800f476:	08db      	lsrs	r3, r3, #3
 800f478:	637b      	str	r3, [r7, #52]	@ 0x34
            media_ptr -> fx_media_fat_secondary_update_map[ind] = 
                (UCHAR)((INT)media_ptr -> fx_media_fat_secondary_update_map[ind]
 800f47a:	69fa      	ldr	r2, [r7, #28]
 800f47c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f47e:	4413      	add	r3, r2
 800f480:	f503 63fd 	add.w	r3, r3, #2024	@ 0x7e8
 800f484:	781b      	ldrb	r3, [r3, #0]
 800f486:	b259      	sxtb	r1, r3
                | (1 <<(((FAT_sector - media_ptr -> fx_media_reserved_sectors) / sectors_per_bit) & 7)));
 800f488:	69fb      	ldr	r3, [r7, #28]
 800f48a:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 800f48c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 800f48e:	1a9a      	subs	r2, r3, r2
 800f490:	f897 304b 	ldrb.w	r3, [r7, #75]	@ 0x4b
 800f494:	fbb2 f3f3 	udiv	r3, r2, r3
 800f498:	f003 0207 	and.w	r2, r3, #7
 800f49c:	2301      	movs	r3, #1
 800f49e:	4093      	lsls	r3, r2
 800f4a0:	b25b      	sxtb	r3, r3
 800f4a2:	430b      	orrs	r3, r1
 800f4a4:	b25b      	sxtb	r3, r3
                (UCHAR)((INT)media_ptr -> fx_media_fat_secondary_update_map[ind]
 800f4a6:	b2d9      	uxtb	r1, r3
            media_ptr -> fx_media_fat_secondary_update_map[ind] = 
 800f4a8:	69fa      	ldr	r2, [r7, #28]
 800f4aa:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f4ac:	4413      	add	r3, r2
 800f4ae:	f503 62fd 	add.w	r2, r3, #2024	@ 0x7e8
 800f4b2:	460b      	mov	r3, r1
 800f4b4:	7013      	strb	r3, [r2, #0]
 800f4b6:	e0d4      	b.n	800f662 <_fx_utility_FAT_flush+0x688>
        {

            /* 32-bit FAT or exFAT are present.  */

            /* Calculate the byte offset to the cluster entry.  */
            byte_offset =  (((ULONG)cluster) * 4);
 800f4b8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f4ba:	009b      	lsls	r3, r3, #2
 800f4bc:	63fb      	str	r3, [r7, #60]	@ 0x3c

            /* Calculate the FAT sector the requested FAT entry resides in.  */
            FAT_sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 800f4be:	69fb      	ldr	r3, [r7, #28]
 800f4c0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800f4c2:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 800f4c4:	fbb2 f2f3 	udiv	r2, r2, r3
                (ULONG)media_ptr -> fx_media_reserved_sectors;
 800f4c8:	69fb      	ldr	r3, [r7, #28]
 800f4ca:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
            FAT_sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 800f4cc:	4413      	add	r3, r2
 800f4ce:	657b      	str	r3, [r7, #84]	@ 0x54

            /* Read the FAT sector.  */
            status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 800f4d0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 800f4d2:	2200      	movs	r2, #0
 800f4d4:	60bb      	str	r3, [r7, #8]
 800f4d6:	60fa      	str	r2, [r7, #12]
                                                      media_ptr -> fx_media_memory_buffer, ((ULONG) 1), FX_FAT_SECTOR);
 800f4d8:	69fb      	ldr	r3, [r7, #28]
 800f4da:	689a      	ldr	r2, [r3, #8]
            status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 800f4dc:	2302      	movs	r3, #2
 800f4de:	9302      	str	r3, [sp, #8]
 800f4e0:	2301      	movs	r3, #1
 800f4e2:	9301      	str	r3, [sp, #4]
 800f4e4:	9200      	str	r2, [sp, #0]
 800f4e6:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 800f4ea:	69f8      	ldr	r0, [r7, #28]
 800f4ec:	f000 fe66 	bl	80101bc <_fx_utility_logical_sector_read>
 800f4f0:	63b8      	str	r0, [r7, #56]	@ 0x38

            /* Determine if an error occurred.  */
            if (status != FX_SUCCESS)
 800f4f2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f4f4:	2b00      	cmp	r3, #0
 800f4f6:	d001      	beq.n	800f4fc <_fx_utility_FAT_flush+0x522>
            {

                /* Return the error status.  */
                return(status);
 800f4f8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f4fa:	e0ba      	b.n	800f672 <_fx_utility_FAT_flush+0x698>
            }

            /* Loop through the remainder of the cache to check for multiple entries
               within the same FAT sector being written out.  */
            for (i = index; i < FX_MAX_FAT_CACHE; i++)
 800f4fc:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800f4fe:	653b      	str	r3, [r7, #80]	@ 0x50
 800f500:	e057      	b.n	800f5b2 <_fx_utility_FAT_flush+0x5d8>
            {

                /* Determine if the entry is dirty.  */
                if (media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_dirty == 0)
 800f502:	69f9      	ldr	r1, [r7, #28]
 800f504:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 800f506:	4613      	mov	r3, r2
 800f508:	005b      	lsls	r3, r3, #1
 800f50a:	4413      	add	r3, r2
 800f50c:	009b      	lsls	r3, r3, #2
 800f50e:	440b      	add	r3, r1
 800f510:	f503 63e6 	add.w	r3, r3, #1840	@ 0x730
 800f514:	681b      	ldr	r3, [r3, #0]
 800f516:	2b00      	cmp	r3, #0
 800f518:	d045      	beq.n	800f5a6 <_fx_utility_FAT_flush+0x5cc>
                    /* Not dirty, does not need to be flushed.  */
                    continue;
                }

                /* Isolate the cluster.  */
                cluster = (media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_cluster);
 800f51a:	69f9      	ldr	r1, [r7, #28]
 800f51c:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 800f51e:	4613      	mov	r3, r2
 800f520:	005b      	lsls	r3, r3, #1
 800f522:	4413      	add	r3, r2
 800f524:	009b      	lsls	r3, r3, #2
 800f526:	440b      	add	r3, r1
 800f528:	f503 63e5 	add.w	r3, r3, #1832	@ 0x728
 800f52c:	681b      	ldr	r3, [r3, #0]
 800f52e:	643b      	str	r3, [r7, #64]	@ 0x40

                /* Calculate the byte offset to the cluster entry.  */
                byte_offset =  (((ULONG)cluster) * 4);
 800f530:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f532:	009b      	lsls	r3, r3, #2
 800f534:	63fb      	str	r3, [r7, #60]	@ 0x3c

                /* Pickup the sector.  */
                sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 800f536:	69fb      	ldr	r3, [r7, #28]
 800f538:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800f53a:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 800f53c:	fbb2 f2f3 	udiv	r2, r2, r3
                    (ULONG)media_ptr -> fx_media_reserved_sectors;
 800f540:	69fb      	ldr	r3, [r7, #28]
 800f542:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
                sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 800f544:	4413      	add	r3, r2
 800f546:	633b      	str	r3, [r7, #48]	@ 0x30

                /* Is it the current FAT sector?  */
                if (sector != FAT_sector)
 800f548:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 800f54a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 800f54c:	429a      	cmp	r2, r3
 800f54e:	d12c      	bne.n	800f5aa <_fx_utility_FAT_flush+0x5d0>
                    continue;
                }

                /* Now calculate the byte offset into this FAT sector.  */
                byte_offset =  byte_offset -
                    ((FAT_sector - (ULONG)media_ptr -> fx_media_reserved_sectors) *
 800f550:	69fb      	ldr	r3, [r7, #28]
 800f552:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800f554:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 800f556:	1ad2      	subs	r2, r2, r3
                     media_ptr -> fx_media_bytes_per_sector);
 800f558:	69fb      	ldr	r3, [r7, #28]
 800f55a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
                    ((FAT_sector - (ULONG)media_ptr -> fx_media_reserved_sectors) *
 800f55c:	fb02 f303 	mul.w	r3, r2, r3
                byte_offset =  byte_offset -
 800f560:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 800f562:	1ad3      	subs	r3, r2, r3
 800f564:	63fb      	str	r3, [r7, #60]	@ 0x3c

                /* Setup a pointer into the buffer.  */
                FAT_ptr =  (UCHAR *)media_ptr -> fx_media_memory_buffer + (UINT)byte_offset;
 800f566:	69fb      	ldr	r3, [r7, #28]
 800f568:	689a      	ldr	r2, [r3, #8]
 800f56a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800f56c:	4413      	add	r3, r2
 800f56e:	62fb      	str	r3, [r7, #44]	@ 0x2c

                /* Pickup new value for this FAT entry.  */
                next_cluster =  media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_value;
 800f570:	69f9      	ldr	r1, [r7, #28]
 800f572:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 800f574:	4613      	mov	r3, r2
 800f576:	005b      	lsls	r3, r3, #1
 800f578:	4413      	add	r3, r2
 800f57a:	009b      	lsls	r3, r3, #2
 800f57c:	440b      	add	r3, r1
 800f57e:	f203 732c 	addw	r3, r3, #1836	@ 0x72c
 800f582:	681b      	ldr	r3, [r3, #0]
 800f584:	62bb      	str	r3, [r7, #40]	@ 0x28

                /* Store the FAT entry.  */
                _fx_utility_32_unsigned_write(FAT_ptr, next_cluster);
 800f586:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 800f588:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 800f58a:	f7ff f9e8 	bl	800e95e <_fx_utility_32_unsigned_write>

                /* Clear the dirty flag.  */
                media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_dirty = 0;
 800f58e:	69f9      	ldr	r1, [r7, #28]
 800f590:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 800f592:	4613      	mov	r3, r2
 800f594:	005b      	lsls	r3, r3, #1
 800f596:	4413      	add	r3, r2
 800f598:	009b      	lsls	r3, r3, #2
 800f59a:	440b      	add	r3, r1
 800f59c:	f503 63e6 	add.w	r3, r3, #1840	@ 0x730
 800f5a0:	2200      	movs	r2, #0
 800f5a2:	601a      	str	r2, [r3, #0]
 800f5a4:	e002      	b.n	800f5ac <_fx_utility_FAT_flush+0x5d2>
                    continue;
 800f5a6:	bf00      	nop
 800f5a8:	e000      	b.n	800f5ac <_fx_utility_FAT_flush+0x5d2>
                    continue;
 800f5aa:	bf00      	nop
            for (i = index; i < FX_MAX_FAT_CACHE; i++)
 800f5ac:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800f5ae:	3301      	adds	r3, #1
 800f5b0:	653b      	str	r3, [r7, #80]	@ 0x50
 800f5b2:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800f5b4:	2b0f      	cmp	r3, #15
 800f5b6:	d9a4      	bls.n	800f502 <_fx_utility_FAT_flush+0x528>
            }

            /* Write the last written FAT sector out.  */
            status =  _fx_utility_logical_sector_write(media_ptr, (ULONG64) FAT_sector,
 800f5b8:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 800f5ba:	2200      	movs	r2, #0
 800f5bc:	603b      	str	r3, [r7, #0]
 800f5be:	607a      	str	r2, [r7, #4]
                                                       media_ptr -> fx_media_memory_buffer, ((ULONG) 1), FX_FAT_SECTOR);
 800f5c0:	69fb      	ldr	r3, [r7, #28]
 800f5c2:	689a      	ldr	r2, [r3, #8]
            status =  _fx_utility_logical_sector_write(media_ptr, (ULONG64) FAT_sector,
 800f5c4:	2302      	movs	r3, #2
 800f5c6:	9302      	str	r3, [sp, #8]
 800f5c8:	2301      	movs	r3, #1
 800f5ca:	9301      	str	r3, [sp, #4]
 800f5cc:	9200      	str	r2, [sp, #0]
 800f5ce:	e9d7 2300 	ldrd	r2, r3, [r7]
 800f5d2:	69f8      	ldr	r0, [r7, #28]
 800f5d4:	f001 f886 	bl	80106e4 <_fx_utility_logical_sector_write>
 800f5d8:	63b8      	str	r0, [r7, #56]	@ 0x38

            /* Determine if an error occurred.  */
            if (status != FX_SUCCESS)
 800f5da:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f5dc:	2b00      	cmp	r3, #0
 800f5de:	d001      	beq.n	800f5e4 <_fx_utility_FAT_flush+0x60a>
            {

                /* Return the error status.  */
                return(status);
 800f5e0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f5e2:	e046      	b.n	800f672 <_fx_utility_FAT_flush+0x698>
            {
#endif /* FX_ENABLE_EXFAT */

                /* Mark the FAT sector update bit map to indicate this sector has been
                   written.  */
                if (media_ptr -> fx_media_sectors_per_FAT % (FX_FAT_MAP_SIZE << 3) == 0)
 800f5e4:	69fb      	ldr	r3, [r7, #28]
 800f5e6:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800f5e8:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800f5ec:	2b00      	cmp	r3, #0
 800f5ee:	d105      	bne.n	800f5fc <_fx_utility_FAT_flush+0x622>
                {
                    sectors_per_bit =  (UCHAR)(media_ptr -> fx_media_sectors_per_FAT / (FX_FAT_MAP_SIZE << 3));
 800f5f0:	69fb      	ldr	r3, [r7, #28]
 800f5f2:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800f5f4:	0a9b      	lsrs	r3, r3, #10
 800f5f6:	f887 304b 	strb.w	r3, [r7, #75]	@ 0x4b
 800f5fa:	e006      	b.n	800f60a <_fx_utility_FAT_flush+0x630>
                }
                else
                {
                    sectors_per_bit =  (UCHAR)((media_ptr -> fx_media_sectors_per_FAT / (FX_FAT_MAP_SIZE << 3)) + 1);
 800f5fc:	69fb      	ldr	r3, [r7, #28]
 800f5fe:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800f600:	0a9b      	lsrs	r3, r3, #10
 800f602:	b2db      	uxtb	r3, r3
 800f604:	3301      	adds	r3, #1
 800f606:	f887 304b 	strb.w	r3, [r7, #75]	@ 0x4b
                }
                ind = ((FAT_sector - media_ptr -> fx_media_reserved_sectors) / sectors_per_bit) >> 3;
 800f60a:	69fb      	ldr	r3, [r7, #28]
 800f60c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800f60e:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 800f610:	1ad2      	subs	r2, r2, r3
 800f612:	f897 304b 	ldrb.w	r3, [r7, #75]	@ 0x4b
 800f616:	fbb2 f3f3 	udiv	r3, r2, r3
 800f61a:	08db      	lsrs	r3, r3, #3
 800f61c:	637b      	str	r3, [r7, #52]	@ 0x34
                media_ptr -> fx_media_fat_secondary_update_map[ind] = 
                    (UCHAR)((INT)media_ptr -> fx_media_fat_secondary_update_map[ind]
 800f61e:	69fa      	ldr	r2, [r7, #28]
 800f620:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f622:	4413      	add	r3, r2
 800f624:	f503 63fd 	add.w	r3, r3, #2024	@ 0x7e8
 800f628:	781b      	ldrb	r3, [r3, #0]
 800f62a:	b259      	sxtb	r1, r3
                    | (1 <<(((FAT_sector - media_ptr -> fx_media_reserved_sectors) / sectors_per_bit) & 7)));
 800f62c:	69fb      	ldr	r3, [r7, #28]
 800f62e:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 800f630:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 800f632:	1a9a      	subs	r2, r3, r2
 800f634:	f897 304b 	ldrb.w	r3, [r7, #75]	@ 0x4b
 800f638:	fbb2 f3f3 	udiv	r3, r2, r3
 800f63c:	f003 0207 	and.w	r2, r3, #7
 800f640:	2301      	movs	r3, #1
 800f642:	4093      	lsls	r3, r2
 800f644:	b25b      	sxtb	r3, r3
 800f646:	430b      	orrs	r3, r1
 800f648:	b25b      	sxtb	r3, r3
                    (UCHAR)((INT)media_ptr -> fx_media_fat_secondary_update_map[ind]
 800f64a:	b2d9      	uxtb	r1, r3
                media_ptr -> fx_media_fat_secondary_update_map[ind] = 
 800f64c:	69fa      	ldr	r2, [r7, #28]
 800f64e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f650:	4413      	add	r3, r2
 800f652:	f503 62fd 	add.w	r2, r3, #2024	@ 0x7e8
 800f656:	460b      	mov	r3, r1
 800f658:	7013      	strb	r3, [r2, #0]
 800f65a:	e002      	b.n	800f662 <_fx_utility_FAT_flush+0x688>
            continue;
 800f65c:	bf00      	nop
 800f65e:	e000      	b.n	800f662 <_fx_utility_FAT_flush+0x688>
                    break;
 800f660:	bf00      	nop
    for (index = 0; index < FX_MAX_FAT_CACHE; index++)
 800f662:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800f664:	3301      	adds	r3, #1
 800f666:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800f668:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800f66a:	2b0f      	cmp	r3, #15
 800f66c:	f67f acc4 	bls.w	800eff8 <_fx_utility_FAT_flush+0x1e>
        media_ptr -> fx_media_fault_tolerant_cached_FAT_sector = 0;
    }
#endif /* FX_ENABLE_FAULT_TOLERANT */

    /* Return successful status.  */
    return(FX_SUCCESS);
 800f670:	2300      	movs	r3, #0
}
 800f672:	4618      	mov	r0, r3
 800f674:	3758      	adds	r7, #88	@ 0x58
 800f676:	46bd      	mov	sp, r7
 800f678:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

0800f67c <_fx_utility_FAT_map_flush>:
/*  09-30-2020     William E. Lamie         Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _fx_utility_FAT_map_flush(FX_MEDIA *media_ptr)
{
 800f67c:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 800f680:	b092      	sub	sp, #72	@ 0x48
 800f682:	af04      	add	r7, sp, #16
 800f684:	61f8      	str	r0, [r7, #28]
       or more primary FAT sectors. Because of this, it is possible some FAT sectors that
       were not changed may get flushed out to the secondary FAT.  However, this method
       provides very nice performance benefits during normal operation and is much more
       reasonable than performing a total copy of the primary FAT to each secondary FAT
       on media flush and media close.  */
    if (media_ptr -> fx_media_sectors_per_FAT % (FX_FAT_MAP_SIZE << 3) == 0)
 800f686:	69fb      	ldr	r3, [r7, #28]
 800f688:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800f68a:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800f68e:	2b00      	cmp	r3, #0
 800f690:	d105      	bne.n	800f69e <_fx_utility_FAT_map_flush+0x22>
    {
        sectors_per_bit =  (UCHAR)(media_ptr -> fx_media_sectors_per_FAT / (FX_FAT_MAP_SIZE << 3));
 800f692:	69fb      	ldr	r3, [r7, #28]
 800f694:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800f696:	0a9b      	lsrs	r3, r3, #10
 800f698:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
 800f69c:	e006      	b.n	800f6ac <_fx_utility_FAT_map_flush+0x30>
    }
    else
    {
        sectors_per_bit =  (UCHAR)(media_ptr -> fx_media_sectors_per_FAT / (FX_FAT_MAP_SIZE << 3) + 1);
 800f69e:	69fb      	ldr	r3, [r7, #28]
 800f6a0:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800f6a2:	0a9b      	lsrs	r3, r3, #10
 800f6a4:	b2db      	uxtb	r3, r3
 800f6a6:	3301      	adds	r3, #1
 800f6a8:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    }

    /* Loop through the FAT update map to mirror primary FAT sectors to secondary FAT(s).  */
    for (i = 0; i < FX_FAT_MAP_SIZE << 3; i++)
 800f6ac:	2300      	movs	r3, #0
 800f6ae:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800f6b0:	e089      	b.n	800f7c6 <_fx_utility_FAT_map_flush+0x14a>
    {

        /* Determine if there are FAT changes specified by this entry.  */
        if ((media_ptr -> fx_media_fat_secondary_update_map[i >> 3] & (1 << (i & 7))) == 0)
 800f6b2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800f6b4:	08db      	lsrs	r3, r3, #3
 800f6b6:	69fa      	ldr	r2, [r7, #28]
 800f6b8:	4413      	add	r3, r2
 800f6ba:	f893 37e8 	ldrb.w	r3, [r3, #2024]	@ 0x7e8
 800f6be:	461a      	mov	r2, r3
 800f6c0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800f6c2:	f003 0307 	and.w	r3, r3, #7
 800f6c6:	fa42 f303 	asr.w	r3, r2, r3
 800f6ca:	f003 0301 	and.w	r3, r3, #1
 800f6ce:	2b00      	cmp	r3, #0
 800f6d0:	d075      	beq.n	800f7be <_fx_utility_FAT_map_flush+0x142>
            /* No, look at the next bit map entry.  */
            continue;
        }

        /* Setup the parameters for performing the update.  */
        FAT_sector =    i * sectors_per_bit + media_ptr -> fx_media_reserved_sectors;
 800f6d2:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 800f6d6:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800f6d8:	fb03 f202 	mul.w	r2, r3, r2
 800f6dc:	69fb      	ldr	r3, [r7, #28]
 800f6de:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800f6e0:	4413      	add	r3, r2
 800f6e2:	637b      	str	r3, [r7, #52]	@ 0x34
        last_sector =   FAT_sector + sectors_per_bit;
 800f6e4:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 800f6e8:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 800f6ea:	4413      	add	r3, r2
 800f6ec:	633b      	str	r3, [r7, #48]	@ 0x30

        /* Make sure the last update sector is within range.  */
        if (last_sector > (media_ptr -> fx_media_sectors_per_FAT + media_ptr -> fx_media_reserved_sectors))
 800f6ee:	69fb      	ldr	r3, [r7, #28]
 800f6f0:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
 800f6f2:	69fb      	ldr	r3, [r7, #28]
 800f6f4:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800f6f6:	4413      	add	r3, r2
 800f6f8:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 800f6fa:	429a      	cmp	r2, r3
 800f6fc:	d95a      	bls.n	800f7b4 <_fx_utility_FAT_map_flush+0x138>
        {
            last_sector =  media_ptr -> fx_media_sectors_per_FAT + media_ptr -> fx_media_reserved_sectors;
 800f6fe:	69fb      	ldr	r3, [r7, #28]
 800f700:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
 800f702:	69fb      	ldr	r3, [r7, #28]
 800f704:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800f706:	4413      	add	r3, r2
 800f708:	633b      	str	r3, [r7, #48]	@ 0x30
        }

        /* Loop to mirror primary FAT sectors to secondary FAT(s).  */
        for (; FAT_sector < last_sector; FAT_sector++)
 800f70a:	e053      	b.n	800f7b4 <_fx_utility_FAT_map_flush+0x138>
        {

            /* Read the FAT sector.  */
            status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 800f70c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f70e:	2200      	movs	r2, #0
 800f710:	613b      	str	r3, [r7, #16]
 800f712:	617a      	str	r2, [r7, #20]
                                                      media_ptr -> fx_media_memory_buffer, ((ULONG) 1), FX_FAT_SECTOR);
 800f714:	69fb      	ldr	r3, [r7, #28]
 800f716:	689a      	ldr	r2, [r3, #8]
            status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 800f718:	2302      	movs	r3, #2
 800f71a:	9302      	str	r3, [sp, #8]
 800f71c:	2301      	movs	r3, #1
 800f71e:	9301      	str	r3, [sp, #4]
 800f720:	9200      	str	r2, [sp, #0]
 800f722:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 800f726:	69f8      	ldr	r0, [r7, #28]
 800f728:	f000 fd48 	bl	80101bc <_fx_utility_logical_sector_read>
 800f72c:	6238      	str	r0, [r7, #32]

            /* Determine if an error occurred.  */
            if (status != FX_SUCCESS)
 800f72e:	6a3b      	ldr	r3, [r7, #32]
 800f730:	2b00      	cmp	r3, #0
 800f732:	d001      	beq.n	800f738 <_fx_utility_FAT_map_flush+0xbc>
            {
                /* Return the error status.  */
                return(status);
 800f734:	6a3b      	ldr	r3, [r7, #32]
 800f736:	e05c      	b.n	800f7f2 <_fx_utility_FAT_map_flush+0x176>
            }

            /* Pickup how many secondary FATs there are.  */
            FATs =  media_ptr -> fx_media_number_of_FATs - 1;
 800f738:	69fb      	ldr	r3, [r7, #28]
 800f73a:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800f73c:	3b01      	subs	r3, #1
 800f73e:	62bb      	str	r3, [r7, #40]	@ 0x28

            /* Loop to update additional FAT entries.  */
            while (FATs)
 800f740:	e032      	b.n	800f7a8 <_fx_utility_FAT_map_flush+0x12c>
            {

                /* Mirror main FAT sector write into the additional FATs.  */
                status =  _fx_utility_logical_sector_write(media_ptr,
                                                           ((ULONG64) FAT_sector) + ((ULONG64)FATs * (ULONG64)(media_ptr -> fx_media_sectors_per_FAT)),
 800f742:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f744:	2200      	movs	r2, #0
 800f746:	60bb      	str	r3, [r7, #8]
 800f748:	60fa      	str	r2, [r7, #12]
 800f74a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800f74c:	2200      	movs	r2, #0
 800f74e:	4698      	mov	r8, r3
 800f750:	4691      	mov	r9, r2
 800f752:	69fb      	ldr	r3, [r7, #28]
 800f754:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800f756:	2200      	movs	r2, #0
 800f758:	469a      	mov	sl, r3
 800f75a:	4693      	mov	fp, r2
 800f75c:	fb0a f209 	mul.w	r2, sl, r9
 800f760:	fb08 f30b 	mul.w	r3, r8, fp
 800f764:	4413      	add	r3, r2
 800f766:	fba8 450a 	umull	r4, r5, r8, sl
 800f76a:	442b      	add	r3, r5
 800f76c:	461d      	mov	r5, r3
                status =  _fx_utility_logical_sector_write(media_ptr,
 800f76e:	e9d7 1202 	ldrd	r1, r2, [r7, #8]
 800f772:	460b      	mov	r3, r1
 800f774:	191b      	adds	r3, r3, r4
 800f776:	603b      	str	r3, [r7, #0]
 800f778:	4613      	mov	r3, r2
 800f77a:	416b      	adcs	r3, r5
 800f77c:	607b      	str	r3, [r7, #4]
                                                           media_ptr -> fx_media_memory_buffer, ((ULONG) 1), FX_FAT_SECTOR);
 800f77e:	69fb      	ldr	r3, [r7, #28]
 800f780:	689a      	ldr	r2, [r3, #8]
                status =  _fx_utility_logical_sector_write(media_ptr,
 800f782:	2302      	movs	r3, #2
 800f784:	9302      	str	r3, [sp, #8]
 800f786:	2301      	movs	r3, #1
 800f788:	9301      	str	r3, [sp, #4]
 800f78a:	9200      	str	r2, [sp, #0]
 800f78c:	e9d7 2300 	ldrd	r2, r3, [r7]
 800f790:	69f8      	ldr	r0, [r7, #28]
 800f792:	f000 ffa7 	bl	80106e4 <_fx_utility_logical_sector_write>
 800f796:	6238      	str	r0, [r7, #32]

                /* Determine if an error occurred.  */
                if (status != FX_SUCCESS)
 800f798:	6a3b      	ldr	r3, [r7, #32]
 800f79a:	2b00      	cmp	r3, #0
 800f79c:	d001      	beq.n	800f7a2 <_fx_utility_FAT_map_flush+0x126>
                {

                    /* Return the error status.  */
                    return(status);
 800f79e:	6a3b      	ldr	r3, [r7, #32]
 800f7a0:	e027      	b.n	800f7f2 <_fx_utility_FAT_map_flush+0x176>
                }

                /* Decrement the number of FATs.  */
                FATs--;
 800f7a2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800f7a4:	3b01      	subs	r3, #1
 800f7a6:	62bb      	str	r3, [r7, #40]	@ 0x28
            while (FATs)
 800f7a8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800f7aa:	2b00      	cmp	r3, #0
 800f7ac:	d1c9      	bne.n	800f742 <_fx_utility_FAT_map_flush+0xc6>
        for (; FAT_sector < last_sector; FAT_sector++)
 800f7ae:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f7b0:	3301      	adds	r3, #1
 800f7b2:	637b      	str	r3, [r7, #52]	@ 0x34
 800f7b4:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 800f7b6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800f7b8:	429a      	cmp	r2, r3
 800f7ba:	d3a7      	bcc.n	800f70c <_fx_utility_FAT_map_flush+0x90>
 800f7bc:	e000      	b.n	800f7c0 <_fx_utility_FAT_map_flush+0x144>
            continue;
 800f7be:	bf00      	nop
    for (i = 0; i < FX_FAT_MAP_SIZE << 3; i++)
 800f7c0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800f7c2:	3301      	adds	r3, #1
 800f7c4:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800f7c6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800f7c8:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 800f7cc:	f4ff af71 	bcc.w	800f6b2 <_fx_utility_FAT_map_flush+0x36>
            }
        }
    }

    /* Clear the bit map that indicates primary FAT updates.  */
    for (i = 0; i < FX_FAT_MAP_SIZE; i++)
 800f7d0:	2300      	movs	r3, #0
 800f7d2:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800f7d4:	e009      	b.n	800f7ea <_fx_utility_FAT_map_flush+0x16e>
    {

        /* Clear each entry in the bit map.  */
        media_ptr -> fx_media_fat_secondary_update_map[i] =  0;
 800f7d6:	69fa      	ldr	r2, [r7, #28]
 800f7d8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800f7da:	4413      	add	r3, r2
 800f7dc:	f503 63fd 	add.w	r3, r3, #2024	@ 0x7e8
 800f7e0:	2200      	movs	r2, #0
 800f7e2:	701a      	strb	r2, [r3, #0]
    for (i = 0; i < FX_FAT_MAP_SIZE; i++)
 800f7e4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800f7e6:	3301      	adds	r3, #1
 800f7e8:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800f7ea:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800f7ec:	2b7f      	cmp	r3, #127	@ 0x7f
 800f7ee:	d9f2      	bls.n	800f7d6 <_fx_utility_FAT_map_flush+0x15a>
    }

    /* Return a successful completion.  */
    return(FX_SUCCESS);
 800f7f0:	2300      	movs	r3, #0
}
 800f7f2:	4618      	mov	r0, r3
 800f7f4:	3738      	adds	r7, #56	@ 0x38
 800f7f6:	46bd      	mov	sp, r7
 800f7f8:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

0800f7fc <_fx_utility_logical_sector_cache_entry_read>:
/*                                            resulting in version 6.1.10 */
/*                                                                        */
/**************************************************************************/
FX_CACHED_SECTOR  *_fx_utility_logical_sector_cache_entry_read(FX_MEDIA *media_ptr, ULONG64 logical_sector,
                                                               FX_CACHED_SECTOR **previous_cache_entry)
{
 800f7fc:	b480      	push	{r7}
 800f7fe:	b08f      	sub	sp, #60	@ 0x3c
 800f800:	af00      	add	r7, sp, #0
 800f802:	60f8      	str	r0, [r7, #12]
 800f804:	e9c7 2300 	strd	r2, r3, [r7]
ULONG             cache_size;
ULONG             index;


    /* Determine if the logical sector cache access should use the hash function.  */
    if (media_ptr -> fx_media_sector_cache_hashed)
 800f808:	68fb      	ldr	r3, [r7, #12]
 800f80a:	691b      	ldr	r3, [r3, #16]
 800f80c:	2b00      	cmp	r3, #0
 800f80e:	f000 8275 	beq.w	800fcfc <_fx_utility_logical_sector_cache_entry_read+0x500>

        /* Calculate the area of the cache for this logical sector.  */

        /* First compute the hashed value of this index by simply using the lower bits of
           the sector number.  */
        index =  (ULONG)(logical_sector & media_ptr -> fx_media_sector_cache_hash_mask);
 800f812:	683a      	ldr	r2, [r7, #0]
 800f814:	68fb      	ldr	r3, [r7, #12]
 800f816:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 800f81a:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
 800f81e:	4013      	ands	r3, r2
 800f820:	62fb      	str	r3, [r7, #44]	@ 0x2c

        /* Set the bit indicating there is one or more valid sectors at this cache index.  */
        media_ptr -> fx_media_sector_cache_hashed_sector_valid |=  ((ULONG)1) << (index % 32);
 800f822:	68fb      	ldr	r3, [r7, #12]
 800f824:	6a1a      	ldr	r2, [r3, #32]
 800f826:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800f828:	f003 031f 	and.w	r3, r3, #31
 800f82c:	2101      	movs	r1, #1
 800f82e:	fa01 f303 	lsl.w	r3, r1, r3
 800f832:	431a      	orrs	r2, r3
 800f834:	68fb      	ldr	r3, [r7, #12]
 800f836:	621a      	str	r2, [r3, #32]

        /* Compute the actual array index by multiplying by the cache depth.  */
        index =  index * FX_SECTOR_CACHE_DEPTH;
 800f838:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800f83a:	009b      	lsls	r3, r3, #2
 800f83c:	62fb      	str	r3, [r7, #44]	@ 0x2c

        /* Build a pointer to the cache entry.  */
        cache_entry =  &(media_ptr -> fx_media_sector_cache[index]);
 800f83e:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800f840:	4613      	mov	r3, r2
 800f842:	005b      	lsls	r3, r3, #1
 800f844:	4413      	add	r3, r2
 800f846:	00db      	lsls	r3, r3, #3
 800f848:	f503 6347 	add.w	r3, r3, #3184	@ 0xc70
 800f84c:	68fa      	ldr	r2, [r7, #12]
 800f84e:	4413      	add	r3, r2
 800f850:	637b      	str	r3, [r7, #52]	@ 0x34

        /* Determine if the logical sector is in the cache - assuming the depth of the
           sector cache is 4 entries.  */
        if ((cache_entry -> fx_cached_sector_valid) && (cache_entry -> fx_cached_sector == logical_sector))
 800f852:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f854:	7c5b      	ldrb	r3, [r3, #17]
 800f856:	2b00      	cmp	r3, #0
 800f858:	d015      	beq.n	800f886 <_fx_utility_logical_sector_cache_entry_read+0x8a>
 800f85a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f85c:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800f860:	e9d7 0100 	ldrd	r0, r1, [r7]
 800f864:	4299      	cmp	r1, r3
 800f866:	bf08      	it	eq
 800f868:	4290      	cmpeq	r0, r2
 800f86a:	d10c      	bne.n	800f886 <_fx_utility_logical_sector_cache_entry_read+0x8a>
        {

            /* Yes, we found a match.  Simply setup the pointer to this
               buffer and return.  */
            media_ptr -> fx_media_memory_buffer =  cache_entry -> fx_cached_sector_memory_buffer;
 800f86c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f86e:	681a      	ldr	r2, [r3, #0]
 800f870:	68fb      	ldr	r3, [r7, #12]
 800f872:	609a      	str	r2, [r3, #8]

#ifndef FX_MEDIA_STATISTICS_DISABLE

            /* Increment the number of logical sectors cache read hits.  */
            media_ptr -> fx_media_logical_sector_cache_read_hits++;
 800f874:	68fb      	ldr	r3, [r7, #12]
 800f876:	f8d3 31a4 	ldr.w	r3, [r3, #420]	@ 0x1a4
 800f87a:	1c5a      	adds	r2, r3, #1
 800f87c:	68fb      	ldr	r3, [r7, #12]
 800f87e:	f8c3 21a4 	str.w	r2, [r3, #420]	@ 0x1a4
#endif
            /* Success, return to caller immediately!  */
            return(FX_NULL);
 800f882:	2300      	movs	r3, #0
 800f884:	e27e      	b.n	800fd84 <_fx_utility_logical_sector_cache_entry_read+0x588>
        }
        else if (((cache_entry + 1) -> fx_cached_sector_valid) && ((cache_entry + 1) -> fx_cached_sector == logical_sector))
 800f886:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f888:	3318      	adds	r3, #24
 800f88a:	7c5b      	ldrb	r3, [r3, #17]
 800f88c:	2b00      	cmp	r3, #0
 800f88e:	d060      	beq.n	800f952 <_fx_utility_logical_sector_cache_entry_read+0x156>
 800f890:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f892:	3318      	adds	r3, #24
 800f894:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800f898:	e9d7 0100 	ldrd	r0, r1, [r7]
 800f89c:	4299      	cmp	r1, r3
 800f89e:	bf08      	it	eq
 800f8a0:	4290      	cmpeq	r0, r2
 800f8a2:	d156      	bne.n	800f952 <_fx_utility_logical_sector_cache_entry_read+0x156>
        {

            /* Yes, we found a match.  Simply setup the pointer to this
               buffer and return.  */
            media_ptr -> fx_media_memory_buffer =  (cache_entry + 1) -> fx_cached_sector_memory_buffer;
 800f8a4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f8a6:	3318      	adds	r3, #24
 800f8a8:	681a      	ldr	r2, [r3, #0]
 800f8aa:	68fb      	ldr	r3, [r7, #12]
 800f8ac:	609a      	str	r2, [r3, #8]

#ifndef FX_MEDIA_STATISTICS_DISABLE

            /* Increment the number of logical sectors cache read hits.  */
            media_ptr -> fx_media_logical_sector_cache_read_hits++;
 800f8ae:	68fb      	ldr	r3, [r7, #12]
 800f8b0:	f8d3 31a4 	ldr.w	r3, [r3, #420]	@ 0x1a4
 800f8b4:	1c5a      	adds	r2, r3, #1
 800f8b6:	68fb      	ldr	r3, [r7, #12]
 800f8b8:	f8c3 21a4 	str.w	r2, [r3, #420]	@ 0x1a4
#endif

            /* Swap the first and second cache entries to keep the most recently used
               at the top.  */
            temp_storage.fx_cached_sector_memory_buffer =           (cache_entry) -> fx_cached_sector_memory_buffer;
 800f8bc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f8be:	681b      	ldr	r3, [r3, #0]
 800f8c0:	613b      	str	r3, [r7, #16]
            temp_storage.fx_cached_sector =                         (cache_entry) -> fx_cached_sector;
 800f8c2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f8c4:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800f8c8:	e9c7 2306 	strd	r2, r3, [r7, #24]
            temp_storage.fx_cached_sector_buffer_dirty =            (cache_entry) -> fx_cached_sector_buffer_dirty;
 800f8cc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f8ce:	7c1b      	ldrb	r3, [r3, #16]
 800f8d0:	f887 3020 	strb.w	r3, [r7, #32]
            temp_storage.fx_cached_sector_valid =                   (cache_entry) -> fx_cached_sector_valid;
 800f8d4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f8d6:	7c5b      	ldrb	r3, [r3, #17]
 800f8d8:	f887 3021 	strb.w	r3, [r7, #33]	@ 0x21
            temp_storage.fx_cached_sector_type =                    (cache_entry) -> fx_cached_sector_type;
 800f8dc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f8de:	7c9b      	ldrb	r3, [r3, #18]
 800f8e0:	f887 3022 	strb.w	r3, [r7, #34]	@ 0x22

            (cache_entry) -> fx_cached_sector_memory_buffer =       (cache_entry + 1) -> fx_cached_sector_memory_buffer;
 800f8e4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f8e6:	3318      	adds	r3, #24
 800f8e8:	681a      	ldr	r2, [r3, #0]
 800f8ea:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f8ec:	601a      	str	r2, [r3, #0]
            (cache_entry) -> fx_cached_sector =                     (cache_entry + 1) -> fx_cached_sector;
 800f8ee:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f8f0:	3318      	adds	r3, #24
 800f8f2:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800f8f6:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 800f8f8:	e9c1 2302 	strd	r2, r3, [r1, #8]
            (cache_entry) -> fx_cached_sector_buffer_dirty =        (cache_entry + 1) -> fx_cached_sector_buffer_dirty;
 800f8fc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f8fe:	3318      	adds	r3, #24
 800f900:	7c1a      	ldrb	r2, [r3, #16]
 800f902:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f904:	741a      	strb	r2, [r3, #16]
            (cache_entry) -> fx_cached_sector_valid =               (cache_entry + 1) -> fx_cached_sector_valid;
 800f906:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f908:	3318      	adds	r3, #24
 800f90a:	7c5a      	ldrb	r2, [r3, #17]
 800f90c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f90e:	745a      	strb	r2, [r3, #17]
            (cache_entry) -> fx_cached_sector_type =                (cache_entry + 1) -> fx_cached_sector_type;
 800f910:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f912:	3318      	adds	r3, #24
 800f914:	7c9a      	ldrb	r2, [r3, #18]
 800f916:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f918:	749a      	strb	r2, [r3, #18]

            (cache_entry + 1) -> fx_cached_sector_memory_buffer =   temp_storage.fx_cached_sector_memory_buffer;
 800f91a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f91c:	3318      	adds	r3, #24
 800f91e:	693a      	ldr	r2, [r7, #16]
 800f920:	601a      	str	r2, [r3, #0]
            (cache_entry + 1) -> fx_cached_sector =                 temp_storage.fx_cached_sector;
 800f922:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f924:	f103 0118 	add.w	r1, r3, #24
 800f928:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 800f92c:	e9c1 2302 	strd	r2, r3, [r1, #8]
            (cache_entry + 1) -> fx_cached_sector_buffer_dirty =    temp_storage.fx_cached_sector_buffer_dirty;
 800f930:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f932:	3318      	adds	r3, #24
 800f934:	f897 2020 	ldrb.w	r2, [r7, #32]
 800f938:	741a      	strb	r2, [r3, #16]
            (cache_entry + 1) -> fx_cached_sector_valid =           temp_storage.fx_cached_sector_valid;
 800f93a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f93c:	3318      	adds	r3, #24
 800f93e:	f897 2021 	ldrb.w	r2, [r7, #33]	@ 0x21
 800f942:	745a      	strb	r2, [r3, #17]
            (cache_entry + 1) -> fx_cached_sector_type =            temp_storage.fx_cached_sector_type;
 800f944:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f946:	3318      	adds	r3, #24
 800f948:	f897 2022 	ldrb.w	r2, [r7, #34]	@ 0x22
 800f94c:	749a      	strb	r2, [r3, #18]

            /* Success, return to caller immediately!  */
            return(FX_NULL);
 800f94e:	2300      	movs	r3, #0
 800f950:	e218      	b.n	800fd84 <_fx_utility_logical_sector_cache_entry_read+0x588>
        }
        else if (((cache_entry + 2) -> fx_cached_sector_valid) && ((cache_entry + 2) -> fx_cached_sector == logical_sector))
 800f952:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f954:	3330      	adds	r3, #48	@ 0x30
 800f956:	7c5b      	ldrb	r3, [r3, #17]
 800f958:	2b00      	cmp	r3, #0
 800f95a:	f000 8086 	beq.w	800fa6a <_fx_utility_logical_sector_cache_entry_read+0x26e>
 800f95e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f960:	3330      	adds	r3, #48	@ 0x30
 800f962:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800f966:	e9d7 0100 	ldrd	r0, r1, [r7]
 800f96a:	4299      	cmp	r1, r3
 800f96c:	bf08      	it	eq
 800f96e:	4290      	cmpeq	r0, r2
 800f970:	d17b      	bne.n	800fa6a <_fx_utility_logical_sector_cache_entry_read+0x26e>
        {

            /* Yes, we found a match.  Simply setup the pointer to this
               buffer and return.  */
            media_ptr -> fx_media_memory_buffer =  (cache_entry + 2) -> fx_cached_sector_memory_buffer;
 800f972:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f974:	3330      	adds	r3, #48	@ 0x30
 800f976:	681a      	ldr	r2, [r3, #0]
 800f978:	68fb      	ldr	r3, [r7, #12]
 800f97a:	609a      	str	r2, [r3, #8]

#ifndef FX_MEDIA_STATISTICS_DISABLE

            /* Increment the number of logical sectors cache read hits.  */
            media_ptr -> fx_media_logical_sector_cache_read_hits++;
 800f97c:	68fb      	ldr	r3, [r7, #12]
 800f97e:	f8d3 31a4 	ldr.w	r3, [r3, #420]	@ 0x1a4
 800f982:	1c5a      	adds	r2, r3, #1
 800f984:	68fb      	ldr	r3, [r7, #12]
 800f986:	f8c3 21a4 	str.w	r2, [r3, #420]	@ 0x1a4
#endif

            /* Move the third entry to the top and the first two entries down.  */
            temp_storage.fx_cached_sector_memory_buffer =           (cache_entry) -> fx_cached_sector_memory_buffer;
 800f98a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f98c:	681b      	ldr	r3, [r3, #0]
 800f98e:	613b      	str	r3, [r7, #16]
            temp_storage.fx_cached_sector =                         (cache_entry) -> fx_cached_sector;
 800f990:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f992:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800f996:	e9c7 2306 	strd	r2, r3, [r7, #24]
            temp_storage.fx_cached_sector_buffer_dirty =            (cache_entry) -> fx_cached_sector_buffer_dirty;
 800f99a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f99c:	7c1b      	ldrb	r3, [r3, #16]
 800f99e:	f887 3020 	strb.w	r3, [r7, #32]
            temp_storage.fx_cached_sector_valid =                   (cache_entry) -> fx_cached_sector_valid;
 800f9a2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f9a4:	7c5b      	ldrb	r3, [r3, #17]
 800f9a6:	f887 3021 	strb.w	r3, [r7, #33]	@ 0x21
            temp_storage.fx_cached_sector_type =                    (cache_entry) -> fx_cached_sector_type;
 800f9aa:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f9ac:	7c9b      	ldrb	r3, [r3, #18]
 800f9ae:	f887 3022 	strb.w	r3, [r7, #34]	@ 0x22

            (cache_entry) -> fx_cached_sector_memory_buffer =       (cache_entry + 2) -> fx_cached_sector_memory_buffer;
 800f9b2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f9b4:	3330      	adds	r3, #48	@ 0x30
 800f9b6:	681a      	ldr	r2, [r3, #0]
 800f9b8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f9ba:	601a      	str	r2, [r3, #0]
            (cache_entry) -> fx_cached_sector =                     (cache_entry + 2) -> fx_cached_sector;
 800f9bc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f9be:	3330      	adds	r3, #48	@ 0x30
 800f9c0:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800f9c4:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 800f9c6:	e9c1 2302 	strd	r2, r3, [r1, #8]
            (cache_entry) -> fx_cached_sector_buffer_dirty =        (cache_entry + 2) -> fx_cached_sector_buffer_dirty;
 800f9ca:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f9cc:	3330      	adds	r3, #48	@ 0x30
 800f9ce:	7c1a      	ldrb	r2, [r3, #16]
 800f9d0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f9d2:	741a      	strb	r2, [r3, #16]
            (cache_entry) -> fx_cached_sector_valid =               (cache_entry + 2) -> fx_cached_sector_valid;
 800f9d4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f9d6:	3330      	adds	r3, #48	@ 0x30
 800f9d8:	7c5a      	ldrb	r2, [r3, #17]
 800f9da:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f9dc:	745a      	strb	r2, [r3, #17]
            (cache_entry) -> fx_cached_sector_type =                (cache_entry + 2) -> fx_cached_sector_type;
 800f9de:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f9e0:	3330      	adds	r3, #48	@ 0x30
 800f9e2:	7c9a      	ldrb	r2, [r3, #18]
 800f9e4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f9e6:	749a      	strb	r2, [r3, #18]

            (cache_entry + 2) -> fx_cached_sector_memory_buffer =   (cache_entry + 1) -> fx_cached_sector_memory_buffer;
 800f9e8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f9ea:	f103 0218 	add.w	r2, r3, #24
 800f9ee:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f9f0:	3330      	adds	r3, #48	@ 0x30
 800f9f2:	6812      	ldr	r2, [r2, #0]
 800f9f4:	601a      	str	r2, [r3, #0]
            (cache_entry + 2) -> fx_cached_sector =                 (cache_entry + 1) -> fx_cached_sector;
 800f9f6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f9f8:	3318      	adds	r3, #24
 800f9fa:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 800f9fc:	f102 0130 	add.w	r1, r2, #48	@ 0x30
 800fa00:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800fa04:	e9c1 2302 	strd	r2, r3, [r1, #8]
            (cache_entry + 2) -> fx_cached_sector_buffer_dirty =    (cache_entry + 1) -> fx_cached_sector_buffer_dirty;
 800fa08:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fa0a:	f103 0218 	add.w	r2, r3, #24
 800fa0e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fa10:	3330      	adds	r3, #48	@ 0x30
 800fa12:	7c12      	ldrb	r2, [r2, #16]
 800fa14:	741a      	strb	r2, [r3, #16]
            (cache_entry + 2) -> fx_cached_sector_valid =           (cache_entry + 1) -> fx_cached_sector_valid;
 800fa16:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fa18:	f103 0218 	add.w	r2, r3, #24
 800fa1c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fa1e:	3330      	adds	r3, #48	@ 0x30
 800fa20:	7c52      	ldrb	r2, [r2, #17]
 800fa22:	745a      	strb	r2, [r3, #17]
            (cache_entry + 2) -> fx_cached_sector_type =            (cache_entry + 1) -> fx_cached_sector_type;
 800fa24:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fa26:	f103 0218 	add.w	r2, r3, #24
 800fa2a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fa2c:	3330      	adds	r3, #48	@ 0x30
 800fa2e:	7c92      	ldrb	r2, [r2, #18]
 800fa30:	749a      	strb	r2, [r3, #18]

            (cache_entry + 1) -> fx_cached_sector_memory_buffer =   temp_storage.fx_cached_sector_memory_buffer;
 800fa32:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fa34:	3318      	adds	r3, #24
 800fa36:	693a      	ldr	r2, [r7, #16]
 800fa38:	601a      	str	r2, [r3, #0]
            (cache_entry + 1) -> fx_cached_sector =                 temp_storage.fx_cached_sector;
 800fa3a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fa3c:	f103 0118 	add.w	r1, r3, #24
 800fa40:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 800fa44:	e9c1 2302 	strd	r2, r3, [r1, #8]
            (cache_entry + 1) -> fx_cached_sector_buffer_dirty =    temp_storage.fx_cached_sector_buffer_dirty;
 800fa48:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fa4a:	3318      	adds	r3, #24
 800fa4c:	f897 2020 	ldrb.w	r2, [r7, #32]
 800fa50:	741a      	strb	r2, [r3, #16]
            (cache_entry + 1) -> fx_cached_sector_valid =           temp_storage.fx_cached_sector_valid;
 800fa52:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fa54:	3318      	adds	r3, #24
 800fa56:	f897 2021 	ldrb.w	r2, [r7, #33]	@ 0x21
 800fa5a:	745a      	strb	r2, [r3, #17]
            (cache_entry + 1) -> fx_cached_sector_type =            temp_storage.fx_cached_sector_type;
 800fa5c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fa5e:	3318      	adds	r3, #24
 800fa60:	f897 2022 	ldrb.w	r2, [r7, #34]	@ 0x22
 800fa64:	749a      	strb	r2, [r3, #18]

            /* Success, return to caller immediately!  */
            return(FX_NULL);
 800fa66:	2300      	movs	r3, #0
 800fa68:	e18c      	b.n	800fd84 <_fx_utility_logical_sector_cache_entry_read+0x588>
        }
        else if (((cache_entry + 3) -> fx_cached_sector_valid) && ((cache_entry + 3) -> fx_cached_sector == logical_sector))
 800fa6a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fa6c:	3348      	adds	r3, #72	@ 0x48
 800fa6e:	7c5b      	ldrb	r3, [r3, #17]
 800fa70:	2b00      	cmp	r3, #0
 800fa72:	f000 80ac 	beq.w	800fbce <_fx_utility_logical_sector_cache_entry_read+0x3d2>
 800fa76:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fa78:	3348      	adds	r3, #72	@ 0x48
 800fa7a:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800fa7e:	e9d7 0100 	ldrd	r0, r1, [r7]
 800fa82:	4299      	cmp	r1, r3
 800fa84:	bf08      	it	eq
 800fa86:	4290      	cmpeq	r0, r2
 800fa88:	f040 80a1 	bne.w	800fbce <_fx_utility_logical_sector_cache_entry_read+0x3d2>
        {

            /* Yes, we found a match.  Simply setup the pointer to this
               buffer and return.  */
            media_ptr -> fx_media_memory_buffer =  (cache_entry + 3) -> fx_cached_sector_memory_buffer;
 800fa8c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fa8e:	3348      	adds	r3, #72	@ 0x48
 800fa90:	681a      	ldr	r2, [r3, #0]
 800fa92:	68fb      	ldr	r3, [r7, #12]
 800fa94:	609a      	str	r2, [r3, #8]

#ifndef FX_MEDIA_STATISTICS_DISABLE

            /* Increment the number of logical sectors cache read hits.  */
            media_ptr -> fx_media_logical_sector_cache_read_hits++;
 800fa96:	68fb      	ldr	r3, [r7, #12]
 800fa98:	f8d3 31a4 	ldr.w	r3, [r3, #420]	@ 0x1a4
 800fa9c:	1c5a      	adds	r2, r3, #1
 800fa9e:	68fb      	ldr	r3, [r7, #12]
 800faa0:	f8c3 21a4 	str.w	r2, [r3, #420]	@ 0x1a4
#endif

            /* Move the last entry to the top and the first three entries down.  */
            temp_storage.fx_cached_sector_memory_buffer =           (cache_entry) -> fx_cached_sector_memory_buffer;
 800faa4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800faa6:	681b      	ldr	r3, [r3, #0]
 800faa8:	613b      	str	r3, [r7, #16]
            temp_storage.fx_cached_sector =                         (cache_entry) -> fx_cached_sector;
 800faaa:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800faac:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800fab0:	e9c7 2306 	strd	r2, r3, [r7, #24]
            temp_storage.fx_cached_sector_buffer_dirty =            (cache_entry) -> fx_cached_sector_buffer_dirty;
 800fab4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fab6:	7c1b      	ldrb	r3, [r3, #16]
 800fab8:	f887 3020 	strb.w	r3, [r7, #32]
            temp_storage.fx_cached_sector_valid =                   (cache_entry) -> fx_cached_sector_valid;
 800fabc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fabe:	7c5b      	ldrb	r3, [r3, #17]
 800fac0:	f887 3021 	strb.w	r3, [r7, #33]	@ 0x21
            temp_storage.fx_cached_sector_type =                    (cache_entry) -> fx_cached_sector_type;
 800fac4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fac6:	7c9b      	ldrb	r3, [r3, #18]
 800fac8:	f887 3022 	strb.w	r3, [r7, #34]	@ 0x22

            (cache_entry) -> fx_cached_sector_memory_buffer =       (cache_entry + 3) -> fx_cached_sector_memory_buffer;
 800facc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800face:	3348      	adds	r3, #72	@ 0x48
 800fad0:	681a      	ldr	r2, [r3, #0]
 800fad2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fad4:	601a      	str	r2, [r3, #0]
            (cache_entry) -> fx_cached_sector =                     (cache_entry + 3) -> fx_cached_sector;
 800fad6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fad8:	3348      	adds	r3, #72	@ 0x48
 800fada:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800fade:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 800fae0:	e9c1 2302 	strd	r2, r3, [r1, #8]
            (cache_entry) -> fx_cached_sector_buffer_dirty =        (cache_entry + 3) -> fx_cached_sector_buffer_dirty;
 800fae4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fae6:	3348      	adds	r3, #72	@ 0x48
 800fae8:	7c1a      	ldrb	r2, [r3, #16]
 800faea:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800faec:	741a      	strb	r2, [r3, #16]
            (cache_entry) -> fx_cached_sector_valid =               (cache_entry + 3) -> fx_cached_sector_valid;
 800faee:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800faf0:	3348      	adds	r3, #72	@ 0x48
 800faf2:	7c5a      	ldrb	r2, [r3, #17]
 800faf4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800faf6:	745a      	strb	r2, [r3, #17]
            (cache_entry) -> fx_cached_sector_type =                (cache_entry + 3) -> fx_cached_sector_type;
 800faf8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fafa:	3348      	adds	r3, #72	@ 0x48
 800fafc:	7c9a      	ldrb	r2, [r3, #18]
 800fafe:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fb00:	749a      	strb	r2, [r3, #18]

            (cache_entry + 3) -> fx_cached_sector_memory_buffer =   (cache_entry + 2) -> fx_cached_sector_memory_buffer;
 800fb02:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fb04:	f103 0230 	add.w	r2, r3, #48	@ 0x30
 800fb08:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fb0a:	3348      	adds	r3, #72	@ 0x48
 800fb0c:	6812      	ldr	r2, [r2, #0]
 800fb0e:	601a      	str	r2, [r3, #0]
            (cache_entry + 3) -> fx_cached_sector =                 (cache_entry + 2) -> fx_cached_sector;
 800fb10:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fb12:	3330      	adds	r3, #48	@ 0x30
 800fb14:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 800fb16:	f102 0148 	add.w	r1, r2, #72	@ 0x48
 800fb1a:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800fb1e:	e9c1 2302 	strd	r2, r3, [r1, #8]
            (cache_entry + 3) -> fx_cached_sector_buffer_dirty =    (cache_entry + 2) -> fx_cached_sector_buffer_dirty;
 800fb22:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fb24:	f103 0230 	add.w	r2, r3, #48	@ 0x30
 800fb28:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fb2a:	3348      	adds	r3, #72	@ 0x48
 800fb2c:	7c12      	ldrb	r2, [r2, #16]
 800fb2e:	741a      	strb	r2, [r3, #16]
            (cache_entry + 3) -> fx_cached_sector_valid =           (cache_entry + 2) -> fx_cached_sector_valid;
 800fb30:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fb32:	f103 0230 	add.w	r2, r3, #48	@ 0x30
 800fb36:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fb38:	3348      	adds	r3, #72	@ 0x48
 800fb3a:	7c52      	ldrb	r2, [r2, #17]
 800fb3c:	745a      	strb	r2, [r3, #17]
            (cache_entry + 3) -> fx_cached_sector_type =            (cache_entry + 2) -> fx_cached_sector_type;
 800fb3e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fb40:	f103 0230 	add.w	r2, r3, #48	@ 0x30
 800fb44:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fb46:	3348      	adds	r3, #72	@ 0x48
 800fb48:	7c92      	ldrb	r2, [r2, #18]
 800fb4a:	749a      	strb	r2, [r3, #18]

            (cache_entry + 2) -> fx_cached_sector_memory_buffer =   (cache_entry + 1) -> fx_cached_sector_memory_buffer;
 800fb4c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fb4e:	f103 0218 	add.w	r2, r3, #24
 800fb52:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fb54:	3330      	adds	r3, #48	@ 0x30
 800fb56:	6812      	ldr	r2, [r2, #0]
 800fb58:	601a      	str	r2, [r3, #0]
            (cache_entry + 2) -> fx_cached_sector =                 (cache_entry + 1) -> fx_cached_sector;
 800fb5a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fb5c:	3318      	adds	r3, #24
 800fb5e:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 800fb60:	f102 0130 	add.w	r1, r2, #48	@ 0x30
 800fb64:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800fb68:	e9c1 2302 	strd	r2, r3, [r1, #8]
            (cache_entry + 2) -> fx_cached_sector_buffer_dirty =    (cache_entry + 1) -> fx_cached_sector_buffer_dirty;
 800fb6c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fb6e:	f103 0218 	add.w	r2, r3, #24
 800fb72:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fb74:	3330      	adds	r3, #48	@ 0x30
 800fb76:	7c12      	ldrb	r2, [r2, #16]
 800fb78:	741a      	strb	r2, [r3, #16]
            (cache_entry + 2) -> fx_cached_sector_valid =           (cache_entry + 1) -> fx_cached_sector_valid;
 800fb7a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fb7c:	f103 0218 	add.w	r2, r3, #24
 800fb80:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fb82:	3330      	adds	r3, #48	@ 0x30
 800fb84:	7c52      	ldrb	r2, [r2, #17]
 800fb86:	745a      	strb	r2, [r3, #17]
            (cache_entry + 2) -> fx_cached_sector_type =            (cache_entry + 1) -> fx_cached_sector_type;
 800fb88:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fb8a:	f103 0218 	add.w	r2, r3, #24
 800fb8e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fb90:	3330      	adds	r3, #48	@ 0x30
 800fb92:	7c92      	ldrb	r2, [r2, #18]
 800fb94:	749a      	strb	r2, [r3, #18]

            (cache_entry + 1) -> fx_cached_sector_memory_buffer =   temp_storage.fx_cached_sector_memory_buffer;
 800fb96:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fb98:	3318      	adds	r3, #24
 800fb9a:	693a      	ldr	r2, [r7, #16]
 800fb9c:	601a      	str	r2, [r3, #0]
            (cache_entry + 1) -> fx_cached_sector =                 temp_storage.fx_cached_sector;
 800fb9e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fba0:	f103 0118 	add.w	r1, r3, #24
 800fba4:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 800fba8:	e9c1 2302 	strd	r2, r3, [r1, #8]
            (cache_entry + 1) -> fx_cached_sector_buffer_dirty =    temp_storage.fx_cached_sector_buffer_dirty;
 800fbac:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fbae:	3318      	adds	r3, #24
 800fbb0:	f897 2020 	ldrb.w	r2, [r7, #32]
 800fbb4:	741a      	strb	r2, [r3, #16]
            (cache_entry + 1) -> fx_cached_sector_valid =           temp_storage.fx_cached_sector_valid;
 800fbb6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fbb8:	3318      	adds	r3, #24
 800fbba:	f897 2021 	ldrb.w	r2, [r7, #33]	@ 0x21
 800fbbe:	745a      	strb	r2, [r3, #17]
            (cache_entry + 1) -> fx_cached_sector_type =            temp_storage.fx_cached_sector_type;
 800fbc0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fbc2:	3318      	adds	r3, #24
 800fbc4:	f897 2022 	ldrb.w	r2, [r7, #34]	@ 0x22
 800fbc8:	749a      	strb	r2, [r3, #18]

            /* Success, return to caller immediately!  */
            return(FX_NULL);
 800fbca:	2300      	movs	r3, #0
 800fbcc:	e0da      	b.n	800fd84 <_fx_utility_logical_sector_cache_entry_read+0x588>
        }

        /* At this point we have a cache miss.  We need to move all of the sectors down one slot, swapping
           the 4th entry with the first.  */
        temp_storage.fx_cached_sector_memory_buffer =           (cache_entry + 3) -> fx_cached_sector_memory_buffer;
 800fbce:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fbd0:	3348      	adds	r3, #72	@ 0x48
 800fbd2:	681b      	ldr	r3, [r3, #0]
 800fbd4:	613b      	str	r3, [r7, #16]
        temp_storage.fx_cached_sector =                         (cache_entry + 3) -> fx_cached_sector;
 800fbd6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fbd8:	3348      	adds	r3, #72	@ 0x48
 800fbda:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800fbde:	e9c7 2306 	strd	r2, r3, [r7, #24]
        temp_storage.fx_cached_sector_buffer_dirty =            (cache_entry + 3) -> fx_cached_sector_buffer_dirty;
 800fbe2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fbe4:	3348      	adds	r3, #72	@ 0x48
 800fbe6:	7c1b      	ldrb	r3, [r3, #16]
 800fbe8:	f887 3020 	strb.w	r3, [r7, #32]
        temp_storage.fx_cached_sector_valid =                   (cache_entry + 3) -> fx_cached_sector_valid;
 800fbec:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fbee:	3348      	adds	r3, #72	@ 0x48
 800fbf0:	7c5b      	ldrb	r3, [r3, #17]
 800fbf2:	f887 3021 	strb.w	r3, [r7, #33]	@ 0x21
        temp_storage.fx_cached_sector_type =                    (cache_entry + 3) -> fx_cached_sector_type;
 800fbf6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fbf8:	3348      	adds	r3, #72	@ 0x48
 800fbfa:	7c9b      	ldrb	r3, [r3, #18]
 800fbfc:	f887 3022 	strb.w	r3, [r7, #34]	@ 0x22

        (cache_entry + 3) -> fx_cached_sector_memory_buffer =   (cache_entry + 2) -> fx_cached_sector_memory_buffer;
 800fc00:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fc02:	f103 0230 	add.w	r2, r3, #48	@ 0x30
 800fc06:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fc08:	3348      	adds	r3, #72	@ 0x48
 800fc0a:	6812      	ldr	r2, [r2, #0]
 800fc0c:	601a      	str	r2, [r3, #0]
        (cache_entry + 3) -> fx_cached_sector =                 (cache_entry + 2) -> fx_cached_sector;
 800fc0e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fc10:	3330      	adds	r3, #48	@ 0x30
 800fc12:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 800fc14:	f102 0148 	add.w	r1, r2, #72	@ 0x48
 800fc18:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800fc1c:	e9c1 2302 	strd	r2, r3, [r1, #8]
        (cache_entry + 3) -> fx_cached_sector_buffer_dirty =    (cache_entry + 2) -> fx_cached_sector_buffer_dirty;
 800fc20:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fc22:	f103 0230 	add.w	r2, r3, #48	@ 0x30
 800fc26:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fc28:	3348      	adds	r3, #72	@ 0x48
 800fc2a:	7c12      	ldrb	r2, [r2, #16]
 800fc2c:	741a      	strb	r2, [r3, #16]
        (cache_entry + 3) -> fx_cached_sector_valid =           (cache_entry + 2) -> fx_cached_sector_valid;
 800fc2e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fc30:	f103 0230 	add.w	r2, r3, #48	@ 0x30
 800fc34:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fc36:	3348      	adds	r3, #72	@ 0x48
 800fc38:	7c52      	ldrb	r2, [r2, #17]
 800fc3a:	745a      	strb	r2, [r3, #17]
        (cache_entry + 3) -> fx_cached_sector_type =            (cache_entry + 2) -> fx_cached_sector_type;
 800fc3c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fc3e:	f103 0230 	add.w	r2, r3, #48	@ 0x30
 800fc42:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fc44:	3348      	adds	r3, #72	@ 0x48
 800fc46:	7c92      	ldrb	r2, [r2, #18]
 800fc48:	749a      	strb	r2, [r3, #18]

        (cache_entry + 2) -> fx_cached_sector_memory_buffer =   (cache_entry + 1) -> fx_cached_sector_memory_buffer;
 800fc4a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fc4c:	f103 0218 	add.w	r2, r3, #24
 800fc50:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fc52:	3330      	adds	r3, #48	@ 0x30
 800fc54:	6812      	ldr	r2, [r2, #0]
 800fc56:	601a      	str	r2, [r3, #0]
        (cache_entry + 2) -> fx_cached_sector =                 (cache_entry + 1) -> fx_cached_sector;
 800fc58:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fc5a:	3318      	adds	r3, #24
 800fc5c:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 800fc5e:	f102 0130 	add.w	r1, r2, #48	@ 0x30
 800fc62:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800fc66:	e9c1 2302 	strd	r2, r3, [r1, #8]
        (cache_entry + 2) -> fx_cached_sector_buffer_dirty =    (cache_entry + 1) -> fx_cached_sector_buffer_dirty;
 800fc6a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fc6c:	f103 0218 	add.w	r2, r3, #24
 800fc70:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fc72:	3330      	adds	r3, #48	@ 0x30
 800fc74:	7c12      	ldrb	r2, [r2, #16]
 800fc76:	741a      	strb	r2, [r3, #16]
        (cache_entry + 2) -> fx_cached_sector_valid =           (cache_entry + 1) -> fx_cached_sector_valid;
 800fc78:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fc7a:	f103 0218 	add.w	r2, r3, #24
 800fc7e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fc80:	3330      	adds	r3, #48	@ 0x30
 800fc82:	7c52      	ldrb	r2, [r2, #17]
 800fc84:	745a      	strb	r2, [r3, #17]
        (cache_entry + 2) -> fx_cached_sector_type =            (cache_entry + 1) -> fx_cached_sector_type;
 800fc86:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fc88:	f103 0218 	add.w	r2, r3, #24
 800fc8c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fc8e:	3330      	adds	r3, #48	@ 0x30
 800fc90:	7c92      	ldrb	r2, [r2, #18]
 800fc92:	749a      	strb	r2, [r3, #18]

        (cache_entry + 1) -> fx_cached_sector_memory_buffer =   (cache_entry) -> fx_cached_sector_memory_buffer;
 800fc94:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fc96:	3318      	adds	r3, #24
 800fc98:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 800fc9a:	6812      	ldr	r2, [r2, #0]
 800fc9c:	601a      	str	r2, [r3, #0]
        (cache_entry + 1) -> fx_cached_sector =                 (cache_entry) -> fx_cached_sector;
 800fc9e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fca0:	f103 0118 	add.w	r1, r3, #24
 800fca4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fca6:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800fcaa:	e9c1 2302 	strd	r2, r3, [r1, #8]
        (cache_entry + 1) -> fx_cached_sector_buffer_dirty =    (cache_entry) -> fx_cached_sector_buffer_dirty;
 800fcae:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fcb0:	3318      	adds	r3, #24
 800fcb2:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 800fcb4:	7c12      	ldrb	r2, [r2, #16]
 800fcb6:	741a      	strb	r2, [r3, #16]
        (cache_entry + 1) -> fx_cached_sector_valid =           (cache_entry) -> fx_cached_sector_valid;
 800fcb8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fcba:	3318      	adds	r3, #24
 800fcbc:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 800fcbe:	7c52      	ldrb	r2, [r2, #17]
 800fcc0:	745a      	strb	r2, [r3, #17]
        (cache_entry + 1) -> fx_cached_sector_type =            (cache_entry) -> fx_cached_sector_type;
 800fcc2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fcc4:	3318      	adds	r3, #24
 800fcc6:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 800fcc8:	7c92      	ldrb	r2, [r2, #18]
 800fcca:	749a      	strb	r2, [r3, #18]

        (cache_entry) -> fx_cached_sector_memory_buffer =       temp_storage.fx_cached_sector_memory_buffer;
 800fccc:	693a      	ldr	r2, [r7, #16]
 800fcce:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fcd0:	601a      	str	r2, [r3, #0]
        (cache_entry) -> fx_cached_sector =                     temp_storage.fx_cached_sector;
 800fcd2:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 800fcd6:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 800fcd8:	e9c1 2302 	strd	r2, r3, [r1, #8]
        (cache_entry) -> fx_cached_sector_buffer_dirty =        temp_storage.fx_cached_sector_buffer_dirty;
 800fcdc:	f897 2020 	ldrb.w	r2, [r7, #32]
 800fce0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fce2:	741a      	strb	r2, [r3, #16]
        (cache_entry) -> fx_cached_sector_valid =               temp_storage.fx_cached_sector_valid;
 800fce4:	f897 2021 	ldrb.w	r2, [r7, #33]	@ 0x21
 800fce8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fcea:	745a      	strb	r2, [r3, #17]
        (cache_entry) -> fx_cached_sector_type =                temp_storage.fx_cached_sector_type;
 800fcec:	f897 2022 	ldrb.w	r2, [r7, #34]	@ 0x22
 800fcf0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fcf2:	749a      	strb	r2, [r3, #18]

        /* Set the previous pointer to NULL to avoid the linked list update below.  */
        *previous_cache_entry =  FX_NULL;
 800fcf4:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800fcf6:	2200      	movs	r2, #0
 800fcf8:	601a      	str	r2, [r3, #0]
 800fcfa:	e042      	b.n	800fd82 <_fx_utility_logical_sector_cache_entry_read+0x586>
    }
    else
    {

        /* Search for an entry in the cache that matches this request.  */
        cache_size =            media_ptr -> fx_media_sector_cache_size;
 800fcfc:	68fb      	ldr	r3, [r7, #12]
 800fcfe:	695b      	ldr	r3, [r3, #20]
 800fd00:	633b      	str	r3, [r7, #48]	@ 0x30
        cache_entry =           media_ptr -> fx_media_sector_cache_list_ptr;
 800fd02:	68fb      	ldr	r3, [r7, #12]
 800fd04:	69db      	ldr	r3, [r3, #28]
 800fd06:	637b      	str	r3, [r7, #52]	@ 0x34
        *previous_cache_entry =  FX_NULL;
 800fd08:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800fd0a:	2200      	movs	r2, #0
 800fd0c:	601a      	str	r2, [r3, #0]

        /* Look at the cache entries until a match is found or the end of
           the cache is reached.  */
        while (cache_size--)
 800fd0e:	e033      	b.n	800fd78 <_fx_utility_logical_sector_cache_entry_read+0x57c>
        {

            /* Determine if the requested sector has been found.  */
            if ((cache_entry -> fx_cached_sector_valid) && (cache_entry -> fx_cached_sector == logical_sector))
 800fd10:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fd12:	7c5b      	ldrb	r3, [r3, #17]
 800fd14:	2b00      	cmp	r3, #0
 800fd16:	d025      	beq.n	800fd64 <_fx_utility_logical_sector_cache_entry_read+0x568>
 800fd18:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fd1a:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800fd1e:	e9d7 0100 	ldrd	r0, r1, [r7]
 800fd22:	4299      	cmp	r1, r3
 800fd24:	bf08      	it	eq
 800fd26:	4290      	cmpeq	r0, r2
 800fd28:	d11c      	bne.n	800fd64 <_fx_utility_logical_sector_cache_entry_read+0x568>
            {

                /* Yes, we found a match.  Simply setup the pointer to this
                   buffer and return.  */
                media_ptr -> fx_media_memory_buffer =  cache_entry -> fx_cached_sector_memory_buffer;
 800fd2a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fd2c:	681a      	ldr	r2, [r3, #0]
 800fd2e:	68fb      	ldr	r3, [r7, #12]
 800fd30:	609a      	str	r2, [r3, #8]

                /* Determine if we need to update the last used list.  */
                if (*previous_cache_entry)
 800fd32:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800fd34:	681b      	ldr	r3, [r3, #0]
 800fd36:	2b00      	cmp	r3, #0
 800fd38:	d00b      	beq.n	800fd52 <_fx_utility_logical_sector_cache_entry_read+0x556>

                    /* Yes, the current entry is not at the front of the list
                       so we need to change the order.  */

                    /* Link the previous entry to this entry's next pointer.  */
                    (*previous_cache_entry) -> fx_cached_sector_next_used =
 800fd3a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800fd3c:	681b      	ldr	r3, [r3, #0]
                        cache_entry -> fx_cached_sector_next_used;
 800fd3e:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 800fd40:	6952      	ldr	r2, [r2, #20]
                    (*previous_cache_entry) -> fx_cached_sector_next_used =
 800fd42:	615a      	str	r2, [r3, #20]

                    /* Place this entry at the head of the list.  */
                    cache_entry -> fx_cached_sector_next_used =
                        media_ptr -> fx_media_sector_cache_list_ptr;
 800fd44:	68fb      	ldr	r3, [r7, #12]
 800fd46:	69da      	ldr	r2, [r3, #28]
                    cache_entry -> fx_cached_sector_next_used =
 800fd48:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fd4a:	615a      	str	r2, [r3, #20]
                    media_ptr -> fx_media_sector_cache_list_ptr =  cache_entry;
 800fd4c:	68fb      	ldr	r3, [r7, #12]
 800fd4e:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 800fd50:	61da      	str	r2, [r3, #28]
                }

#ifndef FX_MEDIA_STATISTICS_DISABLE

                /* Increment the number of logical sectors cache read hits.  */
                media_ptr -> fx_media_logical_sector_cache_read_hits++;
 800fd52:	68fb      	ldr	r3, [r7, #12]
 800fd54:	f8d3 31a4 	ldr.w	r3, [r3, #420]	@ 0x1a4
 800fd58:	1c5a      	adds	r2, r3, #1
 800fd5a:	68fb      	ldr	r3, [r7, #12]
 800fd5c:	f8c3 21a4 	str.w	r2, [r3, #420]	@ 0x1a4
#endif

                /* Success, return to caller immediately!  */
                return(FX_NULL);
 800fd60:	2300      	movs	r3, #0
 800fd62:	e00f      	b.n	800fd84 <_fx_utility_logical_sector_cache_entry_read+0x588>
            }

            /* Otherwise, we have not found the cached entry yet.  */

            /* If there are more entries, move to the next one.  */
            if (cache_entry -> fx_cached_sector_next_used)
 800fd64:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fd66:	695b      	ldr	r3, [r3, #20]
 800fd68:	2b00      	cmp	r3, #0
 800fd6a:	d005      	beq.n	800fd78 <_fx_utility_logical_sector_cache_entry_read+0x57c>
            {

                *previous_cache_entry =  cache_entry;
 800fd6c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800fd6e:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 800fd70:	601a      	str	r2, [r3, #0]
                cache_entry =           cache_entry -> fx_cached_sector_next_used;
 800fd72:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fd74:	695b      	ldr	r3, [r3, #20]
 800fd76:	637b      	str	r3, [r7, #52]	@ 0x34
        while (cache_size--)
 800fd78:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800fd7a:	1e5a      	subs	r2, r3, #1
 800fd7c:	633a      	str	r2, [r7, #48]	@ 0x30
 800fd7e:	2b00      	cmp	r3, #0
 800fd80:	d1c6      	bne.n	800fd10 <_fx_utility_logical_sector_cache_entry_read+0x514>
            }
        }
    }

    /* The requested sector is not in cache, return the last cache entry.  */
    return(cache_entry);
 800fd82:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    FX_PARAMETER_NOT_USED(media_ptr);
    FX_PARAMETER_NOT_USED(logical_sector);
    FX_PARAMETER_NOT_USED(previous_cache_entry);
    return(FX_NULL);
#endif /* FX_DISABLE_CACHE */
}
 800fd84:	4618      	mov	r0, r3
 800fd86:	373c      	adds	r7, #60	@ 0x3c
 800fd88:	46bd      	mov	sp, r7
 800fd8a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fd8e:	4770      	bx	lr

0800fd90 <_fx_utility_logical_sector_flush>:
/*                                            errors without cache,       */
/*                                            resulting in version 6.1.10 */
/*                                                                        */
/**************************************************************************/
UINT  _fx_utility_logical_sector_flush(FX_MEDIA *media_ptr, ULONG64 starting_sector, ULONG64 sectors, UINT invalidate)
{
 800fd90:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 800fd94:	b094      	sub	sp, #80	@ 0x50
 800fd96:	af00      	add	r7, sp, #0
 800fd98:	61f8      	str	r0, [r7, #28]
 800fd9a:	e9c7 2304 	strd	r2, r3, [r7, #16]

    /* Extended port-specific processing macro, which is by default defined to white space.  */
    FX_UTILITY_LOGICAL_SECTOR_FLUSH_EXTENSION

    /* Calculate the ending sector.  */
    ending_sector =  starting_sector + sectors - 1;
 800fd9e:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 800fda2:	e9d7 231c 	ldrd	r2, r3, [r7, #112]	@ 0x70
 800fda6:	1884      	adds	r4, r0, r2
 800fda8:	eb41 0503 	adc.w	r5, r1, r3
 800fdac:	1e63      	subs	r3, r4, #1
 800fdae:	60bb      	str	r3, [r7, #8]
 800fdb0:	f145 33ff 	adc.w	r3, r5, #4294967295
 800fdb4:	60fb      	str	r3, [r7, #12]
 800fdb6:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
 800fdba:	e9c7 3408 	strd	r3, r4, [r7, #32]

    /* Pickup the number of dirty sectors currently in the cache.  */
    remaining_dirty =  media_ptr -> fx_media_sector_cache_dirty_count;
 800fdbe:	69fb      	ldr	r3, [r7, #28]
 800fdc0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800fdc2:	633b      	str	r3, [r7, #48]	@ 0x30

    /* If trace is enabled, insert this event into the trace buffer.  */
    FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_MEDIA_FLUSH, media_ptr, media_ptr -> fx_media_sector_cache_dirty_count, 0, 0, FX_TRACE_INTERNAL_EVENTS, 0, 0)

    /* Determine what type of cache configuration we have.  */
    if (media_ptr -> fx_media_sector_cache_hashed == FX_FALSE)
 800fdc4:	69fb      	ldr	r3, [r7, #28]
 800fdc6:	691b      	ldr	r3, [r3, #16]
 800fdc8:	2b00      	cmp	r3, #0
 800fdca:	f040 80b4 	bne.w	800ff36 <_fx_utility_logical_sector_flush+0x1a6>

        /* Linear cache present, simply walk through the search list until
           an unused cache entry is present.  */

        /* Flush and invalidate the internal logical sector cache.  */
        cache_size =            media_ptr -> fx_media_sector_cache_size;
 800fdce:	69fb      	ldr	r3, [r7, #28]
 800fdd0:	695b      	ldr	r3, [r3, #20]
 800fdd2:	64bb      	str	r3, [r7, #72]	@ 0x48
        cache_entry =           media_ptr -> fx_media_sector_cache_list_ptr;
 800fdd4:	69fb      	ldr	r3, [r7, #28]
 800fdd6:	69db      	ldr	r3, [r3, #28]
 800fdd8:	64fb      	str	r3, [r7, #76]	@ 0x4c

        /* Look at the cache entries that have been written to.  */
        while ((cache_size--) && (cache_entry -> fx_cached_sector))
 800fdda:	e09f      	b.n	800ff1c <_fx_utility_logical_sector_flush+0x18c>
        {

            /* Determine if invalidation is not required and there are no
               more dirty sectors. */
            if ((remaining_dirty == 0) && (invalidate == FX_FALSE))
 800fddc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800fdde:	2b00      	cmp	r3, #0
 800fde0:	d103      	bne.n	800fdea <_fx_utility_logical_sector_flush+0x5a>
 800fde2:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 800fde4:	2b00      	cmp	r3, #0
 800fde6:	f000 81de 	beq.w	80101a6 <_fx_utility_logical_sector_flush+0x416>
                /* Yes, nothing left to do.  */
                break;
            }

            /* Determine if there are any more sectors to process.  */
            if (sectors == 0)
 800fdea:	e9d7 231c 	ldrd	r2, r3, [r7, #112]	@ 0x70
 800fdee:	4313      	orrs	r3, r2
 800fdf0:	f000 81db 	beq.w	80101aa <_fx_utility_logical_sector_flush+0x41a>
                /* No more sectors required to process.  */
                break;
            }

            /* Determine if this cached sector is within the specified range and is valid.  */
            if ((cache_entry -> fx_cached_sector_valid) &&
 800fdf4:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800fdf6:	7c5b      	ldrb	r3, [r3, #17]
 800fdf8:	2b00      	cmp	r3, #0
 800fdfa:	f000 808c 	beq.w	800ff16 <_fx_utility_logical_sector_flush+0x186>
                (cache_entry -> fx_cached_sector >= starting_sector) &&
 800fdfe:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800fe00:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
            if ((cache_entry -> fx_cached_sector_valid) &&
 800fe04:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 800fe08:	4290      	cmp	r0, r2
 800fe0a:	eb71 0303 	sbcs.w	r3, r1, r3
 800fe0e:	f0c0 8082 	bcc.w	800ff16 <_fx_utility_logical_sector_flush+0x186>
                (cache_entry -> fx_cached_sector <= ending_sector))
 800fe12:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800fe14:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
                (cache_entry -> fx_cached_sector >= starting_sector) &&
 800fe18:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 800fe1c:	4290      	cmp	r0, r2
 800fe1e:	eb71 0303 	sbcs.w	r3, r1, r3
 800fe22:	d378      	bcc.n	800ff16 <_fx_utility_logical_sector_flush+0x186>
            {

                /* Yes, the cache entry is valid and within the specified range. Determine if
                   the requested sector has been written to.  */
                if (cache_entry -> fx_cached_sector_buffer_dirty)
 800fe24:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800fe26:	7c1b      	ldrb	r3, [r3, #16]
 800fe28:	2b00      	cmp	r3, #0
 800fe2a:	d04d      	beq.n	800fec8 <_fx_utility_logical_sector_flush+0x138>
                {

                    /* Yes, write the cached sector out to the media.  */

                    /* Check for write protect at the media level (set by driver).  */
                    if (media_ptr -> fx_media_driver_write_protect == FX_FALSE)
 800fe2c:	69fb      	ldr	r3, [r7, #28]
 800fe2e:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
 800fe32:	2b00      	cmp	r3, #0
 800fe34:	d148      	bne.n	800fec8 <_fx_utility_logical_sector_flush+0x138>
                    {

#ifndef FX_MEDIA_STATISTICS_DISABLE

                        /* Increment the number of driver write sector(s) requests.  */
                        media_ptr -> fx_media_driver_write_requests++;
 800fe36:	69fb      	ldr	r3, [r7, #28]
 800fe38:	f8d3 31b0 	ldr.w	r3, [r3, #432]	@ 0x1b0
 800fe3c:	1c5a      	adds	r2, r3, #1
 800fe3e:	69fb      	ldr	r3, [r7, #28]
 800fe40:	f8c3 21b0 	str.w	r2, [r3, #432]	@ 0x1b0
#endif

                        /* Build write request to the driver.  */
                        media_ptr -> fx_media_driver_request =          FX_DRIVER_WRITE;
 800fe44:	69fb      	ldr	r3, [r7, #28]
 800fe46:	2201      	movs	r2, #1
 800fe48:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
                        media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 800fe4c:	69fb      	ldr	r3, [r7, #28]
 800fe4e:	2290      	movs	r2, #144	@ 0x90
 800fe50:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
                        media_ptr -> fx_media_driver_buffer =           cache_entry -> fx_cached_sector_memory_buffer;
 800fe54:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800fe56:	681a      	ldr	r2, [r3, #0]
 800fe58:	69fb      	ldr	r3, [r7, #28]
 800fe5a:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
#ifdef FX_DRIVER_USE_64BIT_LBA
                        media_ptr -> fx_media_driver_logical_sector =   cache_entry -> fx_cached_sector;
#else
                        media_ptr -> fx_media_driver_logical_sector =   (ULONG)cache_entry -> fx_cached_sector;
 800fe5e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800fe60:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800fe64:	69fb      	ldr	r3, [r7, #28]
 800fe66:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
#endif
                        media_ptr -> fx_media_driver_sectors =          1;
 800fe6a:	69fb      	ldr	r3, [r7, #28]
 800fe6c:	2201      	movs	r2, #1
 800fe6e:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98
                        media_ptr -> fx_media_driver_sector_type =      cache_entry -> fx_cached_sector_type;
 800fe72:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800fe74:	7c9b      	ldrb	r3, [r3, #18]
 800fe76:	461a      	mov	r2, r3
 800fe78:	69fb      	ldr	r3, [r7, #28]
 800fe7a:	f8c3 20b8 	str.w	r2, [r3, #184]	@ 0xb8

                        /* Sectors other than FX_DATA_SECTOR will never be dirty when FX_FAULT_TOLERANT is defined. */
#ifndef FX_FAULT_TOLERANT
                        /* Determine if the system write flag needs to be set.  */
                        if (cache_entry -> fx_cached_sector_type != FX_DATA_SECTOR)
 800fe7e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800fe80:	7c9b      	ldrb	r3, [r3, #18]
 800fe82:	2b04      	cmp	r3, #4
 800fe84:	d003      	beq.n	800fe8e <_fx_utility_logical_sector_flush+0xfe>
                        {

                            /* Yes, a system sector write is present so set the flag.  The driver
                               can use this flag to make extra safeguards in writing the sector
                               out, yielding more fault tolerance.  */
                            media_ptr -> fx_media_driver_system_write =  FX_TRUE;
 800fe86:	69fb      	ldr	r3, [r7, #28]
 800fe88:	2201      	movs	r2, #1
 800fe8a:	f8c3 20b0 	str.w	r2, [r3, #176]	@ 0xb0

                        /* If trace is enabled, insert this event into the trace buffer.  */
                        FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_WRITE, media_ptr, cache_entry -> fx_cached_sector, 1, cache_entry -> fx_cached_sector_memory_buffer, FX_TRACE_INTERNAL_EVENTS, 0, 0)

                        /* Invoke the driver to write the sector.  */
                        (media_ptr -> fx_media_driver_entry) (media_ptr);
 800fe8e:	69fb      	ldr	r3, [r7, #28]
 800fe90:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
 800fe94:	69f8      	ldr	r0, [r7, #28]
 800fe96:	4798      	blx	r3

                        /* Clear the system write flag.  */
                        media_ptr -> fx_media_driver_system_write =  FX_FALSE;
 800fe98:	69fb      	ldr	r3, [r7, #28]
 800fe9a:	2200      	movs	r2, #0
 800fe9c:	f8c3 20b0 	str.w	r2, [r3, #176]	@ 0xb0

                        /* Check for successful completion.  */
                        if (media_ptr -> fx_media_driver_status)
 800fea0:	69fb      	ldr	r3, [r7, #28]
 800fea2:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800fea6:	2b00      	cmp	r3, #0
 800fea8:	d003      	beq.n	800feb2 <_fx_utility_logical_sector_flush+0x122>
                        {

                            /* Error writing a cached sector out.  Return the
                               error status.  */
                            return(media_ptr -> fx_media_driver_status);
 800feaa:	69fb      	ldr	r3, [r7, #28]
 800feac:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800feb0:	e17f      	b.n	80101b2 <_fx_utility_logical_sector_flush+0x422>
                        }

                        /* Clear the buffer dirty flag since it has been flushed
                           out.  */
                        cache_entry -> fx_cached_sector_buffer_dirty =  FX_FALSE;
 800feb2:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800feb4:	2200      	movs	r2, #0
 800feb6:	741a      	strb	r2, [r3, #16]

                        /* Decrement the number of dirty sectors currently in the cache.  */
                        media_ptr -> fx_media_sector_cache_dirty_count--;
 800feb8:	69fb      	ldr	r3, [r7, #28]
 800feba:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800febc:	1e5a      	subs	r2, r3, #1
 800febe:	69fb      	ldr	r3, [r7, #28]
 800fec0:	625a      	str	r2, [r3, #36]	@ 0x24
                        remaining_dirty--;
 800fec2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800fec4:	3b01      	subs	r3, #1
 800fec6:	633b      	str	r3, [r7, #48]	@ 0x30
                    }
                }

                /* Determine if the invalidate option is specified.  */
                if (invalidate)
 800fec8:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 800feca:	2b00      	cmp	r3, #0
 800fecc:	d018      	beq.n	800ff00 <_fx_utility_logical_sector_flush+0x170>
                {

                    /* Invalidate the cache entry.  */
                    cache_entry -> fx_cached_sector_valid =  FX_FALSE;
 800fece:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800fed0:	2200      	movs	r2, #0
 800fed2:	745a      	strb	r2, [r3, #17]

                    /* Place all ones in the sector number.  */
                    cache_entry -> fx_cached_sector =  (~(ULONG64)0);
 800fed4:	6cf9      	ldr	r1, [r7, #76]	@ 0x4c
 800fed6:	f04f 32ff 	mov.w	r2, #4294967295
 800feda:	f04f 33ff 	mov.w	r3, #4294967295
 800fede:	e9c1 2302 	strd	r2, r3, [r1, #8]

                    /* Determine if this sector is still dirty, this could be the case if
                       write protection was turned on.  */
                    if (cache_entry -> fx_cached_sector_buffer_dirty)
 800fee2:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800fee4:	7c1b      	ldrb	r3, [r3, #16]
 800fee6:	2b00      	cmp	r3, #0
 800fee8:	d00a      	beq.n	800ff00 <_fx_utility_logical_sector_flush+0x170>
                    {

                        /* Yes, clear the dirty flag.  */
                        cache_entry -> fx_cached_sector_buffer_dirty =  FX_FALSE;
 800feea:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800feec:	2200      	movs	r2, #0
 800feee:	741a      	strb	r2, [r3, #16]

                        /* Decrement the number of dirty sectors currently in the cache.  */
                        media_ptr -> fx_media_sector_cache_dirty_count--;
 800fef0:	69fb      	ldr	r3, [r7, #28]
 800fef2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800fef4:	1e5a      	subs	r2, r3, #1
 800fef6:	69fb      	ldr	r3, [r7, #28]
 800fef8:	625a      	str	r2, [r3, #36]	@ 0x24
                        remaining_dirty--;
 800fefa:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800fefc:	3b01      	subs	r3, #1
 800fefe:	633b      	str	r3, [r7, #48]	@ 0x30
                    }
                }

                /* Decrement the number of sectors in the range that have been processed.  */
                sectors--;
 800ff00:	e9d7 231c 	ldrd	r2, r3, [r7, #112]	@ 0x70
 800ff04:	1e51      	subs	r1, r2, #1
 800ff06:	6039      	str	r1, [r7, #0]
 800ff08:	f143 33ff 	adc.w	r3, r3, #4294967295
 800ff0c:	607b      	str	r3, [r7, #4]
 800ff0e:	e9d7 3400 	ldrd	r3, r4, [r7]
 800ff12:	e9c7 341c 	strd	r3, r4, [r7, #112]	@ 0x70
            }

            /* Move to the next entry in the sector cache.  */
            cache_entry =  cache_entry -> fx_cached_sector_next_used;
 800ff16:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800ff18:	695b      	ldr	r3, [r3, #20]
 800ff1a:	64fb      	str	r3, [r7, #76]	@ 0x4c
        while ((cache_size--) && (cache_entry -> fx_cached_sector))
 800ff1c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800ff1e:	1e5a      	subs	r2, r3, #1
 800ff20:	64ba      	str	r2, [r7, #72]	@ 0x48
 800ff22:	2b00      	cmp	r3, #0
 800ff24:	f000 8144 	beq.w	80101b0 <_fx_utility_logical_sector_flush+0x420>
 800ff28:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800ff2a:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800ff2e:	4313      	orrs	r3, r2
 800ff30:	f47f af54 	bne.w	800fddc <_fx_utility_logical_sector_flush+0x4c>
 800ff34:	e13c      	b.n	80101b0 <_fx_utility_logical_sector_flush+0x420>
    }
    else
    {

        /* Hashed cache is present. Pickup the cache size.  */
        cache_size =            media_ptr -> fx_media_sector_cache_size;
 800ff36:	69fb      	ldr	r3, [r7, #28]
 800ff38:	695b      	ldr	r3, [r3, #20]
 800ff3a:	64bb      	str	r3, [r7, #72]	@ 0x48

        /* Initialize the loop control parameters.  */
        bit_set =  0;
 800ff3c:	2300      	movs	r3, #0
 800ff3e:	643b      	str	r3, [r7, #64]	@ 0x40
        valid_bit_map =  media_ptr -> fx_media_sector_cache_hashed_sector_valid;
 800ff40:	69fb      	ldr	r3, [r7, #28]
 800ff42:	6a1b      	ldr	r3, [r3, #32]
 800ff44:	62fb      	str	r3, [r7, #44]	@ 0x2c

        /* Determine how to process the hashed cache based on the number of sectors
           to process. If the sequential sector range is less than the bit map size,
           simply use the starting sector to derive the index into the cache.  */
        if (sectors < 32)
 800ff46:	e9d7 231c 	ldrd	r2, r3, [r7, #112]	@ 0x70
 800ff4a:	2a20      	cmp	r2, #32
 800ff4c:	f173 0300 	sbcs.w	r3, r3, #0
 800ff50:	d202      	bcs.n	800ff58 <_fx_utility_logical_sector_flush+0x1c8>
        {
            use_starting_sector =  FX_TRUE;
 800ff52:	2301      	movs	r3, #1
 800ff54:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800ff56:	e121      	b.n	801019c <_fx_utility_logical_sector_flush+0x40c>
        }
        else
        {
            use_starting_sector =  FX_FALSE;
 800ff58:	2300      	movs	r3, #0
 800ff5a:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }

        /* Determine if there is anything valid in the cache.  */
        while (valid_bit_map)
 800ff5c:	e11e      	b.n	801019c <_fx_utility_logical_sector_flush+0x40c>
        {

            /* Determine if invalidation is not required and there are no
               more dirty sectors. */
            if ((remaining_dirty == 0) && (invalidate == FX_FALSE))
 800ff5e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800ff60:	2b00      	cmp	r3, #0
 800ff62:	d103      	bne.n	800ff6c <_fx_utility_logical_sector_flush+0x1dc>
 800ff64:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 800ff66:	2b00      	cmp	r3, #0
 800ff68:	f000 8121 	beq.w	80101ae <_fx_utility_logical_sector_flush+0x41e>
                /* Yes, nothing left to do.  */
                break;
            }

            /* Determine if there are any more sectors to process.  */
            if ((sectors == 0) || (starting_sector > ending_sector))
 800ff6c:	e9d7 231c 	ldrd	r2, r3, [r7, #112]	@ 0x70
 800ff70:	4313      	orrs	r3, r2
 800ff72:	f000 811d 	beq.w	80101b0 <_fx_utility_logical_sector_flush+0x420>
 800ff76:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 800ff7a:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 800ff7e:	4290      	cmp	r0, r2
 800ff80:	eb71 0303 	sbcs.w	r3, r1, r3
 800ff84:	f0c0 8114 	bcc.w	80101b0 <_fx_utility_logical_sector_flush+0x420>
                /* No more sectors required to process.  */
                break;
            }

            /* Determine how to compute the hash index.  */
            if (use_starting_sector)
 800ff88:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800ff8a:	2b00      	cmp	r3, #0
 800ff8c:	d015      	beq.n	800ffba <_fx_utility_logical_sector_flush+0x22a>
            {

                /* Calculate the hash value of this sector using the lower bits.  */
                index =  (ULONG)(starting_sector & media_ptr -> fx_media_sector_cache_hash_mask);
 800ff8e:	693a      	ldr	r2, [r7, #16]
 800ff90:	69fb      	ldr	r3, [r7, #28]
 800ff92:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 800ff96:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
 800ff9a:	4013      	ands	r3, r2
 800ff9c:	63bb      	str	r3, [r7, #56]	@ 0x38

                /* Calculate the bit set indicating there is one or more valid sectors at this cache index.  */
                bit_set =  (index % 32);
 800ff9e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800ffa0:	f003 031f 	and.w	r3, r3, #31
 800ffa4:	643b      	str	r3, [r7, #64]	@ 0x40

                /* Compute the actual array index by multiplying by the cache depth.  */
                index =  (bit_set * FX_SECTOR_CACHE_DEPTH);
 800ffa6:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800ffa8:	009b      	lsls	r3, r3, #2
 800ffaa:	63bb      	str	r3, [r7, #56]	@ 0x38
 800ffac:	e00d      	b.n	800ffca <_fx_utility_logical_sector_flush+0x23a>
                /* Find the next set bit.  */
                while ((valid_bit_map & 1) == 0)
                {

                    /* Otherwise, shift down the bit in the bit map.  */
                    valid_bit_map =  valid_bit_map >> 1;
 800ffae:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800ffb0:	085b      	lsrs	r3, r3, #1
 800ffb2:	62fb      	str	r3, [r7, #44]	@ 0x2c

                    /* Increment the set bit marker.  */
                    bit_set++;
 800ffb4:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800ffb6:	3301      	adds	r3, #1
 800ffb8:	643b      	str	r3, [r7, #64]	@ 0x40
                while ((valid_bit_map & 1) == 0)
 800ffba:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800ffbc:	f003 0301 	and.w	r3, r3, #1
 800ffc0:	2b00      	cmp	r3, #0
 800ffc2:	d0f4      	beq.n	800ffae <_fx_utility_logical_sector_flush+0x21e>
                }

                /* Compute the first actual index into the hashed cache.  */
                index =  (bit_set * FX_SECTOR_CACHE_DEPTH);
 800ffc4:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800ffc6:	009b      	lsls	r3, r3, #2
 800ffc8:	63bb      	str	r3, [r7, #56]	@ 0x38
            /* At this point, bit_set represents the next group of hashed sectors that could
               have valid cache entries and index represents the index into the sector cache
               of that sector group.  */

            /* Clear the remaining valid sectors for this entry in the bit map.  */
            remaining_valid =  0;
 800ffca:	2300      	movs	r3, #0
 800ffcc:	637b      	str	r3, [r7, #52]	@ 0x34
            /* Loop to check the corresponding hash entries.  */
            do
            {

                /* Setup pointer to the cache entry.  */
                cache_entry =  &(media_ptr -> fx_media_sector_cache[index]);
 800ffce:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 800ffd0:	4613      	mov	r3, r2
 800ffd2:	005b      	lsls	r3, r3, #1
 800ffd4:	4413      	add	r3, r2
 800ffd6:	00db      	lsls	r3, r3, #3
 800ffd8:	f503 6347 	add.w	r3, r3, #3184	@ 0xc70
 800ffdc:	69fa      	ldr	r2, [r7, #28]
 800ffde:	4413      	add	r3, r2
 800ffe0:	64fb      	str	r3, [r7, #76]	@ 0x4c

                /* Loop to examine the full depth of the hashed cache.  */
                for (i = 0; i < 4; i++)
 800ffe2:	2300      	movs	r3, #0
 800ffe4:	647b      	str	r3, [r7, #68]	@ 0x44
 800ffe6:	e0a7      	b.n	8010138 <_fx_utility_logical_sector_flush+0x3a8>
                {

                    /* Determine if this cached sector is within the specified range and is valid.  */
                    if ((cache_entry -> fx_cached_sector_valid) &&
 800ffe8:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800ffea:	7c5b      	ldrb	r3, [r3, #17]
 800ffec:	2b00      	cmp	r3, #0
 800ffee:	f000 8089 	beq.w	8010104 <_fx_utility_logical_sector_flush+0x374>
                        (cache_entry -> fx_cached_sector >= starting_sector) &&
 800fff2:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800fff4:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
                    if ((cache_entry -> fx_cached_sector_valid) &&
 800fff8:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 800fffc:	4290      	cmp	r0, r2
 800fffe:	eb71 0303 	sbcs.w	r3, r1, r3
 8010002:	d37f      	bcc.n	8010104 <_fx_utility_logical_sector_flush+0x374>
                        (cache_entry -> fx_cached_sector <= ending_sector))
 8010004:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8010006:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
                        (cache_entry -> fx_cached_sector >= starting_sector) &&
 801000a:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 801000e:	4290      	cmp	r0, r2
 8010010:	eb71 0303 	sbcs.w	r3, r1, r3
 8010014:	d376      	bcc.n	8010104 <_fx_utility_logical_sector_flush+0x374>
                    {

                        /* Determine if the requested sector has been written to.  */
                        if (cache_entry -> fx_cached_sector_buffer_dirty)
 8010016:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8010018:	7c1b      	ldrb	r3, [r3, #16]
 801001a:	2b00      	cmp	r3, #0
 801001c:	d04d      	beq.n	80100ba <_fx_utility_logical_sector_flush+0x32a>


                            /* Yes, write the cached sector out to the media.  */

                            /* Check for write protect at the media level (set by driver).  */
                            if (media_ptr -> fx_media_driver_write_protect == FX_FALSE)
 801001e:	69fb      	ldr	r3, [r7, #28]
 8010020:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
 8010024:	2b00      	cmp	r3, #0
 8010026:	d148      	bne.n	80100ba <_fx_utility_logical_sector_flush+0x32a>
                            {

#ifndef FX_MEDIA_STATISTICS_DISABLE

                                /* Increment the number of driver write sector(s) requests.  */
                                media_ptr -> fx_media_driver_write_requests++;
 8010028:	69fb      	ldr	r3, [r7, #28]
 801002a:	f8d3 31b0 	ldr.w	r3, [r3, #432]	@ 0x1b0
 801002e:	1c5a      	adds	r2, r3, #1
 8010030:	69fb      	ldr	r3, [r7, #28]
 8010032:	f8c3 21b0 	str.w	r2, [r3, #432]	@ 0x1b0
#endif

                                /* Build Write request to the driver.  */
                                media_ptr -> fx_media_driver_request =          FX_DRIVER_WRITE;
 8010036:	69fb      	ldr	r3, [r7, #28]
 8010038:	2201      	movs	r2, #1
 801003a:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
                                media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 801003e:	69fb      	ldr	r3, [r7, #28]
 8010040:	2290      	movs	r2, #144	@ 0x90
 8010042:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
                                media_ptr -> fx_media_driver_buffer =           cache_entry -> fx_cached_sector_memory_buffer;
 8010046:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8010048:	681a      	ldr	r2, [r3, #0]
 801004a:	69fb      	ldr	r3, [r7, #28]
 801004c:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
#ifdef FX_DRIVER_USE_64BIT_LBA
                                media_ptr -> fx_media_driver_logical_sector =   cache_entry -> fx_cached_sector;
#else
                                media_ptr -> fx_media_driver_logical_sector =   (ULONG)cache_entry -> fx_cached_sector;
 8010050:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8010052:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8010056:	69fb      	ldr	r3, [r7, #28]
 8010058:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
#endif
                                media_ptr -> fx_media_driver_sectors =          1;
 801005c:	69fb      	ldr	r3, [r7, #28]
 801005e:	2201      	movs	r2, #1
 8010060:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98
                                media_ptr -> fx_media_driver_sector_type =      cache_entry -> fx_cached_sector_type;
 8010064:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8010066:	7c9b      	ldrb	r3, [r3, #18]
 8010068:	461a      	mov	r2, r3
 801006a:	69fb      	ldr	r3, [r7, #28]
 801006c:	f8c3 20b8 	str.w	r2, [r3, #184]	@ 0xb8

                                /* Sectors other than FX_DATA_SECTOR will never be dirty when FX_FAULT_TOLERANT is defined. */
#ifndef FX_FAULT_TOLERANT
                                /* Determine if the system write flag needs to be set.  */
                                if (cache_entry -> fx_cached_sector_type != FX_DATA_SECTOR)
 8010070:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8010072:	7c9b      	ldrb	r3, [r3, #18]
 8010074:	2b04      	cmp	r3, #4
 8010076:	d003      	beq.n	8010080 <_fx_utility_logical_sector_flush+0x2f0>
                                {

                                    /* Yes, a system sector write is present so set the flag.  The driver
                                       can use this flag to make extra safeguards in writing the sector
                                       out, yielding more fault tolerance.  */
                                    media_ptr -> fx_media_driver_system_write =  FX_TRUE;
 8010078:	69fb      	ldr	r3, [r7, #28]
 801007a:	2201      	movs	r2, #1
 801007c:	f8c3 20b0 	str.w	r2, [r3, #176]	@ 0xb0

                                /* If trace is enabled, insert this event into the trace buffer.  */
                                FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_WRITE, media_ptr, cache_entry -> fx_cached_sector, 1, cache_entry -> fx_cached_sector_memory_buffer, FX_TRACE_INTERNAL_EVENTS, 0, 0)

                                /* Invoke the driver to write the sector.  */
                                (media_ptr -> fx_media_driver_entry) (media_ptr);
 8010080:	69fb      	ldr	r3, [r7, #28]
 8010082:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
 8010086:	69f8      	ldr	r0, [r7, #28]
 8010088:	4798      	blx	r3

                                /* Clear the system write flag.  */
                                media_ptr -> fx_media_driver_system_write =  FX_FALSE;
 801008a:	69fb      	ldr	r3, [r7, #28]
 801008c:	2200      	movs	r2, #0
 801008e:	f8c3 20b0 	str.w	r2, [r3, #176]	@ 0xb0

                                /* Check for successful completion.  */
                                if (media_ptr -> fx_media_driver_status)
 8010092:	69fb      	ldr	r3, [r7, #28]
 8010094:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8010098:	2b00      	cmp	r3, #0
 801009a:	d003      	beq.n	80100a4 <_fx_utility_logical_sector_flush+0x314>
                                {

                                    /* Error writing a cached sector out.  Return the
                                       error status.  */
                                    return(media_ptr -> fx_media_driver_status);
 801009c:	69fb      	ldr	r3, [r7, #28]
 801009e:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 80100a2:	e086      	b.n	80101b2 <_fx_utility_logical_sector_flush+0x422>
                                }

                                /* Clear the buffer dirty flag since it has been flushed
                                   out.  */
                                cache_entry -> fx_cached_sector_buffer_dirty =  FX_FALSE;
 80100a4:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80100a6:	2200      	movs	r2, #0
 80100a8:	741a      	strb	r2, [r3, #16]

                                /* Decrement the number of dirty sectors currently in the cache.  */
                                media_ptr -> fx_media_sector_cache_dirty_count--;
 80100aa:	69fb      	ldr	r3, [r7, #28]
 80100ac:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80100ae:	1e5a      	subs	r2, r3, #1
 80100b0:	69fb      	ldr	r3, [r7, #28]
 80100b2:	625a      	str	r2, [r3, #36]	@ 0x24
                                remaining_dirty--;
 80100b4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80100b6:	3b01      	subs	r3, #1
 80100b8:	633b      	str	r3, [r7, #48]	@ 0x30
                            }
                        }

                        /* Determine if the invalidate option is specified.  */
                        if (invalidate)
 80100ba:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 80100bc:	2b00      	cmp	r3, #0
 80100be:	d018      	beq.n	80100f2 <_fx_utility_logical_sector_flush+0x362>
                        {

                            /* Invalidate the cache entry.  */
                            cache_entry -> fx_cached_sector_valid =  FX_FALSE;
 80100c0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80100c2:	2200      	movs	r2, #0
 80100c4:	745a      	strb	r2, [r3, #17]

                            /* Place all ones in the sector number.  */
                            cache_entry -> fx_cached_sector =  (~(ULONG64)0);
 80100c6:	6cf9      	ldr	r1, [r7, #76]	@ 0x4c
 80100c8:	f04f 32ff 	mov.w	r2, #4294967295
 80100cc:	f04f 33ff 	mov.w	r3, #4294967295
 80100d0:	e9c1 2302 	strd	r2, r3, [r1, #8]

                            /* Determine if this sector is still dirty, this could be the case if
                               write protection was turned on.  */
                            if (cache_entry -> fx_cached_sector_buffer_dirty)
 80100d4:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80100d6:	7c1b      	ldrb	r3, [r3, #16]
 80100d8:	2b00      	cmp	r3, #0
 80100da:	d00a      	beq.n	80100f2 <_fx_utility_logical_sector_flush+0x362>
                            {

                                /* Yes, clear the dirty flag.  */
                                cache_entry -> fx_cached_sector_buffer_dirty =  FX_FALSE;
 80100dc:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80100de:	2200      	movs	r2, #0
 80100e0:	741a      	strb	r2, [r3, #16]

                                /* Decrement the number of dirty sectors currently in the cache.  */
                                media_ptr -> fx_media_sector_cache_dirty_count--;
 80100e2:	69fb      	ldr	r3, [r7, #28]
 80100e4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80100e6:	1e5a      	subs	r2, r3, #1
 80100e8:	69fb      	ldr	r3, [r7, #28]
 80100ea:	625a      	str	r2, [r3, #36]	@ 0x24
                                remaining_dirty--;
 80100ec:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80100ee:	3b01      	subs	r3, #1
 80100f0:	633b      	str	r3, [r7, #48]	@ 0x30
                            }
                        }

                        /* Decrement the number of sectors in the range that have been processed.  */
                        sectors--;
 80100f2:	e9d7 231c 	ldrd	r2, r3, [r7, #112]	@ 0x70
 80100f6:	f112 38ff 	adds.w	r8, r2, #4294967295
 80100fa:	f143 39ff 	adc.w	r9, r3, #4294967295
 80100fe:	e9c7 891c 	strd	r8, r9, [r7, #112]	@ 0x70
 8010102:	e006      	b.n	8010112 <_fx_utility_logical_sector_flush+0x382>
                    }
                    else
                    {

                        /* Determine if the sector is valid.  */
                        if (cache_entry -> fx_cached_sector_valid)
 8010104:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8010106:	7c5b      	ldrb	r3, [r3, #17]
 8010108:	2b00      	cmp	r3, #0
 801010a:	d002      	beq.n	8010112 <_fx_utility_logical_sector_flush+0x382>
                        {

                            /* Increment the number of still remaining but out of range sectors.  */
                            remaining_valid++;
 801010c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801010e:	3301      	adds	r3, #1
 8010110:	637b      	str	r3, [r7, #52]	@ 0x34
                        }
                    }

                    /* Determine if invalidation is not required and there are no
                       more dirty sectors. */
                    if ((remaining_dirty == 0) && (invalidate == FX_FALSE))
 8010112:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010114:	2b00      	cmp	r3, #0
 8010116:	d102      	bne.n	801011e <_fx_utility_logical_sector_flush+0x38e>
 8010118:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801011a:	2b00      	cmp	r3, #0
 801011c:	d011      	beq.n	8010142 <_fx_utility_logical_sector_flush+0x3b2>
                        /* Yes, nothing left to do.  */
                        break;
                    }

                    /* Determine if there are any more sectors to process.  */
                    if ((sectors == 0) && (invalidate == FX_FALSE))
 801011e:	e9d7 231c 	ldrd	r2, r3, [r7, #112]	@ 0x70
 8010122:	4313      	orrs	r3, r2
 8010124:	d102      	bne.n	801012c <_fx_utility_logical_sector_flush+0x39c>
 8010126:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8010128:	2b00      	cmp	r3, #0
 801012a:	d00c      	beq.n	8010146 <_fx_utility_logical_sector_flush+0x3b6>
                        /* No more sectors required to process.  */
                        break;
                    }

                    /* Move to the next cache entry.  */
                    cache_entry++;
 801012c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801012e:	3318      	adds	r3, #24
 8010130:	64fb      	str	r3, [r7, #76]	@ 0x4c
                for (i = 0; i < 4; i++)
 8010132:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8010134:	3301      	adds	r3, #1
 8010136:	647b      	str	r3, [r7, #68]	@ 0x44
 8010138:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801013a:	2b03      	cmp	r3, #3
 801013c:	f67f af54 	bls.w	800ffe8 <_fx_utility_logical_sector_flush+0x258>
 8010140:	e002      	b.n	8010148 <_fx_utility_logical_sector_flush+0x3b8>
                        break;
 8010142:	bf00      	nop
 8010144:	e000      	b.n	8010148 <_fx_utility_logical_sector_flush+0x3b8>
                        break;
 8010146:	bf00      	nop
                }

                /* Move the index to the next position since the bit map can only represent 32
                   cache entries.  */
                index =  index + (32 * FX_SECTOR_CACHE_DEPTH);
 8010148:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801014a:	3380      	adds	r3, #128	@ 0x80
 801014c:	63bb      	str	r3, [r7, #56]	@ 0x38
            } while (index < cache_size);
 801014e:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8010150:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8010152:	429a      	cmp	r2, r3
 8010154:	f4ff af3b 	bcc.w	800ffce <_fx_utility_logical_sector_flush+0x23e>

            /* Determine if invalidation was required and there are no more valid sectors
               associated with this bit position.  */
            if ((invalidate) && (remaining_valid == 0))
 8010158:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801015a:	2b00      	cmp	r3, #0
 801015c:	d00c      	beq.n	8010178 <_fx_utility_logical_sector_flush+0x3e8>
 801015e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8010160:	2b00      	cmp	r3, #0
 8010162:	d109      	bne.n	8010178 <_fx_utility_logical_sector_flush+0x3e8>
            {

                /* Clear this bit position.  */
                media_ptr -> fx_media_sector_cache_hashed_sector_valid &=  ~(((ULONG)1) << bit_set);
 8010164:	69fb      	ldr	r3, [r7, #28]
 8010166:	6a1a      	ldr	r2, [r3, #32]
 8010168:	2101      	movs	r1, #1
 801016a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801016c:	fa01 f303 	lsl.w	r3, r1, r3
 8010170:	43db      	mvns	r3, r3
 8010172:	401a      	ands	r2, r3
 8010174:	69fb      	ldr	r3, [r7, #28]
 8010176:	621a      	str	r2, [r3, #32]
            }

            /* Determine if the starting sector is being used for examination of the hash.  */
            if (use_starting_sector)
 8010178:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801017a:	2b00      	cmp	r3, #0
 801017c:	d008      	beq.n	8010190 <_fx_utility_logical_sector_flush+0x400>
            {

                /* Move to the next sector.  */
                starting_sector++;
 801017e:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 8010182:	f112 0a01 	adds.w	sl, r2, #1
 8010186:	f143 0b00 	adc.w	fp, r3, #0
 801018a:	e9c7 ab04 	strd	sl, fp, [r7, #16]
 801018e:	e005      	b.n	801019c <_fx_utility_logical_sector_flush+0x40c>
            }
            else
            {

                /* Move to next bit in the map.  */
                valid_bit_map =  valid_bit_map >> 1;
 8010190:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010192:	085b      	lsrs	r3, r3, #1
 8010194:	62fb      	str	r3, [r7, #44]	@ 0x2c

                /* Increment the set bit marker.  */
                bit_set++;
 8010196:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8010198:	3301      	adds	r3, #1
 801019a:	643b      	str	r3, [r7, #64]	@ 0x40
        while (valid_bit_map)
 801019c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801019e:	2b00      	cmp	r3, #0
 80101a0:	f47f aedd 	bne.w	800ff5e <_fx_utility_logical_sector_flush+0x1ce>
 80101a4:	e004      	b.n	80101b0 <_fx_utility_logical_sector_flush+0x420>
                break;
 80101a6:	bf00      	nop
 80101a8:	e002      	b.n	80101b0 <_fx_utility_logical_sector_flush+0x420>
                break;
 80101aa:	bf00      	nop
 80101ac:	e000      	b.n	80101b0 <_fx_utility_logical_sector_flush+0x420>
                break;
 80101ae:	bf00      	nop
    FX_PARAMETER_NOT_USED(sectors);
    FX_PARAMETER_NOT_USED(invalidate);
#endif /* FX_DISABLE_CACHE */

    /* If we get here, return successful status to the caller.  */
    return(FX_SUCCESS);
 80101b0:	2300      	movs	r3, #0
}
 80101b2:	4618      	mov	r0, r3
 80101b4:	3750      	adds	r7, #80	@ 0x50
 80101b6:	46bd      	mov	sp, r7
 80101b8:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

080101bc <_fx_utility_logical_sector_read>:
/*                                            resulting in version 6.2.0  */
/*                                                                        */
/**************************************************************************/
UINT  _fx_utility_logical_sector_read(FX_MEDIA *media_ptr, ULONG64 logical_sector,
                                      VOID *buffer_ptr, ULONG sectors, UCHAR sector_type)
{
 80101bc:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 80101c0:	b09c      	sub	sp, #112	@ 0x70
 80101c2:	af04      	add	r7, sp, #16
 80101c4:	64f8      	str	r0, [r7, #76]	@ 0x4c
 80101c6:	e9c7 2310 	strd	r2, r3, [r7, #64]	@ 0x40


#ifndef FX_MEDIA_STATISTICS_DISABLE

    /* Determine if the request is for FAT sector.  */
    if (sector_type == FX_FAT_SECTOR)
 80101ca:	f897 3088 	ldrb.w	r3, [r7, #136]	@ 0x88
 80101ce:	2b02      	cmp	r3, #2
 80101d0:	d106      	bne.n	80101e0 <_fx_utility_logical_sector_read+0x24>
    {

        /* Increment the number of FAT sector reads.  */
        media_ptr -> fx_media_fat_sector_reads++;
 80101d2:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80101d4:	f8d3 3194 	ldr.w	r3, [r3, #404]	@ 0x194
 80101d8:	1c5a      	adds	r2, r3, #1
 80101da:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80101dc:	f8c3 2194 	str.w	r2, [r3, #404]	@ 0x194
    }

    /* Increment the number of logical sectors read.  */
    media_ptr -> fx_media_logical_sector_reads++;
 80101e0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80101e2:	f8d3 319c 	ldr.w	r3, [r3, #412]	@ 0x19c
 80101e6:	1c5a      	adds	r2, r3, #1
 80101e8:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80101ea:	f8c3 219c 	str.w	r2, [r3, #412]	@ 0x19c
    /* Extended port-specific processing macro, which is by default defined to white space.  */
    FX_UTILITY_LOGICAL_SECTOR_READ_EXTENSION

#ifndef FX_DISABLE_CACHE
    /* Determine if the request is for the internal media buffer area.  */
    if ((((UCHAR *)buffer_ptr) >= media_ptr -> fx_media_memory_buffer) &&
 80101ee:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80101f0:	689a      	ldr	r2, [r3, #8]
 80101f2:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 80101f6:	4293      	cmp	r3, r2
 80101f8:	f0c0 80d9 	bcc.w	80103ae <_fx_utility_logical_sector_read+0x1f2>
        (((UCHAR *)buffer_ptr) <= media_ptr -> fx_media_sector_cache_end))
 80101fc:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80101fe:	699a      	ldr	r2, [r3, #24]
    if ((((UCHAR *)buffer_ptr) >= media_ptr -> fx_media_memory_buffer) &&
 8010200:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8010204:	4293      	cmp	r3, r2
 8010206:	f200 80d2 	bhi.w	80103ae <_fx_utility_logical_sector_read+0x1f2>
    {

        /* Internal cache buffer is requested.  */

        /* Examine the logical sector cache.  */
        cache_entry = _fx_utility_logical_sector_cache_entry_read(media_ptr, logical_sector, &previous_cache_entry);
 801020a:	f107 0350 	add.w	r3, r7, #80	@ 0x50
 801020e:	9300      	str	r3, [sp, #0]
 8010210:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	@ 0x40
 8010214:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 8010216:	f7ff faf1 	bl	800f7fc <_fx_utility_logical_sector_cache_entry_read>
 801021a:	6578      	str	r0, [r7, #84]	@ 0x54

        /* Was the sector found?  */
        if (cache_entry == FX_NULL)
 801021c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801021e:	2b00      	cmp	r3, #0
 8010220:	d101      	bne.n	8010226 <_fx_utility_logical_sector_read+0x6a>
        {

            /* Yes, the sector was found. Return success!  */
            return(FX_SUCCESS);
 8010222:	2300      	movs	r3, #0
 8010224:	e259      	b.n	80106da <_fx_utility_logical_sector_read+0x51e>
        /* At this point, we need to read in a sector from the media.  */

#ifndef FX_MEDIA_STATISTICS_DISABLE

        /* Increment the number of logical sectors cache read misses.  */
        media_ptr -> fx_media_logical_sector_cache_read_misses++;
 8010226:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8010228:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 801022c:	1c5a      	adds	r2, r3, #1
 801022e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8010230:	f8c3 21a8 	str.w	r2, [r3, #424]	@ 0x1a8
        FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_LOG_SECTOR_CACHE_MISS, media_ptr, logical_sector, 0, media_ptr -> fx_media_sector_cache_size, FX_TRACE_INTERNAL_EVENTS, 0, 0)
#endif

        /* First, check and see if the last used entry has been
           modified.  */
        if ((cache_entry -> fx_cached_sector_valid) &&
 8010234:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8010236:	7c5b      	ldrb	r3, [r3, #17]
 8010238:	2b00      	cmp	r3, #0
 801023a:	d049      	beq.n	80102d0 <_fx_utility_logical_sector_read+0x114>
            (cache_entry -> fx_cached_sector_buffer_dirty))
 801023c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801023e:	7c1b      	ldrb	r3, [r3, #16]
        if ((cache_entry -> fx_cached_sector_valid) &&
 8010240:	2b00      	cmp	r3, #0
 8010242:	d045      	beq.n	80102d0 <_fx_utility_logical_sector_read+0x114>
               before we read in the new buffer.  */

#ifndef FX_MEDIA_STATISTICS_DISABLE

            /* Increment the number of driver write sector(s) requests.  */
            media_ptr -> fx_media_driver_write_requests++;
 8010244:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8010246:	f8d3 31b0 	ldr.w	r3, [r3, #432]	@ 0x1b0
 801024a:	1c5a      	adds	r2, r3, #1
 801024c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801024e:	f8c3 21b0 	str.w	r2, [r3, #432]	@ 0x1b0
#endif

            /* Build write request to the driver.  */
            media_ptr -> fx_media_driver_request =          FX_DRIVER_WRITE;
 8010252:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8010254:	2201      	movs	r2, #1
 8010256:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
            media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 801025a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801025c:	2290      	movs	r2, #144	@ 0x90
 801025e:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
            media_ptr -> fx_media_driver_buffer =           cache_entry -> fx_cached_sector_memory_buffer;
 8010262:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8010264:	681a      	ldr	r2, [r3, #0]
 8010266:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8010268:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
#ifdef FX_DRIVER_USE_64BIT_LBA
            media_ptr -> fx_media_driver_logical_sector =   cache_entry -> fx_cached_sector;
#else
            media_ptr -> fx_media_driver_logical_sector =   (ULONG)cache_entry -> fx_cached_sector;
 801026c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801026e:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8010272:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8010274:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
#endif
            media_ptr -> fx_media_driver_sectors =          1;
 8010278:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801027a:	2201      	movs	r2, #1
 801027c:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98
            media_ptr -> fx_media_driver_sector_type =      cache_entry -> fx_cached_sector_type;
 8010280:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8010282:	7c9b      	ldrb	r3, [r3, #18]
 8010284:	461a      	mov	r2, r3
 8010286:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8010288:	f8c3 20b8 	str.w	r2, [r3, #184]	@ 0xb8

            /* Determine if the sector is a data sector or a system sector.  */
            if (cache_entry -> fx_cached_sector_type != FX_DATA_SECTOR)
 801028c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801028e:	7c9b      	ldrb	r3, [r3, #18]
 8010290:	2b04      	cmp	r3, #4
 8010292:	d003      	beq.n	801029c <_fx_utility_logical_sector_read+0xe0>
            {

                /* System sector is present.  */
                media_ptr -> fx_media_driver_system_write =  FX_TRUE;
 8010294:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8010296:	2201      	movs	r2, #1
 8010298:	f8c3 20b0 	str.w	r2, [r3, #176]	@ 0xb0

            /* If trace is enabled, insert this event into the trace buffer.  */
            FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_WRITE, media_ptr, cache_entry -> fx_cached_sector, 1, cache_entry -> fx_cached_sector_memory_buffer, FX_TRACE_INTERNAL_EVENTS, 0, 0)

            /* Invoke the driver to write the sector.  */
            (media_ptr -> fx_media_driver_entry) (media_ptr);
 801029c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801029e:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
 80102a2:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 80102a4:	4798      	blx	r3

            /* Clear the system write flag.  */
            media_ptr -> fx_media_driver_system_write =  FX_FALSE;
 80102a6:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80102a8:	2200      	movs	r2, #0
 80102aa:	f8c3 20b0 	str.w	r2, [r3, #176]	@ 0xb0

            /* Check for successful completion.  */
            if (media_ptr -> fx_media_driver_status)
 80102ae:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80102b0:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 80102b4:	2b00      	cmp	r3, #0
 80102b6:	d003      	beq.n	80102c0 <_fx_utility_logical_sector_read+0x104>
            {

                /* Error writing a cached sector out.  Return the
                   error status.  */
                return(media_ptr -> fx_media_driver_status);
 80102b8:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80102ba:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 80102be:	e20c      	b.n	80106da <_fx_utility_logical_sector_read+0x51e>
            }

            /* Clear the buffer dirty flag since it has been flushed
               out.  */
            cache_entry -> fx_cached_sector_buffer_dirty =  FX_FALSE;
 80102c0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80102c2:	2200      	movs	r2, #0
 80102c4:	741a      	strb	r2, [r3, #16]

            /* Decrement the number of outstanding dirty cache entries.  */
            media_ptr -> fx_media_sector_cache_dirty_count--;
 80102c6:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80102c8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80102ca:	1e5a      	subs	r2, r3, #1
 80102cc:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80102ce:	625a      	str	r2, [r3, #36]	@ 0x24

        /* At this point, we can go out and setup this cached sector
           entry.  */

        /* Compare against logical sector to make sure it is valid.  */
        if (logical_sector >= media_ptr -> fx_media_total_sectors)
 80102d0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80102d2:	e9d3 230e 	ldrd	r2, r3, [r3, #56]	@ 0x38
 80102d6:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	@ 0x40
 80102da:	4290      	cmp	r0, r2
 80102dc:	eb71 0303 	sbcs.w	r3, r1, r3
 80102e0:	d301      	bcc.n	80102e6 <_fx_utility_logical_sector_read+0x12a>
        {
            return(FX_SECTOR_INVALID);
 80102e2:	2389      	movs	r3, #137	@ 0x89
 80102e4:	e1f9      	b.n	80106da <_fx_utility_logical_sector_read+0x51e>
        }

#ifndef FX_MEDIA_STATISTICS_DISABLE

        /* Increment the number of driver read sector(s) requests.  */
        media_ptr -> fx_media_driver_read_requests++;
 80102e6:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80102e8:	f8d3 31ac 	ldr.w	r3, [r3, #428]	@ 0x1ac
 80102ec:	1c5a      	adds	r2, r3, #1
 80102ee:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80102f0:	f8c3 21ac 	str.w	r2, [r3, #428]	@ 0x1ac
#endif

        /* Build Read request to the driver.  */
        media_ptr -> fx_media_driver_request =          FX_DRIVER_READ;
 80102f4:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80102f6:	2200      	movs	r2, #0
 80102f8:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
        media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 80102fc:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80102fe:	2290      	movs	r2, #144	@ 0x90
 8010300:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
        media_ptr -> fx_media_driver_buffer =           cache_entry -> fx_cached_sector_memory_buffer;
 8010304:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8010306:	681a      	ldr	r2, [r3, #0]
 8010308:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801030a:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
#ifdef FX_DRIVER_USE_64BIT_LBA
        media_ptr -> fx_media_driver_logical_sector =   logical_sector;
#else
        media_ptr -> fx_media_driver_logical_sector =   (ULONG)logical_sector;
 801030e:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8010310:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8010312:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
#endif
        media_ptr -> fx_media_driver_sectors =          1;
 8010316:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8010318:	2201      	movs	r2, #1
 801031a:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98
        media_ptr -> fx_media_driver_sector_type =      sector_type;
 801031e:	f897 2088 	ldrb.w	r2, [r7, #136]	@ 0x88
 8010322:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8010324:	f8c3 20b8 	str.w	r2, [r3, #184]	@ 0xb8

        /* Determine if the sector is a data sector or a system sector.  */
        if (sector_type == FX_DATA_SECTOR)
 8010328:	f897 3088 	ldrb.w	r3, [r7, #136]	@ 0x88
 801032c:	2b04      	cmp	r3, #4
 801032e:	d103      	bne.n	8010338 <_fx_utility_logical_sector_read+0x17c>
        {

            /* Data sector is present.  */
            media_ptr -> fx_media_driver_data_sector_read =  FX_TRUE;
 8010330:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8010332:	2201      	movs	r2, #1
 8010334:	f8c3 20b4 	str.w	r2, [r3, #180]	@ 0xb4

        /* If trace is enabled, insert this event into the trace buffer.  */
        FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_READ, media_ptr, logical_sector, 1, cache_entry -> fx_cached_sector_memory_buffer, FX_TRACE_INTERNAL_EVENTS, 0, 0)

        /* Invoke the driver to read the sector.  */
        (media_ptr -> fx_media_driver_entry) (media_ptr);
 8010338:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801033a:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
 801033e:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 8010340:	4798      	blx	r3

        /* Clear data sector is present flag.  */
        media_ptr -> fx_media_driver_data_sector_read =  FX_FALSE;
 8010342:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8010344:	2200      	movs	r2, #0
 8010346:	f8c3 20b4 	str.w	r2, [r3, #180]	@ 0xb4

        /* Determine if the read was successful.  */
        if (media_ptr -> fx_media_driver_status == FX_SUCCESS)
 801034a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801034c:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8010350:	2b00      	cmp	r3, #0
 8010352:	d11a      	bne.n	801038a <_fx_utility_logical_sector_read+0x1ce>
        {

            /* Remember the sector number.  */
            cache_entry -> fx_cached_sector =  logical_sector;
 8010354:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 8010356:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	@ 0x40
 801035a:	e9c1 2302 	strd	r2, r3, [r1, #8]

            /* Make the cache entry valid.  */
            cache_entry -> fx_cached_sector_valid =  FX_TRUE;
 801035e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8010360:	2201      	movs	r2, #1
 8010362:	745a      	strb	r2, [r3, #17]

            /* Remember the sector type.  */
            cache_entry -> fx_cached_sector_type =  sector_type;
 8010364:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8010366:	f897 2088 	ldrb.w	r2, [r7, #136]	@ 0x88
 801036a:	749a      	strb	r2, [r3, #18]

            /* Place this entry that the head of the cached sector
               list.  */

            /* Determine if we need to update the last used list.  */
            if (previous_cache_entry)
 801036c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801036e:	2b00      	cmp	r3, #0
 8010370:	d015      	beq.n	801039e <_fx_utility_logical_sector_read+0x1e2>

                /* Yes, the current entry is not at the front of the list
                   so we need to change the order.  */

                /* Link the previous entry to this entry's next pointer.  */
                previous_cache_entry -> fx_cached_sector_next_used =
 8010372:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
                    cache_entry -> fx_cached_sector_next_used;
 8010374:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8010376:	6952      	ldr	r2, [r2, #20]
                previous_cache_entry -> fx_cached_sector_next_used =
 8010378:	615a      	str	r2, [r3, #20]

                /* Place this entry at the head of the list.  */
                cache_entry -> fx_cached_sector_next_used =
                    media_ptr -> fx_media_sector_cache_list_ptr;
 801037a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801037c:	69da      	ldr	r2, [r3, #28]
                cache_entry -> fx_cached_sector_next_used =
 801037e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8010380:	615a      	str	r2, [r3, #20]
                media_ptr -> fx_media_sector_cache_list_ptr =  cache_entry;
 8010382:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8010384:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8010386:	61da      	str	r2, [r3, #28]
 8010388:	e009      	b.n	801039e <_fx_utility_logical_sector_read+0x1e2>
        }
        else
        {

            /* Invalidate the cache entry on read errors.  */
            cache_entry -> fx_cached_sector_valid =  FX_FALSE;
 801038a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801038c:	2200      	movs	r2, #0
 801038e:	745a      	strb	r2, [r3, #17]

            /* Put all ones in the sector value.  */
            cache_entry -> fx_cached_sector =  (~(ULONG64)0);
 8010390:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 8010392:	f04f 32ff 	mov.w	r2, #4294967295
 8010396:	f04f 33ff 	mov.w	r3, #4294967295
 801039a:	e9c1 2302 	strd	r2, r3, [r1, #8]
        }

        /* Simply setup the pointer to this buffer and return.  */
        media_ptr -> fx_media_memory_buffer =  cache_entry -> fx_cached_sector_memory_buffer;
 801039e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80103a0:	681a      	ldr	r2, [r3, #0]
 80103a2:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80103a4:	609a      	str	r2, [r3, #8]

        /* Return the driver status.  */
        return(media_ptr -> fx_media_driver_status);
 80103a6:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80103a8:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 80103ac:	e195      	b.n	80106da <_fx_utility_logical_sector_read+0x51e>
    {

        /* Direct I/O to application buffer area.  */

        /* Compare against logical sector to make sure it is valid.  */
        if ((logical_sector + sectors - 1) > (ULONG)media_ptr -> fx_media_total_sectors)
 80103ae:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 80103b2:	2200      	movs	r2, #0
 80103b4:	469a      	mov	sl, r3
 80103b6:	4693      	mov	fp, r2
 80103b8:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	@ 0x40
 80103bc:	eb1a 0402 	adds.w	r4, sl, r2
 80103c0:	eb4b 0503 	adc.w	r5, fp, r3
 80103c4:	f114 38ff 	adds.w	r8, r4, #4294967295
 80103c8:	f145 39ff 	adc.w	r9, r5, #4294967295
 80103cc:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80103ce:	e9d3 230e 	ldrd	r2, r3, [r3, #56]	@ 0x38
 80103d2:	2300      	movs	r3, #0
 80103d4:	63ba      	str	r2, [r7, #56]	@ 0x38
 80103d6:	63fb      	str	r3, [r7, #60]	@ 0x3c
 80103d8:	e9d7 120e 	ldrd	r1, r2, [r7, #56]	@ 0x38
 80103dc:	460b      	mov	r3, r1
 80103de:	4543      	cmp	r3, r8
 80103e0:	4613      	mov	r3, r2
 80103e2:	eb73 0309 	sbcs.w	r3, r3, r9
 80103e6:	d22c      	bcs.n	8010442 <_fx_utility_logical_sector_read+0x286>
        {
            return(FX_SECTOR_INVALID);
 80103e8:	2389      	movs	r3, #137	@ 0x89
 80103ea:	e176      	b.n	80106da <_fx_utility_logical_sector_read+0x51e>
        /* Attempt to fill the beginning of the buffer from cached sectors.  */
        while (sectors)
        {

            /* Determine if the sector is in the cache.  */
            if (_fx_utility_logical_sector_cache_entry_read(media_ptr, logical_sector, &previous_cache_entry))
 80103ec:	f107 0350 	add.w	r3, r7, #80	@ 0x50
 80103f0:	9300      	str	r3, [sp, #0]
 80103f2:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	@ 0x40
 80103f6:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 80103f8:	f7ff fa00 	bl	800f7fc <_fx_utility_logical_sector_cache_entry_read>
 80103fc:	4603      	mov	r3, r0
 80103fe:	2b00      	cmp	r3, #0
 8010400:	d124      	bne.n	801044c <_fx_utility_logical_sector_read+0x290>
                /* Not in the cache - get out of the loop!  */
                break;
            }

            /* Yes, sector is in the cache. Copy the data from the cache to the destination buffer.  */
            _fx_utility_memory_copy(media_ptr -> fx_media_memory_buffer, buffer_ptr, media_ptr -> fx_media_bytes_per_sector); /* Use case of memcpy is verified. */
 8010402:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8010404:	6898      	ldr	r0, [r3, #8]
 8010406:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8010408:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 801040a:	461a      	mov	r2, r3
 801040c:	f8d7 1080 	ldr.w	r1, [r7, #128]	@ 0x80
 8010410:	f000 fad0 	bl	80109b4 <_fx_utility_memory_copy>

            /* Advance the destination buffer.  */
            buffer_ptr =  ((UCHAR *)buffer_ptr) + media_ptr -> fx_media_bytes_per_sector;
 8010414:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8010416:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 8010418:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801041c:	4413      	add	r3, r2
 801041e:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80

            /* Advance the sector and decrement the number of sectors left.  */
            logical_sector++;
 8010422:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	@ 0x40
 8010426:	1c51      	adds	r1, r2, #1
 8010428:	61b9      	str	r1, [r7, #24]
 801042a:	f143 0300 	adc.w	r3, r3, #0
 801042e:	61fb      	str	r3, [r7, #28]
 8010430:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
 8010434:	e9c7 3410 	strd	r3, r4, [r7, #64]	@ 0x40
            sectors--;
 8010438:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801043c:	3b01      	subs	r3, #1
 801043e:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
        while (sectors)
 8010442:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 8010446:	2b00      	cmp	r3, #0
 8010448:	d1d0      	bne.n	80103ec <_fx_utility_logical_sector_read+0x230>
 801044a:	e000      	b.n	801044e <_fx_utility_logical_sector_read+0x292>
                break;
 801044c:	bf00      	nop
        }

        /* Calculate the end sector.  */
        end_sector = logical_sector + sectors - 1;
 801044e:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 8010452:	2200      	movs	r2, #0
 8010454:	633b      	str	r3, [r7, #48]	@ 0x30
 8010456:	637a      	str	r2, [r7, #52]	@ 0x34
 8010458:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	@ 0x40
 801045c:	e9d7 450c 	ldrd	r4, r5, [r7, #48]	@ 0x30
 8010460:	4621      	mov	r1, r4
 8010462:	1889      	adds	r1, r1, r2
 8010464:	62b9      	str	r1, [r7, #40]	@ 0x28
 8010466:	4629      	mov	r1, r5
 8010468:	eb43 0101 	adc.w	r1, r3, r1
 801046c:	62f9      	str	r1, [r7, #44]	@ 0x2c
 801046e:	e9d7 120a 	ldrd	r1, r2, [r7, #40]	@ 0x28
 8010472:	460b      	mov	r3, r1
 8010474:	3b01      	subs	r3, #1
 8010476:	613b      	str	r3, [r7, #16]
 8010478:	4613      	mov	r3, r2
 801047a:	f143 33ff 	adc.w	r3, r3, #4294967295
 801047e:	617b      	str	r3, [r7, #20]
 8010480:	e9d7 3404 	ldrd	r3, r4, [r7, #16]
 8010484:	e9c7 3416 	strd	r3, r4, [r7, #88]	@ 0x58

        /* Attempt to fill the end of the buffer from the opposite direction.  */
        while (sectors)
 8010488:	e02b      	b.n	80104e2 <_fx_utility_logical_sector_read+0x326>
        {

            /* Determine if the sector is in the cache.  */
            if (_fx_utility_logical_sector_cache_entry_read(media_ptr, end_sector, &previous_cache_entry))
 801048a:	f107 0350 	add.w	r3, r7, #80	@ 0x50
 801048e:	9300      	str	r3, [sp, #0]
 8010490:	e9d7 2316 	ldrd	r2, r3, [r7, #88]	@ 0x58
 8010494:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 8010496:	f7ff f9b1 	bl	800f7fc <_fx_utility_logical_sector_cache_entry_read>
 801049a:	4603      	mov	r3, r0
 801049c:	2b00      	cmp	r3, #0
 801049e:	d125      	bne.n	80104ec <_fx_utility_logical_sector_read+0x330>
                /* Not in the cache - get out of the loop!  */
                break;
            }

            /* Yes, sector is in the cache. Copy the data from the cache to the destination buffer.  */
            _fx_utility_memory_copy(media_ptr -> fx_media_memory_buffer, /* Use case of memcpy is verified. */
 80104a0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80104a2:	6898      	ldr	r0, [r3, #8]
                                    ((UCHAR *)buffer_ptr) + ((sectors - 1) * media_ptr -> fx_media_bytes_per_sector),
 80104a4:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 80104a8:	3b01      	subs	r3, #1
 80104aa:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 80104ac:	6a92      	ldr	r2, [r2, #40]	@ 0x28
 80104ae:	fb02 f303 	mul.w	r3, r2, r3
            _fx_utility_memory_copy(media_ptr -> fx_media_memory_buffer, /* Use case of memcpy is verified. */
 80104b2:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
 80104b6:	18d1      	adds	r1, r2, r3
                                    media_ptr -> fx_media_bytes_per_sector);
 80104b8:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80104ba:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
            _fx_utility_memory_copy(media_ptr -> fx_media_memory_buffer, /* Use case of memcpy is verified. */
 80104bc:	461a      	mov	r2, r3
 80104be:	f000 fa79 	bl	80109b4 <_fx_utility_memory_copy>

            /* Move sector to previous sector and decrement the number of sectors left.  */
            end_sector--;
 80104c2:	e9d7 2316 	ldrd	r2, r3, [r7, #88]	@ 0x58
 80104c6:	1e51      	subs	r1, r2, #1
 80104c8:	60b9      	str	r1, [r7, #8]
 80104ca:	f143 33ff 	adc.w	r3, r3, #4294967295
 80104ce:	60fb      	str	r3, [r7, #12]
 80104d0:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
 80104d4:	e9c7 3416 	strd	r3, r4, [r7, #88]	@ 0x58
            sectors--;
 80104d8:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 80104dc:	3b01      	subs	r3, #1
 80104de:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
        while (sectors)
 80104e2:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 80104e6:	2b00      	cmp	r3, #0
 80104e8:	d1cf      	bne.n	801048a <_fx_utility_logical_sector_read+0x2ce>
 80104ea:	e000      	b.n	80104ee <_fx_utility_logical_sector_read+0x332>
                break;
 80104ec:	bf00      	nop
        }

        /* Determine if there are still sectors left to read.  */
        if (sectors == 0)
 80104ee:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 80104f2:	2b00      	cmp	r3, #0
 80104f4:	d101      	bne.n	80104fa <_fx_utility_logical_sector_read+0x33e>
        {

            /* No more sectors to read - return success!  */
            return(FX_SUCCESS);
 80104f6:	2300      	movs	r3, #0
 80104f8:	e0ef      	b.n	80106da <_fx_utility_logical_sector_read+0x51e>
        }

        /* Flush and invalidate any entries in the cache that are in this direct I/O read request range.  */
        _fx_utility_logical_sector_flush(media_ptr, logical_sector, (ULONG64) sectors, FX_TRUE);
 80104fa:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 80104fe:	2200      	movs	r2, #0
 8010500:	623b      	str	r3, [r7, #32]
 8010502:	627a      	str	r2, [r7, #36]	@ 0x24
 8010504:	2301      	movs	r3, #1
 8010506:	9302      	str	r3, [sp, #8]
 8010508:	e9d7 3408 	ldrd	r3, r4, [r7, #32]
 801050c:	e9cd 3400 	strd	r3, r4, [sp]
 8010510:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	@ 0x40
 8010514:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 8010516:	f7ff fc3b 	bl	800fd90 <_fx_utility_logical_sector_flush>
#endif /* FX_DISABLE_CACHE */

#ifndef FX_MEDIA_STATISTICS_DISABLE

        /* Increment the number of driver read sector(s) requests.  */
        media_ptr -> fx_media_driver_read_requests++;
 801051a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801051c:	f8d3 31ac 	ldr.w	r3, [r3, #428]	@ 0x1ac
 8010520:	1c5a      	adds	r2, r3, #1
 8010522:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8010524:	f8c3 21ac 	str.w	r2, [r3, #428]	@ 0x1ac
#endif

        /* Build read request to the driver.  */
        media_ptr -> fx_media_driver_request =          FX_DRIVER_READ;
 8010528:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801052a:	2200      	movs	r2, #0
 801052c:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
        media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 8010530:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8010532:	2290      	movs	r2, #144	@ 0x90
 8010534:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
        media_ptr -> fx_media_driver_buffer =           buffer_ptr;
 8010538:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801053a:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
 801053e:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
#ifdef FX_DRIVER_USE_64BIT_LBA
        media_ptr -> fx_media_driver_logical_sector =   logical_sector;
#else
        media_ptr -> fx_media_driver_logical_sector =   (ULONG)logical_sector;
 8010542:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8010544:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8010546:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
#endif
        media_ptr -> fx_media_driver_sectors =          sectors;
 801054a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801054c:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 8010550:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98
        media_ptr -> fx_media_driver_sector_type =      sector_type;
 8010554:	f897 2088 	ldrb.w	r2, [r7, #136]	@ 0x88
 8010558:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801055a:	f8c3 20b8 	str.w	r2, [r3, #184]	@ 0xb8

        /* Determine if the sector is a data sector or a system sector.  */
        if (sector_type == FX_DATA_SECTOR)
 801055e:	f897 3088 	ldrb.w	r3, [r7, #136]	@ 0x88
 8010562:	2b04      	cmp	r3, #4
 8010564:	d103      	bne.n	801056e <_fx_utility_logical_sector_read+0x3b2>
        {

            /* Data sector is present.  */
            media_ptr -> fx_media_driver_data_sector_read =  FX_TRUE;
 8010566:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8010568:	2201      	movs	r2, #1
 801056a:	f8c3 20b4 	str.w	r2, [r3, #180]	@ 0xb4

        /* If trace is enabled, insert this event into the trace buffer.  */
        FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_READ, media_ptr, logical_sector, sectors, buffer_ptr, FX_TRACE_INTERNAL_EVENTS, 0, 0)

        /* Invoke the driver to read the sector.  */
        (media_ptr -> fx_media_driver_entry) (media_ptr);
 801056e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8010570:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
 8010574:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 8010576:	4798      	blx	r3

        /* Clear data sector is present flag.  */
        media_ptr -> fx_media_driver_data_sector_read =  FX_FALSE;
 8010578:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801057a:	2200      	movs	r2, #0
 801057c:	f8c3 20b4 	str.w	r2, [r3, #180]	@ 0xb4

#ifndef FX_DISABLE_DIRECT_DATA_READ_CACHE_FILL

        /* Determine if the read was successful and if number of sectors just read will
           reasonably fit into the cache.  */
        if ((media_ptr -> fx_media_driver_status == FX_SUCCESS) && (sectors < (media_ptr -> fx_media_sector_cache_size / 4)))
 8010580:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8010582:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8010586:	2b00      	cmp	r3, #0
 8010588:	f040 80a4 	bne.w	80106d4 <_fx_utility_logical_sector_read+0x518>
 801058c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801058e:	695b      	ldr	r3, [r3, #20]
 8010590:	089b      	lsrs	r3, r3, #2
 8010592:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 8010596:	429a      	cmp	r2, r3
 8010598:	f080 809c 	bcs.w	80106d4 <_fx_utility_logical_sector_read+0x518>

            /* Yes, read of direct sectors was successful.  */

            /* Copy the sectors directly read into the cache so they are available on
               subsequent read requests.  */
            while (sectors)
 801059c:	e095      	b.n	80106ca <_fx_utility_logical_sector_read+0x50e>
            {

                /* Attempt to read the cache entry.  */
                cache_entry =  _fx_utility_logical_sector_cache_entry_read(media_ptr, logical_sector, &previous_cache_entry);
 801059e:	f107 0350 	add.w	r3, r7, #80	@ 0x50
 80105a2:	9300      	str	r3, [sp, #0]
 80105a4:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	@ 0x40
 80105a8:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 80105aa:	f7ff f927 	bl	800f7fc <_fx_utility_logical_sector_cache_entry_read>
 80105ae:	6578      	str	r0, [r7, #84]	@ 0x54
                FX_UTILITY_LOGICAL_SECTOR_READ_EXTENSION_1

                /* At this point, a cache entry should always be present since we invalidated
                   the cache over this sector range previously. In any case, check for the error
                   condition.  */
                if (cache_entry == FX_NULL)
 80105b0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80105b2:	2b00      	cmp	r3, #0
 80105b4:	d101      	bne.n	80105ba <_fx_utility_logical_sector_read+0x3fe>
                {

                    /* This case should never happen, however, if it does simply give up on updating the
                       cache with the sectors from the direct read.  */
                    return(FX_SUCCESS);
 80105b6:	2300      	movs	r3, #0
 80105b8:	e08f      	b.n	80106da <_fx_utility_logical_sector_read+0x51e>
                }

                /* Determine if the cache entry is dirty and needs to be written out before it is used.  */
                if ((cache_entry -> fx_cached_sector_valid) &&
 80105ba:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80105bc:	7c5b      	ldrb	r3, [r3, #17]
 80105be:	2b00      	cmp	r3, #0
 80105c0:	d049      	beq.n	8010656 <_fx_utility_logical_sector_read+0x49a>
                    (cache_entry -> fx_cached_sector_buffer_dirty))
 80105c2:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80105c4:	7c1b      	ldrb	r3, [r3, #16]
                if ((cache_entry -> fx_cached_sector_valid) &&
 80105c6:	2b00      	cmp	r3, #0
 80105c8:	d045      	beq.n	8010656 <_fx_utility_logical_sector_read+0x49a>
                       before we read in the new buffer.  */

#ifndef FX_MEDIA_STATISTICS_DISABLE

                    /* Increment the number of driver write sector(s) requests.  */
                    media_ptr -> fx_media_driver_write_requests++;
 80105ca:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80105cc:	f8d3 31b0 	ldr.w	r3, [r3, #432]	@ 0x1b0
 80105d0:	1c5a      	adds	r2, r3, #1
 80105d2:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80105d4:	f8c3 21b0 	str.w	r2, [r3, #432]	@ 0x1b0
#endif

                    /* Build write request to the driver.  */
                    media_ptr -> fx_media_driver_request =          FX_DRIVER_WRITE;
 80105d8:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80105da:	2201      	movs	r2, #1
 80105dc:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
                    media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 80105e0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80105e2:	2290      	movs	r2, #144	@ 0x90
 80105e4:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
                    media_ptr -> fx_media_driver_buffer =           cache_entry -> fx_cached_sector_memory_buffer;
 80105e8:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80105ea:	681a      	ldr	r2, [r3, #0]
 80105ec:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80105ee:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
#ifdef FX_DRIVER_USE_64BIT_LBA
                    media_ptr -> fx_media_driver_logical_sector =   cache_entry -> fx_cached_sector;
#else
                    media_ptr -> fx_media_driver_logical_sector =   (ULONG)cache_entry -> fx_cached_sector;
 80105f2:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80105f4:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 80105f8:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80105fa:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
#endif
                    media_ptr -> fx_media_driver_sectors =          1;
 80105fe:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8010600:	2201      	movs	r2, #1
 8010602:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98
                    media_ptr -> fx_media_driver_sector_type =      cache_entry -> fx_cached_sector_type;
 8010606:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8010608:	7c9b      	ldrb	r3, [r3, #18]
 801060a:	461a      	mov	r2, r3
 801060c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801060e:	f8c3 20b8 	str.w	r2, [r3, #184]	@ 0xb8

                    /* Only data sectors may be dirty when FX_FAULT_TOLERANT is defined */
#ifndef FX_FAULT_TOLERANT
                    /* Determine if the sector is a data sector or a system sector.  */
                    if (cache_entry -> fx_cached_sector_type != FX_DATA_SECTOR)
 8010612:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8010614:	7c9b      	ldrb	r3, [r3, #18]
 8010616:	2b04      	cmp	r3, #4
 8010618:	d003      	beq.n	8010622 <_fx_utility_logical_sector_read+0x466>
                    {

                        /* System sector is present.  */
                        media_ptr -> fx_media_driver_system_write =  FX_TRUE;
 801061a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801061c:	2201      	movs	r2, #1
 801061e:	f8c3 20b0 	str.w	r2, [r3, #176]	@ 0xb0

                    /* If trace is enabled, insert this event into the trace buffer.  */
                    FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_WRITE, media_ptr, cache_entry -> fx_cached_sector, 1, cache_entry -> fx_cached_sector_memory_buffer, FX_TRACE_INTERNAL_EVENTS, 0, 0)

                    /* Invoke the driver to write the sector.  */
                    (media_ptr -> fx_media_driver_entry) (media_ptr);
 8010622:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8010624:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
 8010628:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 801062a:	4798      	blx	r3

                    /* Clear the system write flag.  */
                    media_ptr -> fx_media_driver_system_write =  FX_FALSE;
 801062c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801062e:	2200      	movs	r2, #0
 8010630:	f8c3 20b0 	str.w	r2, [r3, #176]	@ 0xb0

                    /* Check for successful completion.  */
                    if (media_ptr -> fx_media_driver_status)
 8010634:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8010636:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 801063a:	2b00      	cmp	r3, #0
 801063c:	d003      	beq.n	8010646 <_fx_utility_logical_sector_read+0x48a>
                    {

                        /* Error writing a cached sector out.  Return the
                           error status.  */
                        return(media_ptr -> fx_media_driver_status);
 801063e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8010640:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8010644:	e049      	b.n	80106da <_fx_utility_logical_sector_read+0x51e>
                    }

                    /* Clear the buffer dirty flag since it has been flushed
                       out.  */
                    cache_entry -> fx_cached_sector_buffer_dirty =  FX_FALSE;
 8010646:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8010648:	2200      	movs	r2, #0
 801064a:	741a      	strb	r2, [r3, #16]

                    /* Decrement the number of outstanding dirty cache entries.  */
                    media_ptr -> fx_media_sector_cache_dirty_count--;
 801064c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801064e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8010650:	1e5a      	subs	r2, r3, #1
 8010652:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8010654:	625a      	str	r2, [r3, #36]	@ 0x24
                }

                /* Now setup the cache entry with information from the new sector.  */

                /* Remember the sector number.  */
                cache_entry -> fx_cached_sector =  logical_sector;
 8010656:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 8010658:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	@ 0x40
 801065c:	e9c1 2302 	strd	r2, r3, [r1, #8]

                /* Make the cache entry valid.  */
                cache_entry -> fx_cached_sector_valid =  FX_TRUE;
 8010660:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8010662:	2201      	movs	r2, #1
 8010664:	745a      	strb	r2, [r3, #17]

                /* Remember the sector type.  */
                cache_entry -> fx_cached_sector_type =  sector_type;
 8010666:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8010668:	f897 2088 	ldrb.w	r2, [r7, #136]	@ 0x88
 801066c:	749a      	strb	r2, [r3, #18]

                /* Place this entry that the head of the cached sector
                   list.  */

                /* Determine if we need to update the last used list.  */
                if (previous_cache_entry)
 801066e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8010670:	2b00      	cmp	r3, #0
 8010672:	d00a      	beq.n	801068a <_fx_utility_logical_sector_read+0x4ce>

                    /* Yes, the current entry is not at the front of the list
                       so we need to change the order.  */

                    /* Link the previous entry to this entry's next pointer.  */
                    previous_cache_entry -> fx_cached_sector_next_used =
 8010674:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
                        cache_entry -> fx_cached_sector_next_used;
 8010676:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8010678:	6952      	ldr	r2, [r2, #20]
                    previous_cache_entry -> fx_cached_sector_next_used =
 801067a:	615a      	str	r2, [r3, #20]

                    /* Place this entry at the head of the list.  */
                    cache_entry -> fx_cached_sector_next_used =
                        media_ptr -> fx_media_sector_cache_list_ptr;
 801067c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801067e:	69da      	ldr	r2, [r3, #28]
                    cache_entry -> fx_cached_sector_next_used =
 8010680:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8010682:	615a      	str	r2, [r3, #20]
                    media_ptr -> fx_media_sector_cache_list_ptr =  cache_entry;
 8010684:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8010686:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8010688:	61da      	str	r2, [r3, #28]
                }

                /* Copy the data from the destination buffer to the cache entry.  */
                _fx_utility_memory_copy(buffer_ptr, /* Use case of memcpy is verified. */
 801068a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801068c:	6819      	ldr	r1, [r3, #0]
                                        cache_entry -> fx_cached_sector_memory_buffer,
                                        media_ptr -> fx_media_bytes_per_sector);
 801068e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8010690:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
                _fx_utility_memory_copy(buffer_ptr, /* Use case of memcpy is verified. */
 8010692:	461a      	mov	r2, r3
 8010694:	f8d7 0080 	ldr.w	r0, [r7, #128]	@ 0x80
 8010698:	f000 f98c 	bl	80109b4 <_fx_utility_memory_copy>

                /* Advance the destination buffer.  */
                buffer_ptr =  ((UCHAR *)buffer_ptr) + media_ptr -> fx_media_bytes_per_sector;
 801069c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801069e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80106a0:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
 80106a4:	4413      	add	r3, r2
 80106a6:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80

                /* Advance the source sector and decrement the sector count.  */
                logical_sector++;
 80106aa:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	@ 0x40
 80106ae:	1c51      	adds	r1, r2, #1
 80106b0:	6039      	str	r1, [r7, #0]
 80106b2:	f143 0300 	adc.w	r3, r3, #0
 80106b6:	607b      	str	r3, [r7, #4]
 80106b8:	e9d7 3400 	ldrd	r3, r4, [r7]
 80106bc:	e9c7 3410 	strd	r3, r4, [r7, #64]	@ 0x40
                sectors--;
 80106c0:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 80106c4:	3b01      	subs	r3, #1
 80106c6:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
            while (sectors)
 80106ca:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 80106ce:	2b00      	cmp	r3, #0
 80106d0:	f47f af65 	bne.w	801059e <_fx_utility_logical_sector_read+0x3e2>
            }
        }
#endif

        /* Return the driver status.  */
        return(media_ptr -> fx_media_driver_status);
 80106d4:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80106d6:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
    }
}
 80106da:	4618      	mov	r0, r3
 80106dc:	3760      	adds	r7, #96	@ 0x60
 80106de:	46bd      	mov	sp, r7
 80106e0:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

080106e4 <_fx_utility_logical_sector_write>:
/*                                            resulting in version 6.1.6  */
/*                                                                        */
/**************************************************************************/
UINT  _fx_utility_logical_sector_write(FX_MEDIA *media_ptr, ULONG64 logical_sector,
                                       VOID *buffer_ptr, ULONG sectors, UCHAR sector_type)
{
 80106e4:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 80106e8:	b096      	sub	sp, #88	@ 0x58
 80106ea:	af04      	add	r7, sp, #16
 80106ec:	62f8      	str	r0, [r7, #44]	@ 0x2c
 80106ee:	e9c7 2308 	strd	r2, r3, [r7, #32]
#ifndef FX_DISABLE_CACHE
FX_CACHED_SECTOR *cache_entry;
UINT              cache_size;
UINT              index;
UINT              i;
UCHAR             cache_found = FX_FALSE;
 80106f2:	2300      	movs	r3, #0
 80106f4:	f887 303b 	strb.w	r3, [r7, #59]	@ 0x3b
#endif /* FX_DISABLE_CACHE */

#ifndef FX_MEDIA_STATISTICS_DISABLE

    /* Determine if the request is for FAT sector.  */
    if (sector_type == FX_FAT_SECTOR)
 80106f8:	f897 3070 	ldrb.w	r3, [r7, #112]	@ 0x70
 80106fc:	2b02      	cmp	r3, #2
 80106fe:	d106      	bne.n	801070e <_fx_utility_logical_sector_write+0x2a>
    {

        /* Increment the number of FAT sector writes.  */
        media_ptr -> fx_media_fat_sector_writes++;
 8010700:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010702:	f8d3 3198 	ldr.w	r3, [r3, #408]	@ 0x198
 8010706:	1c5a      	adds	r2, r3, #1
 8010708:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801070a:	f8c3 2198 	str.w	r2, [r3, #408]	@ 0x198
    }

    /* Increment the number of logical sectors written.  */
    media_ptr -> fx_media_logical_sector_writes++;
 801070e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010710:	f8d3 31a0 	ldr.w	r3, [r3, #416]	@ 0x1a0
 8010714:	1c5a      	adds	r2, r3, #1
 8010716:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010718:	f8c3 21a0 	str.w	r2, [r3, #416]	@ 0x1a0
    /* Extended port-specific processing macro, which is by default defined to white space.  */
    FX_UTILITY_LOGICAL_SECTOR_WRITE_EXTENSION

#ifndef FX_DISABLE_CACHE
    /* Determine if the request is from the internal media buffer area.  */
    if ((((UCHAR *)buffer_ptr) >= media_ptr -> fx_media_memory_buffer) &&
 801071c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801071e:	689a      	ldr	r2, [r3, #8]
 8010720:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8010722:	4293      	cmp	r3, r2
 8010724:	f0c0 80d8 	bcc.w	80108d8 <_fx_utility_logical_sector_write+0x1f4>
        (((UCHAR *)buffer_ptr) <= media_ptr -> fx_media_sector_cache_end))
 8010728:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801072a:	699a      	ldr	r2, [r3, #24]
    if ((((UCHAR *)buffer_ptr) >= media_ptr -> fx_media_memory_buffer) &&
 801072c:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801072e:	4293      	cmp	r3, r2
 8010730:	f200 80d2 	bhi.w	80108d8 <_fx_utility_logical_sector_write+0x1f4>
    {

        /* Internal cache buffer is requested.  */

        /* Determine if the logical sector cache access should use the hash function.  */
        if (media_ptr -> fx_media_sector_cache_hashed)
 8010734:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010736:	691b      	ldr	r3, [r3, #16]
 8010738:	2b00      	cmp	r3, #0
 801073a:	d030      	beq.n	801079e <_fx_utility_logical_sector_write+0xba>
        {

            /* Calculate the area of the cache for this logical sector.  */
            index =  (ULONG)(logical_sector & media_ptr -> fx_media_sector_cache_hash_mask) * FX_SECTOR_CACHE_DEPTH;
 801073c:	6a3a      	ldr	r2, [r7, #32]
 801073e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010740:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 8010744:	f8d3 3470 	ldr.w	r3, [r3, #1136]	@ 0x470
 8010748:	4013      	ands	r3, r2
 801074a:	009b      	lsls	r3, r3, #2
 801074c:	637b      	str	r3, [r7, #52]	@ 0x34

            /* Build a pointer to the cache entry.  */
            cache_entry =  &(media_ptr -> fx_media_sector_cache[index]);
 801074e:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8010750:	4613      	mov	r3, r2
 8010752:	005b      	lsls	r3, r3, #1
 8010754:	4413      	add	r3, r2
 8010756:	00db      	lsls	r3, r3, #3
 8010758:	f503 6347 	add.w	r3, r3, #3184	@ 0xc70
 801075c:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801075e:	4413      	add	r3, r2
 8010760:	647b      	str	r3, [r7, #68]	@ 0x44

            for (i = 0; i < FX_SECTOR_CACHE_DEPTH; i++, cache_entry++)
 8010762:	2300      	movs	r3, #0
 8010764:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8010766:	e016      	b.n	8010796 <_fx_utility_logical_sector_write+0xb2>
            {


                /* Determine if the logical sector is in the cache - assuming the depth of the
                   sector cache is 4 entries.  */
                if ((cache_entry -> fx_cached_sector_valid) && (cache_entry -> fx_cached_sector == logical_sector))
 8010768:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801076a:	7c5b      	ldrb	r3, [r3, #17]
 801076c:	2b00      	cmp	r3, #0
 801076e:	d00c      	beq.n	801078a <_fx_utility_logical_sector_write+0xa6>
 8010770:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8010772:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8010776:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 801077a:	4299      	cmp	r1, r3
 801077c:	bf08      	it	eq
 801077e:	4290      	cmpeq	r0, r2
 8010780:	d103      	bne.n	801078a <_fx_utility_logical_sector_write+0xa6>
                {
                    cache_found = FX_TRUE;
 8010782:	2301      	movs	r3, #1
 8010784:	f887 303b 	strb.w	r3, [r7, #59]	@ 0x3b
                    break;
 8010788:	e02d      	b.n	80107e6 <_fx_utility_logical_sector_write+0x102>
            for (i = 0; i < FX_SECTOR_CACHE_DEPTH; i++, cache_entry++)
 801078a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801078c:	3301      	adds	r3, #1
 801078e:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8010790:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8010792:	3318      	adds	r3, #24
 8010794:	647b      	str	r3, [r7, #68]	@ 0x44
 8010796:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8010798:	2b03      	cmp	r3, #3
 801079a:	d9e5      	bls.n	8010768 <_fx_utility_logical_sector_write+0x84>
 801079c:	e023      	b.n	80107e6 <_fx_utility_logical_sector_write+0x102>
        }
        else
        {

            /* Search for an entry in the cache that matches this request.  */
            cache_size =            media_ptr -> fx_media_sector_cache_size;
 801079e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80107a0:	695b      	ldr	r3, [r3, #20]
 80107a2:	643b      	str	r3, [r7, #64]	@ 0x40
            cache_entry =           media_ptr -> fx_media_sector_cache_list_ptr;
 80107a4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80107a6:	69db      	ldr	r3, [r3, #28]
 80107a8:	647b      	str	r3, [r7, #68]	@ 0x44

            /* Look at the cache entries until a match is found or the end of
               the cache is reached.  */
            while (cache_size--)
 80107aa:	e017      	b.n	80107dc <_fx_utility_logical_sector_write+0xf8>
            {

                /* Determine if the requested sector has been found.  */
                if ((cache_entry -> fx_cached_sector_valid) && (cache_entry -> fx_cached_sector == logical_sector))
 80107ac:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80107ae:	7c5b      	ldrb	r3, [r3, #17]
 80107b0:	2b00      	cmp	r3, #0
 80107b2:	d00c      	beq.n	80107ce <_fx_utility_logical_sector_write+0xea>
 80107b4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80107b6:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 80107ba:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 80107be:	4299      	cmp	r1, r3
 80107c0:	bf08      	it	eq
 80107c2:	4290      	cmpeq	r0, r2
 80107c4:	d103      	bne.n	80107ce <_fx_utility_logical_sector_write+0xea>
                {
                    cache_found = FX_TRUE;
 80107c6:	2301      	movs	r3, #1
 80107c8:	f887 303b 	strb.w	r3, [r7, #59]	@ 0x3b
                    break;
 80107cc:	e00b      	b.n	80107e6 <_fx_utility_logical_sector_write+0x102>
                }

                /* Otherwise, we have not found the cached entry yet.  */

                /* If there are more entries, move to the next one.  */
                if (cache_entry -> fx_cached_sector_next_used)
 80107ce:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80107d0:	695b      	ldr	r3, [r3, #20]
 80107d2:	2b00      	cmp	r3, #0
 80107d4:	d002      	beq.n	80107dc <_fx_utility_logical_sector_write+0xf8>
                {

                    /* Move to the next cache entry.  */
                    cache_entry =  cache_entry -> fx_cached_sector_next_used;
 80107d6:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80107d8:	695b      	ldr	r3, [r3, #20]
 80107da:	647b      	str	r3, [r7, #68]	@ 0x44
            while (cache_size--)
 80107dc:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80107de:	1e5a      	subs	r2, r3, #1
 80107e0:	643a      	str	r2, [r7, #64]	@ 0x40
 80107e2:	2b00      	cmp	r3, #0
 80107e4:	d1e2      	bne.n	80107ac <_fx_utility_logical_sector_write+0xc8>
                }
            }
        }
#endif /* FX_ENABLE_FAULT_TOLERANT */

        if (cache_found)
 80107e6:	f897 303b 	ldrb.w	r3, [r7, #59]	@ 0x3b
 80107ea:	2b00      	cmp	r3, #0
 80107ec:	d00d      	beq.n	801080a <_fx_utility_logical_sector_write+0x126>
                return(media_ptr -> fx_media_driver_status);
            }
#endif

            /* Determine if this is the first write of this logical sector.  */
            if (cache_entry -> fx_cached_sector_buffer_dirty == FX_FALSE)
 80107ee:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80107f0:	7c1b      	ldrb	r3, [r3, #16]
 80107f2:	2b00      	cmp	r3, #0
 80107f4:	d107      	bne.n	8010806 <_fx_utility_logical_sector_write+0x122>
            {

                /* Yes, increment the number of outstanding dirty sectors.  */
                media_ptr -> fx_media_sector_cache_dirty_count++;
 80107f6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80107f8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80107fa:	1c5a      	adds	r2, r3, #1
 80107fc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80107fe:	625a      	str	r2, [r3, #36]	@ 0x24

                /* Simply mark this entry as dirty.  */
                cache_entry -> fx_cached_sector_buffer_dirty =  FX_TRUE;
 8010800:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8010802:	2201      	movs	r2, #1
 8010804:	741a      	strb	r2, [r3, #16]

            /* Don't bother updating the cache linked list since writes are
               preceded by reads anyway.  */

            /* Success, return to caller immediately!  */
            return(FX_SUCCESS);
 8010806:	2300      	movs	r3, #0
 8010808:	e0cf      	b.n	80109aa <_fx_utility_logical_sector_write+0x2c6>

        /* Okay, so if we are here the request must be for the additional FAT writes, since this is the
           only time a write request is made without a preceding read request.  */

        /* Is the logical sector valid?  */
        if ((logical_sector == 0) || (logical_sector == ((ULONG)0xFFFFFFFF)))
 801080a:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 801080e:	4313      	orrs	r3, r2
 8010810:	d004      	beq.n	801081c <_fx_utility_logical_sector_write+0x138>
 8010812:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 8010816:	1c51      	adds	r1, r2, #1
 8010818:	430b      	orrs	r3, r1
 801081a:	d101      	bne.n	8010820 <_fx_utility_logical_sector_write+0x13c>
        {
            return(FX_SECTOR_INVALID);
 801081c:	2389      	movs	r3, #137	@ 0x89
 801081e:	e0c4      	b.n	80109aa <_fx_utility_logical_sector_write+0x2c6>
        }

        /* Compare logical sector against total sectors to make sure it is valid.  */
        if ((logical_sector + sectors - 1) >= media_ptr -> fx_media_total_sectors)
 8010820:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8010822:	2200      	movs	r2, #0
 8010824:	61bb      	str	r3, [r7, #24]
 8010826:	61fa      	str	r2, [r7, #28]
 8010828:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 801082c:	e9d7 4506 	ldrd	r4, r5, [r7, #24]
 8010830:	4621      	mov	r1, r4
 8010832:	1889      	adds	r1, r1, r2
 8010834:	6139      	str	r1, [r7, #16]
 8010836:	4629      	mov	r1, r5
 8010838:	eb43 0101 	adc.w	r1, r3, r1
 801083c:	6179      	str	r1, [r7, #20]
 801083e:	e9d7 1204 	ldrd	r1, r2, [r7, #16]
 8010842:	460b      	mov	r3, r1
 8010844:	f113 3aff 	adds.w	sl, r3, #4294967295
 8010848:	4613      	mov	r3, r2
 801084a:	f143 3bff 	adc.w	fp, r3, #4294967295
 801084e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010850:	e9d3 230e 	ldrd	r2, r3, [r3, #56]	@ 0x38
 8010854:	4592      	cmp	sl, r2
 8010856:	eb7b 0303 	sbcs.w	r3, fp, r3
 801085a:	d301      	bcc.n	8010860 <_fx_utility_logical_sector_write+0x17c>
        {
            return(FX_SECTOR_INVALID);
 801085c:	2389      	movs	r3, #137	@ 0x89
 801085e:	e0a4      	b.n	80109aa <_fx_utility_logical_sector_write+0x2c6>
        /* Just write the buffer to the media.  */

#ifndef FX_MEDIA_STATISTICS_DISABLE

        /* Increment the number of driver write sector(s) requests.  */
        media_ptr -> fx_media_driver_write_requests++;
 8010860:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010862:	f8d3 31b0 	ldr.w	r3, [r3, #432]	@ 0x1b0
 8010866:	1c5a      	adds	r2, r3, #1
 8010868:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801086a:	f8c3 21b0 	str.w	r2, [r3, #432]	@ 0x1b0
#endif

        /* Build write request to the driver.  */
        media_ptr -> fx_media_driver_request =          FX_DRIVER_WRITE;
 801086e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010870:	2201      	movs	r2, #1
 8010872:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
        media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 8010876:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010878:	2290      	movs	r2, #144	@ 0x90
 801087a:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
        media_ptr -> fx_media_driver_buffer =           buffer_ptr;
 801087e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010880:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8010882:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
#ifdef FX_DRIVER_USE_64BIT_LBA
        media_ptr -> fx_media_driver_logical_sector =   logical_sector;
#else
        media_ptr -> fx_media_driver_logical_sector =   (ULONG)logical_sector;
 8010886:	6a3a      	ldr	r2, [r7, #32]
 8010888:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801088a:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
#endif
        media_ptr -> fx_media_driver_sectors =          sectors;
 801088e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010890:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 8010892:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98
        media_ptr -> fx_media_driver_sector_type =      sector_type;
 8010896:	f897 2070 	ldrb.w	r2, [r7, #112]	@ 0x70
 801089a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801089c:	f8c3 20b8 	str.w	r2, [r3, #184]	@ 0xb8

        /* Determine if the system write flag needs to be set.  */
        if (sector_type != FX_DATA_SECTOR)
 80108a0:	f897 3070 	ldrb.w	r3, [r7, #112]	@ 0x70
 80108a4:	2b04      	cmp	r3, #4
 80108a6:	d003      	beq.n	80108b0 <_fx_utility_logical_sector_write+0x1cc>
        {

            /* Yes, a system sector write is present so set the flag.  The driver
               can use this flag to make extra safeguards in writing the sector
               out, yielding more fault tolerance.  */
            media_ptr -> fx_media_driver_system_write =  FX_TRUE;
 80108a8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80108aa:	2201      	movs	r2, #1
 80108ac:	f8c3 20b0 	str.w	r2, [r3, #176]	@ 0xb0

        /* If trace is enabled, insert this event into the trace buffer.  */
        FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_WRITE, media_ptr, logical_sector, sectors, buffer_ptr, FX_TRACE_INTERNAL_EVENTS, 0, 0)

        /* Invoke the driver to write the sector(s).  */
        (media_ptr -> fx_media_driver_entry) (media_ptr);
 80108b0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80108b2:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
 80108b6:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 80108b8:	4798      	blx	r3

        /* Clear the system write flag.  */
        media_ptr -> fx_media_driver_system_write =  FX_FALSE;
 80108ba:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80108bc:	2200      	movs	r2, #0
 80108be:	f8c3 20b0 	str.w	r2, [r3, #176]	@ 0xb0

        /* Check for successful completion.  */
        if (media_ptr -> fx_media_driver_status)
 80108c2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80108c4:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 80108c8:	2b00      	cmp	r3, #0
 80108ca:	d003      	beq.n	80108d4 <_fx_utility_logical_sector_write+0x1f0>
        {

            /* Error writing a internal sector out.  Return the
               error status.  */
            return(media_ptr -> fx_media_driver_status);
 80108cc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80108ce:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 80108d2:	e06a      	b.n	80109aa <_fx_utility_logical_sector_write+0x2c6>
        }

        /* At this point, we have a successful write.  */
        return(FX_SUCCESS);
 80108d4:	2300      	movs	r3, #0
 80108d6:	e068      	b.n	80109aa <_fx_utility_logical_sector_write+0x2c6>

        /* Otherwise, the write request is being made directly from an application
           buffer. Determine if the logical sector is valid.  */

        /* Is the logical sector valid? */
        if ((logical_sector == 0) || (logical_sector == ((ULONG)0xFFFFFFFF)))
 80108d8:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 80108dc:	4313      	orrs	r3, r2
 80108de:	d004      	beq.n	80108ea <_fx_utility_logical_sector_write+0x206>
 80108e0:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 80108e4:	1c51      	adds	r1, r2, #1
 80108e6:	430b      	orrs	r3, r1
 80108e8:	d101      	bne.n	80108ee <_fx_utility_logical_sector_write+0x20a>
        {
            return(FX_SECTOR_INVALID);
 80108ea:	2389      	movs	r3, #137	@ 0x89
 80108ec:	e05d      	b.n	80109aa <_fx_utility_logical_sector_write+0x2c6>
        }

        /* Compare logical sector against total sectors to make sure it is valid.  */
        if ((logical_sector + sectors - 1) >= media_ptr -> fx_media_total_sectors)
 80108ee:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80108f0:	2200      	movs	r2, #0
 80108f2:	60bb      	str	r3, [r7, #8]
 80108f4:	60fa      	str	r2, [r7, #12]
 80108f6:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 80108fa:	e9d7 ab02 	ldrd	sl, fp, [r7, #8]
 80108fe:	4651      	mov	r1, sl
 8010900:	eb11 0802 	adds.w	r8, r1, r2
 8010904:	4659      	mov	r1, fp
 8010906:	eb41 0903 	adc.w	r9, r1, r3
 801090a:	f118 34ff 	adds.w	r4, r8, #4294967295
 801090e:	f149 35ff 	adc.w	r5, r9, #4294967295
 8010912:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010914:	e9d3 230e 	ldrd	r2, r3, [r3, #56]	@ 0x38
 8010918:	4294      	cmp	r4, r2
 801091a:	eb75 0303 	sbcs.w	r3, r5, r3
 801091e:	d301      	bcc.n	8010924 <_fx_utility_logical_sector_write+0x240>
        {
            return(FX_SECTOR_INVALID);
 8010920:	2389      	movs	r3, #137	@ 0x89
 8010922:	e042      	b.n	80109aa <_fx_utility_logical_sector_write+0x2c6>
        }

        /* Flush and invalidate for any entries in the cache that are in this direct I/O read request range.  */
        _fx_utility_logical_sector_flush(media_ptr, logical_sector, (ULONG64) sectors, FX_TRUE);
 8010924:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8010926:	2200      	movs	r2, #0
 8010928:	603b      	str	r3, [r7, #0]
 801092a:	607a      	str	r2, [r7, #4]
 801092c:	2301      	movs	r3, #1
 801092e:	9302      	str	r3, [sp, #8]
 8010930:	e9d7 3400 	ldrd	r3, r4, [r7]
 8010934:	e9cd 3400 	strd	r3, r4, [sp]
 8010938:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 801093c:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 801093e:	f7ff fa27 	bl	800fd90 <_fx_utility_logical_sector_flush>
#endif /* FX_DISABLE_CACHE */

#ifndef FX_MEDIA_STATISTICS_DISABLE

        /* Increment the number of driver write sector(s) requests.  */
        media_ptr -> fx_media_driver_write_requests++;
 8010942:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010944:	f8d3 31b0 	ldr.w	r3, [r3, #432]	@ 0x1b0
 8010948:	1c5a      	adds	r2, r3, #1
 801094a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801094c:	f8c3 21b0 	str.w	r2, [r3, #432]	@ 0x1b0
#endif

        /* Build request to the driver.  */
        media_ptr -> fx_media_driver_request =          FX_DRIVER_WRITE;
 8010950:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010952:	2201      	movs	r2, #1
 8010954:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
        media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 8010958:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801095a:	2290      	movs	r2, #144	@ 0x90
 801095c:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
        media_ptr -> fx_media_driver_buffer =           buffer_ptr;
 8010960:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010962:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8010964:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
#ifdef FX_DRIVER_USE_64BIT_LBA
        media_ptr -> fx_media_driver_logical_sector =   logical_sector;
#else
        media_ptr -> fx_media_driver_logical_sector =   (ULONG)logical_sector;
 8010968:	6a3a      	ldr	r2, [r7, #32]
 801096a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801096c:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
#endif
        media_ptr -> fx_media_driver_sectors =          sectors;
 8010970:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010972:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 8010974:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98
        media_ptr -> fx_media_driver_sector_type =      sector_type;
 8010978:	f897 2070 	ldrb.w	r2, [r7, #112]	@ 0x70
 801097c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801097e:	f8c3 20b8 	str.w	r2, [r3, #184]	@ 0xb8

        /* Determine if the system write flag needs to be set.  */
        if (sector_type != FX_DATA_SECTOR)
 8010982:	f897 3070 	ldrb.w	r3, [r7, #112]	@ 0x70
 8010986:	2b04      	cmp	r3, #4
 8010988:	d003      	beq.n	8010992 <_fx_utility_logical_sector_write+0x2ae>
        {

            /* Yes, a system sector write is present so set the flag.  The driver
               can use this flag to make extra safeguards in writing the sector
               out, yielding more fault tolerance.  */
            media_ptr -> fx_media_driver_system_write =  FX_TRUE;
 801098a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801098c:	2201      	movs	r2, #1
 801098e:	f8c3 20b0 	str.w	r2, [r3, #176]	@ 0xb0

        /* If trace is enabled, insert this event into the trace buffer.  */
        FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_WRITE, media_ptr, logical_sector, sectors, buffer_ptr, FX_TRACE_INTERNAL_EVENTS, 0, 0)

        /* Invoke the driver to write the sector(s).  */
        (media_ptr -> fx_media_driver_entry) (media_ptr);
 8010992:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010994:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
 8010998:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 801099a:	4798      	blx	r3

        /* Clear the system write flag.  */
        media_ptr -> fx_media_driver_system_write =  FX_FALSE;
 801099c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801099e:	2200      	movs	r2, #0
 80109a0:	f8c3 20b0 	str.w	r2, [r3, #176]	@ 0xb0

        /* Return driver status.  */
        return(media_ptr -> fx_media_driver_status);
 80109a4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80109a6:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
    }
}
 80109aa:	4618      	mov	r0, r3
 80109ac:	3748      	adds	r7, #72	@ 0x48
 80109ae:	46bd      	mov	sp, r7
 80109b0:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

080109b4 <_fx_utility_memory_copy>:
/*                                            memcpy usage,               */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _fx_utility_memory_copy(UCHAR *source_ptr, UCHAR *dest_ptr, ULONG size)
{
 80109b4:	b580      	push	{r7, lr}
 80109b6:	b084      	sub	sp, #16
 80109b8:	af00      	add	r7, sp, #0
 80109ba:	60f8      	str	r0, [r7, #12]
 80109bc:	60b9      	str	r1, [r7, #8]
 80109be:	607a      	str	r2, [r7, #4]

    /* Copy the memory.  */
    memcpy(dest_ptr, source_ptr, size); /* Use case of memcpy is verified. */
 80109c0:	687a      	ldr	r2, [r7, #4]
 80109c2:	68f9      	ldr	r1, [r7, #12]
 80109c4:	68b8      	ldr	r0, [r7, #8]
 80109c6:	f000 fbc0 	bl	801114a <memcpy>
}
 80109ca:	bf00      	nop
 80109cc:	3710      	adds	r7, #16
 80109ce:	46bd      	mov	sp, r7
 80109d0:	bd80      	pop	{r7, pc}

080109d2 <_fxe_file_close>:
/*  09-30-2020     William E. Lamie         Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _fxe_file_close(FX_FILE *file_ptr)
{
 80109d2:	b580      	push	{r7, lr}
 80109d4:	b084      	sub	sp, #16
 80109d6:	af00      	add	r7, sp, #0
 80109d8:	6078      	str	r0, [r7, #4]

UINT status;


    /* Check for a null file pointer.  */
    if (file_ptr == FX_NULL)
 80109da:	687b      	ldr	r3, [r7, #4]
 80109dc:	2b00      	cmp	r3, #0
 80109de:	d101      	bne.n	80109e4 <_fxe_file_close+0x12>
    {
        return(FX_PTR_ERROR);
 80109e0:	2318      	movs	r3, #24
 80109e2:	e004      	b.n	80109ee <_fxe_file_close+0x1c>

    /* Check for a valid caller.  */
    FX_CALLER_CHECKING_CODE

    /* Call actual file close service.  */
    status =  _fx_file_close(file_ptr);
 80109e4:	6878      	ldr	r0, [r7, #4]
 80109e6:	f7fa fae5 	bl	800afb4 <_fx_file_close>
 80109ea:	60f8      	str	r0, [r7, #12]

    /* Return status to the caller.  */
    return(status);
 80109ec:	68fb      	ldr	r3, [r7, #12]
}
 80109ee:	4618      	mov	r0, r3
 80109f0:	3710      	adds	r7, #16
 80109f2:	46bd      	mov	sp, r7
 80109f4:	bd80      	pop	{r7, pc}

080109f6 <_fxe_file_create>:
/*  09-30-2020     William E. Lamie         Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _fxe_file_create(FX_MEDIA *media_ptr, CHAR *file_name)
{
 80109f6:	b580      	push	{r7, lr}
 80109f8:	b084      	sub	sp, #16
 80109fa:	af00      	add	r7, sp, #0
 80109fc:	6078      	str	r0, [r7, #4]
 80109fe:	6039      	str	r1, [r7, #0]

UINT status;


    /* Check for a null media pointer.  */
    if (media_ptr == FX_NULL)
 8010a00:	687b      	ldr	r3, [r7, #4]
 8010a02:	2b00      	cmp	r3, #0
 8010a04:	d101      	bne.n	8010a0a <_fxe_file_create+0x14>
    {
        return(FX_PTR_ERROR);
 8010a06:	2318      	movs	r3, #24
 8010a08:	e005      	b.n	8010a16 <_fxe_file_create+0x20>

    /* Check for a valid caller.  */
    FX_CALLER_CHECKING_CODE

    /* Call actual file create service.  */
    status =  _fx_file_create(media_ptr, file_name);
 8010a0a:	6839      	ldr	r1, [r7, #0]
 8010a0c:	6878      	ldr	r0, [r7, #4]
 8010a0e:	f7fa fb45 	bl	800b09c <_fx_file_create>
 8010a12:	60f8      	str	r0, [r7, #12]

    /* File create is complete, return status.  */
    return(status);
 8010a14:	68fb      	ldr	r3, [r7, #12]
}
 8010a16:	4618      	mov	r0, r3
 8010a18:	3710      	adds	r7, #16
 8010a1a:	46bd      	mov	sp, r7
 8010a1c:	bd80      	pop	{r7, pc}
	...

08010a20 <_fxe_file_open>:
/*  09-30-2020     William E. Lamie         Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _fxe_file_open(FX_MEDIA *media_ptr, FX_FILE *file_ptr, CHAR *file_name, UINT open_type, UINT file_control_block_size)
{
 8010a20:	b580      	push	{r7, lr}
 8010a22:	b088      	sub	sp, #32
 8010a24:	af00      	add	r7, sp, #0
 8010a26:	60f8      	str	r0, [r7, #12]
 8010a28:	60b9      	str	r1, [r7, #8]
 8010a2a:	607a      	str	r2, [r7, #4]
 8010a2c:	603b      	str	r3, [r7, #0]
FX_FILE *current_file;
ULONG    open_count;


    /* Check for a null media or file pointer.  */
    if ((media_ptr == FX_NULL) || (media_ptr -> fx_media_id != FX_MEDIA_ID) || (file_ptr == FX_NULL) || (file_control_block_size != sizeof(FX_FILE)))
 8010a2e:	68fb      	ldr	r3, [r7, #12]
 8010a30:	2b00      	cmp	r3, #0
 8010a32:	d00b      	beq.n	8010a4c <_fxe_file_open+0x2c>
 8010a34:	68fb      	ldr	r3, [r7, #12]
 8010a36:	681b      	ldr	r3, [r3, #0]
 8010a38:	4a1c      	ldr	r2, [pc, #112]	@ (8010aac <_fxe_file_open+0x8c>)
 8010a3a:	4293      	cmp	r3, r2
 8010a3c:	d106      	bne.n	8010a4c <_fxe_file_open+0x2c>
 8010a3e:	68bb      	ldr	r3, [r7, #8]
 8010a40:	2b00      	cmp	r3, #0
 8010a42:	d003      	beq.n	8010a4c <_fxe_file_open+0x2c>
 8010a44:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010a46:	f5b3 7ff0 	cmp.w	r3, #480	@ 0x1e0
 8010a4a:	d001      	beq.n	8010a50 <_fxe_file_open+0x30>
    {
        return(FX_PTR_ERROR);
 8010a4c:	2318      	movs	r3, #24
 8010a4e:	e029      	b.n	8010aa4 <_fxe_file_open+0x84>
    }

    /* Check for an invalid open type.  */
    if ((open_type != FX_OPEN_FOR_READ) && (open_type != FX_OPEN_FOR_READ_FAST) && (open_type != FX_OPEN_FOR_WRITE))
 8010a50:	683b      	ldr	r3, [r7, #0]
 8010a52:	2b00      	cmp	r3, #0
 8010a54:	d007      	beq.n	8010a66 <_fxe_file_open+0x46>
 8010a56:	683b      	ldr	r3, [r7, #0]
 8010a58:	2b02      	cmp	r3, #2
 8010a5a:	d004      	beq.n	8010a66 <_fxe_file_open+0x46>
 8010a5c:	683b      	ldr	r3, [r7, #0]
 8010a5e:	2b01      	cmp	r3, #1
 8010a60:	d001      	beq.n	8010a66 <_fxe_file_open+0x46>
    {
        return(FX_ACCESS_ERROR);
 8010a62:	2306      	movs	r3, #6
 8010a64:	e01e      	b.n	8010aa4 <_fxe_file_open+0x84>
    FX_PROTECT

    /* Check for a duplicate file open.  */

    /* Loop to search the list for the same file handle.  */
    current_file =  media_ptr -> fx_media_opened_file_list;
 8010a66:	68fb      	ldr	r3, [r7, #12]
 8010a68:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
 8010a6c:	61fb      	str	r3, [r7, #28]
    open_count =    media_ptr -> fx_media_opened_file_count;
 8010a6e:	68fb      	ldr	r3, [r7, #12]
 8010a70:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
 8010a74:	61bb      	str	r3, [r7, #24]

    while (open_count--)
 8010a76:	e008      	b.n	8010a8a <_fxe_file_open+0x6a>
    {

        /* See if a match exists.  */
        if (file_ptr == current_file)
 8010a78:	68ba      	ldr	r2, [r7, #8]
 8010a7a:	69fb      	ldr	r3, [r7, #28]
 8010a7c:	429a      	cmp	r2, r3
 8010a7e:	d101      	bne.n	8010a84 <_fxe_file_open+0x64>

            /* Release protection.  */
            FX_UNPROTECT

            /* Return error.  */
            return(FX_PTR_ERROR);
 8010a80:	2318      	movs	r3, #24
 8010a82:	e00f      	b.n	8010aa4 <_fxe_file_open+0x84>
        }

        /* Move to the next opened file.  */
        current_file =  current_file -> fx_file_opened_next;
 8010a84:	69fb      	ldr	r3, [r7, #28]
 8010a86:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8010a88:	61fb      	str	r3, [r7, #28]
    while (open_count--)
 8010a8a:	69bb      	ldr	r3, [r7, #24]
 8010a8c:	1e5a      	subs	r2, r3, #1
 8010a8e:	61ba      	str	r2, [r7, #24]
 8010a90:	2b00      	cmp	r3, #0
 8010a92:	d1f1      	bne.n	8010a78 <_fxe_file_open+0x58>

    /* Release protection.  */
    FX_UNPROTECT

    /* Call actual file open service.  */
    status =  _fx_file_open(media_ptr, file_ptr, file_name, open_type);
 8010a94:	683b      	ldr	r3, [r7, #0]
 8010a96:	687a      	ldr	r2, [r7, #4]
 8010a98:	68b9      	ldr	r1, [r7, #8]
 8010a9a:	68f8      	ldr	r0, [r7, #12]
 8010a9c:	f7fa fe60 	bl	800b760 <_fx_file_open>
 8010aa0:	6178      	str	r0, [r7, #20]

    /* Open is complete, return status.  */
    return(status);
 8010aa2:	697b      	ldr	r3, [r7, #20]
}
 8010aa4:	4618      	mov	r0, r3
 8010aa6:	3720      	adds	r7, #32
 8010aa8:	46bd      	mov	sp, r7
 8010aaa:	bd80      	pop	{r7, pc}
 8010aac:	4d454449 	.word	0x4d454449

08010ab0 <_fxe_file_read>:
/*  09-30-2020     William E. Lamie         Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _fxe_file_read(FX_FILE *file_ptr, VOID *buffer_ptr, ULONG request_size, ULONG *actual_size)
{
 8010ab0:	b580      	push	{r7, lr}
 8010ab2:	b086      	sub	sp, #24
 8010ab4:	af00      	add	r7, sp, #0
 8010ab6:	60f8      	str	r0, [r7, #12]
 8010ab8:	60b9      	str	r1, [r7, #8]
 8010aba:	607a      	str	r2, [r7, #4]
 8010abc:	603b      	str	r3, [r7, #0]

UINT status;


    /* Check for a null file or buffer pointer.  */
    if ((file_ptr == FX_NULL) || (buffer_ptr == FX_NULL) || (actual_size == FX_NULL))
 8010abe:	68fb      	ldr	r3, [r7, #12]
 8010ac0:	2b00      	cmp	r3, #0
 8010ac2:	d005      	beq.n	8010ad0 <_fxe_file_read+0x20>
 8010ac4:	68bb      	ldr	r3, [r7, #8]
 8010ac6:	2b00      	cmp	r3, #0
 8010ac8:	d002      	beq.n	8010ad0 <_fxe_file_read+0x20>
 8010aca:	683b      	ldr	r3, [r7, #0]
 8010acc:	2b00      	cmp	r3, #0
 8010ace:	d101      	bne.n	8010ad4 <_fxe_file_read+0x24>
    {
        return(FX_PTR_ERROR);
 8010ad0:	2318      	movs	r3, #24
 8010ad2:	e007      	b.n	8010ae4 <_fxe_file_read+0x34>

    /* Check for a valid caller.  */
    FX_CALLER_CHECKING_CODE

    /* Call actual file read service.  */
    status =  _fx_file_read(file_ptr, buffer_ptr, request_size, actual_size);
 8010ad4:	683b      	ldr	r3, [r7, #0]
 8010ad6:	687a      	ldr	r2, [r7, #4]
 8010ad8:	68b9      	ldr	r1, [r7, #8]
 8010ada:	68f8      	ldr	r0, [r7, #12]
 8010adc:	f7fb fac4 	bl	800c068 <_fx_file_read>
 8010ae0:	6178      	str	r0, [r7, #20]

    /* Return status to the caller.  */
    return(status);
 8010ae2:	697b      	ldr	r3, [r7, #20]
}
 8010ae4:	4618      	mov	r0, r3
 8010ae6:	3718      	adds	r7, #24
 8010ae8:	46bd      	mov	sp, r7
 8010aea:	bd80      	pop	{r7, pc}

08010aec <_fxe_file_seek>:
/*  09-30-2020     William E. Lamie         Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _fxe_file_seek(FX_FILE *file_ptr, ULONG byte_offset)
{
 8010aec:	b580      	push	{r7, lr}
 8010aee:	b084      	sub	sp, #16
 8010af0:	af00      	add	r7, sp, #0
 8010af2:	6078      	str	r0, [r7, #4]
 8010af4:	6039      	str	r1, [r7, #0]

UINT status;


    /* Check for a null file pointer.  */
    if (file_ptr == FX_NULL)
 8010af6:	687b      	ldr	r3, [r7, #4]
 8010af8:	2b00      	cmp	r3, #0
 8010afa:	d101      	bne.n	8010b00 <_fxe_file_seek+0x14>
    {
        return(FX_PTR_ERROR);
 8010afc:	2318      	movs	r3, #24
 8010afe:	e005      	b.n	8010b0c <_fxe_file_seek+0x20>

    /* Check for a valid caller.  */
    FX_CALLER_CHECKING_CODE

    /* Call actual file seek service.  */
    status =  _fx_file_seek(file_ptr, byte_offset);
 8010b00:	6839      	ldr	r1, [r7, #0]
 8010b02:	6878      	ldr	r0, [r7, #4]
 8010b04:	f7fb fd14 	bl	800c530 <_fx_file_seek>
 8010b08:	60f8      	str	r0, [r7, #12]

    /* Seek is complete, return status.  */
    return(status);
 8010b0a:	68fb      	ldr	r3, [r7, #12]
}
 8010b0c:	4618      	mov	r0, r3
 8010b0e:	3710      	adds	r7, #16
 8010b10:	46bd      	mov	sp, r7
 8010b12:	bd80      	pop	{r7, pc}

08010b14 <_fxe_file_write>:
/*  09-30-2020     William E. Lamie         Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _fxe_file_write(FX_FILE *file_ptr, VOID *buffer_ptr, ULONG size)
{
 8010b14:	b580      	push	{r7, lr}
 8010b16:	b086      	sub	sp, #24
 8010b18:	af00      	add	r7, sp, #0
 8010b1a:	60f8      	str	r0, [r7, #12]
 8010b1c:	60b9      	str	r1, [r7, #8]
 8010b1e:	607a      	str	r2, [r7, #4]

UINT status;


    /* Check for a null file or buffer pointer.  */
    if ((file_ptr == FX_NULL) || (buffer_ptr == FX_NULL))
 8010b20:	68fb      	ldr	r3, [r7, #12]
 8010b22:	2b00      	cmp	r3, #0
 8010b24:	d002      	beq.n	8010b2c <_fxe_file_write+0x18>
 8010b26:	68bb      	ldr	r3, [r7, #8]
 8010b28:	2b00      	cmp	r3, #0
 8010b2a:	d101      	bne.n	8010b30 <_fxe_file_write+0x1c>
    {
        return(FX_PTR_ERROR);
 8010b2c:	2318      	movs	r3, #24
 8010b2e:	e006      	b.n	8010b3e <_fxe_file_write+0x2a>

    /* Check for a valid caller.  */
    FX_CALLER_CHECKING_CODE

    /* Call actual file write service.  */
    status =  _fx_file_write(file_ptr, buffer_ptr, size);
 8010b30:	687a      	ldr	r2, [r7, #4]
 8010b32:	68b9      	ldr	r1, [r7, #8]
 8010b34:	68f8      	ldr	r0, [r7, #12]
 8010b36:	f7fb fd0d 	bl	800c554 <_fx_file_write>
 8010b3a:	6178      	str	r0, [r7, #20]

    /* Return status to the caller.  */
    return(status);
 8010b3c:	697b      	ldr	r3, [r7, #20]
}
 8010b3e:	4618      	mov	r0, r3
 8010b40:	3718      	adds	r7, #24
 8010b42:	46bd      	mov	sp, r7
 8010b44:	bd80      	pop	{r7, pc}

08010b46 <_fxe_media_close>:
/*  09-30-2020     William E. Lamie         Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _fxe_media_close(FX_MEDIA  *media_ptr)
{
 8010b46:	b580      	push	{r7, lr}
 8010b48:	b084      	sub	sp, #16
 8010b4a:	af00      	add	r7, sp, #0
 8010b4c:	6078      	str	r0, [r7, #4]

UINT status;


    /* Check for a null media pointer.  */
    if (media_ptr == FX_NULL)
 8010b4e:	687b      	ldr	r3, [r7, #4]
 8010b50:	2b00      	cmp	r3, #0
 8010b52:	d101      	bne.n	8010b58 <_fxe_media_close+0x12>
    {
        return(FX_PTR_ERROR);
 8010b54:	2318      	movs	r3, #24
 8010b56:	e004      	b.n	8010b62 <_fxe_media_close+0x1c>

    /* Check for a valid caller.  */
    FX_CALLER_CHECKING_CODE

    /* Call actual media close service.  */
    status =  _fx_media_close(media_ptr);
 8010b58:	6878      	ldr	r0, [r7, #4]
 8010b5a:	f7fc fccf 	bl	800d4fc <_fx_media_close>
 8010b5e:	60f8      	str	r0, [r7, #12]

    /* Return status to the caller.  */
    return(status);
 8010b60:	68fb      	ldr	r3, [r7, #12]
}
 8010b62:	4618      	mov	r0, r3
 8010b64:	3710      	adds	r7, #16
 8010b66:	46bd      	mov	sp, r7
 8010b68:	bd80      	pop	{r7, pc}

08010b6a <_fxe_media_flush>:
/*  09-30-2020     William E. Lamie         Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _fxe_media_flush(FX_MEDIA  *media_ptr)
{
 8010b6a:	b580      	push	{r7, lr}
 8010b6c:	b084      	sub	sp, #16
 8010b6e:	af00      	add	r7, sp, #0
 8010b70:	6078      	str	r0, [r7, #4]

UINT status;


    /* Check for a null media pointer.  */
    if (media_ptr == FX_NULL)
 8010b72:	687b      	ldr	r3, [r7, #4]
 8010b74:	2b00      	cmp	r3, #0
 8010b76:	d101      	bne.n	8010b7c <_fxe_media_flush+0x12>
    {
        return(FX_PTR_ERROR);
 8010b78:	2318      	movs	r3, #24
 8010b7a:	e004      	b.n	8010b86 <_fxe_media_flush+0x1c>

    /* Check for a valid caller.  */
    FX_CALLER_CHECKING_CODE

    /* Call actual media flush service.  */
    status =  _fx_media_flush(media_ptr);
 8010b7c:	6878      	ldr	r0, [r7, #4]
 8010b7e:	f7fc fe4b 	bl	800d818 <_fx_media_flush>
 8010b82:	60f8      	str	r0, [r7, #12]

    /* Return status to the caller.  */
    return(status);
 8010b84:	68fb      	ldr	r3, [r7, #12]
}
 8010b86:	4618      	mov	r0, r3
 8010b88:	3710      	adds	r7, #16
 8010b8a:	46bd      	mov	sp, r7
 8010b8c:	bd80      	pop	{r7, pc}
	...

08010b90 <_fxe_media_open>:
/*                                                                        */
/**************************************************************************/
UINT  _fxe_media_open(FX_MEDIA *media_ptr, CHAR *media_name,
                      VOID (*media_driver)(FX_MEDIA *), VOID *driver_info_ptr,
                      VOID *memory_ptr, ULONG memory_size, UINT media_control_block_size)
{
 8010b90:	b580      	push	{r7, lr}
 8010b92:	b08a      	sub	sp, #40	@ 0x28
 8010b94:	af02      	add	r7, sp, #8
 8010b96:	60f8      	str	r0, [r7, #12]
 8010b98:	60b9      	str	r1, [r7, #8]
 8010b9a:	607a      	str	r2, [r7, #4]
 8010b9c:	603b      	str	r3, [r7, #0]
UINT       old_threshold;
#endif


    /* Check for invalid input pointers.  */
    if ((media_ptr == FX_NULL) || (media_driver == FX_NULL) || (memory_ptr == FX_NULL) || (media_control_block_size != sizeof(FX_MEDIA)))
 8010b9e:	68fb      	ldr	r3, [r7, #12]
 8010ba0:	2b00      	cmp	r3, #0
 8010ba2:	d00a      	beq.n	8010bba <_fxe_media_open+0x2a>
 8010ba4:	687b      	ldr	r3, [r7, #4]
 8010ba6:	2b00      	cmp	r3, #0
 8010ba8:	d007      	beq.n	8010bba <_fxe_media_open+0x2a>
 8010baa:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010bac:	2b00      	cmp	r3, #0
 8010bae:	d004      	beq.n	8010bba <_fxe_media_open+0x2a>
 8010bb0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010bb2:	f242 4288 	movw	r2, #9352	@ 0x2488
 8010bb6:	4293      	cmp	r3, r2
 8010bb8:	d001      	beq.n	8010bbe <_fxe_media_open+0x2e>
    {
        return(FX_PTR_ERROR);
 8010bba:	2318      	movs	r3, #24
 8010bbc:	e045      	b.n	8010c4a <_fxe_media_open+0xba>

    /* Check for a valid caller.  */
    FX_CALLER_CHECKING_CODE

    /* Check for proper size of the logical sector cache.  */
    temp =  _fx_system_media_max_sector_cache;
 8010bbe:	4b25      	ldr	r3, [pc, #148]	@ (8010c54 <_fxe_media_open+0xc4>)
 8010bc0:	681b      	ldr	r3, [r3, #0]
 8010bc2:	617b      	str	r3, [r7, #20]

    /* Isolate the lowest set bit.  */
    temp =  (temp & ((~temp) + ((ULONG) 1)));
 8010bc4:	697b      	ldr	r3, [r7, #20]
 8010bc6:	425b      	negs	r3, r3
 8010bc8:	697a      	ldr	r2, [r7, #20]
 8010bca:	4013      	ands	r3, r2
 8010bcc:	617b      	str	r3, [r7, #20]

    /* If FX_MAX_SECTOR_CACHE is a power of 2, the value of temp should be unchanged.  */
    if ((temp == 1) || (temp != _fx_system_media_max_sector_cache))
 8010bce:	697b      	ldr	r3, [r7, #20]
 8010bd0:	2b01      	cmp	r3, #1
 8010bd2:	d004      	beq.n	8010bde <_fxe_media_open+0x4e>
 8010bd4:	4b1f      	ldr	r3, [pc, #124]	@ (8010c54 <_fxe_media_open+0xc4>)
 8010bd6:	681b      	ldr	r3, [r3, #0]
 8010bd8:	697a      	ldr	r2, [r7, #20]
 8010bda:	429a      	cmp	r2, r3
 8010bdc:	d001      	beq.n	8010be2 <_fxe_media_open+0x52>
    {

        /* Not a power of 2, return an error.  */
        return(FX_MEDIA_INVALID);
 8010bde:	2302      	movs	r3, #2
 8010be0:	e033      	b.n	8010c4a <_fxe_media_open+0xba>
    }

    /* Check for proper size of the FAT cache.  */
    temp =  _fx_system_media_max_fat_cache;
 8010be2:	4b1d      	ldr	r3, [pc, #116]	@ (8010c58 <_fxe_media_open+0xc8>)
 8010be4:	681b      	ldr	r3, [r3, #0]
 8010be6:	617b      	str	r3, [r7, #20]

    /* Isolate the lowest set bit.  */
    temp =  (temp & ((~temp) + ((ULONG) 1)));
 8010be8:	697b      	ldr	r3, [r7, #20]
 8010bea:	425b      	negs	r3, r3
 8010bec:	697a      	ldr	r2, [r7, #20]
 8010bee:	4013      	ands	r3, r2
 8010bf0:	617b      	str	r3, [r7, #20]

    /* If FX_MAX_FAT_CACHE is a power of 2, the value of temp should be unchanged.  */
    if ((temp == 1) || (temp != _fx_system_media_max_fat_cache))
 8010bf2:	697b      	ldr	r3, [r7, #20]
 8010bf4:	2b01      	cmp	r3, #1
 8010bf6:	d004      	beq.n	8010c02 <_fxe_media_open+0x72>
 8010bf8:	4b17      	ldr	r3, [pc, #92]	@ (8010c58 <_fxe_media_open+0xc8>)
 8010bfa:	681b      	ldr	r3, [r3, #0]
 8010bfc:	697a      	ldr	r2, [r7, #20]
 8010bfe:	429a      	cmp	r2, r3
 8010c00:	d001      	beq.n	8010c06 <_fxe_media_open+0x76>
    {

        /* Not a power of 2, return an error.  */
        return(FX_MEDIA_INVALID);
 8010c02:	2302      	movs	r3, #2
 8010c04:	e021      	b.n	8010c4a <_fxe_media_open+0xba>
    /* Disable preemption temporarily.  */
    tx_thread_preemption_change(current_thread, 0, &old_threshold);
#endif

    /* Loop to check for the media already opened.  */
    current_media =  _fx_system_media_opened_ptr;
 8010c06:	4b15      	ldr	r3, [pc, #84]	@ (8010c5c <_fxe_media_open+0xcc>)
 8010c08:	681b      	ldr	r3, [r3, #0]
 8010c0a:	61fb      	str	r3, [r7, #28]
    open_count =     _fx_system_media_opened_count;
 8010c0c:	4b14      	ldr	r3, [pc, #80]	@ (8010c60 <_fxe_media_open+0xd0>)
 8010c0e:	681b      	ldr	r3, [r3, #0]
 8010c10:	61bb      	str	r3, [r7, #24]
    while (open_count--)
 8010c12:	e009      	b.n	8010c28 <_fxe_media_open+0x98>
    {

        /* Is the new media pointer already open?  */
        if (media_ptr == current_media)
 8010c14:	68fa      	ldr	r2, [r7, #12]
 8010c16:	69fb      	ldr	r3, [r7, #28]
 8010c18:	429a      	cmp	r2, r3
 8010c1a:	d101      	bne.n	8010c20 <_fxe_media_open+0x90>
            /* Restore preemption.  */
            tx_thread_preemption_change(current_thread, old_threshold, &old_threshold);
#endif

            /* Duplicate media open, return an error!  */
            return(FX_PTR_ERROR);
 8010c1c:	2318      	movs	r3, #24
 8010c1e:	e014      	b.n	8010c4a <_fxe_media_open+0xba>
        }

        /* Move to next entry.  */
        current_media =  current_media -> fx_media_opened_next;
 8010c20:	69fb      	ldr	r3, [r7, #28]
 8010c22:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
 8010c26:	61fb      	str	r3, [r7, #28]
    while (open_count--)
 8010c28:	69bb      	ldr	r3, [r7, #24]
 8010c2a:	1e5a      	subs	r2, r3, #1
 8010c2c:	61ba      	str	r2, [r7, #24]
 8010c2e:	2b00      	cmp	r3, #0
 8010c30:	d1f0      	bne.n	8010c14 <_fxe_media_open+0x84>
    /* Restore preemption.  */
    tx_thread_preemption_change(current_thread, old_threshold, &old_threshold);
#endif

    /* Call actual media open service.  */
    status =  _fx_media_open(media_ptr, media_name, media_driver, driver_info_ptr,
 8010c32:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010c34:	9301      	str	r3, [sp, #4]
 8010c36:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010c38:	9300      	str	r3, [sp, #0]
 8010c3a:	683b      	ldr	r3, [r7, #0]
 8010c3c:	687a      	ldr	r2, [r7, #4]
 8010c3e:	68b9      	ldr	r1, [r7, #8]
 8010c40:	68f8      	ldr	r0, [r7, #12]
 8010c42:	f7fc ff29 	bl	800da98 <_fx_media_open>
 8010c46:	6138      	str	r0, [r7, #16]
                             memory_ptr, memory_size);

    /* Return status.  */
    return(status);
 8010c48:	693b      	ldr	r3, [r7, #16]
}
 8010c4a:	4618      	mov	r0, r3
 8010c4c:	3720      	adds	r7, #32
 8010c4e:	46bd      	mov	sp, r7
 8010c50:	bd80      	pop	{r7, pc}
 8010c52:	bf00      	nop
 8010c54:	20002c9c 	.word	0x20002c9c
 8010c58:	20002ca0 	.word	0x20002ca0
 8010c5c:	20002c8c 	.word	0x20002c8c
 8010c60:	20002c90 	.word	0x20002c90

08010c64 <std>:
 8010c64:	2300      	movs	r3, #0
 8010c66:	b510      	push	{r4, lr}
 8010c68:	4604      	mov	r4, r0
 8010c6a:	6083      	str	r3, [r0, #8]
 8010c6c:	8181      	strh	r1, [r0, #12]
 8010c6e:	4619      	mov	r1, r3
 8010c70:	6643      	str	r3, [r0, #100]	@ 0x64
 8010c72:	81c2      	strh	r2, [r0, #14]
 8010c74:	2208      	movs	r2, #8
 8010c76:	6183      	str	r3, [r0, #24]
 8010c78:	e9c0 3300 	strd	r3, r3, [r0]
 8010c7c:	e9c0 3304 	strd	r3, r3, [r0, #16]
 8010c80:	305c      	adds	r0, #92	@ 0x5c
 8010c82:	f000 f9e7 	bl	8011054 <memset>
 8010c86:	4b0d      	ldr	r3, [pc, #52]	@ (8010cbc <std+0x58>)
 8010c88:	6224      	str	r4, [r4, #32]
 8010c8a:	6263      	str	r3, [r4, #36]	@ 0x24
 8010c8c:	4b0c      	ldr	r3, [pc, #48]	@ (8010cc0 <std+0x5c>)
 8010c8e:	62a3      	str	r3, [r4, #40]	@ 0x28
 8010c90:	4b0c      	ldr	r3, [pc, #48]	@ (8010cc4 <std+0x60>)
 8010c92:	62e3      	str	r3, [r4, #44]	@ 0x2c
 8010c94:	4b0c      	ldr	r3, [pc, #48]	@ (8010cc8 <std+0x64>)
 8010c96:	6323      	str	r3, [r4, #48]	@ 0x30
 8010c98:	4b0c      	ldr	r3, [pc, #48]	@ (8010ccc <std+0x68>)
 8010c9a:	429c      	cmp	r4, r3
 8010c9c:	d006      	beq.n	8010cac <std+0x48>
 8010c9e:	f103 0268 	add.w	r2, r3, #104	@ 0x68
 8010ca2:	4294      	cmp	r4, r2
 8010ca4:	d002      	beq.n	8010cac <std+0x48>
 8010ca6:	33d0      	adds	r3, #208	@ 0xd0
 8010ca8:	429c      	cmp	r4, r3
 8010caa:	d105      	bne.n	8010cb8 <std+0x54>
 8010cac:	f104 0058 	add.w	r0, r4, #88	@ 0x58
 8010cb0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8010cb4:	f000 ba46 	b.w	8011144 <__retarget_lock_init_recursive>
 8010cb8:	bd10      	pop	{r4, pc}
 8010cba:	bf00      	nop
 8010cbc:	08010ea5 	.word	0x08010ea5
 8010cc0:	08010ec7 	.word	0x08010ec7
 8010cc4:	08010eff 	.word	0x08010eff
 8010cc8:	08010f23 	.word	0x08010f23
 8010ccc:	20002cb0 	.word	0x20002cb0

08010cd0 <stdio_exit_handler>:
 8010cd0:	4a02      	ldr	r2, [pc, #8]	@ (8010cdc <stdio_exit_handler+0xc>)
 8010cd2:	4903      	ldr	r1, [pc, #12]	@ (8010ce0 <stdio_exit_handler+0x10>)
 8010cd4:	4803      	ldr	r0, [pc, #12]	@ (8010ce4 <stdio_exit_handler+0x14>)
 8010cd6:	f000 b869 	b.w	8010dac <_fwalk_sglue>
 8010cda:	bf00      	nop
 8010cdc:	20000070 	.word	0x20000070
 8010ce0:	0801145d 	.word	0x0801145d
 8010ce4:	20000080 	.word	0x20000080

08010ce8 <cleanup_stdio>:
 8010ce8:	6841      	ldr	r1, [r0, #4]
 8010cea:	4b0c      	ldr	r3, [pc, #48]	@ (8010d1c <cleanup_stdio+0x34>)
 8010cec:	4299      	cmp	r1, r3
 8010cee:	b510      	push	{r4, lr}
 8010cf0:	4604      	mov	r4, r0
 8010cf2:	d001      	beq.n	8010cf8 <cleanup_stdio+0x10>
 8010cf4:	f000 fbb2 	bl	801145c <_fflush_r>
 8010cf8:	68a1      	ldr	r1, [r4, #8]
 8010cfa:	4b09      	ldr	r3, [pc, #36]	@ (8010d20 <cleanup_stdio+0x38>)
 8010cfc:	4299      	cmp	r1, r3
 8010cfe:	d002      	beq.n	8010d06 <cleanup_stdio+0x1e>
 8010d00:	4620      	mov	r0, r4
 8010d02:	f000 fbab 	bl	801145c <_fflush_r>
 8010d06:	68e1      	ldr	r1, [r4, #12]
 8010d08:	4b06      	ldr	r3, [pc, #24]	@ (8010d24 <cleanup_stdio+0x3c>)
 8010d0a:	4299      	cmp	r1, r3
 8010d0c:	d004      	beq.n	8010d18 <cleanup_stdio+0x30>
 8010d0e:	4620      	mov	r0, r4
 8010d10:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8010d14:	f000 bba2 	b.w	801145c <_fflush_r>
 8010d18:	bd10      	pop	{r4, pc}
 8010d1a:	bf00      	nop
 8010d1c:	20002cb0 	.word	0x20002cb0
 8010d20:	20002d18 	.word	0x20002d18
 8010d24:	20002d80 	.word	0x20002d80

08010d28 <global_stdio_init.part.0>:
 8010d28:	b510      	push	{r4, lr}
 8010d2a:	4b0b      	ldr	r3, [pc, #44]	@ (8010d58 <global_stdio_init.part.0+0x30>)
 8010d2c:	2104      	movs	r1, #4
 8010d2e:	4c0b      	ldr	r4, [pc, #44]	@ (8010d5c <global_stdio_init.part.0+0x34>)
 8010d30:	4a0b      	ldr	r2, [pc, #44]	@ (8010d60 <global_stdio_init.part.0+0x38>)
 8010d32:	4620      	mov	r0, r4
 8010d34:	601a      	str	r2, [r3, #0]
 8010d36:	2200      	movs	r2, #0
 8010d38:	f7ff ff94 	bl	8010c64 <std>
 8010d3c:	f104 0068 	add.w	r0, r4, #104	@ 0x68
 8010d40:	2201      	movs	r2, #1
 8010d42:	2109      	movs	r1, #9
 8010d44:	f7ff ff8e 	bl	8010c64 <std>
 8010d48:	f104 00d0 	add.w	r0, r4, #208	@ 0xd0
 8010d4c:	2202      	movs	r2, #2
 8010d4e:	2112      	movs	r1, #18
 8010d50:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8010d54:	f7ff bf86 	b.w	8010c64 <std>
 8010d58:	20002de8 	.word	0x20002de8
 8010d5c:	20002cb0 	.word	0x20002cb0
 8010d60:	08010cd1 	.word	0x08010cd1

08010d64 <__sfp_lock_acquire>:
 8010d64:	4801      	ldr	r0, [pc, #4]	@ (8010d6c <__sfp_lock_acquire+0x8>)
 8010d66:	f000 b9ee 	b.w	8011146 <__retarget_lock_acquire_recursive>
 8010d6a:	bf00      	nop
 8010d6c:	20002df1 	.word	0x20002df1

08010d70 <__sfp_lock_release>:
 8010d70:	4801      	ldr	r0, [pc, #4]	@ (8010d78 <__sfp_lock_release+0x8>)
 8010d72:	f000 b9e9 	b.w	8011148 <__retarget_lock_release_recursive>
 8010d76:	bf00      	nop
 8010d78:	20002df1 	.word	0x20002df1

08010d7c <__sinit>:
 8010d7c:	b510      	push	{r4, lr}
 8010d7e:	4604      	mov	r4, r0
 8010d80:	f7ff fff0 	bl	8010d64 <__sfp_lock_acquire>
 8010d84:	6a23      	ldr	r3, [r4, #32]
 8010d86:	b11b      	cbz	r3, 8010d90 <__sinit+0x14>
 8010d88:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8010d8c:	f7ff bff0 	b.w	8010d70 <__sfp_lock_release>
 8010d90:	4b04      	ldr	r3, [pc, #16]	@ (8010da4 <__sinit+0x28>)
 8010d92:	6223      	str	r3, [r4, #32]
 8010d94:	4b04      	ldr	r3, [pc, #16]	@ (8010da8 <__sinit+0x2c>)
 8010d96:	681b      	ldr	r3, [r3, #0]
 8010d98:	2b00      	cmp	r3, #0
 8010d9a:	d1f5      	bne.n	8010d88 <__sinit+0xc>
 8010d9c:	f7ff ffc4 	bl	8010d28 <global_stdio_init.part.0>
 8010da0:	e7f2      	b.n	8010d88 <__sinit+0xc>
 8010da2:	bf00      	nop
 8010da4:	08010ce9 	.word	0x08010ce9
 8010da8:	20002de8 	.word	0x20002de8

08010dac <_fwalk_sglue>:
 8010dac:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8010db0:	4607      	mov	r7, r0
 8010db2:	4688      	mov	r8, r1
 8010db4:	4614      	mov	r4, r2
 8010db6:	2600      	movs	r6, #0
 8010db8:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 8010dbc:	f1b9 0901 	subs.w	r9, r9, #1
 8010dc0:	d505      	bpl.n	8010dce <_fwalk_sglue+0x22>
 8010dc2:	6824      	ldr	r4, [r4, #0]
 8010dc4:	2c00      	cmp	r4, #0
 8010dc6:	d1f7      	bne.n	8010db8 <_fwalk_sglue+0xc>
 8010dc8:	4630      	mov	r0, r6
 8010dca:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8010dce:	89ab      	ldrh	r3, [r5, #12]
 8010dd0:	2b01      	cmp	r3, #1
 8010dd2:	d907      	bls.n	8010de4 <_fwalk_sglue+0x38>
 8010dd4:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 8010dd8:	3301      	adds	r3, #1
 8010dda:	d003      	beq.n	8010de4 <_fwalk_sglue+0x38>
 8010ddc:	4629      	mov	r1, r5
 8010dde:	4638      	mov	r0, r7
 8010de0:	47c0      	blx	r8
 8010de2:	4306      	orrs	r6, r0
 8010de4:	3568      	adds	r5, #104	@ 0x68
 8010de6:	e7e9      	b.n	8010dbc <_fwalk_sglue+0x10>

08010de8 <_puts_r>:
 8010de8:	6a03      	ldr	r3, [r0, #32]
 8010dea:	b570      	push	{r4, r5, r6, lr}
 8010dec:	4605      	mov	r5, r0
 8010dee:	460e      	mov	r6, r1
 8010df0:	6884      	ldr	r4, [r0, #8]
 8010df2:	b90b      	cbnz	r3, 8010df8 <_puts_r+0x10>
 8010df4:	f7ff ffc2 	bl	8010d7c <__sinit>
 8010df8:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 8010dfa:	07db      	lsls	r3, r3, #31
 8010dfc:	d405      	bmi.n	8010e0a <_puts_r+0x22>
 8010dfe:	89a3      	ldrh	r3, [r4, #12]
 8010e00:	0598      	lsls	r0, r3, #22
 8010e02:	d402      	bmi.n	8010e0a <_puts_r+0x22>
 8010e04:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 8010e06:	f000 f99e 	bl	8011146 <__retarget_lock_acquire_recursive>
 8010e0a:	89a3      	ldrh	r3, [r4, #12]
 8010e0c:	0719      	lsls	r1, r3, #28
 8010e0e:	d502      	bpl.n	8010e16 <_puts_r+0x2e>
 8010e10:	6923      	ldr	r3, [r4, #16]
 8010e12:	2b00      	cmp	r3, #0
 8010e14:	d135      	bne.n	8010e82 <_puts_r+0x9a>
 8010e16:	4621      	mov	r1, r4
 8010e18:	4628      	mov	r0, r5
 8010e1a:	f000 f8c5 	bl	8010fa8 <__swsetup_r>
 8010e1e:	b380      	cbz	r0, 8010e82 <_puts_r+0x9a>
 8010e20:	f04f 35ff 	mov.w	r5, #4294967295
 8010e24:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 8010e26:	07da      	lsls	r2, r3, #31
 8010e28:	d405      	bmi.n	8010e36 <_puts_r+0x4e>
 8010e2a:	89a3      	ldrh	r3, [r4, #12]
 8010e2c:	059b      	lsls	r3, r3, #22
 8010e2e:	d402      	bmi.n	8010e36 <_puts_r+0x4e>
 8010e30:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 8010e32:	f000 f989 	bl	8011148 <__retarget_lock_release_recursive>
 8010e36:	4628      	mov	r0, r5
 8010e38:	bd70      	pop	{r4, r5, r6, pc}
 8010e3a:	2b00      	cmp	r3, #0
 8010e3c:	da04      	bge.n	8010e48 <_puts_r+0x60>
 8010e3e:	69a2      	ldr	r2, [r4, #24]
 8010e40:	429a      	cmp	r2, r3
 8010e42:	dc17      	bgt.n	8010e74 <_puts_r+0x8c>
 8010e44:	290a      	cmp	r1, #10
 8010e46:	d015      	beq.n	8010e74 <_puts_r+0x8c>
 8010e48:	6823      	ldr	r3, [r4, #0]
 8010e4a:	1c5a      	adds	r2, r3, #1
 8010e4c:	6022      	str	r2, [r4, #0]
 8010e4e:	7019      	strb	r1, [r3, #0]
 8010e50:	68a3      	ldr	r3, [r4, #8]
 8010e52:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 8010e56:	3b01      	subs	r3, #1
 8010e58:	60a3      	str	r3, [r4, #8]
 8010e5a:	2900      	cmp	r1, #0
 8010e5c:	d1ed      	bne.n	8010e3a <_puts_r+0x52>
 8010e5e:	2b00      	cmp	r3, #0
 8010e60:	da11      	bge.n	8010e86 <_puts_r+0x9e>
 8010e62:	4622      	mov	r2, r4
 8010e64:	210a      	movs	r1, #10
 8010e66:	4628      	mov	r0, r5
 8010e68:	f000 f85f 	bl	8010f2a <__swbuf_r>
 8010e6c:	3001      	adds	r0, #1
 8010e6e:	d0d7      	beq.n	8010e20 <_puts_r+0x38>
 8010e70:	250a      	movs	r5, #10
 8010e72:	e7d7      	b.n	8010e24 <_puts_r+0x3c>
 8010e74:	4622      	mov	r2, r4
 8010e76:	4628      	mov	r0, r5
 8010e78:	f000 f857 	bl	8010f2a <__swbuf_r>
 8010e7c:	3001      	adds	r0, #1
 8010e7e:	d1e7      	bne.n	8010e50 <_puts_r+0x68>
 8010e80:	e7ce      	b.n	8010e20 <_puts_r+0x38>
 8010e82:	3e01      	subs	r6, #1
 8010e84:	e7e4      	b.n	8010e50 <_puts_r+0x68>
 8010e86:	6823      	ldr	r3, [r4, #0]
 8010e88:	1c5a      	adds	r2, r3, #1
 8010e8a:	6022      	str	r2, [r4, #0]
 8010e8c:	220a      	movs	r2, #10
 8010e8e:	701a      	strb	r2, [r3, #0]
 8010e90:	e7ee      	b.n	8010e70 <_puts_r+0x88>
	...

08010e94 <puts>:
 8010e94:	4b02      	ldr	r3, [pc, #8]	@ (8010ea0 <puts+0xc>)
 8010e96:	4601      	mov	r1, r0
 8010e98:	6818      	ldr	r0, [r3, #0]
 8010e9a:	f7ff bfa5 	b.w	8010de8 <_puts_r>
 8010e9e:	bf00      	nop
 8010ea0:	2000007c 	.word	0x2000007c

08010ea4 <__sread>:
 8010ea4:	b510      	push	{r4, lr}
 8010ea6:	460c      	mov	r4, r1
 8010ea8:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8010eac:	f000 f8fc 	bl	80110a8 <_read_r>
 8010eb0:	2800      	cmp	r0, #0
 8010eb2:	bfab      	itete	ge
 8010eb4:	6d63      	ldrge	r3, [r4, #84]	@ 0x54
 8010eb6:	89a3      	ldrhlt	r3, [r4, #12]
 8010eb8:	181b      	addge	r3, r3, r0
 8010eba:	f423 5380 	biclt.w	r3, r3, #4096	@ 0x1000
 8010ebe:	bfac      	ite	ge
 8010ec0:	6563      	strge	r3, [r4, #84]	@ 0x54
 8010ec2:	81a3      	strhlt	r3, [r4, #12]
 8010ec4:	bd10      	pop	{r4, pc}

08010ec6 <__swrite>:
 8010ec6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8010eca:	461f      	mov	r7, r3
 8010ecc:	898b      	ldrh	r3, [r1, #12]
 8010ece:	4605      	mov	r5, r0
 8010ed0:	460c      	mov	r4, r1
 8010ed2:	05db      	lsls	r3, r3, #23
 8010ed4:	4616      	mov	r6, r2
 8010ed6:	d505      	bpl.n	8010ee4 <__swrite+0x1e>
 8010ed8:	2302      	movs	r3, #2
 8010eda:	2200      	movs	r2, #0
 8010edc:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8010ee0:	f000 f8d0 	bl	8011084 <_lseek_r>
 8010ee4:	89a3      	ldrh	r3, [r4, #12]
 8010ee6:	4632      	mov	r2, r6
 8010ee8:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8010eec:	4628      	mov	r0, r5
 8010eee:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 8010ef2:	81a3      	strh	r3, [r4, #12]
 8010ef4:	463b      	mov	r3, r7
 8010ef6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8010efa:	f000 b8e7 	b.w	80110cc <_write_r>

08010efe <__sseek>:
 8010efe:	b510      	push	{r4, lr}
 8010f00:	460c      	mov	r4, r1
 8010f02:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8010f06:	f000 f8bd 	bl	8011084 <_lseek_r>
 8010f0a:	1c43      	adds	r3, r0, #1
 8010f0c:	89a3      	ldrh	r3, [r4, #12]
 8010f0e:	bf15      	itete	ne
 8010f10:	6560      	strne	r0, [r4, #84]	@ 0x54
 8010f12:	f423 5380 	biceq.w	r3, r3, #4096	@ 0x1000
 8010f16:	f443 5380 	orrne.w	r3, r3, #4096	@ 0x1000
 8010f1a:	81a3      	strheq	r3, [r4, #12]
 8010f1c:	bf18      	it	ne
 8010f1e:	81a3      	strhne	r3, [r4, #12]
 8010f20:	bd10      	pop	{r4, pc}

08010f22 <__sclose>:
 8010f22:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8010f26:	f000 b89d 	b.w	8011064 <_close_r>

08010f2a <__swbuf_r>:
 8010f2a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8010f2c:	460e      	mov	r6, r1
 8010f2e:	4614      	mov	r4, r2
 8010f30:	4605      	mov	r5, r0
 8010f32:	b118      	cbz	r0, 8010f3c <__swbuf_r+0x12>
 8010f34:	6a03      	ldr	r3, [r0, #32]
 8010f36:	b90b      	cbnz	r3, 8010f3c <__swbuf_r+0x12>
 8010f38:	f7ff ff20 	bl	8010d7c <__sinit>
 8010f3c:	69a3      	ldr	r3, [r4, #24]
 8010f3e:	60a3      	str	r3, [r4, #8]
 8010f40:	89a3      	ldrh	r3, [r4, #12]
 8010f42:	071a      	lsls	r2, r3, #28
 8010f44:	d501      	bpl.n	8010f4a <__swbuf_r+0x20>
 8010f46:	6923      	ldr	r3, [r4, #16]
 8010f48:	b943      	cbnz	r3, 8010f5c <__swbuf_r+0x32>
 8010f4a:	4621      	mov	r1, r4
 8010f4c:	4628      	mov	r0, r5
 8010f4e:	f000 f82b 	bl	8010fa8 <__swsetup_r>
 8010f52:	b118      	cbz	r0, 8010f5c <__swbuf_r+0x32>
 8010f54:	f04f 37ff 	mov.w	r7, #4294967295
 8010f58:	4638      	mov	r0, r7
 8010f5a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8010f5c:	6823      	ldr	r3, [r4, #0]
 8010f5e:	b2f6      	uxtb	r6, r6
 8010f60:	6922      	ldr	r2, [r4, #16]
 8010f62:	4637      	mov	r7, r6
 8010f64:	1a98      	subs	r0, r3, r2
 8010f66:	6963      	ldr	r3, [r4, #20]
 8010f68:	4283      	cmp	r3, r0
 8010f6a:	dc05      	bgt.n	8010f78 <__swbuf_r+0x4e>
 8010f6c:	4621      	mov	r1, r4
 8010f6e:	4628      	mov	r0, r5
 8010f70:	f000 fa74 	bl	801145c <_fflush_r>
 8010f74:	2800      	cmp	r0, #0
 8010f76:	d1ed      	bne.n	8010f54 <__swbuf_r+0x2a>
 8010f78:	68a3      	ldr	r3, [r4, #8]
 8010f7a:	3b01      	subs	r3, #1
 8010f7c:	60a3      	str	r3, [r4, #8]
 8010f7e:	6823      	ldr	r3, [r4, #0]
 8010f80:	1c5a      	adds	r2, r3, #1
 8010f82:	6022      	str	r2, [r4, #0]
 8010f84:	701e      	strb	r6, [r3, #0]
 8010f86:	1c43      	adds	r3, r0, #1
 8010f88:	6962      	ldr	r2, [r4, #20]
 8010f8a:	429a      	cmp	r2, r3
 8010f8c:	d004      	beq.n	8010f98 <__swbuf_r+0x6e>
 8010f8e:	89a3      	ldrh	r3, [r4, #12]
 8010f90:	07db      	lsls	r3, r3, #31
 8010f92:	d5e1      	bpl.n	8010f58 <__swbuf_r+0x2e>
 8010f94:	2e0a      	cmp	r6, #10
 8010f96:	d1df      	bne.n	8010f58 <__swbuf_r+0x2e>
 8010f98:	4621      	mov	r1, r4
 8010f9a:	4628      	mov	r0, r5
 8010f9c:	f000 fa5e 	bl	801145c <_fflush_r>
 8010fa0:	2800      	cmp	r0, #0
 8010fa2:	d0d9      	beq.n	8010f58 <__swbuf_r+0x2e>
 8010fa4:	e7d6      	b.n	8010f54 <__swbuf_r+0x2a>
	...

08010fa8 <__swsetup_r>:
 8010fa8:	b538      	push	{r3, r4, r5, lr}
 8010faa:	4b29      	ldr	r3, [pc, #164]	@ (8011050 <__swsetup_r+0xa8>)
 8010fac:	4605      	mov	r5, r0
 8010fae:	460c      	mov	r4, r1
 8010fb0:	6818      	ldr	r0, [r3, #0]
 8010fb2:	b118      	cbz	r0, 8010fbc <__swsetup_r+0x14>
 8010fb4:	6a03      	ldr	r3, [r0, #32]
 8010fb6:	b90b      	cbnz	r3, 8010fbc <__swsetup_r+0x14>
 8010fb8:	f7ff fee0 	bl	8010d7c <__sinit>
 8010fbc:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8010fc0:	0719      	lsls	r1, r3, #28
 8010fc2:	d422      	bmi.n	801100a <__swsetup_r+0x62>
 8010fc4:	06da      	lsls	r2, r3, #27
 8010fc6:	d407      	bmi.n	8010fd8 <__swsetup_r+0x30>
 8010fc8:	2209      	movs	r2, #9
 8010fca:	602a      	str	r2, [r5, #0]
 8010fcc:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8010fd0:	f04f 30ff 	mov.w	r0, #4294967295
 8010fd4:	81a3      	strh	r3, [r4, #12]
 8010fd6:	e033      	b.n	8011040 <__swsetup_r+0x98>
 8010fd8:	0758      	lsls	r0, r3, #29
 8010fda:	d512      	bpl.n	8011002 <__swsetup_r+0x5a>
 8010fdc:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 8010fde:	b141      	cbz	r1, 8010ff2 <__swsetup_r+0x4a>
 8010fe0:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 8010fe4:	4299      	cmp	r1, r3
 8010fe6:	d002      	beq.n	8010fee <__swsetup_r+0x46>
 8010fe8:	4628      	mov	r0, r5
 8010fea:	f000 f8bb 	bl	8011164 <_free_r>
 8010fee:	2300      	movs	r3, #0
 8010ff0:	6363      	str	r3, [r4, #52]	@ 0x34
 8010ff2:	89a3      	ldrh	r3, [r4, #12]
 8010ff4:	f023 0324 	bic.w	r3, r3, #36	@ 0x24
 8010ff8:	81a3      	strh	r3, [r4, #12]
 8010ffa:	2300      	movs	r3, #0
 8010ffc:	6063      	str	r3, [r4, #4]
 8010ffe:	6923      	ldr	r3, [r4, #16]
 8011000:	6023      	str	r3, [r4, #0]
 8011002:	89a3      	ldrh	r3, [r4, #12]
 8011004:	f043 0308 	orr.w	r3, r3, #8
 8011008:	81a3      	strh	r3, [r4, #12]
 801100a:	6923      	ldr	r3, [r4, #16]
 801100c:	b94b      	cbnz	r3, 8011022 <__swsetup_r+0x7a>
 801100e:	89a3      	ldrh	r3, [r4, #12]
 8011010:	f403 7320 	and.w	r3, r3, #640	@ 0x280
 8011014:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8011018:	d003      	beq.n	8011022 <__swsetup_r+0x7a>
 801101a:	4621      	mov	r1, r4
 801101c:	4628      	mov	r0, r5
 801101e:	f000 fa6a 	bl	80114f6 <__smakebuf_r>
 8011022:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8011026:	f013 0201 	ands.w	r2, r3, #1
 801102a:	d00a      	beq.n	8011042 <__swsetup_r+0x9a>
 801102c:	2200      	movs	r2, #0
 801102e:	60a2      	str	r2, [r4, #8]
 8011030:	6962      	ldr	r2, [r4, #20]
 8011032:	4252      	negs	r2, r2
 8011034:	61a2      	str	r2, [r4, #24]
 8011036:	6922      	ldr	r2, [r4, #16]
 8011038:	b942      	cbnz	r2, 801104c <__swsetup_r+0xa4>
 801103a:	f013 0080 	ands.w	r0, r3, #128	@ 0x80
 801103e:	d1c5      	bne.n	8010fcc <__swsetup_r+0x24>
 8011040:	bd38      	pop	{r3, r4, r5, pc}
 8011042:	0799      	lsls	r1, r3, #30
 8011044:	bf58      	it	pl
 8011046:	6962      	ldrpl	r2, [r4, #20]
 8011048:	60a2      	str	r2, [r4, #8]
 801104a:	e7f4      	b.n	8011036 <__swsetup_r+0x8e>
 801104c:	2000      	movs	r0, #0
 801104e:	e7f7      	b.n	8011040 <__swsetup_r+0x98>
 8011050:	2000007c 	.word	0x2000007c

08011054 <memset>:
 8011054:	4402      	add	r2, r0
 8011056:	4603      	mov	r3, r0
 8011058:	4293      	cmp	r3, r2
 801105a:	d100      	bne.n	801105e <memset+0xa>
 801105c:	4770      	bx	lr
 801105e:	f803 1b01 	strb.w	r1, [r3], #1
 8011062:	e7f9      	b.n	8011058 <memset+0x4>

08011064 <_close_r>:
 8011064:	b538      	push	{r3, r4, r5, lr}
 8011066:	2300      	movs	r3, #0
 8011068:	4d05      	ldr	r5, [pc, #20]	@ (8011080 <_close_r+0x1c>)
 801106a:	4604      	mov	r4, r0
 801106c:	4608      	mov	r0, r1
 801106e:	602b      	str	r3, [r5, #0]
 8011070:	f7ef fce9 	bl	8000a46 <_close>
 8011074:	1c43      	adds	r3, r0, #1
 8011076:	d102      	bne.n	801107e <_close_r+0x1a>
 8011078:	682b      	ldr	r3, [r5, #0]
 801107a:	b103      	cbz	r3, 801107e <_close_r+0x1a>
 801107c:	6023      	str	r3, [r4, #0]
 801107e:	bd38      	pop	{r3, r4, r5, pc}
 8011080:	20002dec 	.word	0x20002dec

08011084 <_lseek_r>:
 8011084:	b538      	push	{r3, r4, r5, lr}
 8011086:	4604      	mov	r4, r0
 8011088:	4d06      	ldr	r5, [pc, #24]	@ (80110a4 <_lseek_r+0x20>)
 801108a:	4608      	mov	r0, r1
 801108c:	4611      	mov	r1, r2
 801108e:	2200      	movs	r2, #0
 8011090:	602a      	str	r2, [r5, #0]
 8011092:	461a      	mov	r2, r3
 8011094:	f7ef fcfe 	bl	8000a94 <_lseek>
 8011098:	1c43      	adds	r3, r0, #1
 801109a:	d102      	bne.n	80110a2 <_lseek_r+0x1e>
 801109c:	682b      	ldr	r3, [r5, #0]
 801109e:	b103      	cbz	r3, 80110a2 <_lseek_r+0x1e>
 80110a0:	6023      	str	r3, [r4, #0]
 80110a2:	bd38      	pop	{r3, r4, r5, pc}
 80110a4:	20002dec 	.word	0x20002dec

080110a8 <_read_r>:
 80110a8:	b538      	push	{r3, r4, r5, lr}
 80110aa:	4604      	mov	r4, r0
 80110ac:	4d06      	ldr	r5, [pc, #24]	@ (80110c8 <_read_r+0x20>)
 80110ae:	4608      	mov	r0, r1
 80110b0:	4611      	mov	r1, r2
 80110b2:	2200      	movs	r2, #0
 80110b4:	602a      	str	r2, [r5, #0]
 80110b6:	461a      	mov	r2, r3
 80110b8:	f7ef fc8c 	bl	80009d4 <_read>
 80110bc:	1c43      	adds	r3, r0, #1
 80110be:	d102      	bne.n	80110c6 <_read_r+0x1e>
 80110c0:	682b      	ldr	r3, [r5, #0]
 80110c2:	b103      	cbz	r3, 80110c6 <_read_r+0x1e>
 80110c4:	6023      	str	r3, [r4, #0]
 80110c6:	bd38      	pop	{r3, r4, r5, pc}
 80110c8:	20002dec 	.word	0x20002dec

080110cc <_write_r>:
 80110cc:	b538      	push	{r3, r4, r5, lr}
 80110ce:	4604      	mov	r4, r0
 80110d0:	4d06      	ldr	r5, [pc, #24]	@ (80110ec <_write_r+0x20>)
 80110d2:	4608      	mov	r0, r1
 80110d4:	4611      	mov	r1, r2
 80110d6:	2200      	movs	r2, #0
 80110d8:	602a      	str	r2, [r5, #0]
 80110da:	461a      	mov	r2, r3
 80110dc:	f7ef fc97 	bl	8000a0e <_write>
 80110e0:	1c43      	adds	r3, r0, #1
 80110e2:	d102      	bne.n	80110ea <_write_r+0x1e>
 80110e4:	682b      	ldr	r3, [r5, #0]
 80110e6:	b103      	cbz	r3, 80110ea <_write_r+0x1e>
 80110e8:	6023      	str	r3, [r4, #0]
 80110ea:	bd38      	pop	{r3, r4, r5, pc}
 80110ec:	20002dec 	.word	0x20002dec

080110f0 <__errno>:
 80110f0:	4b01      	ldr	r3, [pc, #4]	@ (80110f8 <__errno+0x8>)
 80110f2:	6818      	ldr	r0, [r3, #0]
 80110f4:	4770      	bx	lr
 80110f6:	bf00      	nop
 80110f8:	2000007c 	.word	0x2000007c

080110fc <__libc_init_array>:
 80110fc:	b570      	push	{r4, r5, r6, lr}
 80110fe:	4d0d      	ldr	r5, [pc, #52]	@ (8011134 <__libc_init_array+0x38>)
 8011100:	2600      	movs	r6, #0
 8011102:	4c0d      	ldr	r4, [pc, #52]	@ (8011138 <__libc_init_array+0x3c>)
 8011104:	1b64      	subs	r4, r4, r5
 8011106:	10a4      	asrs	r4, r4, #2
 8011108:	42a6      	cmp	r6, r4
 801110a:	d109      	bne.n	8011120 <__libc_init_array+0x24>
 801110c:	4d0b      	ldr	r5, [pc, #44]	@ (801113c <__libc_init_array+0x40>)
 801110e:	2600      	movs	r6, #0
 8011110:	4c0b      	ldr	r4, [pc, #44]	@ (8011140 <__libc_init_array+0x44>)
 8011112:	f000 fa5f 	bl	80115d4 <_init>
 8011116:	1b64      	subs	r4, r4, r5
 8011118:	10a4      	asrs	r4, r4, #2
 801111a:	42a6      	cmp	r6, r4
 801111c:	d105      	bne.n	801112a <__libc_init_array+0x2e>
 801111e:	bd70      	pop	{r4, r5, r6, pc}
 8011120:	f855 3b04 	ldr.w	r3, [r5], #4
 8011124:	3601      	adds	r6, #1
 8011126:	4798      	blx	r3
 8011128:	e7ee      	b.n	8011108 <__libc_init_array+0xc>
 801112a:	f855 3b04 	ldr.w	r3, [r5], #4
 801112e:	3601      	adds	r6, #1
 8011130:	4798      	blx	r3
 8011132:	e7f2      	b.n	801111a <__libc_init_array+0x1e>
 8011134:	08011784 	.word	0x08011784
 8011138:	08011784 	.word	0x08011784
 801113c:	08011784 	.word	0x08011784
 8011140:	08011788 	.word	0x08011788

08011144 <__retarget_lock_init_recursive>:
 8011144:	4770      	bx	lr

08011146 <__retarget_lock_acquire_recursive>:
 8011146:	4770      	bx	lr

08011148 <__retarget_lock_release_recursive>:
 8011148:	4770      	bx	lr

0801114a <memcpy>:
 801114a:	440a      	add	r2, r1
 801114c:	1e43      	subs	r3, r0, #1
 801114e:	4291      	cmp	r1, r2
 8011150:	d100      	bne.n	8011154 <memcpy+0xa>
 8011152:	4770      	bx	lr
 8011154:	b510      	push	{r4, lr}
 8011156:	f811 4b01 	ldrb.w	r4, [r1], #1
 801115a:	4291      	cmp	r1, r2
 801115c:	f803 4f01 	strb.w	r4, [r3, #1]!
 8011160:	d1f9      	bne.n	8011156 <memcpy+0xc>
 8011162:	bd10      	pop	{r4, pc}

08011164 <_free_r>:
 8011164:	b538      	push	{r3, r4, r5, lr}
 8011166:	4605      	mov	r5, r0
 8011168:	2900      	cmp	r1, #0
 801116a:	d041      	beq.n	80111f0 <_free_r+0x8c>
 801116c:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8011170:	1f0c      	subs	r4, r1, #4
 8011172:	2b00      	cmp	r3, #0
 8011174:	bfb8      	it	lt
 8011176:	18e4      	addlt	r4, r4, r3
 8011178:	f000 f8e0 	bl	801133c <__malloc_lock>
 801117c:	4a1d      	ldr	r2, [pc, #116]	@ (80111f4 <_free_r+0x90>)
 801117e:	6813      	ldr	r3, [r2, #0]
 8011180:	b933      	cbnz	r3, 8011190 <_free_r+0x2c>
 8011182:	6063      	str	r3, [r4, #4]
 8011184:	6014      	str	r4, [r2, #0]
 8011186:	4628      	mov	r0, r5
 8011188:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 801118c:	f000 b8dc 	b.w	8011348 <__malloc_unlock>
 8011190:	42a3      	cmp	r3, r4
 8011192:	d908      	bls.n	80111a6 <_free_r+0x42>
 8011194:	6820      	ldr	r0, [r4, #0]
 8011196:	1821      	adds	r1, r4, r0
 8011198:	428b      	cmp	r3, r1
 801119a:	bf01      	itttt	eq
 801119c:	6819      	ldreq	r1, [r3, #0]
 801119e:	685b      	ldreq	r3, [r3, #4]
 80111a0:	1809      	addeq	r1, r1, r0
 80111a2:	6021      	streq	r1, [r4, #0]
 80111a4:	e7ed      	b.n	8011182 <_free_r+0x1e>
 80111a6:	461a      	mov	r2, r3
 80111a8:	685b      	ldr	r3, [r3, #4]
 80111aa:	b10b      	cbz	r3, 80111b0 <_free_r+0x4c>
 80111ac:	42a3      	cmp	r3, r4
 80111ae:	d9fa      	bls.n	80111a6 <_free_r+0x42>
 80111b0:	6811      	ldr	r1, [r2, #0]
 80111b2:	1850      	adds	r0, r2, r1
 80111b4:	42a0      	cmp	r0, r4
 80111b6:	d10b      	bne.n	80111d0 <_free_r+0x6c>
 80111b8:	6820      	ldr	r0, [r4, #0]
 80111ba:	4401      	add	r1, r0
 80111bc:	1850      	adds	r0, r2, r1
 80111be:	6011      	str	r1, [r2, #0]
 80111c0:	4283      	cmp	r3, r0
 80111c2:	d1e0      	bne.n	8011186 <_free_r+0x22>
 80111c4:	6818      	ldr	r0, [r3, #0]
 80111c6:	685b      	ldr	r3, [r3, #4]
 80111c8:	4408      	add	r0, r1
 80111ca:	6053      	str	r3, [r2, #4]
 80111cc:	6010      	str	r0, [r2, #0]
 80111ce:	e7da      	b.n	8011186 <_free_r+0x22>
 80111d0:	d902      	bls.n	80111d8 <_free_r+0x74>
 80111d2:	230c      	movs	r3, #12
 80111d4:	602b      	str	r3, [r5, #0]
 80111d6:	e7d6      	b.n	8011186 <_free_r+0x22>
 80111d8:	6820      	ldr	r0, [r4, #0]
 80111da:	1821      	adds	r1, r4, r0
 80111dc:	428b      	cmp	r3, r1
 80111de:	bf02      	ittt	eq
 80111e0:	6819      	ldreq	r1, [r3, #0]
 80111e2:	685b      	ldreq	r3, [r3, #4]
 80111e4:	1809      	addeq	r1, r1, r0
 80111e6:	6063      	str	r3, [r4, #4]
 80111e8:	bf08      	it	eq
 80111ea:	6021      	streq	r1, [r4, #0]
 80111ec:	6054      	str	r4, [r2, #4]
 80111ee:	e7ca      	b.n	8011186 <_free_r+0x22>
 80111f0:	bd38      	pop	{r3, r4, r5, pc}
 80111f2:	bf00      	nop
 80111f4:	20002df8 	.word	0x20002df8

080111f8 <sbrk_aligned>:
 80111f8:	b570      	push	{r4, r5, r6, lr}
 80111fa:	4e0f      	ldr	r6, [pc, #60]	@ (8011238 <sbrk_aligned+0x40>)
 80111fc:	460c      	mov	r4, r1
 80111fe:	4605      	mov	r5, r0
 8011200:	6831      	ldr	r1, [r6, #0]
 8011202:	b911      	cbnz	r1, 801120a <sbrk_aligned+0x12>
 8011204:	f000 f9d6 	bl	80115b4 <_sbrk_r>
 8011208:	6030      	str	r0, [r6, #0]
 801120a:	4621      	mov	r1, r4
 801120c:	4628      	mov	r0, r5
 801120e:	f000 f9d1 	bl	80115b4 <_sbrk_r>
 8011212:	1c43      	adds	r3, r0, #1
 8011214:	d103      	bne.n	801121e <sbrk_aligned+0x26>
 8011216:	f04f 34ff 	mov.w	r4, #4294967295
 801121a:	4620      	mov	r0, r4
 801121c:	bd70      	pop	{r4, r5, r6, pc}
 801121e:	1cc4      	adds	r4, r0, #3
 8011220:	f024 0403 	bic.w	r4, r4, #3
 8011224:	42a0      	cmp	r0, r4
 8011226:	d0f8      	beq.n	801121a <sbrk_aligned+0x22>
 8011228:	1a21      	subs	r1, r4, r0
 801122a:	4628      	mov	r0, r5
 801122c:	f000 f9c2 	bl	80115b4 <_sbrk_r>
 8011230:	3001      	adds	r0, #1
 8011232:	d1f2      	bne.n	801121a <sbrk_aligned+0x22>
 8011234:	e7ef      	b.n	8011216 <sbrk_aligned+0x1e>
 8011236:	bf00      	nop
 8011238:	20002df4 	.word	0x20002df4

0801123c <_malloc_r>:
 801123c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8011240:	1ccd      	adds	r5, r1, #3
 8011242:	4606      	mov	r6, r0
 8011244:	f025 0503 	bic.w	r5, r5, #3
 8011248:	3508      	adds	r5, #8
 801124a:	2d0c      	cmp	r5, #12
 801124c:	bf38      	it	cc
 801124e:	250c      	movcc	r5, #12
 8011250:	2d00      	cmp	r5, #0
 8011252:	db01      	blt.n	8011258 <_malloc_r+0x1c>
 8011254:	42a9      	cmp	r1, r5
 8011256:	d904      	bls.n	8011262 <_malloc_r+0x26>
 8011258:	230c      	movs	r3, #12
 801125a:	6033      	str	r3, [r6, #0]
 801125c:	2000      	movs	r0, #0
 801125e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8011262:	f8df 80d4 	ldr.w	r8, [pc, #212]	@ 8011338 <_malloc_r+0xfc>
 8011266:	f000 f869 	bl	801133c <__malloc_lock>
 801126a:	f8d8 3000 	ldr.w	r3, [r8]
 801126e:	461c      	mov	r4, r3
 8011270:	bb44      	cbnz	r4, 80112c4 <_malloc_r+0x88>
 8011272:	4629      	mov	r1, r5
 8011274:	4630      	mov	r0, r6
 8011276:	f7ff ffbf 	bl	80111f8 <sbrk_aligned>
 801127a:	1c43      	adds	r3, r0, #1
 801127c:	4604      	mov	r4, r0
 801127e:	d158      	bne.n	8011332 <_malloc_r+0xf6>
 8011280:	f8d8 4000 	ldr.w	r4, [r8]
 8011284:	4627      	mov	r7, r4
 8011286:	2f00      	cmp	r7, #0
 8011288:	d143      	bne.n	8011312 <_malloc_r+0xd6>
 801128a:	2c00      	cmp	r4, #0
 801128c:	d04b      	beq.n	8011326 <_malloc_r+0xea>
 801128e:	6823      	ldr	r3, [r4, #0]
 8011290:	4639      	mov	r1, r7
 8011292:	4630      	mov	r0, r6
 8011294:	eb04 0903 	add.w	r9, r4, r3
 8011298:	f000 f98c 	bl	80115b4 <_sbrk_r>
 801129c:	4581      	cmp	r9, r0
 801129e:	d142      	bne.n	8011326 <_malloc_r+0xea>
 80112a0:	6821      	ldr	r1, [r4, #0]
 80112a2:	4630      	mov	r0, r6
 80112a4:	1a6d      	subs	r5, r5, r1
 80112a6:	4629      	mov	r1, r5
 80112a8:	f7ff ffa6 	bl	80111f8 <sbrk_aligned>
 80112ac:	3001      	adds	r0, #1
 80112ae:	d03a      	beq.n	8011326 <_malloc_r+0xea>
 80112b0:	6823      	ldr	r3, [r4, #0]
 80112b2:	442b      	add	r3, r5
 80112b4:	6023      	str	r3, [r4, #0]
 80112b6:	f8d8 3000 	ldr.w	r3, [r8]
 80112ba:	685a      	ldr	r2, [r3, #4]
 80112bc:	bb62      	cbnz	r2, 8011318 <_malloc_r+0xdc>
 80112be:	f8c8 7000 	str.w	r7, [r8]
 80112c2:	e00f      	b.n	80112e4 <_malloc_r+0xa8>
 80112c4:	6822      	ldr	r2, [r4, #0]
 80112c6:	1b52      	subs	r2, r2, r5
 80112c8:	d420      	bmi.n	801130c <_malloc_r+0xd0>
 80112ca:	2a0b      	cmp	r2, #11
 80112cc:	d917      	bls.n	80112fe <_malloc_r+0xc2>
 80112ce:	1961      	adds	r1, r4, r5
 80112d0:	42a3      	cmp	r3, r4
 80112d2:	6025      	str	r5, [r4, #0]
 80112d4:	bf18      	it	ne
 80112d6:	6059      	strne	r1, [r3, #4]
 80112d8:	6863      	ldr	r3, [r4, #4]
 80112da:	bf08      	it	eq
 80112dc:	f8c8 1000 	streq.w	r1, [r8]
 80112e0:	5162      	str	r2, [r4, r5]
 80112e2:	604b      	str	r3, [r1, #4]
 80112e4:	4630      	mov	r0, r6
 80112e6:	f000 f82f 	bl	8011348 <__malloc_unlock>
 80112ea:	f104 000b 	add.w	r0, r4, #11
 80112ee:	1d23      	adds	r3, r4, #4
 80112f0:	f020 0007 	bic.w	r0, r0, #7
 80112f4:	1ac2      	subs	r2, r0, r3
 80112f6:	bf1c      	itt	ne
 80112f8:	1a1b      	subne	r3, r3, r0
 80112fa:	50a3      	strne	r3, [r4, r2]
 80112fc:	e7af      	b.n	801125e <_malloc_r+0x22>
 80112fe:	6862      	ldr	r2, [r4, #4]
 8011300:	42a3      	cmp	r3, r4
 8011302:	bf0c      	ite	eq
 8011304:	f8c8 2000 	streq.w	r2, [r8]
 8011308:	605a      	strne	r2, [r3, #4]
 801130a:	e7eb      	b.n	80112e4 <_malloc_r+0xa8>
 801130c:	4623      	mov	r3, r4
 801130e:	6864      	ldr	r4, [r4, #4]
 8011310:	e7ae      	b.n	8011270 <_malloc_r+0x34>
 8011312:	463c      	mov	r4, r7
 8011314:	687f      	ldr	r7, [r7, #4]
 8011316:	e7b6      	b.n	8011286 <_malloc_r+0x4a>
 8011318:	461a      	mov	r2, r3
 801131a:	685b      	ldr	r3, [r3, #4]
 801131c:	42a3      	cmp	r3, r4
 801131e:	d1fb      	bne.n	8011318 <_malloc_r+0xdc>
 8011320:	2300      	movs	r3, #0
 8011322:	6053      	str	r3, [r2, #4]
 8011324:	e7de      	b.n	80112e4 <_malloc_r+0xa8>
 8011326:	230c      	movs	r3, #12
 8011328:	4630      	mov	r0, r6
 801132a:	6033      	str	r3, [r6, #0]
 801132c:	f000 f80c 	bl	8011348 <__malloc_unlock>
 8011330:	e794      	b.n	801125c <_malloc_r+0x20>
 8011332:	6005      	str	r5, [r0, #0]
 8011334:	e7d6      	b.n	80112e4 <_malloc_r+0xa8>
 8011336:	bf00      	nop
 8011338:	20002df8 	.word	0x20002df8

0801133c <__malloc_lock>:
 801133c:	4801      	ldr	r0, [pc, #4]	@ (8011344 <__malloc_lock+0x8>)
 801133e:	f7ff bf02 	b.w	8011146 <__retarget_lock_acquire_recursive>
 8011342:	bf00      	nop
 8011344:	20002df0 	.word	0x20002df0

08011348 <__malloc_unlock>:
 8011348:	4801      	ldr	r0, [pc, #4]	@ (8011350 <__malloc_unlock+0x8>)
 801134a:	f7ff befd 	b.w	8011148 <__retarget_lock_release_recursive>
 801134e:	bf00      	nop
 8011350:	20002df0 	.word	0x20002df0

08011354 <__sflush_r>:
 8011354:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
 8011358:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801135c:	0716      	lsls	r6, r2, #28
 801135e:	4605      	mov	r5, r0
 8011360:	460c      	mov	r4, r1
 8011362:	d454      	bmi.n	801140e <__sflush_r+0xba>
 8011364:	684b      	ldr	r3, [r1, #4]
 8011366:	2b00      	cmp	r3, #0
 8011368:	dc02      	bgt.n	8011370 <__sflush_r+0x1c>
 801136a:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
 801136c:	2b00      	cmp	r3, #0
 801136e:	dd48      	ble.n	8011402 <__sflush_r+0xae>
 8011370:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 8011372:	2e00      	cmp	r6, #0
 8011374:	d045      	beq.n	8011402 <__sflush_r+0xae>
 8011376:	2300      	movs	r3, #0
 8011378:	f412 5280 	ands.w	r2, r2, #4096	@ 0x1000
 801137c:	682f      	ldr	r7, [r5, #0]
 801137e:	6a21      	ldr	r1, [r4, #32]
 8011380:	602b      	str	r3, [r5, #0]
 8011382:	d030      	beq.n	80113e6 <__sflush_r+0x92>
 8011384:	6d62      	ldr	r2, [r4, #84]	@ 0x54
 8011386:	89a3      	ldrh	r3, [r4, #12]
 8011388:	0759      	lsls	r1, r3, #29
 801138a:	d505      	bpl.n	8011398 <__sflush_r+0x44>
 801138c:	6863      	ldr	r3, [r4, #4]
 801138e:	1ad2      	subs	r2, r2, r3
 8011390:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 8011392:	b10b      	cbz	r3, 8011398 <__sflush_r+0x44>
 8011394:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 8011396:	1ad2      	subs	r2, r2, r3
 8011398:	2300      	movs	r3, #0
 801139a:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 801139c:	6a21      	ldr	r1, [r4, #32]
 801139e:	4628      	mov	r0, r5
 80113a0:	47b0      	blx	r6
 80113a2:	1c43      	adds	r3, r0, #1
 80113a4:	89a3      	ldrh	r3, [r4, #12]
 80113a6:	d106      	bne.n	80113b6 <__sflush_r+0x62>
 80113a8:	6829      	ldr	r1, [r5, #0]
 80113aa:	291d      	cmp	r1, #29
 80113ac:	d82b      	bhi.n	8011406 <__sflush_r+0xb2>
 80113ae:	4a2a      	ldr	r2, [pc, #168]	@ (8011458 <__sflush_r+0x104>)
 80113b0:	410a      	asrs	r2, r1
 80113b2:	07d6      	lsls	r6, r2, #31
 80113b4:	d427      	bmi.n	8011406 <__sflush_r+0xb2>
 80113b6:	2200      	movs	r2, #0
 80113b8:	04d9      	lsls	r1, r3, #19
 80113ba:	6062      	str	r2, [r4, #4]
 80113bc:	6922      	ldr	r2, [r4, #16]
 80113be:	6022      	str	r2, [r4, #0]
 80113c0:	d504      	bpl.n	80113cc <__sflush_r+0x78>
 80113c2:	1c42      	adds	r2, r0, #1
 80113c4:	d101      	bne.n	80113ca <__sflush_r+0x76>
 80113c6:	682b      	ldr	r3, [r5, #0]
 80113c8:	b903      	cbnz	r3, 80113cc <__sflush_r+0x78>
 80113ca:	6560      	str	r0, [r4, #84]	@ 0x54
 80113cc:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 80113ce:	602f      	str	r7, [r5, #0]
 80113d0:	b1b9      	cbz	r1, 8011402 <__sflush_r+0xae>
 80113d2:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 80113d6:	4299      	cmp	r1, r3
 80113d8:	d002      	beq.n	80113e0 <__sflush_r+0x8c>
 80113da:	4628      	mov	r0, r5
 80113dc:	f7ff fec2 	bl	8011164 <_free_r>
 80113e0:	2300      	movs	r3, #0
 80113e2:	6363      	str	r3, [r4, #52]	@ 0x34
 80113e4:	e00d      	b.n	8011402 <__sflush_r+0xae>
 80113e6:	2301      	movs	r3, #1
 80113e8:	4628      	mov	r0, r5
 80113ea:	47b0      	blx	r6
 80113ec:	4602      	mov	r2, r0
 80113ee:	1c50      	adds	r0, r2, #1
 80113f0:	d1c9      	bne.n	8011386 <__sflush_r+0x32>
 80113f2:	682b      	ldr	r3, [r5, #0]
 80113f4:	2b00      	cmp	r3, #0
 80113f6:	d0c6      	beq.n	8011386 <__sflush_r+0x32>
 80113f8:	2b1d      	cmp	r3, #29
 80113fa:	d001      	beq.n	8011400 <__sflush_r+0xac>
 80113fc:	2b16      	cmp	r3, #22
 80113fe:	d11d      	bne.n	801143c <__sflush_r+0xe8>
 8011400:	602f      	str	r7, [r5, #0]
 8011402:	2000      	movs	r0, #0
 8011404:	e021      	b.n	801144a <__sflush_r+0xf6>
 8011406:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 801140a:	b21b      	sxth	r3, r3
 801140c:	e01a      	b.n	8011444 <__sflush_r+0xf0>
 801140e:	690f      	ldr	r7, [r1, #16]
 8011410:	2f00      	cmp	r7, #0
 8011412:	d0f6      	beq.n	8011402 <__sflush_r+0xae>
 8011414:	0793      	lsls	r3, r2, #30
 8011416:	680e      	ldr	r6, [r1, #0]
 8011418:	600f      	str	r7, [r1, #0]
 801141a:	bf0c      	ite	eq
 801141c:	694b      	ldreq	r3, [r1, #20]
 801141e:	2300      	movne	r3, #0
 8011420:	eba6 0807 	sub.w	r8, r6, r7
 8011424:	608b      	str	r3, [r1, #8]
 8011426:	f1b8 0f00 	cmp.w	r8, #0
 801142a:	ddea      	ble.n	8011402 <__sflush_r+0xae>
 801142c:	4643      	mov	r3, r8
 801142e:	463a      	mov	r2, r7
 8011430:	6a21      	ldr	r1, [r4, #32]
 8011432:	4628      	mov	r0, r5
 8011434:	6aa6      	ldr	r6, [r4, #40]	@ 0x28
 8011436:	47b0      	blx	r6
 8011438:	2800      	cmp	r0, #0
 801143a:	dc08      	bgt.n	801144e <__sflush_r+0xfa>
 801143c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8011440:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8011444:	f04f 30ff 	mov.w	r0, #4294967295
 8011448:	81a3      	strh	r3, [r4, #12]
 801144a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801144e:	4407      	add	r7, r0
 8011450:	eba8 0800 	sub.w	r8, r8, r0
 8011454:	e7e7      	b.n	8011426 <__sflush_r+0xd2>
 8011456:	bf00      	nop
 8011458:	dfbffffe 	.word	0xdfbffffe

0801145c <_fflush_r>:
 801145c:	b538      	push	{r3, r4, r5, lr}
 801145e:	690b      	ldr	r3, [r1, #16]
 8011460:	4605      	mov	r5, r0
 8011462:	460c      	mov	r4, r1
 8011464:	b913      	cbnz	r3, 801146c <_fflush_r+0x10>
 8011466:	2500      	movs	r5, #0
 8011468:	4628      	mov	r0, r5
 801146a:	bd38      	pop	{r3, r4, r5, pc}
 801146c:	b118      	cbz	r0, 8011476 <_fflush_r+0x1a>
 801146e:	6a03      	ldr	r3, [r0, #32]
 8011470:	b90b      	cbnz	r3, 8011476 <_fflush_r+0x1a>
 8011472:	f7ff fc83 	bl	8010d7c <__sinit>
 8011476:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 801147a:	2b00      	cmp	r3, #0
 801147c:	d0f3      	beq.n	8011466 <_fflush_r+0xa>
 801147e:	6e62      	ldr	r2, [r4, #100]	@ 0x64
 8011480:	07d0      	lsls	r0, r2, #31
 8011482:	d404      	bmi.n	801148e <_fflush_r+0x32>
 8011484:	0599      	lsls	r1, r3, #22
 8011486:	d402      	bmi.n	801148e <_fflush_r+0x32>
 8011488:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 801148a:	f7ff fe5c 	bl	8011146 <__retarget_lock_acquire_recursive>
 801148e:	4628      	mov	r0, r5
 8011490:	4621      	mov	r1, r4
 8011492:	f7ff ff5f 	bl	8011354 <__sflush_r>
 8011496:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 8011498:	4605      	mov	r5, r0
 801149a:	07da      	lsls	r2, r3, #31
 801149c:	d4e4      	bmi.n	8011468 <_fflush_r+0xc>
 801149e:	89a3      	ldrh	r3, [r4, #12]
 80114a0:	059b      	lsls	r3, r3, #22
 80114a2:	d4e1      	bmi.n	8011468 <_fflush_r+0xc>
 80114a4:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 80114a6:	f7ff fe4f 	bl	8011148 <__retarget_lock_release_recursive>
 80114aa:	e7dd      	b.n	8011468 <_fflush_r+0xc>

080114ac <__swhatbuf_r>:
 80114ac:	b570      	push	{r4, r5, r6, lr}
 80114ae:	460c      	mov	r4, r1
 80114b0:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80114b4:	b096      	sub	sp, #88	@ 0x58
 80114b6:	4615      	mov	r5, r2
 80114b8:	2900      	cmp	r1, #0
 80114ba:	461e      	mov	r6, r3
 80114bc:	da0c      	bge.n	80114d8 <__swhatbuf_r+0x2c>
 80114be:	89a3      	ldrh	r3, [r4, #12]
 80114c0:	2100      	movs	r1, #0
 80114c2:	f013 0f80 	tst.w	r3, #128	@ 0x80
 80114c6:	bf14      	ite	ne
 80114c8:	2340      	movne	r3, #64	@ 0x40
 80114ca:	f44f 6380 	moveq.w	r3, #1024	@ 0x400
 80114ce:	2000      	movs	r0, #0
 80114d0:	6031      	str	r1, [r6, #0]
 80114d2:	602b      	str	r3, [r5, #0]
 80114d4:	b016      	add	sp, #88	@ 0x58
 80114d6:	bd70      	pop	{r4, r5, r6, pc}
 80114d8:	466a      	mov	r2, sp
 80114da:	f000 f849 	bl	8011570 <_fstat_r>
 80114de:	2800      	cmp	r0, #0
 80114e0:	dbed      	blt.n	80114be <__swhatbuf_r+0x12>
 80114e2:	9901      	ldr	r1, [sp, #4]
 80114e4:	f401 4170 	and.w	r1, r1, #61440	@ 0xf000
 80114e8:	f5a1 5300 	sub.w	r3, r1, #8192	@ 0x2000
 80114ec:	4259      	negs	r1, r3
 80114ee:	4159      	adcs	r1, r3
 80114f0:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 80114f4:	e7eb      	b.n	80114ce <__swhatbuf_r+0x22>

080114f6 <__smakebuf_r>:
 80114f6:	898b      	ldrh	r3, [r1, #12]
 80114f8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 80114fa:	079d      	lsls	r5, r3, #30
 80114fc:	4606      	mov	r6, r0
 80114fe:	460c      	mov	r4, r1
 8011500:	d507      	bpl.n	8011512 <__smakebuf_r+0x1c>
 8011502:	f104 0347 	add.w	r3, r4, #71	@ 0x47
 8011506:	6023      	str	r3, [r4, #0]
 8011508:	6123      	str	r3, [r4, #16]
 801150a:	2301      	movs	r3, #1
 801150c:	6163      	str	r3, [r4, #20]
 801150e:	b003      	add	sp, #12
 8011510:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8011512:	ab01      	add	r3, sp, #4
 8011514:	466a      	mov	r2, sp
 8011516:	f7ff ffc9 	bl	80114ac <__swhatbuf_r>
 801151a:	9f00      	ldr	r7, [sp, #0]
 801151c:	4605      	mov	r5, r0
 801151e:	4630      	mov	r0, r6
 8011520:	4639      	mov	r1, r7
 8011522:	f7ff fe8b 	bl	801123c <_malloc_r>
 8011526:	b948      	cbnz	r0, 801153c <__smakebuf_r+0x46>
 8011528:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 801152c:	059a      	lsls	r2, r3, #22
 801152e:	d4ee      	bmi.n	801150e <__smakebuf_r+0x18>
 8011530:	f023 0303 	bic.w	r3, r3, #3
 8011534:	f043 0302 	orr.w	r3, r3, #2
 8011538:	81a3      	strh	r3, [r4, #12]
 801153a:	e7e2      	b.n	8011502 <__smakebuf_r+0xc>
 801153c:	89a3      	ldrh	r3, [r4, #12]
 801153e:	6020      	str	r0, [r4, #0]
 8011540:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8011544:	81a3      	strh	r3, [r4, #12]
 8011546:	9b01      	ldr	r3, [sp, #4]
 8011548:	e9c4 0704 	strd	r0, r7, [r4, #16]
 801154c:	b15b      	cbz	r3, 8011566 <__smakebuf_r+0x70>
 801154e:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8011552:	4630      	mov	r0, r6
 8011554:	f000 f81e 	bl	8011594 <_isatty_r>
 8011558:	b128      	cbz	r0, 8011566 <__smakebuf_r+0x70>
 801155a:	89a3      	ldrh	r3, [r4, #12]
 801155c:	f023 0303 	bic.w	r3, r3, #3
 8011560:	f043 0301 	orr.w	r3, r3, #1
 8011564:	81a3      	strh	r3, [r4, #12]
 8011566:	89a3      	ldrh	r3, [r4, #12]
 8011568:	431d      	orrs	r5, r3
 801156a:	81a5      	strh	r5, [r4, #12]
 801156c:	e7cf      	b.n	801150e <__smakebuf_r+0x18>
	...

08011570 <_fstat_r>:
 8011570:	b538      	push	{r3, r4, r5, lr}
 8011572:	2300      	movs	r3, #0
 8011574:	4d06      	ldr	r5, [pc, #24]	@ (8011590 <_fstat_r+0x20>)
 8011576:	4604      	mov	r4, r0
 8011578:	4608      	mov	r0, r1
 801157a:	4611      	mov	r1, r2
 801157c:	602b      	str	r3, [r5, #0]
 801157e:	f7ef fa6e 	bl	8000a5e <_fstat>
 8011582:	1c43      	adds	r3, r0, #1
 8011584:	d102      	bne.n	801158c <_fstat_r+0x1c>
 8011586:	682b      	ldr	r3, [r5, #0]
 8011588:	b103      	cbz	r3, 801158c <_fstat_r+0x1c>
 801158a:	6023      	str	r3, [r4, #0]
 801158c:	bd38      	pop	{r3, r4, r5, pc}
 801158e:	bf00      	nop
 8011590:	20002dec 	.word	0x20002dec

08011594 <_isatty_r>:
 8011594:	b538      	push	{r3, r4, r5, lr}
 8011596:	2300      	movs	r3, #0
 8011598:	4d05      	ldr	r5, [pc, #20]	@ (80115b0 <_isatty_r+0x1c>)
 801159a:	4604      	mov	r4, r0
 801159c:	4608      	mov	r0, r1
 801159e:	602b      	str	r3, [r5, #0]
 80115a0:	f7ef fa6d 	bl	8000a7e <_isatty>
 80115a4:	1c43      	adds	r3, r0, #1
 80115a6:	d102      	bne.n	80115ae <_isatty_r+0x1a>
 80115a8:	682b      	ldr	r3, [r5, #0]
 80115aa:	b103      	cbz	r3, 80115ae <_isatty_r+0x1a>
 80115ac:	6023      	str	r3, [r4, #0]
 80115ae:	bd38      	pop	{r3, r4, r5, pc}
 80115b0:	20002dec 	.word	0x20002dec

080115b4 <_sbrk_r>:
 80115b4:	b538      	push	{r3, r4, r5, lr}
 80115b6:	2300      	movs	r3, #0
 80115b8:	4d05      	ldr	r5, [pc, #20]	@ (80115d0 <_sbrk_r+0x1c>)
 80115ba:	4604      	mov	r4, r0
 80115bc:	4608      	mov	r0, r1
 80115be:	602b      	str	r3, [r5, #0]
 80115c0:	f7ef fa76 	bl	8000ab0 <_sbrk>
 80115c4:	1c43      	adds	r3, r0, #1
 80115c6:	d102      	bne.n	80115ce <_sbrk_r+0x1a>
 80115c8:	682b      	ldr	r3, [r5, #0]
 80115ca:	b103      	cbz	r3, 80115ce <_sbrk_r+0x1a>
 80115cc:	6023      	str	r3, [r4, #0]
 80115ce:	bd38      	pop	{r3, r4, r5, pc}
 80115d0:	20002dec 	.word	0x20002dec

080115d4 <_init>:
 80115d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80115d6:	bf00      	nop
 80115d8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80115da:	bc08      	pop	{r3}
 80115dc:	469e      	mov	lr, r3
 80115de:	4770      	bx	lr

080115e0 <_fini>:
 80115e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80115e2:	bf00      	nop
 80115e4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80115e6:	bc08      	pop	{r3}
 80115e8:	469e      	mov	lr, r3
 80115ea:	4770      	bx	lr
